
--string.lpad = function(str, len, char)
--	if char == nil then char = ' ' end
--	return string.rep(char, len - string.len(str))..str
--end

--[[function memoize(f)
	local mem = {} -- memoizing table
	setmetatable(mem, {__mode = "kv"}) -- make it weak
	return function (x) -- new version of ’f’, with memoizing
		local r = mem[x]
		if r == nil then -- no previous result?
			r = f(x) -- calls original function
			mem[x] = r -- store result for reuse
		end
		return r
	end
end]]

local abs = math.abs
local min = math.min
local max = math.max
local ceil = math.ceil
local floor = math.floor
local sqrt = math.sqrt
local sort = table.sort

function normalizeVector(pos)
	local lengthM = 1/sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z)
	return World_Pos(pos.x * lengthM, pos.y * lengthM, pos.z * lengthM)
end
function AIControl_IsSquadVehicle(squad)
	return Squad_GetMax(squad) == 1 and Entity_IsVehicle(Squad_EntityAt(squad, 0))
end

g_AIControl_Enable = true
g_AIControl_Pause = false

----------------------------------------------------
-- Table direct access locals optimization

local AIControl_Grid
local AIControl_Grid_Settings
local Dimensions

local AIControl_Grid_DataHistory
local AIControl_Grid_t_DataHistory

local AIControl_Grid_DataClump
local AIControl_Grid_DataClumpFOW

local AIControl_Grid_DataSquads
local AIControl_Grid_t_DataSquads
local AIControl_Grid_DataCounts
local AIControl_Grid_t_DataCounts
local AIControl_Grid_Data
local AIControl_Grid_t_Data
local AIControl_Grid_ArmorData
local AIControl_Grid_t_ArmorData
local AIControl_Grid_AveragePosData
local AIControl_Grid_t_AveragePosData

local AIControl_MainControl
local AIControl_MainControl_Settings
local AIControl_MainControl_Settings_UnitControl
local AIControl_MainControl_Settings_VehicleControl
local AIControl_MainControl_Settings_BarrageControl
local AIControl_MainControl_Settings_HQControl
local AIControl_MainControl_Settings_CombatUnitControl
local AIControl_MainControl_LockedSquads

local wHalfWidth = World_GetWidth()*0.5
local wHalfHeight = World_GetLength()*0.5

local AIControl = {}

local AIControl_Players = {}
local AIControl_PlayerCount = 0

AIControl.Grid = {
	Settings = {
		SplitUpdates = true, -- If true, the update will be split to be performed over the course of UpdateInterval rather than once per UpdateInterval
		SplitUpdateIncreasePerSquadCount = 8,
		
		-- These settings will only be used on game start, changing them later on will not affect the actual values
		Init_Dimensions = {11, 11}, -- Initial dimensions table
		
		AutoDimensionsEnable = true, -- if this is enabled, world will automatically be divided into areas with dimensions closest to supplied dimensions table
		                             -- Otherwise, init dimensions will be used directly to divide map into that many parts
		HistoryGrowthModifier = 0.775, -- Higher modifiers mean faster growth and higher max history values
		HistoryDecrementPerTick = 0.0015, --
		
		GetSpawnableLocations = true, -- if this is enabled, all the grid control points will be spawnable locations
		SpawnableLocationEntity = EBP.CW.HQ, -- bigger entities means seeking of bigger open map areas
		
		SpawnAIMarkers = 0, -- if this is enabled, entities will be spawned for each near all the control points to allow AI to build defensive structures near
		                    -- them and for additional targets. 0 - disabled, 1 - only spawn if no markers are present on the map, 2 - spawn always
		AIMarkers_SkipGrids = 3, -- only spawn every (n-1)th time
		AIMarker = EBP.STRAT_POINT.AI_LOW, -- should only be set to AI_LOW, AI_MEDIUM or AI_HIGH
		
		ReduceMarkerCount = 40, -- Automatically reduce marker count to this number of markers to be updated per player: N/max(1, AICount)*max(1, min(AICount, PlayerCount)).
		ExcludedUnits = {
			[BP_GetID(SBP.CW.HQ)] = true,
			[BP_GetID(SBP.CW.HQ_REINFORCEMENT)] = true,
			[BP_GetID(SBP.CW.ARMOUR_HQ)] = true,
			[BP_GetID(SBP.CW.INFANTRY_HQ)] = true,
		},
	},
	
	Dimensions = {0, 0, 1, 1}, -- {x divisions, y divisions, cell width, cell height}
	
	DataHistory = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat history over time
	t_DataHistory = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat history over time
	
	DataClump = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat combined with nearby cell threat without cells hidden in FOW
	DataClumpFOW = {}, -- double array of Dimensions[1] * Dimensions[2] size containing threat combined with nearby cell threat with cells hidden in FOW and additional weight for history
	
	DataSquads = {}, -- double array of Dimensions[1] * Dimensions[2] size containing squads for each cell
	t_DataSquads = {}, -- double array of Dimensions[1] * Dimensions[2] size containing squads for each cell used for split updates
	DataCounts = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit counts for each cell
	t_DataCounts = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit counts for each cell used for split updates
	Data = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit weights for each cell
	t_Data = {}, -- double array of Dimensions[1] * Dimensions[2] size containing unit weights for each cell used for split updates
	ArmorData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing total unit min armor for each cell
	t_ArmorData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing total unit min armor for each cell used for split updates
	AveragePosData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing average unit positions for each cell
	t_AveragePosData = {}, -- double array of Dimensions[1] * Dimensions[2] size containing average unit positions for each cell used for split updates
	
	ControlPoints = {}, -- double array of Dimensions[1] * Dimensions[2] size containing spawnable locations or middle positions for each cell
	DisabledLocations = {}, -- in case HQ setup was unsuccessful in a certain point, we disable further attempts of setting up there
	AIMarkerCount = 0,
	AIMarkers = {}, -- array containing invisible entities used by AI for building defensive structures
	
	SplitUpdateCount = 1,
	SplitUpdateStep = 0,
	SplitUpdateSquads = {},
	
	RecentlyCancelledCapture = {},
	
	SetDimensions = function(x, y, auto, SpawnAIMarkers, getSpawnableLocations, spawnableLocationEntity)
		local worldWidth, worldLength = World_GetWidth(), World_GetLength()
		if auto == nil then auto = AIControl_Grid_Settings.AutoDimensionsEnable end
		if SpawnAIMarkers == nil then SpawnAIMarkers = AIControl_Grid_Settings.SpawnAIMarkers end
		if auto then
			Dimensions[1] = floor(worldWidth/x)
			Dimensions[2] = floor(worldLength/y)
		else
			Dimensions[1] = x
			Dimensions[2] = y
		end
		Dimensions[3] = worldWidth/Dimensions[1]
		Dimensions[4] = worldLength/Dimensions[2]
		--print("AIControl Grid Dimensions: "..Dimensions[1].."*"..Dimensions[3].." x "..Dimensions[2].."*"..Dimensions[4])
		AIControl_Grid.SetupControlPoints(getSpawnableLocations, spawnableLocationEntity)
		AIControl_Grid.ResetupAIMarkers(nil, SpawnAIMarkers)
		AIControl_Grid_DataHistory = {}
		AIControl_Grid_t_DataHistory = {}
		AIControl_Grid_DataSquads = {}
		AIControl_Grid_t_DataSquads = {}
		for i=1,Dimensions[1] do
			AIControl_Grid_DataHistory[i] = {}
			AIControl_Grid_t_DataHistory[i] = {}
			AIControl_Grid_DataSquads[i] = {}
			AIControl_Grid_t_DataSquads[i] = {}
			for j=1,Dimensions[2] do
				AIControl_Grid_DataHistory[i][j] = {0, 0}
				AIControl_Grid_t_DataHistory[i][j] = {0, 0}
				AIControl_Grid_DataSquads[i][j] = {SGroup_CreateIfNotFound('AIControl_Grid_DataSquads['..i..']['..j..'][1]'), SGroup_CreateIfNotFound('AIControl_Grid_DataSquads['..i..']['..j..'][1]')}
				AIControl_Grid_t_DataSquads[i][j] = {SGroup_CreateIfNotFound('AIControl_Grid_t_DataSquads['..i..']['..j..'][1]'), SGroup_CreateIfNotFound('AIControl_Grid_t_DataSquads['..i..']['..j..'][1]')}
			end
		end
	end,
	SetupControlPoints = function(getSpawnableLocations, spawnableLocationEntity)
		if getSpawnableLocations == nil then getSpawnableLocations = AIControl_Grid_Settings.GetSpawnableLocations end
		if spawnableLocationEntity == nil then spawnableLocationEntity = AIControl_Grid_Settings.SpawnableLocationEntity end
		
		local halfWidth = Dimensions[3]*0.5
		local halfHeight = Dimensions[4]*0.5
		if getSpawnableLocations then
			local tempEntity = Entity_CreateENV(spawnableLocationEntity, World_Pos(0, 0, 0), World_Pos(1, 0, 0))
			for i=1,Dimensions[1] do
				AIControl_Grid.ControlPoints[i] = {}
				AIControl_Grid.DisabledLocations[i] = {}
				for j=1,Dimensions[2] do
					AIControl_Grid.ControlPoints[i][j] = World_GetSpawnablePosition(World_Pos(i*Dimensions[3]-halfWidth-wHalfWidth, 0, j*Dimensions[3]-halfHeight-wHalfHeight), tempEntity)
					--World_Pos(i*Dimensions[3]-halfWidth-wHalfWidth, 0, j*Dimensions[3]-halfHeight-wHalfHeight)
					AIControl_Grid.DisabledLocations[i][j] = false
					--Entity_CreateENV(spawnableLocationEntity, AIControl_Grid.ControlPoints[i][j], AIControl_Grid.ControlPoints[i][j]) -- to test placement
				end
			end
			Entity_Destroy(tempEntity)
		else
			for i=1,Dimensions[1] do
				AIControl_Grid.ControlPoints[i] = {}
				AIControl_Grid.DisabledLocations[i] = {}
				for j=1,Dimensions[2] do
					AIControl_Grid.ControlPoints[i][j] = World_Pos(i*Dimensions[3]-halfWidth-wHalfWidth, 0, j*Dimensions[4]-halfHeight-wHalfHeight)
					AIControl_Grid.DisabledLocations[i][j] = false
				end
			end
		end
	end,
	RemoveAIMarkers = function()
		if AIControl_Grid.AIMarkers then
			for i=1,AIControl_Grid.AIMarkerCount do
				Entity_Destroy(AIControl_Grid.AIMarkers[i])
			end
			AIControl_Grid.AIMarkers = {}
		end
	end,
	ResetupAIMarkers = function(marker, spawn)
		if marker == nil then marker = AIControl_Grid_Settings.AIMarker end
		if spawn == nil then spawn = AIControl_Grid_Settings.SpawnAIMarkers end
		AIControl_Grid.RemoveAIMarkers()
		AIControl_Grid.AIMarkerCount = 0
		AIControl_Grid.AIMarkers = {}
		for i=0,World_GetNumEntities()-1 do
			local e = World_GetEntity(i)
			local bp = Entity_GetBlueprint(e)
			if bp == EBP.STRAT_POINT.AI_LOW or bp == EBP.STRAT_POINT.AI_MEDIUM or bp == EBP.STRAT_POINT.AI_HIGH then
				AIControl_Grid.AIMarkerCount = AIControl_Grid.AIMarkerCount + 1
				AIControl_Grid.AIMarkers[AIControl_Grid.AIMarkerCount] = e
			end
		end
		if spawn == 2 or (spawn == 1 and AIControl_Grid.AIMarkerCount < 5) then
			local skipped = 0
			for i=1,Dimensions[1] do
				for j=1,Dimensions[2] do
					if skipped >= AIControl_Grid_Settings.AIMarkers_SkipGrids then
						skipped = 0
						AIControl_Grid.AIMarkerCount = AIControl_Grid.AIMarkerCount + 1
						AIControl_Grid.AIMarkers[AIControl_Grid.AIMarkerCount] = Entity_CreateENV(marker, AIControl_Grid.ControlPoints[i][j], AIControl_Grid.ControlPoints[i][j])
					else
						skipped = skipped + 1
					end
				end
			end
		end
	end,
	ReduceMarkerCount = function()
		if AIControl_Grid_Settings.ReduceMarkerCount then
			--print("reducing marker count")
			local wantedCount = AIControl_Grid_Settings.ReduceMarkerCount/max(1, AIControl_PlayerCount)*min(AIControl_PlayerCount, max(1, World_GetPlayerCount()-AIControl_PlayerCount))
			--print(" - initial count: "..AIControl_Grid.AIMarkerCount)
			--print(" - wanted count: "..wantedCount)
			while AIControl_Grid.AIMarkerCount > wantedCount do
				local remIndex = World_GetRand(1, AIControl_Grid.AIMarkerCount)
				Entity_Destroy(AIControl_Grid.AIMarkers[remIndex])
				for i=remIndex,AIControl_Grid.AIMarkerCount do
					AIControl_Grid.AIMarkers[i] = AIControl_Grid.AIMarkers[i+1]
				end
				AIControl_Grid.AIMarkerCount = AIControl_Grid.AIMarkerCount - 1
			end
			--print(" - result count: "..AIControl_Grid.AIMarkerCount)
		end
	end,
	ResetData = function(resetReal)
		if resetReal == nil then resetReal = false end
		for i=1,Dimensions[1] do
			AIControl_Grid_t_Data[i] = {}
			AIControl_Grid_t_ArmorData[i] = {}
			AIControl_Grid_t_DataCounts[i] = {}
			AIControl_Grid_t_AveragePosData[i] = {}
			
			for j=1,Dimensions[2] do
				AIControl_Grid_t_Data[i][j] = {0, 0}
				AIControl_Grid_t_ArmorData[i][j] = {0, 0}
				AIControl_Grid_t_DataCounts[i][j] = {0, 0}
				SGroup_Clear(AIControl_Grid_t_DataSquads[i][j][1])
				SGroup_Clear(AIControl_Grid_t_DataSquads[i][j][2])
				AIControl_Grid_t_AveragePosData[i][j] = {
					World_Pos(AIControl_Grid.ControlPoints[i][j].x, AIControl_Grid.ControlPoints[i][j].y, AIControl_Grid.ControlPoints[i][j].z),
					World_Pos(AIControl_Grid.ControlPoints[i][j].x, AIControl_Grid.ControlPoints[i][j].y, AIControl_Grid.ControlPoints[i][j].z)
				}
				
			end
		end
		if resetReal then
			for i=1,Dimensions[1] do
				AIControl_Grid_Data[i] = {}
				AIControl_Grid_ArmorData[i] = {}
				AIControl_Grid_DataCounts[i] = {}
				AIControl_Grid_AveragePosData[i] = {}
			
				AIControl_Grid_DataClump[i] = {}
				AIControl_Grid_DataClumpFOW[i] = {}
				
				for j=1,Dimensions[2] do
					AIControl_Grid_Data[i][j] = {0, 0}
					AIControl_Grid_ArmorData[i][j] = {0, 0}
					AIControl_Grid_DataCounts[i][j] = {0, 0}
					SGroup_Clear(AIControl_Grid_DataSquads[i][j][1])
					SGroup_Clear(AIControl_Grid_DataSquads[i][j][2])
					AIControl_Grid_AveragePosData[i][j] = {
						World_Pos(AIControl_Grid.ControlPoints[i][j].x, AIControl_Grid.ControlPoints[i][j].y, AIControl_Grid.ControlPoints[i][j].z),
						World_Pos(AIControl_Grid.ControlPoints[i][j].x, AIControl_Grid.ControlPoints[i][j].y, AIControl_Grid.ControlPoints[i][j].z)
					}
					
					AIControl_Grid_DataClump[i][j] = {0, 0}
					AIControl_Grid_DataClumpFOW[i][j] = {0, 0}
					
				end
			end
		end
	end,
	
	GetXY = function(pos)
		local x = floor((pos.x+World_GetWidth()*0.5)/Dimensions[3])+1
		local y = floor((pos.z+World_GetLength()*0.5)/Dimensions[4])+1
		if x < 1 then
			x = 1
		elseif x > Dimensions[1] then
			x = Dimensions[1]
		end
		if y < 1 then
			y = 1
		elseif y > Dimensions[2] then
			y = Dimensions[2]
		end
		return x, y
	end,
	UpdateAIPlayers = function() -- returns squad counts
		AIControl_PlayerCount = 0
		AIControl_Players = {}
		local squadCounts = {0, 0}
		for i=1,World_GetPlayerCount() do
			local player = World_GetPlayerAt(i)
			if not Player_IsHuman(player) then
				AIControl_PlayerCount = AIControl_PlayerCount + 1
				AIControl_Players[AIControl_PlayerCount] = i
			end
			local team = Player_GetTeam(player)+1
			if team == 1 or team == 2 then
				squadCounts[team] = squadCounts[team] + SGroup_CountSpawned(Player_GetSquads(player))
			end
		end
		return squadCounts
	end,
	Update = function()
		if g_AIControl_Pause then return end
		
		local squadCounts = AIControl_Grid.UpdateAIPlayers()
		if not AIControl_Grid_Settings.SplitUpdates or AIControl_Grid.SplitUpdateStep == 0 then
			--dr_clear('aicontrol_maincontrol')
			--dr_clear("aicontrol_grid")
			AIControl_Grid.ResetData(false)
			for i=1,Dimensions[1] do
				for j=1,Dimensions[2] do
					AIControl_Grid_t_AveragePosData[i][j] = {World_Pos(0, 0, 0), World_Pos(0, 0, 0)}
					for team=1,2 do
						if squadCounts[team] > 0 then
							AIControl_Grid_DataHistory[i][j][team] = max(0,
								AIControl_Grid_DataHistory[i][j][team]
								- max(0, AIControl_Grid_Settings.HistoryDecrementPerTick)
								- (max(1, AIControl_Grid_DataHistory[i][j][team]*0.05)^2)/max(1, squadCounts[team])
								)
							AIControl_Grid_t_DataHistory[i][j][team] = AIControl_Grid_DataHistory[i][j][team]
						end
					end
				end
			end
			
			if AIControl_Grid.SplitUpdateStep == 0 then
				AIControl_Grid.SplitUpdateSquads = {}
				
				local allSquads = {}
				local sqCount = 0
				for i=1,World_GetPlayerCount() do
					local player = World_GetPlayerAt(i)
					local team = Player_GetTeam(player)+1
					if team == 1 or team == 2 then
						local pSquads = Player_GetSquads(player)
						for j=1,SGroup_CountSpawned(pSquads) do
							sqCount = sqCount + 1
							allSquads[sqCount] = SGroup_GetSpawnedSquadAt(pSquads, j)
						end
					end
				end
				
				AIControl_Grid.SplitUpdateCount = max(8, ceil(sqCount / AIControl_Grid_Settings.SplitUpdateIncreasePerSquadCount))
				
				local sqPerStep = AIControl_Grid_Settings.SplitUpdateIncreasePerSquadCount
				for i=1,AIControl_Grid.SplitUpdateCount do
					AIControl_Grid.SplitUpdateSquads[i] = SGroup_CreateIfNotFound("sg_aicontrol_splitupdatesquads_"..i)
					SGroup_Clear(AIControl_Grid.SplitUpdateSquads[i])
					if sqCount >= AIControl_Grid.SplitUpdateCount or i <= sqCount then
						for j=(i-1)*sqPerStep+1,min(sqCount, i*sqPerStep) do
							if allSquads[j] then
								SGroup_Add(AIControl_Grid.SplitUpdateSquads[i], allSquads[j])
							end
						end
					end
				end
			end
		end
		
		AIControl_Grid.RecentlyCancelledCapture = {}
		
		local squads
		if AIControl_Grid_Settings.SplitUpdates then
			AIControl_Grid.SplitUpdateStep = AIControl_Grid.SplitUpdateStep + 1
			squads = AIControl_Grid.SplitUpdateSquads[AIControl_Grid.SplitUpdateStep]
			if AIControl_Grid.SplitUpdateStep >= AIControl_Grid.SplitUpdateCount then
				AIControl_Grid.SplitUpdateStep = 0
			end
		else
			squads = SGroup_CreateIfNotFound("sg_temp_aicontrol_squads")
			for i=1,World_GetPlayerCount() do
				local player = World_GetPlayerAt(i)
				local team = Player_GetTeam(player)+1
				if team == 1 or team == 2 then
					local pSquads = Player_GetSquads(player)
					for j=1,SGroup_CountSpawned(pSquads) do
						local s = SGroup_GetSpawnedSquadAt(pSquads, j)
						SGroup_Add(squads, s)
					end
				end
			end
		end
		for i=1,SGroup_CountSpawned(squads) do
			local s = SGroup_GetSpawnedSquadAt(squads, i)
			local squadGameID = Squad_GetGameID(s)
			local bpID = BP_GetID(Squad_GetBlueprint(s))
			local player = Squad_GetPlayerOwner(s)
			local team = Player_GetTeam(player)+1
			local enemyTeam = Team_GetEnemyTeam(team-1)+1
			local pos = Squad_GetPosition(s)
			local x,y = AIControl_Grid.GetXY(pos)
			
			local retreated = Squad_IsRetreating(s)
			if not retreated and not Player_IsHuman(player) then
				
				-- retreating
				if Squad_IsUnderAttack(s, 2) and not Squad_IsRetreating(s) and not AIControl_IsSquadVehicle(s) then
					local retreatDemand = AIControl_MainControl.RetreatTactic(s)
					if retreatDemand > 0 then
						--local r = World_GetRand(0, 20)/10
						--if r <= retreatDemand then
							retreated = true
							
							local retreatSG = SGroup_CreateIfNotFound('BtB_retreat')
							SGroup_Clear(retreatSG)
							SGroup_Add(retreatSG, s)
							if Squad_IsInHoldEntity(s) then -- eject squads in entity hold
								local holdEntity = Squad_GetHoldEntity(s)
								SGroup_Eject(retreatSG, AIControl_MainControl.HQPositions[World_GetPlayerIndex(player)])
								Cmd_Retreat(retreatSG, nil, nil, true) -- queued retreat
							elseif Squad_IsInHoldSquad(s) then -- eject squads in s hold
								local holdSquad = Squad_GetHoldSquad(s)
								local tmpSG = SGroup_CreateIfNotFound('BtB_tmp')
								SGroup_Clear(tmpSG)
								SGroup_Add(tmpSG, holdSquad)
								Cmd_EjectOccupants(tmpSG)
								SGroup_Destroy(tmpSG)
								Cmd_Retreat(retreatSG, nil, nil, true) -- queued retreat
							else
								Cmd_Retreat(retreatSG)
							end
							SGroup_Destroy(retreatSG)
						--end
					end
				end
				
				if not retreated then
					
					local tmpSG = SGroup_CreateIfNotFound("tempsg")
					SGroup_Single(tmpSG, s)
					
					-- reinforcing
					if Squad_CanInstantReinforceNow(s) and Squad_HasActiveCommand(s) and Squad_GetActiveCommand(s) ~= SQUADSTATEID_Idle then
						if not Squad_IsReinforcing(s) or Squad_GetProductionQueueSize(s) < 2 then
							Cmd_ReinforceUnit(tmpSG, 1)
						end
					end
					if Squad_IsReinforcing(s) and (not Squad_CanInstantReinforceNow(s) or Squad_Count(s) == Squad_GetMax(s)) then -- Fix for reinforce bug
						Command_Squad(player, tmpSG, SCMD_CancelProduction, false)
					end
					
					local raceStr = Player_GetRaceName(player)
					local ucSetting = AIControl_MainControl_Settings_UnitControl.UnitSettings[bpID]
					local vcUnit = false
					local isVehicle = false
					if ucSetting then -- unit control
						AIControl_MainControl.FUnitControl(s, ucSetting)
					else
						local excludeFromVehicleControl = AIControl_MainControl_Settings_VehicleControl.ExcludeFromControl[raceStr] and AIControl_MainControl_Settings_VehicleControl.ExcludeFromControl[raceStr][bpID]
						isVehicle = AIControl_IsSquadVehicle(s)
						if not excludeFromVehicleControl and isVehicle then -- vehicle control
							vcUnit = true
							AIControl_MainControl.FVehicleControl(s)
						end
					end
					local bcSetting = AIControl_MainControl_Settings_BarrageControl.UnitSettings[bpID]
					if bcSetting then
						AIControl_MainControl.FBarrageControl(s, bcSetting)
					end
					if not ucSetting and not vcUnit and not bcSetting and not isVehicle then
						local squadGameID = Squad_GetGameID(s)
						if not AIControl_MainControl_LockedSquads[team][squadGameID]
								or AIControl_MainControl_LockedSquads[team][squadGameID] == -1
								or AIControl_MainControl_LockedSquads[team][squadGameID] == 4
								or AIControl_MainControl_LockedSquads[team][squadGameID] == 5
								or AIControl_MainControl_LockedSquads[team][squadGameID] == 6 then
							local inCombat = Squad_IsAttacking(s, 20) or Squad_IsUnderAttack(s, 20)
							if inCombat
									or AIControl_MainControl_LockedSquads[team][squadGameID] == 4
									or AIControl_MainControl_LockedSquads[team][squadGameID] == 5
									or AIControl_MainControl_LockedSquads[team][squadGameID] == 6 then
								AIControl_MainControl.FCombatUnitControl(s, inCombat)
							else
								-- endless capture/move order bug fix
								local lockCapturer = false
								if Squad_HasActiveCommand(s) and Squad_GetActiveCommand(s) == SQUADSTATEID_Capture then
									local nearbySG = SGroup_Create('aicontrol_capture_nearby')
									World_GetSquadsNearPoint(player, nearbySG, pos, 15, OT_Ally)
									local nearbyCapturers = false
									for j=1,SGroup_CountSpawned(nearbySG) do
										local nearbySquad = SGroup_GetSpawnedSquadAt(nearbySG, j)
										local nearbyquadGameID = Squad_GetGameID(nearbySquad)
										if nearbyquadGameID ~= squadGameID and not AIControl_Grid.RecentlyCancelledCapture[nearbyquadGameID] and Squad_HasActiveCommand(nearbySquad) and Squad_GetActiveCommand(nearbySquad) == SQUADSTATEID_Capture then
											nearbyCapturers = true
											break
										end
									end
									SGroup_Destroy(nearbySG)
									if nearbyCapturers then
										AIControl_Grid.RecentlyCancelledCapture[squadGameID] = true
										Cmd_Stop(tmpSG)
									else
										lockCapturer = true
									end
								end
								if lockCapturer then
									if not AIControl_MainControl_LockedSquads[team][squadGameID] then
										if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
											AI_LockSquad(player, s)
										end
										AIControl_MainControl_LockedSquads[team][squadGameID] = -1
									end
								else
									if AIControl_MainControl_LockedSquads[team][squadGameID] == -1 then
										if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
											AI_UnlockSquad(player, s)
										end
										AIControl_MainControl_LockedSquads[team][squadGameID] = nil
									end
								end
							end
						end
					end
					SGroup_Destroy(tmpSG)
				end
			end
			
			if not AIControl_Grid_Settings.ExcludedUnits[bpID] then
				local squadWeight = 1
				local squadHealthMax = Squad_GetHealthMax(s)
				local squadHealth = Squad_GetHealth(s)
				
				local armorValue = 0
				if Squad_GetMax(s) == 1 then
					if squadHealthMax > 200 then
						squadWeight = squadHealthMax/(50+(squadHealthMax-200)*0.1)*(1/3) + squadHealth/(50+(squadHealth-200)*0.1)*(1/3)*2
						armorValue = (squadHealthMax-200)*(1/4)
					else
						squadWeight = squadHealthMax*0.02*(1/3) + squadHealth*0.02*(1/3)*2
					end
					if armorValue > 0 then
						squadWeight = squadWeight * (1 + armorValue/70)
					end
				elseif Squad_Count(s) > 0 then
					squadWeight = Squad_Count(s)*0.5+squadHealthMax/150*(1/3)+squadHealth/150*(1/3)*2
				end
				if Squad_IsRetreating(s) or retreated then
					squadWeight = squadWeight * (1/4)
				end
				
				AIControl_Grid_t_Data[x][y][team] = AIControl_Grid_t_Data[x][y][team] + squadWeight
				AIControl_Grid_t_DataCounts[x][y][team] = AIControl_Grid_t_DataCounts[x][y][team] + 1
				AIControl_Grid_t_ArmorData[x][y][team] = AIControl_Grid_t_ArmorData[x][y][team] + armorValue
				AIControl_Grid_t_DataHistory[x][y][team] = AIControl_Grid_t_DataHistory[x][y][team] + squadWeight/max(squadCounts[team])*AIControl_Grid_Settings.HistoryGrowthModifier
				SGroup_Add(AIControl_Grid_t_DataSquads[x][y][team], s)
				
				AIControl_Grid_t_AveragePosData[x][y][team].x = AIControl_Grid_t_AveragePosData[x][y][team].x + pos.x
				AIControl_Grid_t_AveragePosData[x][y][team].y = AIControl_Grid_t_AveragePosData[x][y][team].y + pos.y
				AIControl_Grid_t_AveragePosData[x][y][team].z = AIControl_Grid_t_AveragePosData[x][y][team].z + pos.z
			end
		end
		SGroup_Destroy(squads)
		
		if not AIControl_Grid_Settings.SplitUpdates or AIControl_Grid.SplitUpdateStep == 0 then
			for i=1,Dimensions[1] do
				for j=1,Dimensions[2] do
					for team=1,2 do
						AIControl_Grid_DataCounts[i][j][team] = AIControl_Grid_t_DataCounts[i][j][team]
						
						SGroup_Clear(AIControl_Grid_DataSquads[i][j][team])
						for k=1,SGroup_CountSpawned(AIControl_Grid_t_DataSquads[i][j][team]) do
							SGroup_Add(AIControl_Grid_DataSquads[i][j][team], SGroup_GetSpawnedSquadAt(AIControl_Grid_t_DataSquads[i][j][team], k))
						end
						
						AIControl_Grid_Data[i][j][team] = AIControl_Grid_t_Data[i][j][team]
						AIControl_Grid_ArmorData[i][j][team] = AIControl_Grid_t_ArmorData[i][j][team]
						AIControl_Grid_DataHistory[i][j][team] = AIControl_Grid_t_DataHistory[i][j][team]
						if AIControl_Grid_DataCounts[i][j][team] > 0 then
							AIControl_Grid_AveragePosData[i][j][team] = World_Pos(
								AIControl_Grid_t_AveragePosData[i][j][team].x/AIControl_Grid_DataCounts[i][j][team],
								AIControl_Grid_t_AveragePosData[i][j][team].y/AIControl_Grid_DataCounts[i][j][team],
								AIControl_Grid_t_AveragePosData[i][j][team].z/AIControl_Grid_DataCounts[i][j][team])
						else
							AIControl_Grid_AveragePosData[i][j][team] = World_Pos(AIControl_Grid.ControlPoints[i][j].x, AIControl_Grid.ControlPoints[i][j].y, AIControl_Grid.ControlPoints[i][j].z)
						end
					end
				end
			end
			
			-- Update clump data
			local highestPos = {{0, 0}, {0, 0}}
			local highestDanger = {0, 0}
			local highestPosFOW = {{0, 0}, {0, 0}}
			local highestDangerFOW = {0, 0}
			for team=1,2 do
				local enemyTeam = Team_GetEnemyTeam(team-1)+1
				local player
				for i=1,World_GetPlayerCount() do
					local p = World_GetPlayerAt(i)
					if Player_GetTeam(p)+1 == team then
						player = p
						break
					end
				end
				for i=1,Dimensions[1] do
					for j=1,Dimensions[2] do
						if AIControl_Grid_Data[i][j][enemyTeam] > 0 then
							local canSee = Player_CanSeePosition(player, AIControl_Grid_AveragePosData[i][j][enemyTeam])
							local surroundingSafety = AIControl_MainControl.GetSurroundingSafety({i, j}, 0, 1, team)
							local danger = 0
							local dangerFOW = 0
							for k=1,#surroundingSafety do
								local v = surroundingSafety[k]
								danger = danger + v[3] + v[4]*0.015 - v[5]*0.35
								dangerFOW = dangerFOW - v[5]*0.35
								if canSee then
									dangerFOW = dangerFOW + v[3] + v[4]*0.015
								else
									dangerFOW = dangerFOW + v[3]*0.275 + v[4]*0.175
								end
							end
							AIControl_Grid_DataClumpFOW[i][j][enemyTeam] = dangerFOW
							if dangerFOW > highestDangerFOW[team] then
								highestDangerFOW[team] = dangerFOW
								highestPosFOW[team] = {i, j}
							end
							if canSee then
								AIControl_Grid_DataClump[i][j][enemyTeam] = danger
								if danger > highestDanger[team] then
									highestDanger[team] = danger
									highestPos[team] = {i, j}
								end
							else
								AIControl_Grid_DataClump[i][j][enemyTeam] = 0
							end
						else
							AIControl_Grid_DataClump[i][j][enemyTeam] = 0
							AIControl_Grid_DataClumpFOW[i][j][enemyTeam] = 0
						end
					end
				end
			end
			for p=1,AIControl_PlayerCount do
				local player = World_GetPlayerAt(AIControl_Players[p])
				if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
					local team = Player_GetTeam(player)+1
					local enemyTeam
					if team == 1 then enemyTeam = 2
					else enemyTeam = 1 end
					local pos
					if highestDangerFOW[team] < 2 then
						AI_DoString(player, "AIControlArtyPosFOW=nil")
					else
						pos = AIControl_Grid_AveragePosData[ highestPosFOW[team][1] ][ highestPosFOW[team][2] ][enemyTeam]
						AI_DoString(player, string.format("AIControlArtyPosFOW=World_Pos(%.2f, %.2f, %.2f)", pos.x, pos.y, pos.z))
					end
					if highestDanger[team] < 2 then
						AI_DoString(player, "AIControlArtyPos=nil")
					else
						pos = AIControl_Grid_AveragePosData[ highestPos[team][1] ][ highestPos[team][2] ][enemyTeam]
						AI_DoString(player, string.format("AIControlArtyPos=World_Pos(%.2f, %.2f, %.2f)", pos.x, pos.y, pos.z))
					end
				end
			end
			
			--AIControl_Grid.DebugOutput()
			
			AIControl_MainControl.Update()
		end
	end,
	DebugOutput = function()
		local function pr(i, j, val1, val2)
			local x = i*Dimensions[3]-wHalfWidth-Dimensions[3]*0.5
			local y = j*Dimensions[4]-wHalfHeight-Dimensions[4]*0.5
			--dr_text3d('aicontrol_grid', x, World_GetHeightAt(x, y)+0.35, y, string.format('%.1f / %.1f', val1, val2), 0, 255, 0)
		end
		for i=1,Dimensions[1] do
			for j=1,Dimensions[2] do
				pr(i, j, AIControl_Grid_DataClumpFOW[i][j][1], AIControl_Grid_DataClumpFOW[i][j][2])
			end
		end
	end
}

--------------------------------------------------------------------------------------------------------------------

AIControl.Pathfinding = { -- currently unused
	Settings = {
		Precision = 1.5,
		EntityBlueprint = BP_GetEntityBlueprint("ebps/races/allies/vehicles/m4_sherman.lua")
	},
	StepsTotal = {1,1},
	Data = {},
	CurrentYStep = 1,
	Entity = nil,
	DebugPrint = function(path)
		--dr_clear("aicontrol_pathfinding_mapdebug")
		for y = 1,AIControl.Pathfinding.StepsTotal[2] do
			local line = ''
			for x = 1,AIControl.Pathfinding.StepsTotal[1] do
				if AIControl.Pathfinding.Data[x][y] then
					--if y == AIControl.Pathfinding.CurrentYStep then
					--	--dr_text2d("aicontrol_pathfinding_mapdebug", 0.007+x*0.004, 0.007+y*0.0045, '-', 255, 255, 255)
					--end
				else
					--dr_text2d("aicontrol_pathfinding_mapdebug", 0.007+x*0.004, 0.007+y*0.0045, '+', 0, 0, 0)
				end
			end
		end
		
		if path then
			--dr_clear("aicontrol_pathfinding_pathdebug")
			for i,v in pairs(path) do
				--dr_text2d("aicontrol_pathfinding_pathdebug", 0.007+v[1]*0.004, 0.007+v[2]*0.0045, 'o', 255, 0, 0)
			end
		end
	end,
	
	-- Pseudocode from http://en.wikipedia.org/wiki/A_star
	GetPath = function(start, goal)
		local closedset = {} -- The set of nodes already evaluated.
		local closedsetCount = 0
		local openset = {{start[1],start[2]}} -- The set of tentative nodes to be evaluated, initially containing the start node
		local opensetCount = 1
		local came_from = {} -- The map of navigated nodes.
		
		local g_score = {}
		g_score[start[1]] = {}
		g_score[start[1]][start[2]] = 0 -- Cost from start along best known path.
		-- Estimated total cost from start to goal through y.
		local f_score = {}
		f_score[start[1]] = {}
		f_score[start[1]][start[2]] = g_score[start[1]][start[2]] + AIControl.Pathfinding.CostEstimate(start, goal)
		
		local stepsTotal = 0
		while opensetCount > 0 and stepsTotal < 150 do
			stepsTotal = stepsTotal + 1
			
			local currenti = 1 --the node in openset having the lowest f_score[] value
			for i=2,opensetCount do
				if f_score[openset[currenti][1]][openset[currenti][2]] > f_score[openset[i][1]][openset[i][2]] then
					currenti = i
				end
			end
			
			local current = {openset[currenti][1],openset[currenti][2]}
			
			if current[1] == goal[1] and current[2] == goal[2] then
				return AIControl.Pathfinding.ReconstructPath(came_from, goal)
			end
			
			--remove current from openset
			for i=currenti,opensetCount do
				openset[i] = openset[i+1]
			end
			opensetCount = opensetCount - 1
			
			-- add current to closedset
			closedsetCount = closedsetCount + 1
			closedset[closedsetCount] = {current[1],current[2]}
			
			local neighbour_nodes = AIControl.Pathfinding.GetNeighbours(current)
			local neighbourCount = #neighbour_nodes
			for neighbourIndex = 1,neighbourCount do
				local neighbour = neighbour_nodes[neighbourIndex]
				local notInClosedSet = true
				for i=1,closedsetCount do
					if neighbour[1] == closedset[i][1] and neighbour[2] == closedset[i][2] then
						notInClosedSet = false
						break
					end
				end
				if notInClosedSet then
					local tentative_g_score = g_score[current[1]][current[2]] + AIControl.Pathfinding.DistBetween(current, neighbour)
					
					local notInOpenset = true
					for i=1,opensetCount do
						if (neighbour[1] == openset[i][1]) and (neighbour[2] == openset[i][2]) then
							notInOpenset = false
							break
						end
					end
					if notInOpenset or tentative_g_score < g_score[neighbour[1]][neighbour[2]] then
						if not came_from[neighbour[1]] then
							came_from[neighbour[1]] = {}
						end
						came_from[neighbour[1]][neighbour[2]] = {current[1],current[2]}
						
						if not g_score[neighbour[1]] then
							g_score[neighbour[1]] = {}
						end
						g_score[neighbour[1]][neighbour[2]] = tentative_g_score
						
						if not f_score[neighbour[1]] then
							f_score[neighbour[1]] = {}
						end
						f_score[neighbour[1]][neighbour[2]] = g_score[neighbour[1]][neighbour[2]] + AIControl.Pathfinding.CostEstimate(neighbour, goal)
						
						if notInOpenset then
							opensetCount = opensetCount + 1
							openset[opensetCount] = {neighbour[1],neighbour[2]}
						end
					end
				end
			end
		end
		return AIControl.Pathfinding.ReconstructPath(came_from, goal)
	end,
	ReconstructPath = function(came_from, current_node)
		if came_from[current_node[1]] and came_from[current_node[1]][current_node[2]] then
			local p = AIControl.Pathfinding.ReconstructPath(came_from, came_from[current_node[1]][current_node[2]])
			p[#p+1] = current_node
			return p
		else
			return {current_node}
		end
	end,
	GetNeighbours = function(cell)
		local result = {}
		local resultn = 0
		
		local leftOK = false
		local topOK = false
		local rightOK = false
		local bottomOK = false
		
		-- left
		if cell[1]-1 >= 1 then
			leftOK = true
			if AIControl.Pathfinding.Data[cell[1]-1][cell[2]] then
				resultn = resultn + 1
				result[resultn] = {cell[1]-1, cell[2]}
			end
		end
		-- top
		if cell[2]-1 >= 1 then
			topOK = true
			if AIControl.Pathfinding.Data[cell[1]][cell[2]-1] then
				resultn = resultn + 1
				result[resultn] = {cell[1], cell[2]-1}
			end
		end
		-- right
		if cell[1]+1 <= AIControl.Pathfinding.StepsTotal[1] then
			rightOK = true
			if AIControl.Pathfinding.Data[cell[1]+1][cell[2]] then
				resultn = resultn + 1
				result[resultn] = {cell[1]+1, cell[2]}
			end
		end
		-- bottom
		if cell[2]+1 <= AIControl.Pathfinding.StepsTotal[2] then
			bottomOK = true
			if AIControl.Pathfinding.Data[cell[1]][cell[2]+1] then
				resultn = resultn + 1
				result[resultn] = {cell[1], cell[2]+1}
			end
		end
		
		-- topleft
		if topOK and leftOK and AIControl.Pathfinding.Data[cell[1]-1][cell[2]-1] then
			resultn = resultn + 1
			result[resultn] = {cell[1]-1, cell[2]-1}
		end
		-- topright
		if topOK and rightOK and AIControl.Pathfinding.Data[cell[1]+1][cell[2]-1] then
			resultn = resultn + 1
			result[resultn] = {cell[1]+1, cell[2]-1}
		end
		-- bottomleft
		if bottomOK and leftOK and AIControl.Pathfinding.Data[cell[1]-1][cell[2]+1] then
			resultn = resultn + 1
			result[resultn] = {cell[1]-1, cell[2]+1}
		end
		-- bottomright
		if bottomOK and rightOK and AIControl.Pathfinding.Data[cell[1]+1][cell[2]+1] then
			resultn = resultn + 1
			result[resultn] = {cell[1]+1, cell[2]+1}
		end
		
		return result
	end,
	DistBetween = function(start, goal)
		local xdist = goal[1]-start[1]
		local ydist = goal[2]-start[2]
		return xdist^2 + ydist^2
	end,
	CostEstimate = function(start, goal)
		return 1 -- AIControl.Pathfinding.DistBetween(start, goal)
	end,
	
	-- A* pathfinding algorithm
	-- Code taken and modified from https://github.com/philnelson/A-Star-Pathfinding-For-Lua
	--[[CalcMoves = function(startx, starty, tx, ty)
		-- Returns:
		--  closedlist - a list with the checked nodes
		--  OR nil if all the available nodes have been checked but the target hasn't been found
		
		local map = AIControl.Pathfinding.Data
		
		-- variables
		local openlist = {} -- Initialize table to store possible moves
		local closedlist = {}  -- Initialize table to store checked gridsquares
		local listk = 1  -- List counter
		local closedk = 0 -- Closedlist counter
		local tempH = math.abs(startx-tx) + math.abs(starty-ty)
		local tempG = 0
		local xsize = AIControl.Pathfinding.StepsTotal[1] -- horizontal map size
		local ysize = AIControl.Pathfinding.StepsTotal[2] -- vertical map size
		local curbase = {} -- Current square from which to check possible moves
		local basis = 1 -- Index of current base
		
		openlist[1] = {x=startx, y=starty, g=0, h=tempH, f=0+tempH, par=1} -- Make starting point in list
		
		-- Growing loop
		local stepsTotal = 0
		while listk > 0 and stepsTotal < 200 do
			stepsTotal = stepsTotal + 1
			
			-- Get the lowest f of the openlist
			local lowestF = openlist[listk].f
			basis = listk
			for k = listk,1,-1 do
				if openlist[k].f < lowestF then
					lowestF = openlist[k].f
					basis = k
				end
			end
			
			closedk = closedk+1
			table.insert(closedlist, closedk, openlist[basis])
			
			curbase = closedlist[closedk] -- define current base from which to grow list
			
			-- Booleans defining if they're OK to add
			-- (must be reset for each while loop)
			local rightOK = true
			local leftOK = true
			local downOK = true 
			local upOK = true
			local topRightOK = true
			local topLeftOK = true
			local bottomRightOK = true
			local bottomLeftOK = true

			-- Look through closedlist
			if closedk > 0 then
				for k = 1,closedk do
					if closedlist[k].x == curbase.x+1 and closedlist[k].y == curbase.y then
						rightOK = false
					end
					if closedlist[k].x == curbase.x-1 and closedlist[k].y == curbase.y then
						leftOK = false
					end
					if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y+1 then
						downOK = false
					end
					if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y-1 then
						upOK = false
					end
					
					if closedlist[k].x == curbase.x+1 and closedlist[k].y == curbase.y-1 then
						topRightOK = false
					end
					if closedlist[k].x == curbase.x-1 and closedlist[k].y == curbase.y-1 then
						topLeftOK = false
					end
					if closedlist[k].x == curbase.x+1 and closedlist[k].y == curbase.y+1 then
						bottomrRightOK = false
					end
					if closedlist[k].x == curbase.x-1 and closedlist[k].y == curbase.y+1 then
						bottomLeftOK = false
					end
				end
			end
			
			-- Check if next points are on the map and within moving distance
			if curbase.x+1 > xsize then rightOK = false topRightOK = false bottomRightOK = false end
			if curbase.x-1 < 1     then leftOK = false topLeftOK = false bottomLeftOK = false end
			if curbase.y+1 > ysize then downOK = false bottomRightOK = false bottomLeftOK = false end
			if curbase.y-1 < 1     then upOK = false topRightOK = false topLeftOK = false end
			
			-- If it IS on the map, check map for obstacles
			-- (Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
			if rightOK and map[curbase.y][curbase.x+1] == false then rightOK = false end
			if leftOK and map[curbase.y][curbase.x-1] == false then leftOK = false end
			if downOK and map[curbase.y+1][curbase.x] == false then downOK = false end
			if upOK and map[curbase.y-1][curbase.x] == false then upOK = false end
			
			if topRightOK and map[curbase.y-1][curbase.x+1] == false then topRightOK = false end
			if topLeftOK and map[curbase.y-1][curbase.x-1] == false then topLeftOK = false end
			if bottomRightOK and map[curbase.y+1][curbase.x+1] == false then bottomRightOK = false end
			if bottomLeftOK and map[curbase.y+1][curbase.x-1] == false then bottomLeftOK = false end
			
			-- check if the move from the current base is shorter then from the former parrent
			tempG = curbase.g+1
			for k = 1,listk do
				if rightOK and openlist[k].x == curbase.x+1 and openlist[k].y == curbase.y and openlist[k].g > tempG then
					tempH = math.abs((curbase.x+1)-tx) + math.abs(curbase.y-ty)
					table.insert(openlist, k, {x=curbase.x+1, y=curbase.y, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					rightOK = false
				end
				if leftOK and openlist[k].x==curbase.x-1 and openlist[k].y==curbase.y and openlist[k].g > tempG then
					tempH = math.abs((curbase.x-1)-tx) + math.abs(curbase.y-ty)
					table.insert(openlist, k, {x=curbase.x-1, y=curbase.y, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					leftOK = false
				end
				if downOK and openlist[k].x==curbase.x and openlist[k].y==curbase.y+1 and openlist[k].g>tempG then
					tempH = math.abs((curbase.x)-tx) + math.abs(curbase.y+1-ty)
					table.insert(openlist, k, {x=curbase.x, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					downOK = false
				end
				if upOK and openlist[k].x==curbase.x and openlist[k].y==curbase.y-1 and openlist[k].g>tempG then
					tempH = math.abs((curbase.x)-tx) + math.abs(curbase.y-1-ty)
					table.insert(openlist, k, {x=curbase.x, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					upOK = false
				end
				
				if topRightOK and openlist[k].x == curbase.x+1 and openlist[k].y == curbase.y-1 and openlist[k].g > tempG then
					tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y-1)-ty)
					table.insert(openlist, k, {x=curbase.x+1, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					topRightOK = false
				end
				if topLeftOK and openlist[k].x==curbase.x-1 and openlist[k].y==curbase.y-1 and openlist[k].g > tempG then
					tempH = math.abs((curbase.x-1)-tx) + math.abs((curbase.y-1)-ty)
					table.insert(openlist, k, {x=curbase.x-1, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					topLeftOK = false
				end
				if bottomRightOK and openlist[k].x==curbase.x+1 and openlist[k].y==curbase.y+1 and openlist[k].g>tempG then
					tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y+1)-ty)
					table.insert(openlist, k, {x=curbase.x, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					bottomRightOK = false
				end
				if bottomLeftOK and openlist[k].x==curbase.x+1 and openlist[k].y==curbase.y-1 and openlist[k].g>tempG then
					tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y-1)-ty)
					table.insert(openlist, k, {x=curbase.x, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
					bottomLeftOK = false
				end
			end
			
			-- Add points to openlist
			if rightOK then
				listk = listk+1
				tempH = math.abs((curbase.x+1)-tx) + math.abs(curbase.y-ty)
				table.insert(openlist, listk, {x=curbase.x+1, y=curbase.y, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if leftOK then
				listk = listk+1
				tempH = math.abs((curbase.x-1)-tx) + math.abs(curbase.y-ty)
				table.insert(openlist, listk, {x=curbase.x-1, y=curbase.y, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if downOK then
				listk = listk+1
				tempH = math.abs(curbase.x-tx) + math.abs((curbase.y+1)-ty)
				table.insert(openlist, listk, {x=curbase.x, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if upOK then
				listk = listk+1
				tempH = math.abs(curbase.x-tx) + math.abs((curbase.y-1)-ty)
				table.insert(openlist, listk, {x=curbase.x, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			
			if topRightOK then
				listk = listk+1
				tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y-1)-ty)
				table.insert(openlist, listk, {x=curbase.x+1, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if topLeftOK then
				listk = listk+1
				tempH = math.abs((curbase.x-1)-tx) + math.abs((curbase.y-1)-ty)
				table.insert(openlist, listk, {x=curbase.x-1, y=curbase.y-1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if bottomRightOK then
				listk = listk+1
				tempH = math.abs((curbase.x+1)-tx) + math.abs((curbase.y+1)-ty)
				table.insert(openlist, listk, {x=curbase.x+1, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			if bottomLeftOK then
				listk = listk+1
				tempH = math.abs((curbase.x-1)-tx) + math.abs((curbase.y+1)-ty)
				table.insert(openlist, listk, {x=curbase.x-1, y=curbase.y+1, g=tempG, h=tempH, f=tempG+tempH, par=closedk})
			end
			
			table.remove(openlist, basis)
			listk = listk-1
			
			if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
				return closedlist
			end
		end
		
		return closedlist
	end,
	CalcPath = function(closedlist)
		-- closedlist - a list with the checked nodes.
		--  OR nil if all the available nodes have been checked but the target hasn't been found.
		-- Returns:
		--  a path is a list with all the x and y coords of the nodes of the path to the target.
		--  OR nil if closedlist==nil
		
		if closedlist==nil then
			return nil
		end
		
		local path = {}
		local pathIndex = {}
		local last = #closedlist
		table.insert(pathIndex, 1, last)
		
		local i = 1
		while pathIndex[i] > 1 do
			i = i+1
			table.insert(pathIndex, i, closedlist[ pathIndex[i-1] ].par)
		end
		
		for n = #pathIndex,1,-1 do
			table.insert(path, {x=closedlist[ pathIndex[n] ].x, y=closedlist[ pathIndex[n] ].y})
		end
		
		closedlist = nil
		
		AIControl.Pathfinding.DebugPrint(path)
		
		return path
	end,]]
	
	FindClosestUnobstructedPoint = function(startx, starty, bias)
		local angle
		local directionMultiplier
		if bias then
			angle = math.acos((startx*bias[1]+starty*bias[2]) / (sqrt(startx*startx + starty*starty) * sqrt(bias[1]*bias[1] + bias[2]*bias[2])))
			directionMultiplier = 1
		else
			angle = World_GetRand(1, 360) / 180 * 3.14
			directionMultiplier = 0
		end
		local direction = {math.cos(angle), math.sin(angle)}
		local startx = max(2, min(AIControl.Pathfinding.StepsTotal[1]-1, startx))
		local starty = max(2, min(AIControl.Pathfinding.StepsTotal[2]-1, starty))
		local curx = startx
		local cury = starty
		local radius = 2
		if AIControl.Pathfinding.Data[curx][cury] then
			return {curx, cury}
		end
		while radius < 4 do
			curx = curx + direction[1]*directionMultiplier
			cury = cury + direction[2]*directionMultiplier
			local curxv = floor(curx+0.5)
			local curyv = floor(cury+0.5)
			if not (curxv >= 1 and curxv <= AIControl.Pathfinding.StepsTotal[1] and curyv >= 1 and curyv <= AIControl.Pathfinding.StepsTotal[2]) then
				break
			end
			for x=-radius,radius do
				local testx = curxv+x
				if testx >= 1 and testx <= AIControl.Pathfinding.StepsTotal[1] then
					for y=-radius,radius do
						local testy = curyv+y
						if testy >= 1 and testy <= AIControl.Pathfinding.StepsTotal[2] then
							if AIControl.Pathfinding.Data[testx][testy] then
								return {testx,testy}
							end
						end
					end
				end
			end
			
			radius = radius + 1
		end
		return {startx, starty}
	end,
	
	Reset = function()
		AIControl.Pathfinding.StepsTotal[1] = floor(World_GetWidth()/AIControl.Pathfinding.Settings.Precision)+1
		AIControl.Pathfinding.StepsTotal[2] = floor(World_GetLength()/AIControl.Pathfinding.Settings.Precision)+1
		AIControl.Pathfinding.Data = {}
		for x=1,AIControl.Pathfinding.StepsTotal[1] do
			AIControl.Pathfinding.Data[x] = {}
			for y=1,AIControl.Pathfinding.StepsTotal[2] do
				AIControl.Pathfinding.Data[x][y] = false
			end
		end
		AIControl.Pathfinding.ReconstructFullMap()
	end,
	ReconstructPart = function()
		local halfWidth = AIControl.Pathfinding.Settings.Precision*0.5
		for step=1,2 do
			for x=1,AIControl.Pathfinding.StepsTotal[1] do
				AIControl.Pathfinding.Data[x][AIControl.Pathfinding.CurrentYStep] = false
			end
			if AIControl.Pathfinding.CurrentYStep ~= 1 and AIControl.Pathfinding.CurrentYStep ~= AIControl.Pathfinding.StepsTotal[2] then
				for x=2,AIControl.Pathfinding.StepsTotal[1]-1 do
					local pos = World_GetSpawnablePosition(World_Pos(
						x*AIControl.Pathfinding.Settings.Precision-halfWidth-wHalfWidth,
						0,
						AIControl.Pathfinding.CurrentYStep*AIControl.Pathfinding.Settings.Precision-halfWidth-wHalfHeight
					), AIControl.Pathfinding.Entity)
					local posx = floor((pos.x + wHalfWidth) / AIControl.Pathfinding.Settings.Precision)+1
					local posy = floor((pos.z + wHalfHeight) / AIControl.Pathfinding.Settings.Precision)+1
					AIControl.Pathfinding.Data[posx][posy] = true
				end
			end
			
			AIControl.Pathfinding.CurrentYStep = AIControl.Pathfinding.CurrentYStep + 1
			if AIControl.Pathfinding.CurrentYStep > AIControl.Pathfinding.StepsTotal[2] then
				AIControl.Pathfinding.CurrentYStep = 1
			end
		end
		
		--AIControl.Pathfinding.DebugPrint()
	end,
	ReconstructFullMap = function()
		local halfWidth = AIControl.Pathfinding.Settings.Precision*0.5
		for x=2,AIControl.Pathfinding.StepsTotal[1]-1 do
			for y=2,AIControl.Pathfinding.StepsTotal[2]-1 do
				local pos = World_GetSpawnablePosition(World_Pos(
					x*AIControl.Pathfinding.Settings.Precision-halfWidth-wHalfWidth,
					0,
					y*AIControl.Pathfinding.Settings.Precision-halfWidth-wHalfHeight
				), AIControl.Pathfinding.Entity)
				local posx = floor((pos.x + wHalfWidth) / AIControl.Pathfinding.Settings.Precision)+1
				local posy = floor((pos.z + wHalfHeight) / AIControl.Pathfinding.Settings.Precision)+1
				AIControl.Pathfinding.Data[posx][posy] = true
			end
		end
		
		--[[--print('Pathfinding:');
		for y = 1,AIControl.Pathfinding.StepsTotal[2] do
			local line = ''
			for x = 1,AIControl.Pathfinding.StepsTotal[1] do
				if AIControl.Pathfinding.Data[x][y] then
					line = line..' '
				else
					line = line..'█'
				end
			end
			--print(line)
		end]]
		
		--AIControl.Pathfinding.DebugPrint()
	end,
	Init = function()
		AIControl.Pathfinding.Entity = Entity_CreateENV(AIControl.Pathfinding.Settings.EntityBlueprint, World_Pos(-wHalfWidth, 0, -wHalfHeight), World_Pos(1, 0, 0))
		Entity_DeSpawn(AIControl.Pathfinding.Entity)
		
		--dr_setdisplay("aicontrol_pathfinding_mapdebug", true)
		--dr_setautoclear("aicontrol_pathfinding_mapdebug", false)
		--dr_clear("aicontrol_pathfinding_mapdebug")
		
		--dr_setdisplay("aicontrol_pathfinding_pathdebug", true)
		--dr_setautoclear("aicontrol_pathfinding_pathdebug", false)
		--dr_clear("aicontrol_pathfinding_pathdebug")
		
		AIControl.Pathfinding.Reset()
		--Rule_AddInterval(AIControl.Pathfinding.ReconstructPart, 0.1)
	end
}

--------------------------------------------------------------------------------------------------------------------

local UNIT_CONTROL_CONST = {
	DEFAULT_SETUP_TARGET_DANGER = 2.3,
	DEFAULT_SAFETY_SEARCH_RADIUS_STEPS = 3,
	DEFAULT_MOVE_BACK_DANGER = 8.5,
	DEFAULT_RETREAT_DANGER = 19,
}
local UNIT_CONTROL_PRESET = {
	SNIPER = {
		['attack_move_forward'] = true,
		['safety_radius_steps'] = 3,
		['setup_target_danger'] = 0.85,
		['move_back_danger'] = 2.15,
		['retreat_danger'] = 6,
		['init_step'] = 2,
		['step_count'] = 2,
		['target_angle_threshold'] = -1
	},
	MORTAR = {
		['safety_radius_steps'] = 5,
		['setup_target_danger'] = 0.5,
		['move_back_danger'] = 1.35,
		['retreat_danger'] = 11,
		['init_step'] = 2,
		['step_count'] = 6,
		['target_angle_threshold'] = -1
	},
	NEBELWERFER = {
		['safety_radius_steps'] = 7,
		['setup_target_danger'] = 0.5, -- shouldn't ever setup (get locked while not barraging)
		['move_back_danger'] = 0.55,
		['retreat_danger'] = -1,
		['init_step'] = 3,
		['step_count'] = 2,
		['target_angle_threshold'] = -1
	},
	AT_GUN = {
		['targets_armor'] = true,
		['armor_danger_decrease'] = 0.45,
		['armor_danger_decrease_reduction_threshold'] = 200,
		['search_cover'] = false,
		['safety_radius_steps'] = 6,
		['setup_target_danger'] = 2,
		['move_back_danger'] = 0.45,
		['retreat_danger'] = -1,
		['init_step'] = 0,
		['step_count'] = 5,
		['target_angle_threshold'] = 18
	}
}

local HMGBlueprintIDs = {
	[BP_GetID(SBP.ALLIES.HEAVYMG)] = true,
	[BP_GetID(SBP.ALLIES.PARATROOPER_HEAVYMG_SP)] = true,
	[BP_GetID(SBP.AXIS.HEAVYMG)] = true,
	[BP_GetID(SBP.AXIS.CAPTURE_MG)] = true,
	[BP_GetID(SBP.CW.VICKERSMG)] = true,
	[BP_GetID(SBP.CW.VICKERS_MG_SP)] = true,
	[BP_GetID(SBP.CW.CAPTURE_MG)] = true,
	[BP_GetID(SBP.CW.COMMANDOS_MG42_SP)] = true,
	[BP_GetID(SBP.ELITE.HEAVYMG)] = true,
	[BP_GetID(SBP.ELITE.FALLSCHIRMJAGER_HMG)] = true,
}

local BARRAGE_CONTROL_POSITION
BARRAGE_CONTROL_POSITION = {
	SMOKE_BARRAGE = function(squad, setting, distance_in_front)
		local distanceInFront = distance_in_front or 40
		local player = Squad_GetPlayerOwner(squad)
		local selfPos = Squad_GetPosition(squad)
		local sg = SGroup_CreateIfNotFound('tactics_infrontofmgpos')
		SGroup_Clear(sg)
		World_GetSquadsNearPoint(player, sg, selfPos, setting.searchrange, OT_Enemy)
		local closestDist = setting.searchrange+5
		local closestSquad = nil
		for i=1,SGroup_CountSpawned(sg) do
			local s = SGroup_GetSpawnedSquadAt(sg, i)
			local bpID = BP_GetID(Squad_GetBlueprint(s))
			if HMGBlueprintIDs[bpID] then
				local heading = false
				for j=0,Squad_Count(s)-1 do
					local e = Squad_EntityAt(s, j)
					if Entity_IsSyncWeapon(e) then
						heading = Entity_GetHeading(e)
						break
					end
				end
				if not heading then
					heading = Squad_GetHeading(s)
				end
				local sg2 = SGroup_CreateIfNotFound('tactics_infrontofmgpos2')
				local squadPos = Squad_GetPosition(s)
				local dropPos = World_Pos(squadPos.x+heading.x*distanceInFront, squadPos.y+heading.y*distanceInFront, squadPos.z+heading.z*distanceInFront)
				World_GetSquadsNearPoint(player, sg2, dropPos, 45, OT_Ally)
				if SGroup_CountSpawned(sg2) > 0 then
					SGroup_Destroy(sg2)
					SGroup_Destroy(sg)
					return dropPos
				end
				SGroup_Destroy(sg2)
			end
		end
		SGroup_Destroy(sg)
		return false
	end,
}

local CUCONTROL_TACTIC
local CUCONTROL_ABILITY_PRESET
local CUCONTROL_BEHAVIORS

CUCONTROL_TACTIC = {
	FILTER = {
		--GRENADE = function(squad) return true end
	},
	RANGE = {
		GRENADE = function(squad)
		
		end
	},
	POSITION_FILTER = {
		GRENADE = function(squad, custom_range, custom_starting_position)
			local range = custom_range or 30
			local selfPos = custom_starting_position or Squad_GetPosition(squad)
			local sg = SGroup_CreateIfNotFound('tactics_grenadepos')
			SGroup_Clear(sg)
			World_GetSquadsNearPoint(Squad_GetPlayerOwner(squad), sg, selfPos, range, OT_Enemy)
			local closestDist = range+5
			local closestSquad = nil
			for i=1,SGroup_CountSpawned(sg) do
				local s = SGroup_GetSpawnedSquadAt(sg, i)
				if not AIControl_IsSquadVehicle(s) and not Squad_IsMoving(s) then
					local pos = Squad_GetPosition(s)
					local dist = World_DistancePointToPoint(selfPos, pos)
					if dist < closestDist then
						closestDist = dist
						closestSquad = s
					end
				end
			end
			SGroup_Destroy(sg)
			if closestSquad then
				return Squad_GetPosition(closestSquad)
			else
				return false
			end
		end,
		SMOKE_GRENADE = function(squad, custom_range)
			return BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE(squad, {searchrange=40}, 30) -- TODO: Improve this
		end,
		SATCHEL_CHARGE = function(squad, custom_range)
			local range = custom_range or 30
			local selfPos = Squad_GetPosition(squad)
			
			local closestDist = range+5
			local closestPos = nil
			
			-- Throw satchels on MGs
			local sg = SGroup_CreateIfNotFound('tactics_satchelpos')
			SGroup_Clear(sg)
			World_GetSquadsNearPoint(Squad_GetPlayerOwner(squad), sg, selfPos, range, OT_Enemy)
			for i=1,SGroup_CountSpawned(sg) do
				local s = SGroup_GetSpawnedSquadAt(sg, i)
				local isVehicle = false
				for j=0,Squad_Count(s)-1 do
					local entity = Squad_EntityAt(s, j)
					if Entity_IsVehicle(entity) then
						isVehicle = true
						break
					end
				end
				if not isVehicle and not Squad_IsMoving(s) then
					local pos = Squad_GetPosition(s)
					local dist = World_DistancePointToPoint(selfPos, pos)
					if dist < closestDist then
						closestDist = dist
						closestPos = pos
					end
				end
			end
			SGroup_Destroy(sg)
			if closestPos then
				return closestPos
			end
			
			-- Throw satchels on enemy entities
			local eg = EGroup_CreateIfNotFound('tactics_satchelpos')
			EGroup_Clear(eg)
			World_GetEntitiesNearPoint(Squad_GetPlayerOwner(squad), eg, selfPos, range, OT_Enemy)
			local closestEntityPos = nil
			for i=1,EGroup_CountSpawned(eg) do
				local e = EGroup_GetSpawnedEntityAt(eg, i)
				if Entity_IsBuilding(e) then
					local pos = Entity_GetPosition(e)
					local dist = World_DistancePointToPoint(selfPos, pos)
					if dist < closestDist then
						closestDist = dist
						closestPos = pos
					end
				end
			end
			EGroup_Destroy(eg)
			if closestPos then
				return closestPos
			end
			
			return false
		end,
	},
	SQUAD_FILTER = {
		FIRST_VEHICLE = function(squad, custom_range)
			local range = custom_range or 30
			local selfPos = Squad_GetPosition(squad)
			local sg = SGroup_CreateIfNotFound('tactics_stickypos')
			SGroup_Clear(sg)
			World_GetSquadsNearPoint(Squad_GetPlayerOwner(squad), sg, selfPos, range, OT_Enemy)
			local closestDist = range+5
			local closestSquad = nil
			for i=1,SGroup_CountSpawned(sg) do
				local s = SGroup_GetSpawnedSquadAt(sg, i)
				if AIControl_IsSquadVehicle(s) then
					local pos = Squad_GetPosition(s)
					local dist = World_DistancePointToPoint(selfPos, pos)
					if dist < closestDist then
						closestDist = dist
						closestSquad = s
					end
				end
			end
			SGroup_Destroy(sg)
			if closestSquad then
				return closestSquad
			end
			return false
		end,
		VITAL_SHOT = function(squad, custom_range)
			local range = custom_range or 30
			local selfPos = Squad_GetPosition(squad)
			local sg = SGroup_CreateIfNotFound('tactics_vitalshot')
			SGroup_Clear(sg)
			World_GetSquadsNearPoint(Squad_GetPlayerOwner(squad), sg, selfPos, range, OT_Enemy)
			local closestDist = range+5
			local closestSquad = nil
			for i=1,SGroup_CountSpawned(sg) do
				local s = SGroup_GetSpawnedSquadAt(sg, i)
				if not AIControl_IsSquadVehicle(s)
						and (not Squad_IsRetreating(s) or Squad_Count(s) == 1)
						and (Squad_GetMax(s) <= 4 or Squad_Count(s)/Squad_GetMax(s) < 0.6) then
					local pos = Squad_GetPosition(s)
					local dist = World_DistancePointToPoint(selfPos, pos)
					if dist < closestDist then
						closestDist = dist
						closestSquad = s
					end
				end
			end
			SGroup_Destroy(sg)
			if closestSquad then
				return closestSquad
			end
			return false
		end,
	},
	POSITION_VERIFY = {
		GRENADE = function(squad, position1, position2)
			local pos = CUCONTROL_TACTIC.POSITION_FILTER.GRENADE(squad, 5, position1)
			return pos and World_DistancePointToPoint(position1, pos) < 7
		end,
	}
}

CUCONTROL_BEHAVIORS = {
	FIRE_UP = function(squad, callback)
		Cmd_Ability(sg, BP_GetAbilityBlueprint('abilities/ally_fireup_ability.lua'), nil, nil, false, false)
		callback()
	end,
	SPRINT_CW = function(squad, callback)
		Cmd_Ability(sg, BP_GetAbilityBlueprint('abilities/commonwealth_sprint_ability.lua'), nil, nil, false, false)
		callback()
	end,
	SPRINT = function(squad, callback)
		Cmd_Ability(sg, BP_GetAbilityBlueprint('abilities/panzer_elite_sprint_ability.lua'), nil, nil, false, false)
		callback()
	end,
	SPRINT_MOUNTAIN = function(squad, callback)
		Cmd_Ability(sg, BP_GetAbilityBlueprint('abilities/panzer_elite_sprint_ability_mountain.lua'), nil, nil, false, false)
		callback()
	end,
	FIRE_UP_ELITE = function(squad, callback)
		Cmd_Ability(sg, BP_GetAbilityBlueprint('abilities/panzer_elite_fireup_ability.lua'), nil, nil, false, false)
		callback()
	end,
}

CUCONTROL_ABILITY_PRESET = {
	GRENADE = {
		blueprint = BP_GetAbilityBlueprint('abilities/ally_throw_grenade.lua'),
		lockDuration = 15,
		verifyPosition = true,
		weight = 10,
		queued = false,
		type = 'position',
		position = CUCONTROL_TACTIC.POSITION_FILTER.GRENADE,
		positionVerify = CUCONTROL_TACTIC.POSITION_VERIFY.GRENADE
	},
	SMOKE_GRENADE = {
		blueprint = BP_GetAbilityBlueprint('abilities/commonwealth_smoke_rifle_grenade_ability.lua'),
		lockDuration = 15,
		verifyPosition = false,
		weight = 10,
		queued = false,
		type = 'position',
		position = CUCONTROL_TACTIC.POSITION_FILTER.SMOKE_GRENADE,
	},
	FIRST_VEHICLE = {
		blueprint = BP_GetAbilityBlueprint('abilities/ally_throw_sticky_bombs.lua'),
		type = 'squad',
		lockDuration = 10,
		verifyPosition = false,
		weight = 10,
		queued = false,
		squad = CUCONTROL_TACTIC.SQUAD_FILTER.FIRST_VEHICLE,
	},
	VITAL_SHOT = {
		blueprint = BP_GetAbilityBlueprint('abilities/commonwealth_recon_marksmen_shot.lua'),
		lockDuration = 10,
		verifyPosition = false,
		weight = 10,
		queued = false,
		type = 'squad',
		squad = CUCONTROL_TACTIC.SQUAD_FILTER.VITAL_SHOT,
	},
	SATCHEL_CHARGE = {
		blueprint = BP_GetAbilityBlueprint('abilities/ally_throw_satchel_charge.lua'),
		lockDuration = 15,
		verifyPosition = true,
		weight = 10,
		queued = false,
		type = 'position',
		position = CUCONTROL_TACTIC.POSITION_FILTER.SATCHEL_CHARGE,
	},
	FIRE_UP = {
		blueprint = BP_GetAbilityBlueprint('abilities/ally_fireup_ability.lua'),
		lockDuration = 0,
		verifyPosition = false,
		weight = 10,
		queued = false,
		type = 'default',
		--filter = CUCONTROL_TACTIC.FILTER.TRIVIAL_ACCEPT,
	}
}

AIControl.MainControl = {
	Settings = {
		SecondaryUpdateTicks = 12, -- every n updates we'll check for new controlled units
		
		RetreatTactic_BattleRadius = 55,
		RetreatTactic_BaseSafety = 0.75, -- Higher value means higher danger is required for a squad to retreat
		
		UnitControl = {
			UnitSettings = {
				-- Allies
				[BP_GetID(SBP.ALLIES.HEAVYMG)] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 3,
					['target_angle_threshold'] = 28
				},
				[BP_GetID(SBP.ALLIES.CAPTURE_MG)] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 3,
					['target_angle_threshold'] = 28
				},
				[BP_GetID(SBP.ALLIES.SNIPER)] = UNIT_CONTROL_PRESET.SNIPER,
				[BP_GetID(SBP.ALLIES.MORTAR)] = UNIT_CONTROL_PRESET.MORTAR,
				[BP_GetID(SBP.ALLIES.PARATROOPER_AT_57MM)] = UNIT_CONTROL_PRESET.AT_GUN,
				[BP_GetID(SBP.ALLIES.AT_57MM)] = UNIT_CONTROL_PRESET.AT_GUN,
				[BP_GetID(SBP.ALLIES.CAPTURE_AT)] = UNIT_CONTROL_PRESET.AT_GUN,
				
				-- Ostheer
				[BP_GetID(SBP.AXIS.HEAVYMG)] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 30
				},
				[BP_GetID(SBP.AXIS.SNIPER)] = UNIT_CONTROL_PRESET.SNIPER,
				[BP_GetID(SBP.AXIS.MORTAR)] = UNIT_CONTROL_PRESET.MORTAR,
				[BP_GetID(SBP.AXIS.CAPTURE_MORTAR_AXIS)] = UNIT_CONTROL_PRESET.MORTAR,
				[BP_GetID(SBP.AXIS.NEBELWERFER)] = UNIT_CONTROL_PRESET.NEBELWERFER,
				[BP_GetID(SBP.AXIS.PAK_38)] = UNIT_CONTROL_PRESET.AT_GUN,
				[BP_GetID(SBP.AXIS.PAK_40)] = UNIT_CONTROL_PRESET.AT_GUN,
				[BP_GetID(SBP.AXIS.CAPTURE_AT)] = UNIT_CONTROL_PRESET.AT_GUN,
				[BP_GetID(SBP.AXIS.CAPTURE_AT_AXIS)] = UNIT_CONTROL_PRESET.AT_GUN,
				
				-- Commonwealth
				[BP_GetID(SBP.CW.VICKERSMG)] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 28
				},
				[BP_GetID(SBP.CW.COMMANDOS_MG42_SP)] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 28
				},
				[BP_GetID(SBP.CW.CAPTURE_MG)] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 28
				},
				[BP_GetID(SBP.CW.MORTAR)] = UNIT_CONTROL_PRESET.MORTAR,
				[BP_GetID(SBP.CW.COMMANDOS_MORTAR)] = UNIT_CONTROL_PRESET.MORTAR,
				[BP_GetID(SBP.CW.CAPTURE_MORTAR)] = UNIT_CONTROL_PRESET.MORTAR,
				[BP_GetID(SBP.CW.CAPTURE_AXIS_ATGUN)] = UNIT_CONTROL_PRESET.AT_GUN,
				[BP_GetID(SBP.CW.CAPTURE_ATGUN)] = UNIT_CONTROL_PRESET.AT_GUN,
				
				-- Panzer Elite
				[BP_GetID(SBP.ELITE.HEAVYMG)] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 30
				},
				[BP_GetID(SBP.ELITE.FALLSCHIRMJAGER_HMG)] = {
					['safety_radius_steps'] = UNIT_CONTROL_CONST.DEFAULT_SAFETY_SEARCH_RADIUS_STEPS,
					['setup_target_danger'] = UNIT_CONTROL_CONST.DEFAULT_SETUP_TARGET_DANGER,
					['move_back_danger'] = UNIT_CONTROL_CONST.DEFAULT_MOVE_BACK_DANGER,
					['retreat_danger'] = UNIT_CONTROL_CONST.DEFAULT_RETREAT_DANGER,
					['init_step'] = 1,
					['step_count'] = 4,
					['target_angle_threshold'] = 30
				},
				
				--[BP_GetID(SBP.ELITE.FALLSCHIRMJAGER_PAK)] = UNIT_CONTROL_PRESET.AT_GUN,
				[BP_GetID(SBP.ELITE.MORTAR)] = UNIT_CONTROL_PRESET.MORTAR,
				[BP_GetID(SBP.ELITE.FALLSCHIRMJAGER_MORTAR)] = UNIT_CONTROL_PRESET.MORTAR,
			},
			
			HistoryMultiplier = 0.003, --
			CoverSearchRadius = 7, -- how far do we search for cover
		},
		
		VehicleControl = {
			DefaultBaseDangerRequiredToRetreat = 60,
			DefaultDangerRequiredDecreaseWithHealth = 85,
			DefaultDangerRequiredDecreaseWithFriendlyArmor = 0.045,
			DangerRequiredToRetreatDecreaseForLightVehicles = 45,
			DangerRequiredToRetreatIncreaseNearHQ = 45,
			CustomVehicles = { -- {base danger requirement to retreat, danger requirement decrease with health, reverse facing}
				[TRACE_ALLIES] = {
					[BP_GetID(SBP.ALLIES.HALFTRACK)] = {30, 60, -0.05},
					[BP_GetID(SBP.ALLIES.CALLIOPE)] = {2, 2, 0},
					[BP_GetID(SBP.ALLIES.CROCODILE)] = {100, 230, -0.05},
				},
				[TRACE_AXIS] = {
					[BP_GetID(SBP.AXIS.HALFTRACK)] = {4, 8, 0},
					[BP_GetID(SBP.AXIS.HALFTRACK_STUKA)] = {4, 8, 0},
					[BP_GetID(SBP.AXIS.HALFTRACK_FLAME)] = {30, 60, -0.1},
				},
				[TRACE_ALLIES_COMMONWEALTH] = {
					[BP_GetID(SBP.CW.COMMAND_CROMWELL)] = {10, 20, -0.05},
					[BP_GetID(SBP.CW.PRIEST)] = {1, 1, 0},
				},
				[TRACE_AXIS_PANZER_ELITE] = {
					[BP_GetID(SBP.ELITE.KETTENRAD)] = {5, 10, -0.05},
					[BP_GetID(SBP.ELITE.HALFTRACK_MORTAR)] = {10, 30, -0.05},
					[BP_GetID(SBP.ELITE.HUMMEL)] = {1, 1, 0},
					[BP_GetID(SBP.ELITE.MARDER)] = {10, 15, 0.05},
					[BP_GetID(SBP.ELITE.NASHORN)] = {10, 15, 0.05},
				}
			},
			DisableCriticals = {
				CRIT.VEH.IMMOBILIZE,
			},
			DamageCriticals = {
				CRIT.VEH.DAMAGE_ENGINE,
				CRIT.VEH.MOBILITY_MAJOR,
				CRIT.VEH.MAIN_WEAPON_DESTROYED,
				CRIT.VEH.AXIS_KILL_TOP_MG,
			},
			ExcludeFromControl = {
				[TRACE_ALLIES] = {
					
				},
				[TRACE_AXIS] = {
					
				},
				[TRACE_ALLIES_COMMONWEALTH] = {
					[BP_GetID(SBP.CW.ARMOUR_HQ)] = true,
					[SBP.CW.INFANTRY_HQ] = true,
					[SBP.CW.HQ] = true,
					[SBP.CW.HQ_REINFORCEMENT] = true,
				},
				[TRACE_AXIS_PANZER_ELITE] = {
					
				}
			}
		},
		
		BarrageControl = { -- Normal ai tactic functionality should be used for most barrages. These barrages are included here mostly to fix the units locked due to other aicontrol functionality
			SaveUpAmountGrowthWithTime = 150/700, -- Munitions saved starts at 0 and grows throughout the game
			SaveUpAmount = 150, -- We'll try to save up to this amount of munitions in the lategame
			ChanceToCastBelowsavedMunitionsThreshold = 5, -- A percentage chance (0 to 100) to cast the abilities even if we're currently saving up our munitions
			UnitSettings = {
				[BP_GetID(SBP.ALLIES.MORTAR)] = {
					{weight=4, searchrange=90, cost=20, minThreatToCast=1.75, lockDuration=48, blueprint=BP_GetAbilityBlueprint('abilities/ally_sync_mortar_barrage.lua')},
					{weight=2, searchrange=100, cost=15, positionFunc=BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE, lockDuration=30, blueprint=BP_GetAbilityBlueprint('abilities/ally_mortar_smoke_barrage.lua')},
					{weight=2, searchrange=100, cost=15, positionFunc=BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE, lockDuration=30, blueprint=BP_GetAbilityBlueprint('abilities/axis_mortar_smoke_barrage.lua')},
				},
				[BP_GetID(SBP.AXIS.MORTAR)] = {
					{weight=4, searchrange=90, cost=20, minThreatToCast=1.75, lockDuration=48, blueprint=BP_GetAbilityBlueprint('abilities/axis_sync_mortar_barrage.lua')},
					{weight=2, searchrange=100, cost=15, positionFunc=BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE, lockDuration=30, blueprint=BP_GetAbilityBlueprint('abilities/ally_mortar_smoke_barrage.lua')},
					{weight=2, searchrange=100, cost=15, positionFunc=BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE, lockDuration=30, blueprint=BP_GetAbilityBlueprint('abilities/axis_mortar_smoke_barrage.lua')},
				},
				[BP_GetID(SBP.AXIS.NEBELWERFER)] = {
					{weight=1, searchrange=245, cost=35, minThreatToCast=2.55, lockDuration=48, blueprint=BP_GetAbilityBlueprint('abilities/axis_nebelwerfer_barrage.lua')},
				},
				[BP_GetID(SBP.AXIS.HALFTRACK)] = {
					{weight=1, searchrange=200, cost=50, minThreatToCast=2.75, lockDuration=48, blueprint=BP_GetAbilityBlueprint('abilities/axis_stuka_zu_fuss_rocket_halftrack.lua')},
				},
				[BP_GetID(SBP.ELITE.MORTAR)] = {
					{weight=3, searchrange=100, cost=20, minThreatToCast=1.75, lockDuration=48, blueprint=BP_GetAbilityBlueprint('abilities/axis_sync_mortar_barrage.lua')},
					{weight=3, searchrange=100, cost=35, minThreatToCast=2.25, lockDuration=30, blueprint=BP_GetAbilityBlueprint('abilities/panzer_elite_incendiary_mortar_barrage.lua')},
					{weight=2, searchrange=100, cost=15, positionFunc=BARRAGE_CONTROL_POSITION.SMOKE_BARRAGE, lockDuration=30, blueprint=BP_GetAbilityBlueprint('abilities/panzer_elite_mortar_smoke_barrage.lua')},
				},
			},
		},
		
		CombatUnitControl = {
			BaseLockChance = 45,
			HelpRadius = 85,
			UnitSettings = {
				-- USF
				[BP_GetID(SBP.ALLIES.ENGINEER)] = {
					assault_troops = true,
					lock_chance = 100,
					ability_chance = 40,
					abilities = {
						-- todo: add demo charges
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/ally_throw_grenade_engineer.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.ALLIES.LOGISTICS_ENGINEER)] = {
					assault_troops = true,
					lock_chance = 100,
					ability_chance = 40,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE
						},
					},
				},
				[BP_GetID(SBP.ALLIES.RIFLEMEN)] = {
					assault_troops = true,
					close_in_distance = 33,
					lock_chance = 100,
					ability_chance = 75,
					abilities = {
						CUCONTROL_ABILITY_PRESET.GRENADE,
						{
							blueprint = BP_GetAbilityBlueprint('abilities/ally_suppression_ability_rifle_squad_infantry.lua'),
							type = 'default',
							lockDuration = 5,
							verifyPosition = false,
							weight = 10,
							queued = false,
						},
						CUCONTROL_ABILITY_PRESET.FIRST_VEHICLE
					}
				},
				[BP_GetID(SBP.ALLIES.PARATROOPER)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 50,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								behavior = CUCONTROL_BEHAVIORS.FIRE_UP,
							}
						},
						{
							preset = CUCONTROL_ABILITY_PRESET.SATCHEL_CHARGE,
							overrides = {
								behavior = CUCONTROL_BEHAVIORS.FIRE_UP,
							}
						},
					}
				},
				[BP_GetID(SBP.ALLIES.RANGER)] = {
					assault_troops = function(squad) return Squad_HasUpgrade(squad, BP_GetUpgradeBlueprint('upgrade/allies/items/allies_rifle_squad_anti_infantry_package.lua')) end,
					lock_chance = 100,
					ability_chance = 75,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								behavior = CUCONTROL_BEHAVIORS.FIRE_UP
							}
						},
					}
				},
				
				-- Wehrmacht
				[BP_GetID(SBP.AXIS.PIONEER)] = {
					assault_troops = true,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {},
				},
				[BP_GetID(SBP.AXIS.VOLKSGRENADIER)] = {
					assault_troops = function(squad) return Squad_HasUpgrade(squad, BP_GetUpgradeBlueprint('upgrade/axis/items/axis_squad_item_volksgrenadier_smg.lua')) end,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/axis_throw_grenade.lua')
							}
						},
						{
							preset = CUCONTROL_ABILITY_PRESET.FIRST_VEHICLE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/axis_fire_panzerfaust.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.AXIS.GRENADIER)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/axis_throw_grenade.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.AXIS.STORMTROOPER)] = {
					assault_troops = function(squad) return Squad_HasUpgrade(squad, BP_GetUpgradeBlueprint('upgrade/axis/items/axis_squad_item_mp44.lua')) end,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/axis_throw_grenade_improved.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.AXIS.STURMPIONEER)] = {
					assault_troops = function(squad) return Squad_HasUpgrade(squad, BP_GetUpgradeBlueprint('upgrade/axis/items/axis_squad_item_mp44_sturmpioneer.lua')) end,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/axis_throw_grenade_improved.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.AXIS.WAFFENSS)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/axis_throw_grenade_improved.lua')
							}
						},
					},
				},
				
				-- Commonwealth
				[BP_GetID(SBP.CW.TOMMIES)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 70,
					abilities = {
						CUCONTROL_ABILITY_PRESET.SMOKE_GRENADE,
						CUCONTROL_ABILITY_PRESET.VITAL_SHOT,
						{
							preset = CUCONTROL_ABILITY_PRESET.FIRST_VEHICLE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/button_enemy_vehicle.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.CW.SAPPER)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/commonwealth_throw_grenade_commando.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.CW.COMMANDOS)] = {
					assault_troops = true,
					lock_chance = 100,
					ability_chance = 40,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/commonwealth_throw_grenade_commando.lua')
							}
						},
						{
							preset = CUCONTROL_ABILITY_PRESET.FIRE_UP,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/commonwealth_suppression_break.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.CW.HIGHLANDERS)] = {
					assault_troops = true,
					lock_chance = 100,
					ability_chance = 40,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/commonwealth_throw_grenade_commando.lua'),
							}
						},
					},
				},
				[BP_GetID(SBP.CW.TOMMIES_CANADIAN)] = {
					assault_troops = true,
					lock_chance = 100,
					ability_chance = 40,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/commonwealth_throw_grenade_commando.lua'),
								behavior = CUCONTROL_BEHAVIORS.SPRINT_CW,
							}
						},
						{
							preset = CUCONTROL_ABILITY_PRESET.FIRST_VEHICLE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/button_enemy_vehicle_canadian.lua'),
							}
						},
					},
				},
				
				-- Panzer Elite
				[BP_GetID(SBP.ELITE.PANZERGRENADIER)] = {
					assault_troops = function(squad) Squad_HasUpgrade(squad, BP_GetUpgradeBlueprint('upgrade/axis_pe/items/panzer_elite_squad_mp44_package.lua')) end,
					close_in_distance = 26,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/panzer_elite_throw_incendiary_grenade.lua'),
								behavior = CUCONTROL_BEHAVIORS.SPRINT,
							}
						},
					},
				},
				[BP_GetID(SBP.ELITE.ASSAULTGRENADIER)] = {
					assault_troops = true,
					close_in_distance = 26,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/panzer_elite_throw_incendiary_grenade.lua'),
								behavior = CUCONTROL_BEHAVIORS.SPRINT,
							}
						},
					},
				},
				[BP_GetID(SBP.ELITE.TANKBUSTERS)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/panzer_elite_throw_incendiary_grenade.lua'),
								behavior = CUCONTROL_BEHAVIORS.SPRINT,
							}
						},
					},
				},
				[BP_GetID(SBP.ELITE.LUFTWAFFE)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/panzer_elite_throw_grenade.lua'),
								behavior = CUCONTROL_BEHAVIORS.SPRINT_MOUNTAIN,
							}
						},
					},
				},
				[BP_GetID(SBP.ELITE.FALLSCHIRMJAGER)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.SATCHEL_CHARGE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/panzer_elite_fallschirmjager_throw_incendiary_grenade.lua')
							}
						},
						{
							preset = CUCONTROL_ABILITY_PRESET.FIRST_VEHICLE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/panzer_elite_fire_panzerfaust_fallschirmjager.lua')
							}
						},
					},
				},
				[BP_GetID(SBP.ELITE.GEBIRGSJAGER)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.VITAL_SHOT,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/panzer_elite_vital_shot.lua'),
								behavior = CUCONTROL_BEHAVIORS.FIRE_UP_ELITE,
							}
						},
					},
				},
				[BP_GetID(SBP.ELITE.PANZERFUSILIER)] = {
					assault_troops = false,
					lock_chance = 100,
					ability_chance = 20,
					abilities = {
						{
							preset = CUCONTROL_ABILITY_PRESET.GRENADE,
							overrides = {
								blueprint = BP_GetAbilityBlueprint('abilities/panzer_elite_throw_grenade_improved.lua'),
								behavior = CUCONTROL_BEHAVIORS.FIRE_UP_ELITE,
							}
						},
					},
				},
			},
		},
		
		HQControl = {
			UpdateInterval = 4, -- HQ updates will be performed only every Nth time
			Blueprints = {
				[BP_GetID(SBP.CW.HQ)] = true,
				[BP_GetID(SBP.CW.HQ_REINFORCEMENT)] = true,
				[BP_GetID(SBP.CW.ARMOUR_HQ)] = true,
				[BP_GetID(SBP.CW.INFANTRY_HQ)] = true,
			},
			
			MaxSetupWaitTime = 5, -- seconds to decide that we can't setup on the currently selected location
			
			ImportanceDifferenceToGoToANewPoint = 2, -- If there's a point with this much more importance than the current one, we'll go there.
			SafePositionChoiceRandomnessThreshold = 0.15, -- positions which are different by only this amount will have the same choice possibility as the best point.
			
			DangerDivideByDistance = true, --
			MinDistanceModifier = 0.5, --
			
			HistoryDangerMultiplier = 0.005, -- 
			DangerMultiplierWithHealth = 3, -- (1-healthLeftRatio)*value is the multiplier which will be applied to overall danger avoidance
			MaxImportanceDecreaseOverDistance = 2.75, -- cap which prevents big importance decrease due to big distance to the point
			ImportanceByDistanceModifier = 0.00175, -- modifier applied on distance between HQ and territory sector strategic point
			PosDangerIncreaseNearEnemySectorTerritory = 0.015, -- increases overall danger of a setup location if it's near enemy territory
			PosDangerIncreaseNearNeutralSectorTerritory = 0.003, -- increases overall danger of a setup location if it's near neutral territory
			DangerOnEnemyValue = 20, -- 
			DangerDecreaseWithFriendlyUnits = 0.25, -- If there's a lot of friendly units nearby, we can still setup there even if enemy is present
			CurrentChoicePriority = 1.25, -- higher values will ensure that HQs current choice will not be changed too often (not allowing it to setup at all)
			
			ImportanceDecreaseIfNotSafe = 4.5, -- If the sector isn't safe, importance is decreased by this number
			ImportanceDecreaseWithDanger = 0.35, -- Importance will decrease with each unit present nearby by this amount
			ImportanceDecreaseIfHQAlreadySetup = 8, -- This decrease should ensure that we use same sector only if we have no other choice
			MaxImportanceDecreaseWithDanger = 15, -- cap which prevents big importance decrease. Shouldn't be a low cap as we don't want suicide HQs trying to take high points for no reason
			
			StrategicPoints = { -- blueprint, importance
				{EBP.STRAT_POINT.FUEL_HIGH, 11.5},
				{EBP.STRAT_POINT.FUEL_MED, 11},
				{EBP.STRAT_POINT.FUEL_LOW, 6},
				{EBP.STRAT_POINT.MUN_HIGH, 10.5},
				{EBP.STRAT_POINT.MUN_MED, 8},
				{EBP.STRAT_POINT.MUN_LOW, 5},
			},
			UnrecognizedStrategicPointImportance = 3, -- if SP is not in the table above, its importance will be this (manpower points)
		},
		
		AICheats = {
			StartingResources = 1.45,
			ExperienceReceived = 1.05,
			CommandPointGainRate = 1.35,
			ProductionRate = 1.5,
			Upkeep = 0.85,
			VehicleRepairRate = 1.2,
			SightRadius = 1,
			Popcap = 150,
		},
	},
	
	AIMarkers = {},
	
	HQPositions = {},
	HQUpdateWait = 0,
	
	InitUpdateComplete = false,
	TerritorySectors = {},
	SecondaryUpdateTicks = 0,
	
	-- SGroups
	HQs = {},
	
	AICheatModifiers = {},
	LockedSquads = {{}, {}},
	HQTargets = {{}, {}},
	SettingUpHQs = {{}, {}}, -- array containing all HQ setup attempts and time when they start (used to determine failed setup attempts)
	
	UnitControlTargets = {{}, {}},
	UnitControlUnlockTimers = {{}, {}},
	UnitControlIdleTimers = {{}, {}},
	
	VehicleControl = {
		RepairsRetreat = {{}, {}},
		FacingCmdTimers = {{}, {}},
		RetreatCmdTimers = {{}, {}},
	},
	
	BarrageControlLockTimers = {},
	
	CombatUnitControlAbilityLockTimers = {},
	CombatUnitControlHelpLockTimers = {},
	
	Init = function()
		AIControl_MainControl.HQs = {SGroup_CreateIfNotFound("AIControl.MainControl.HQT1"), SGroup_CreateIfNotFound("AIControl.MainControl.HQT2")}
		
		AIControl_MainControl.FindTerritorySectors()
		AIControl_MainControl.SecondaryUpdate()
	end,
	
	GetRetreatDirection = function(surroundingSafety, pos, team, dangerMultiplier, safetyMultiplier, directionToHq, hqMultiplier, historyMultiplier, armorDangerMultiplier, armorSafetyMultiplier)
		if not armorDangerMultiplier then armorDangerMultiplier = 0 end
		if not armorSafetyMultiplier then armorSafetyMultiplier = 0 end
		local enemyTeam
		if team == 1 then
			enemyTeam = 2
		else
			enemyTeam = 1
		end
		local x,y = AIControl_Grid.GetXY(pos)
		local retreatDirection = Util_ScarPos(
			directionToHq.x*hqMultiplier,
			directionToHq.z*hqMultiplier
		)
		local highestDanger = 5
		local highestSafety = 15
		local highestArmorDanger = 15
		local highestArmorSafety = 15
		for i=1,#surroundingSafety do
			local safety = surroundingSafety[i]
			if safety[3] > highestDanger then
				highestDanger = safety[3]
			end
			if safety[5] > highestSafety then
				highestSafety = safety[5]
			end
			if safety[7] > highestArmorDanger then
				highestArmorDanger = safety[7]
			end
			if safety[8] > highestArmorSafety then
				highestArmorSafety = safety[8]
			end
		end
		for i=1,#surroundingSafety do
			local safety = surroundingSafety[i]
			local dangerPos = AIControl_Grid_AveragePosData[ safety[1] ][ safety[2] ][enemyTeam]
			if dangerPos.x ~= pos.x or dangerPos.z ~= pos.z then
				local dangerDir = normalizeVector(Util_ScarPos(
					dangerPos.x - pos.x,
					dangerPos.z - pos.z
				))
				retreatDirection.x = retreatDirection.x - (
						dangerDir.x * safety[3] +
						dangerDir.x * safety[4] * historyMultiplier
					) * dangerMultiplier / highestDanger - (
						dangerDir.x * safety[7]
					) * armorDangerMultiplier / highestArmorDanger
				retreatDirection.z = retreatDirection.z - (
						dangerDir.z * safety[3] +
						dangerDir.z * safety[4] * historyMultiplier
					) * dangerMultiplier / highestDanger - (
						dangerDir.z * safety[7]
					) * armorDangerMultiplier / highestArmorDanger
			end
			if safety[1] ~= x or safety[2] ~= y then
				local safetyPos = AIControl_Grid_AveragePosData[ safety[1] ][ safety[2] ][team]
				if safetyPos.x ~= pos.x or safetyPos.z ~= pos.z then
					local safetyDir = normalizeVector(Util_ScarPos(
						safetyPos.x - pos.x,
						safetyPos.z - pos.z
					))
					retreatDirection.x = retreatDirection.x + (
							safetyDir.x * safety[5] +
							safetyDir.x * safety[6] * historyMultiplier
						) * safetyMultiplier / highestSafety - (
							safetyDir.x * safety[8]
						) * armorSafetyMultiplier / highestArmorSafety
					retreatDirection.z = retreatDirection.z + (
							safetyDir.z * safety[5] +
							safetyDir.z * safety[6] * historyMultiplier
						) * safetyMultiplier / highestSafety - (
							safetyDir.z * safety[8]
						) * armorSafetyMultiplier / highestArmorSafety
				end
			end
		end
		if sqrt(retreatDirection.x^2 + retreatDirection.z^2) < 0.001 then
			retreatDirection = directionToHq
		else
			retreatDirection = normalizeVector(retreatDirection)
		end
		return retreatDirection
	end,
	GetRetreatLocation = function(pos, retreatDirection, retreatDistance)
		local result = Util_ScarPos(
			pos.x + retreatDirection.x*retreatDistance,
			pos.z + retreatDirection.z*retreatDistance
		)
		if result.x > wHalfWidth-1 then
			result.x = wHalfWidth-1
		elseif result.x < -wHalfWidth+1 then
			result.x = -wHalfWidth+1
		end
		if result.z > wHalfHeight-1 then
			result.z = wHalfHeight-1
		elseif result.z < -wHalfHeight+1 then
			result.z = -wHalfHeight+1
		end
		return result
	end,
	
	GetBestClumpForRadius = function(team, x, y, radius, noFOW)
		if noFOW == nil then noFOW = false end
		local maxDanger = 0
		local maxDangerPos = nil
		local radiusSquared = radius*radius
		for i = max(1, floor(x-radius)),min(Dimensions[1], ceil(x+radius)) do
			local aSquared = (i-x)^2
			for j = max(1, floor(y-radius)),min(Dimensions[2], ceil(y+radius)) do
				local bSquared = (j-y)^2
				if aSquared + bSquared <= radiusSquared then
					if noFOW then
						if AIControl_Grid_DataClump[i][j][team] then
							if AIControl_Grid_DataClump[i][j][team] > maxDanger then
								maxDanger = AIControl_Grid_DataClump[i][j][team]
								maxDangerPos = {i, j}
							end
						end
					else
						if AIControl_Grid_DataClumpFOW[i][j][team] then
							if AIControl_Grid_DataClumpFOW[i][j][team] > maxDanger then
								maxDanger = AIControl_Grid_DataClumpFOW[i][j][team]
								maxDangerPos = {i, j}
							end
						end
					end
				end
			end
		end
		return maxDangerPos, maxDanger
	end,
	
	GetSafetyData = function(x, y, team) -- returns danger (float), history_danger (float)
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		
		if x >= 1 and x <= Dimensions[1] and y >= 1 and y <= Dimensions[2] then
			return {
				AIControl_Grid_Data[x][y][enemyTeam], -- 1
				AIControl_Grid_DataHistory[x][y][enemyTeam], -- 2
				AIControl_Grid_Data[x][y][team], -- 3
				AIControl_Grid_DataHistory[x][y][team], -- 4
				AIControl_Grid_ArmorData[x][y][enemyTeam], -- 5
				AIControl_Grid_ArmorData[x][y][team], -- 6
			}
		else
			return {0,0,0,0,0,0,0,0}
		end
	end,
	GetSurroundingSafetyData = function(gridPos, team, distance, maxDistance)
		local safetyData = AIControl_MainControl.GetSafetyData(gridPos[1], gridPos[2], team)
		local distanceMultiplier = min(1, 1.1 - distance/maxDistance)
		return {
			gridPos[1], -- 1
			gridPos[2], -- 2
			safetyData[1] * distanceMultiplier, -- 3
			safetyData[2] * distanceMultiplier, -- 4
			safetyData[3] * distanceMultiplier, -- 5
			safetyData[4] * distanceMultiplier, -- 6
			safetyData[5] * distanceMultiplier, -- 7
			safetyData[6] * distanceMultiplier, -- 8
		}
	end,
	GetSurroundingSafety = function(pos, dist, steps, team)
		local result, resultCount = {}, 0
		
		--[[local gridPos = {
			floor((pos.x+wHalfWidth)/Dimensions[3])+1,
			floor((pos.z+wHalfHeight)/Dimensions[4])+1
		}]]
		
		local maxPointDistance
		if dist == 0 then
			resultCount = resultCount + 1
			result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData(pos, team, 0, 1)
			dist = 1
			maxPointDistance = sqrt((dist+steps)^2+(dist+steps)^2)
		else
			maxPointDistance = sqrt((dist+steps)^2+(dist+steps)^2)
		end
		
		for x = 0,dist+steps do
			local curx
			curx = pos[1]+x
			if curx <= Dimensions[1] then
				for y=0,dist+steps do
					if x > dist or y > dist then
						local pointDistance = sqrt(x^2 + y^2)
						local cury
						cury = pos[2]+y
						if cury <= Dimensions[2] then
							resultCount = resultCount + 1
							result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
						end
						cury = pos[2]-y
						if cury >= 1 then
							resultCount = resultCount + 1
							result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
						end
					end
				end
			end
			curx = pos[1]-x
			if curx >= 1 then
				for y=0,dist+steps do
					if x > dist or y > dist then
						local pointDistance = sqrt(x^2 + y^2)
						local cury
						cury = pos[2]+y
						if cury <= Dimensions[2] then
							resultCount = resultCount + 1
							result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
						end
						cury = pos[2]-y
						if cury >= 1 then
							resultCount = resultCount + 1
							result[resultCount] = AIControl_MainControl.GetSurroundingSafetyData({curx, cury}, team, pointDistance, maxPointDistance)
						end
					end
				end
			end
		end
		return result
	end,
	
	RetreatTactic = function(squad)
		local result = -AIControl_MainControl_Settings.RetreatTactic_BaseSafety
		
		local pos = Squad_GetPosition(squad)
		local p = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(p)
		local enemyTeam = Team_GetEnemyTeam(team)
		local squadsNearSG_enemy = SGroup_CreateIfNotFound("BtB_RetreatTactic_squadsNear_enemy")
		local squadsNearSG_allied = SGroup_CreateIfNotFound("BtB_RetreatTactic_squadsNear_allied")
		SGroup_Clear(squadsNearSG_enemy)
		SGroup_Clear(squadsNearSG_allied)
		World_GetSquadsNearPoint(p, squadsNearSG_enemy , pos, AIControl_MainControl_Settings.RetreatTactic_BattleRadius, OT_Enemy)
		World_GetSquadsNearPoint(p, squadsNearSG_allied, pos, AIControl_MainControl_Settings.RetreatTactic_BattleRadius-10, OT_Ally)
		--dr _text3d('aicontrol_maincontrol', pos.x, pos.y+3, pos.z, SGroup_Count(squadsNearSG_allied), 255, 0, 0)
		
		--local maxHealth = Squad_GetHealthMax(squad)
		local healthLeft = Squad_GetHealth(squad)
		local healthLeftPercentage = Squad_GetHealthPercentage(squad)
		result = result + 14*max(0, 0.35 - healthLeftPercentage)
		
		if Squad_IsInHoldEntity(squad) then
			result = result - 1.5
			if Squad_IsUnderAttack(squad, 5) then
				if Squad_Count(squad) == 1 then result = result + 1.75 end
				result = result + 0.5
				if healthLeftPercentage < 0.275 or healthLeft < 70 then
					result = result + 5
				end
				result = result + max(0, min((90-healthLeft)/11, 5))
			end
			if Squad_IsAttacking(squad, 5) then
				result = result - 1.5
			end
		else
			if Squad_IsUnderAttack(squad, 5) then
				if Squad_Count(squad) == 1 then result = result + 1.75 end
				result = result + 0.25
				if healthLeftPercentage < 0.275 or healthLeft < 80 then
					result = result + 5
				end
				result = result + max(0, min((90-healthLeft)/11, 5))
			end
			if Squad_IsAttacking(squad, 5) then result = result - 0.35 end
		end
		
		if Squad_IsPinned(squad) then result = result + 0.75 end
		if Squad_HasTeamWeapon(squad) then result = result + 0.45 end
		
		local closestEnemyDistaceSq -- squared
		local enemyValue = 0
		local friendlyValue = 0
		local squadsNearSG_enemyCount = SGroup_Count(squadsNearSG_enemy)
		local squadsNearSG_alliedCount = SGroup_Count(squadsNearSG_allied)
		for i=1,squadsNearSG_enemyCount do
			local enemySquad = SGroup_GetSpawnedSquadAt(squadsNearSG_enemy, i)
			if AIControl_IsSquadVehicle(enemySquad) then
				enemyValue = enemyValue + Squad_GetHealth(enemySquad)/150
			else
				enemyValue = enemyValue + Squad_Count(enemySquad)*0.5
			end
			local dist = World_DistancePointToPoint(pos, Squad_GetPosition(enemySquad))
			if not closestEnemyDistaceSq or closestEnemyDistaceSq > closestEnemyDistaceSq then
				closestEnemyDistaceSq = dist
			end
		end
		for i=1,squadsNearSG_alliedCount do
			local friendlySquad = SGroup_GetSpawnedSquadAt(squadsNearSG_allied, i)
			if AIControl_IsSquadVehicle(friendlySquad) then
				friendlyValue = friendlyValue + Squad_GetHealth(friendlySquad)/150
			else
				friendlyValue = friendlyValue + Squad_Count(friendlySquad)*0.5
			end
		end
		
		if closestEnemyDistaceSq and closestEnemyDistaceSq < 25 then
			result = result + (25-closestEnemyDistaceSq)/35
		end
		
		SGroup_Destroy(squadsNearSG_enemy)
		SGroup_Destroy(squadsNearSG_allied)
		
		result = result + enemyValue*(1/8) - min(friendlyValue, enemyValue)*(1/8)
		
		return max(0, result)
	end,
	
	FUnitControl = function(squad, setting)
		local squadGameID = Squad_GetGameID(squad)
		local player = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(player)+1
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local playerIndex = World_GetPlayerIndex(player)
		if not AIControl_MainControl_LockedSquads[team][squadGameID] or AIControl_MainControl_LockedSquads[team][squadGameID] == 1 or AIControl_MainControl_LockedSquads[team][squadGameID] == -1 then
			local pos = Squad_GetPosition(squad)
			local x,y = AIControl_Grid.GetXY(pos)
			
			--print("["..BP_GetName(Squad_GetBlueprint(squad)).."] --- "..team.." "..World_GetPlayerIndex(player))
			
			local sg = SGroup_Create("aicontrol_vc_tempsg")
			SGroup_Single(sg, squad)
			local syncWeapon = SyncWeapon_GetFromSGroup(sg)
			--local syncWeaponEntity = SyncWeapon_GetEntity(syncWeapon)
			if not Squad_IsInHoldEntity(squad) and not Squad_IsRetreating(squad) then
				local stepsTotal = setting['init_step'] + setting['step_count']
				local inProximityOfEnemy = false
				for i=1,World_GetPlayerCount() do
					local p2 = World_GetPlayerAt(i)
					if Player_GetRelationship(player, p2) == R_ENEMY and Prox_PlayerSquadsInProximityOfSquads(p2, sg, (stepsTotal+1)*(Dimensions[3]+Dimensions[4])*0.5, false, nil) then
						inProximityOfEnemy = true
						break
					end
				end
				local lockSquad = false
				if inProximityOfEnemy then
					--local isUnderAttack = Squad_IsUnderAttack(squad, 2)
					local healthPercentage = Squad_GetHealthPercentage(squad)
					local surroundingSafety = AIControl_MainControl.GetSurroundingSafety({x, y}, 0, setting['safety_radius_steps'], team)
					--sort(surroundingSafety, function(a, b) return a[3] > b[3] end)
					
					local collectiveDanger = 0
					local totalArmor = 0
					for i=1,#surroundingSafety do
						local v = surroundingSafety[i]
						collectiveDanger = collectiveDanger + v[3] + v[4]*0.01 - v[5]*0.1 - v[6]*0.0025
						totalArmor = totalArmor + v[7]
					end
					--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+9, pos.z, string.format('%.2f', collectiveDanger), 255, 255, 255)
					
					local playerHQPosition = AIControl_MainControl.HQPositions[playerIndex]
					local directionToHq = normalizeVector(Util_ScarPos(playerHQPosition.x - pos.x, playerHQPosition.z - pos.z))
					local moveBackDanger = setting['move_back_danger']
					local retreatDanger = setting['retreat_danger']
					if setting['targets_armor'] then
						local dangerDecrease = min(setting['armor_danger_decrease_reduction_threshold'], totalArmor)*setting['armor_danger_decrease']
						
						moveBackDanger = moveBackDanger + dangerDecrease
						if retreatDanger >= 0 then
							retreatDanger = retreatDanger + dangerDecrease
						end
					end
					if collectiveDanger > moveBackDanger then
						
						-- We are in danger
						--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+2, pos.z, 'in danger', 255, 255, 0)
						
						lockSquad = true
						
						if retreatDanger >= 0 and collectiveDanger > retreatDanger then
							local distanceToHq = World_DistancePointToPoint(pos, playerHQPosition)
							--Cmd_Move(sg, AIControl_MainControl.HQPositions[playerIndex])
							--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+1, pos.z, 'retreating', 255, 0, 0)
							if distanceToHq > 20 then
								Cmd_Retreat(sg)
							end
						else
							--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+1, pos.z, 'moving away', 255, 255, 0)
							
							local hqMult = 0.7
							local xBorderDistRatio = math.abs(pos.x) / wHalfWidth - 0.6
							if xBorderDistRatio > 0 then
								hqMult = hqMult + xBorderDistRatio*2
							end
							local yBorderDistRatio = math.abs(pos.z) / wHalfHeight - 0.6
							if yBorderDistRatio > 0 then
								hqMult = hqMult + yBorderDistRatio*2
							end
							local retreatDirection = AIControl_MainControl.GetRetreatDirection(surroundingSafety, pos, team, 1.5, 1.1, directionToHq, hqMult, 0.025, 0.5, 0)
							local retreatDistance = 25
							local retreatLocation = AIControl_MainControl.GetRetreatLocation(pos, retreatDirection, retreatDistance)
							
							local x2,y2 = AIControl_Grid.GetXY(retreatLocation)
							local retreatLocation2 = AIControl_MainControl.GetRetreatLocation(
								retreatLocation,
								AIControl_MainControl.GetRetreatDirection(
									AIControl_MainControl.GetSurroundingSafety({x2, y2}, 0, stepsTotal, team),
									retreatLocation,
									team, 1.5, 1.1, directionToHq, hqMult, 0.025, 0.5, 0),
								retreatDistance)
							
							Cmd_Move(sg, retreatLocation, false)
							Cmd_Move(sg, retreatLocation2, true)
							Cmd_Move(sg, playerHQPosition, true)
						end
					else
						local targetSafetyData = AIControl_MainControl.GetSurroundingSafety({x, y}, setting['init_step'], setting['step_count'], team)
						sort(targetSafetyData, function(a, b) return a[3] > b[3] end)
						
						if targetSafetyData[1][3] > setting['setup_target_danger'] then
							
							lockSquad = true
							--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+3, pos.z, 'setting up', 255, 255, 255)
							
							local dangerMultiplier
							local safetyMultiplier
							local hqDirectionMultiplier
							local historyMultiplier
							local armorMultiplier
							if setting['targets_armor'] then
								dangerMultiplier = -3
								safetyMultiplier = -1
								hqDirectionMultiplier = -0.5
								historyMultiplier = -0.005
								armorMultiplier = 0
							else
								dangerMultiplier = -0.05
								safetyMultiplier = -0.0005
								hqDirectionMultiplier = 0
								historyMultiplier = 0
								armorMultiplier = -2
							end
							local headingDirection = AIControl_MainControl.GetRetreatDirection(targetSafetyData, pos, team, dangerMultiplier, safetyMultiplier, directionToHq, hqDirectionMultiplier, historyMultiplier, armorMultiplier, 0)
							local headingPos = AIControl_MainControl.GetRetreatLocation(pos, headingDirection, 25)
							--dr_drawline(World_Pos(pos.x, pos.y+0.35, pos.z), World_Pos(headingPos.x, headingPos.y+0.35, headingPos.z), 0, 125, 125, 'aicontrol_maincontrol')
							
							local setupWell = false
							if AIControl_MainControl.UnitControlTargets[team][squadGameID] and not AIControl_MainControl.UnitControlTargets[team][squadGameID][1] then
								local heading = normalizeVector(World_Pos(
									AIControl_MainControl.UnitControlTargets[team][squadGameID][3].x - AIControl_MainControl.UnitControlTargets[team][squadGameID][2].x,
									0,
									AIControl_MainControl.UnitControlTargets[team][squadGameID][3].z - AIControl_MainControl.UnitControlTargets[team][squadGameID][2].z
								))
								local angle = math.acos(
									(heading.x*headingDirection.x+heading.z*headingDirection.z) /
									(sqrt(heading.x*heading.x + heading.z*heading.z) * sqrt(headingDirection.x*headingDirection.x + headingDirection.z*headingDirection.z))
								)*180/3.14
								
								--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'angle: '..string.format('%d', angle), 255, 255, 255)
								if setting['target_angle_threshold'] == -1 or angle < setting['target_angle_threshold'] then
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+2, pos.z, 'setup well', 255, 0, 0)
									setupWell = true
								end
							end
							if setupWell and World_DistancePointToPoint(pos, AIControl_MainControl.UnitControlTargets[team][squadGameID][2]) > AIControl_MainControl_Settings_UnitControl.CoverSearchRadius*3 then
								--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+5, pos.z, 'NOT IN COVER', 255, 0, 0)
								setupWell = false
							end
							if not setupWell then
								local coverSearchPos = pos
								for i=0,Squad_Count(squad)-1 do
									local e = Squad_EntityAt(squad, i)
									if Entity_IsSyncWeapon(e) then
										coverSearchPos = Entity_GetPosition(e)
									end
								end
								
								if setting['attack_move_forward'] then
									Cmd_AttackMove(sg, headingPos, false)
								else
									local setupPos = pos
									if setting['search_cover'] then
										setupPos = Squad_FindCover(squad, pos, AIControl_MainControl_Settings_UnitControl.CoverSearchRadius)
										
										--dr_text3d('aicontrol_maincontrol', coverPos.x, coverPos.y+0.35, coverPos.z, 'o', 255, 255, 255)
										--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+1, pos.z, 'new setup pos', 255, 0, 0)
									end
									
									AIControl_MainControl.UnitControlTargets[team][squadGameID] = {false, setupPos, headingPos}
									Command_SquadPosFacing(player, sg, SCMD_Move, setupPos, headingPos, false)
								end
							end
						end
					end
				end
				if lockSquad then
					if not AIControl_MainControl_LockedSquads[team][squadGameID] then
						AIControl_MainControl_LockedSquads[team][squadGameID] = 1
						if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
							AI_LockSquad(player, squad)
						end
					end
				else
					if AIControl_MainControl.UnitControlTargets[team][squadGameID] then
						AIControl_MainControl.UnitControlTargets[team][squadGameID] = nil
						AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] = 0
					elseif AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] then
						AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] = AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] + 1
						if AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] > 56/AIControl_Grid.SplitUpdateCount then
							if AIControl_MainControl_LockedSquads[team][squadGameID] then
								if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
									AI_UnlockSquad(player, squad)
								end
							end
							AIControl_MainControl_LockedSquads[team][squadGameID] = nil
							AIControl_MainControl.UnitControlUnlockTimers[team][squadGameID] = nil
						end
					else
						if AIControl_MainControl_LockedSquads[team][squadGameID] then
							if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
								AI_UnlockSquad(player, squad)
							end
							AIControl_MainControl_LockedSquads[team][squadGameID] = nil
						end
					end
				end
			end
			SGroup_Destroy(sg)
		end
	end,
	
	FVehicleControl = function(squad)
		local sg = SGroup_Create("aicontrol_v_tempsg")
		local squadGameID = Squad_GetGameID(squad)
		local player = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(player)+1
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local playerIndex = World_GetPlayerIndex(player)
		if not AIControl_MainControl_LockedSquads[team][squadGameID] or AIControl_MainControl_LockedSquads[team][squadGameID] == 2 or AIControl_MainControl_LockedSquads[team][squadGameID] == -1 then
			local raceStr = Player_GetRaceName(player)
			local hasDisableCritical = false
			for j=1,#AIControl_MainControl_Settings_VehicleControl.DisableCriticals do
				local critical = AIControl_MainControl_Settings_VehicleControl.DisableCriticals[j]
				if Squad_HasCritical(squad, critical) then
					hasDisableCritical = true
					break
				end
			end
			local lockSquad = false
			if not hasDisableCritical then
				local lowHealth = false
				local healthPercentage = Squad_GetHealthPercentage(squad)
				local pos = Squad_GetPosition(squad)
				
				-- Retreat on low health
				local hasDamageCritical = false
				for j=1,#AIControl_MainControl_Settings_VehicleControl.DamageCriticals do
					local critical = AIControl_MainControl_Settings_VehicleControl.DamageCriticals[j]
					if Squad_HasCritical(squad, critical) then
						hasDamageCritical = true
						break
					end
				end
				if (AIControl_MainControl.VehicleControl.RepairsRetreat[team][squadGameID] and healthPercentage < 0.9)
						or (not Squad_IsAttacking(squad, 10) and (healthPercentage < 0.5 or hasDamageCritical)) then
					lockSquad = true
					lowHealth = true
					--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+3, pos.z, 'low health', 255, 0, 0)
				else
					AIControl_MainControl.VehicleControl.RepairsRetreat[team][squadGameID] = nil
				end
				
				if not AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID]
						or (lowHealth and AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] > 35)
						or (not lowHealth and AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] > 5) then
					AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] = nil
					--print("["..BP_GetName(Squad_GetBlueprint(squad)).."] --- "..team.." "..World_GetPlayerIndex(player))
					
					SGroup_Single(sg, squad)
					
					local initialStep = 0
					local stepsTotal = 9
					local maxDist = initialStep + stepsTotal
					
					local inProximityOfEnemy = false
					for i=1,World_GetPlayerCount() do
						local p2 = World_GetPlayerAt(i)
						if Player_GetRelationship(player, p2) == R_ENEMY and Prox_PlayerSquadsInProximityOfSquads(p2, sg, (maxDist+1)*(Dimensions[3]+Dimensions[4])*0.5, false, nil) then
							inProximityOfEnemy = true
							break
						end
					end
					if inProximityOfEnemy then
						
						local x,y = AIControl_Grid.GetXY(pos)
						local playerHQPosition = AIControl_MainControl.HQPositions[playerIndex]
						local directionToHq = normalizeVector(Util_ScarPos(playerHQPosition.x - pos.x, playerHQPosition.z - pos.z))
						
						local surroundingSafety = AIControl_MainControl.GetSurroundingSafety({x, y}, initialStep, stepsTotal, team)
						--sort(surroundingSafety, function(a, b) return a[3] > b[3] end)
						
						local collectiveDanger = 0
						local friendlyArmor = 0
						for j=1,#surroundingSafety do
							local v = surroundingSafety[j]
							collectiveDanger = collectiveDanger + v[3] + v[4]*0.01 - v[5]*0.04 - v[6]*0.00125
							friendlyArmor = friendlyArmor + v[8]
						end
						
						local hqMult = 1.6
						local xBorderDistRatio = math.abs(pos.x) / wHalfWidth - 0.5
						if xBorderDistRatio > 0 then
							hqMult = hqMult + xBorderDistRatio*4
						end
						local yBorderDistRatio = math.abs(pos.z) / wHalfHeight - 0.5
						if yBorderDistRatio > 0 then
							hqMult = hqMult + yBorderDistRatio*4
						end
						local retreatDirection = AIControl_MainControl.GetRetreatDirection(surroundingSafety, pos, team, 1.35, 1.45, directionToHq, hqMult, 0.035, 0.5, 0)
						
						local baseDangerRequirement = AIControl_MainControl_Settings_VehicleControl.DefaultBaseDangerRequiredToRetreat
						local dangerRequirementDecreaseWithHealth = AIControl_MainControl_Settings_VehicleControl.DefaultDangerRequiredDecreaseWithHealth
						local dangerRequirementDecreaseWithFriendlyArmor = AIControl_MainControl_Settings_VehicleControl.DefaultDangerRequiredDecreaseWithFriendlyArmor
						local customSettings = AIControl_MainControl_Settings_VehicleControl.CustomVehicles[raceStr][BP_GetID(Squad_GetBlueprint(squad))]
						if customSettings then
							if customSettings[1] ~= nil then
								baseDangerRequirement = customSettings[1]
							end
							if customSettings[2] ~= nil then
								dangerRequirementDecreaseWithHealth = customSettings[2]
							end
							if customSettings[3] ~= nil then
								dangerRequirementDecreaseWithFriendlyArmor = customSettings[3]
							end
						end
						local dangerRequiredToRetreat = baseDangerRequirement - dangerRequirementDecreaseWithHealth*min(1, max(0, 1-(healthPercentage-0.25)/0.75)) + dangerRequirementDecreaseWithFriendlyArmor*friendlyArmor
						if not customSettings then
							local maxHealth = Squad_GetHealthMax(squad)
							if maxHealth < 850 then
								dangerRequiredToRetreat = dangerRequiredToRetreat - min(1, max(0, 1-(maxHealth-150)/(850-150))) * AIControl_MainControl_Settings_VehicleControl.DangerRequiredToRetreatDecreaseForLightVehicles
							end
						end
						local distToHq = World_DistancePointToPoint(pos, playerHQPosition)
						if distToHq < 75 then
							dangerRequiredToRetreat = dangerRequiredToRetreat + AIControl_MainControl_Settings_VehicleControl.DangerRequiredToRetreatIncreaseNearHQ*max(0, 1-(distToHq-25)*0.02)
						end
						
						local retreatDistance = 20
						local retreatThreshold
						if lowHealth then
							retreatThreshold = 15
						else
							retreatThreshold = max(0, min(25, 100*(collectiveDanger-max(0, dangerRequiredToRetreat))/max(1, dangerRequiredToRetreat)))
						end
						
						local retreatLocation = AIControl_MainControl.GetRetreatLocation(pos, retreatDirection, retreatDistance)
						--dr_drawline(World_Pos(pos.x, pos.y+1, pos.z), World_Pos(retreatLocation.x, retreatLocation.y+1, retreatLocation.z), 255, 125, 0, 'aicontrol_maincontrol')
						
						--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+5, pos.z, 'danger: '..string.format('%d / %d', collectiveDanger, dangerRequiredToRetreat), 255, 255, 255)
						
						-- Retreat if in danger
						if not lockSquad then
							-- Retreat if in danger
							if collectiveDanger > dangerRequiredToRetreat then
								lockSquad = true
							end
						end
						
						if lockSquad then
							local inSafety = false
							if lowHealth then
								if collectiveDanger < -0.2+0.175*healthPercentage or distToHq < 25 then
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'in safety', 255, 255, 0)
									if Squad_IsMoving(squad) then
										--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+2, pos.z, 'stopped', 255, 255, 255)
										Cmd_Stop(sg)
									end
									inSafety = true
								end
							end
							if not inSafety then
								if lowHealth or (retreatThreshold > 5 and World_DistancePointToPoint(pos, retreatLocation) > 5) then
									--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+4, pos.z, 'retreating', 255, 255, 255)
									
									Cmd_Move(sg, retreatLocation, false)
									
									for j=1,5 do
										hqMult = hqMult + 0.35
										local x2,y2 = AIControl_Grid.GetXY(retreatLocation)
										local retreatLocation2 = AIControl_MainControl.GetRetreatLocation(
											retreatLocation,
											AIControl_MainControl.GetRetreatDirection(
												AIControl_MainControl.GetSurroundingSafety({x2, y2}, max(0, stepsTotal-j), stepsTotal, team),
												retreatLocation,
												team, 1.25, 1.45, directionToHq, hqMult, 0.035, 0.5),
											retreatDistance)
										--dr_drawline(World_Pos(retreatLocation.x, retreatLocation.y+1, retreatLocation.z), World_Pos(retreatLocation2.x, retreatLocation2.y+1, retreatLocation2.z), 255, 0, 0, 'aicontrol_maincontrol')
										Cmd_Move(sg, retreatLocation2, true)
										retreatLocation = retreatLocation2
									end
									
									--dr_drawline(World_Pos(retreatLocation.x, retreatLocation.y+1, retreatLocation.z), World_Pos(playerHQPosition.x, playerHQPosition.y+1, playerHQPosition.z), 255, 0, 0, 'aicontrol_maincontrol')
									Cmd_Move(sg, playerHQPosition, true)
									
									AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] = 1
								else
									if Squad_IsMoving(squad) then
										--dr_text3d('aicontrol_maincontrol', pos.x, pos.y+2, pos.z, 'stopped', 255, 255, 255)
										Cmd_Stop(sg)
									end
								end
							end
						end
						
						if not lockSquad and pos.x > -wHalfWidth and pos.x < wHalfWidth and pos.z > -wHalfHeight and pos.z < wHalfHeight then
							local angleThreshold
							
							-- Rotate if facing badly
							local facingDirection
							if #surroundingSafety >= 2 and surroundingSafety[1][3] > 1.5 and surroundingSafety[2][3] > 1.5 then
								angleThreshold = 105
								if customSettings and customSettings[4] == true then
									facingDirection = Util_ScarPos(retreatDirection.x, retreatDirection.z)
								else
									facingDirection = Util_ScarPos(-retreatDirection.x, -retreatDirection.z)
								end
							else
								angleThreshold = 160
								if customSettings and customSettings[4] == true then
									facingDirection = Util_ScarPos(directionToHq.x, directionToHq.z)
								else
									facingDirection = Util_ScarPos(-directionToHq.x, -directionToHq.z)
								end
							end
							
							local heading = Squad_GetHeading(squad)
							
							local angle = math.acos(
								(facingDirection.x*heading.x+facingDirection.z*heading.z) /
								(sqrt(facingDirection.x*facingDirection.x + facingDirection.z*facingDirection.z) * sqrt(heading.x*heading.x + heading.z*heading.z))
							)*180/3.14
							
							if angle > angleThreshold then
								lockSquad = true
								
								if not AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] or AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] > 48/AIControl_Grid.SplitUpdateCount then
									AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = 0
									Command_SquadPosFacing(player, sg, SCMD_Move, pos, Util_ScarPos(pos.x + facingDirection.x*10, pos.z + facingDirection.z*10), false)
								else
									AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] + 1
								end
							else
								if AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] and AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] <= 32/AIControl_Grid.SplitUpdateCount then
									AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] + 1
								else
									AIControl_MainControl.VehicleControl.FacingCmdTimers[team][squadGameID] = nil
								end
							end
							
						end
					
					end
				elseif AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] then
					lockSquad = true
					AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] = AIControl_MainControl.VehicleControl.RetreatCmdTimers[team][squadGameID] + 1
				end
			end
			
			if lockSquad then
				if not AIControl_MainControl_LockedSquads[team][squadGameID] then
					AIControl_MainControl_LockedSquads[team][squadGameID] = 2
					if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
						AI_LockSquad(player, squad)
					end
				end
			elseif AIControl_MainControl_LockedSquads[team][squadGameID] then
				AIControl_MainControl_LockedSquads[team][squadGameID] = nil
				if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
					AI_UnlockSquad(player, squad)
				end
			end
		end
		SGroup_Destroy(sg)
	end,
	
	FBarrageControl = function(squad, setting)
		local sg = SGroup_Create("aicontrol_bc_tempsg")
		local squadGameID = Squad_GetGameID(squad)
		local player = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(player)+1
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local lockSquad = false
		if not AIControl_MainControl_LockedSquads[team][squadGameID]
				or AIControl_MainControl_LockedSquads[team][squadGameID] == -1
				or ( -- also want to barrage with any 'setup' unit control squads
					AIControl_MainControl_LockedSquads[team][squadGameID] == 1 -- Unit control
					and AIControl_MainControl.UnitControlTargets[team][squadGameID] -- Has target
					and not AIControl_MainControl.UnitControlTargets[team][squadGameID][1] -- Target is not a move back target
					)
				then
			local bpID = BP_GetID(Squad_GetBlueprint(squad))
			local curMunitions = Player_GetResource(player, RT_Munition)
			local desiredSaveUpAmount = min(AIControl_MainControl_Settings_BarrageControl.SaveUpAmount, AIControl_MainControl_Settings_BarrageControl.SaveUpAmountGrowthWithTime*World_GetGameTime())
			
			local shouldCast = curMunitions > desiredSaveUpAmount
			if not shouldCast then -- are we saving up?
				shouldCast = World_GetRand(0,100) < AIControl_MainControl_Settings_BarrageControl.ChanceToCastBelowsavedMunitionsThreshold
			end
			
			if shouldCast then
				local pos = Squad_GetPosition(squad)
				local x,y = AIControl_Grid.GetXY(pos)
				
				local totalAbilityWeight = 0
				for i=1,#setting do
					totalAbilityWeight = totalAbilityWeight + setting[i].weight
				end
				
				local weightRand = World_GetRand(0, totalAbilityWeight)
				local curWeight = 0
				for i=1,#setting do
					local v = setting[i]
					curWeight = curWeight + v.weight
					if curWeight >= weightRand then
						
						SGroup_Single(sg, squad)
						
						local castPosition = false
						
						if not v.positionFunc then
							local inProximityOfEnemy = false
							for i=1,World_GetPlayerCount() do
								local p2 = World_GetPlayerAt(i)
								if Player_GetRelationship(player, p2) == R_ENEMY and Prox_PlayerSquadsInProximityOfSquads(p2, sg, v.searchrange, false, nil) then
									inProximityOfEnemy = true
									break
								end
							end
							if inProximityOfEnemy then
								local clumpSearchRadius = v.searchrange/((Dimensions[3]+Dimensions[4])*0.5)
								--d r_drawCircle('aicontrol_maincontrol', pos.x, pos.y+10, pos.z, clumpSearchRadius*((Dimensions[1]+Dimensions[2])*0.5), 255, 255, 255)
								local bestClump, bestClumpThreat = AIControl_MainControl.GetBestClumpForRadius(enemyTeam, x, y, clumpSearchRadius, false)
								
								if bestClump and bestClumpThreat >= v.minThreatToCast then
									castPosition = AIControl_Grid_AveragePosData[bestClump[1]][bestClump[2]][enemyTeam]
									--dr_drawline(World_Pos(pos.x, pos.y+2, pos.z), World_Pos(castPosition.x, castPosition.y+2, castPosition.z), 255, 125, 125, 'aicontrol_maincontrol')
								end
							end
						else
							castPosition = v.positionFunc(squad, v)
						end
						
						if castPosition then
							Cmd_Ability(sg, v.blueprint, castPosition, World_Pos(0,0,0), false, false)
							AIControl_MainControl.BarrageControlLockTimers[squadGameID] = v.lockDuration/AIControl_Grid.SplitUpdateCount
							lockSquad = true
						end
						
						break
					end
				end
			end
		end
		if lockSquad then
			if not AIControl_MainControl_LockedSquads[team][squadGameID] then
				AIControl_MainControl_LockedSquads[team][squadGameID] = 3
				if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
					AI_LockSquad(player, squad)
				end
			end
		else
			if AIControl_MainControl.BarrageControlLockTimers[squadGameID] then
				AIControl_MainControl.BarrageControlLockTimers[squadGameID] = AIControl_MainControl.BarrageControlLockTimers[squadGameID] - 1
				if AIControl_MainControl.BarrageControlLockTimers[squadGameID] <= 0 then
					if AIControl_MainControl_LockedSquads[team][squadGameID] then
						if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
							AI_UnlockSquad(player, squad)
						end
					end
					AIControl_MainControl.BarrageControlLockTimers[squadGameID] = nil
					AIControl_MainControl_LockedSquads[team][squadGameID] = nil
				end
			end
		end
		SGroup_Destroy(sg)
	end,
	
	GetSquadCoverPosition = function(squad, targetSquadPos)
		local pos = Squad_GetPosition(squad)
		
		local coverpos = Squad_FindCoverCompareCurrent(squad, pos, 18, 23, true)
		
		if targetSquadPos then
			local posDiff = World_Pos(targetSquadPos.x - pos.x, 0, targetSquadPos.z - pos.z)
			local posDiffLength = sqrt(posDiff.x*posDiff.x + posDiff.z*posDiff.z)
			if posDiffLength > 0 then
				local posDiffLengthM = 1/posDiffLength
				posDiff.x = posDiff.x*posDiffLengthM
				posDiff.z = posDiff.z*posDiffLengthM
				
				pos.x = coverpos.x - posDiff.x*3
				pos.z = coverpos.z - posDiff.z*3
				
				coverpos = Squad_FindCoverCompareCurrent(squad, pos, 4, 25, true)
			end
		end
		
		return coverpos
	end,
	ExecuteCombatUnitAbility = function(sg, squad, ability)
		if ability.type == 'position' then
			local castPosition, castPosition2 = ability.position(squad)
			if castPosition then
				local secondPosition = castPosition2 or World_Pos(0,0,0)
				Cmd_Ability(sg, ability.blueprint, castPosition, secondPosition, false, ability.queued)
				return true, castPosition, secondPosition
			end
		elseif ability.type == 'squad' then
			local castSquad = ability.squad(squad)
			if castSquad then
				Cmd_Ability(sg, ability.blueprint, castSquad, nil, false, ability.queued)
			end
		elseif ability.type == 'default' then
			Cmd_Ability(sg, ability.blueprint, nil, nil, false, ability.queued)
			return true, nil, nil
		end
		return false, nil, nil
	end,
	FCombatUnitControl = function(squad, inCombat)
		local sg = SGroup_Create("aicontrol_cuc_tempsg")
		SGroup_Single(sg, squad)
		local squadGameID = Squad_GetGameID(squad)
		local player = Squad_GetPlayerOwner(squad)
		local team = Player_GetTeam(player)+1
		local enemyTeam = Team_GetEnemyTeam(team-1)+1
		local pos = Squad_GetPosition(squad)
		if not AIControl_MainControl_LockedSquads[team][squadGameID]
				or AIControl_MainControl_LockedSquads[team][squadGameID] == 4
				or AIControl_MainControl_LockedSquads[team][squadGameID] == 5
				or AIControl_MainControl_LockedSquads[team][squadGameID] == 6
				or AIControl_MainControl_LockedSquads[team][squadGameID] == -1 then
			
			local bpID = BP_GetID(Squad_GetBlueprint(squad))
			local setting = AIControl_MainControl_Settings_CombatUnitControl.UnitSettings[bpID]
			if setting then
				if setting.preset and setting.overrides then
					local finalSetting = {}
					for i,v in pairs(setting.preset) do
						if setting.overrides[i] then
							finalSetting[i] = setting.overrides[i]
						else
							finalSetting[i] = v
						end
					end
					setting = finalSetting
				end
			end
			
			-- get our target squad
			local targetSquadPos = false
			local targetSG = SGroup_Create('aicontrol_cuc_target_tempsg')
			Squad_GetAttackTargets(squad, targetSG)
			local targetSquad = nil
			if SGroup_CountSpawned(targetSG) > 0 then
				targetSquad = SGroup_GetSpawnedSquadAt(targetSG, 1)
			end
			SGroup_Destroy(targetSG)
			if targetSquad then
				targetSquadPos = Squad_GetPosition(targetSquad)
			end
			
			-- ask for support from surrounding squads
			if inCombat and targetSquadPos then
				local sgNearby = SGroup_Create('aicontrol_cuc_tmpsurrounding')
				
				World_GetSquadsNearPoint(player, sgNearby, pos, AIControl_MainControl_Settings_CombatUnitControl.HelpRadius, OT_Ally)
				for i=1,SGroup_CountSpawned(sgNearby) do
					local nearbySquad = SGroup_GetSpawnedSquadAt(sgNearby, i)
					if
							not AIControl_IsSquadVehicle(nearbySquad)
							and Squad_GetMax(nearbySquad) > 1
							and not Squad_IsRetreating(nearbySquad)
							and not Squad_IsAttacking(nearbySquad, 20)
							and not Squad_IsSuppressed(nearbySquad)
							and not Squad_IsPinned(nearbySquad)
							and not Squad_IsInHoldSquad(nearbySquad)
							and not Squad_IsInHoldEntity(nearbySquad)
							and (
								not Squad_HasActiveCommand(nearbySquad)
								or (
									Squad_GetActiveCommand(nearbySquad) ~= SQUADSTATEID_Capture
									and Squad_GetActiveCommand(nearbySquad) ~= SQUADSTATEID_CaptureTeamWeapon
									and Squad_GetActiveCommand(nearbySquad) ~= SQUADSTATEID_DefuseMine
									and Squad_GetActiveCommand(nearbySquad) ~= SQUADSTATEID_Construction
								)
							) then
						local nearbySquadPlayer = Squad_GetPlayerOwner(nearbySquad)
						local nearbySquadTeam = Player_GetTeam(nearbySquadPlayer)+1
						local nearbySquadID = Squad_GetGameID(nearbySquad)
						if
								not Player_IsHuman(nearbySquadPlayer)
								and (
									not AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID]
									or (AIControl_MainControl.CombatUnitControlHelpLockTimers[nearbySquadID] and AIControl_MainControl.CombatUnitControlHelpLockTimers[nearbySquadID] <= 1)
								) then
							local raceStr = Player_GetRaceName(nearbySquadPlayer)
							local nearbySquadBPID = BP_GetID(Squad_GetBlueprint(nearbySquad))
							local ucSetting = AIControl_MainControl_Settings_UnitControl.UnitSettings[nearbySquadBPID]
							local bcSetting = AIControl_MainControl_Settings_BarrageControl.UnitSettings[nearbySquadBPID]
							if not ucSetting and not bcSetting
									and (
										not AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID]
										or AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID] == 4
										or AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID] == 6
									) then
								
								local nearbySquadPos = Squad_GetPosition(nearbySquad)
								local hqPos = AIControl_MainControl.HQPositions[World_GetPlayerIndex(nearbySquadPlayer)]
								local distToHQ = sqrt((nearbySquadPos.x - hqPos.x)^2 + (nearbySquadPos.z - hqPos.z)^2)
								if distToHQ > 40 then
									
									AIControl_MainControl.CombatUnitControlHelpLockTimers[nearbySquadID] = 3
									if not AIControl_MainControl_LockedSquads[nearbySquadTeam][nearbySquadID] then
										AIControl_MainControl_LockedSquads[team][nearbySquadID] = 6
										if AI_IsAIPlayer(nearbySquadPlayer) and AI_IsEnabled(nearbySquadPlayer) then
											AI_LockSquad(nearbySquadPlayer, nearbySquad)
										end
									end
									
									local diffV = World_Pos(nearbySquadPos.x - targetSquadPos.x, 0, nearbySquadPos.z - targetSquadPos.z)
									diffVLengthM = 1/sqrt(diffV.x^2 + diffV.z^2)
									diffV.x = -diffV.z * diffVLengthM
									diffV.z =  diffV.x * diffVLengthM
									
									local xRand = abs(diffV.x*50)
									local yRand = abs(diffV.z*50)
									
									local attackPos = World_Pos(
										targetSquadPos.x - xRand + World_GetRand(0, ceil(xRand*20))/10,
										0,
										targetSquadPos.z - yRand + World_GetRand(0, ceil(yRand*20))/10
									)
									attackPos.y = World_GetHeightAt(attackPos.x, attackPos.z)
									
									local sg2 = SGroup_Create('aicontrol_cuc_tempsg2')
									SGroup_Single(sg2, nearbySquad)
									
									--dr_drawline(World_Pos(nearbySquadPos.x, nearbySquadPos.y+1, nearbySquadPos.z), World_Pos(attackPos.x, attackPos.y+1, attackPos.z), 255, 255, 0, 'aicontrol_maincontrol')
									
									Cmd_AttackMove(sg2, attackPos, false, nil, 12)
									SGroup_Destroy(sg2)
								end
								
							end
						end
					end
				end
				
				SGroup_Destroy(sgNearby)
			end
			
			local lockType = 4
			local lockSquad = false
			if AIControl_MainControl_LockedSquads[team][squadGameID] == 5 then
				local timerData = AIControl_MainControl.CombatUnitControlAbilityLockTimers[squadGameID]
				if timerData then
					timerData.timer = timerData.timer - 1
					if timerData.timer <= 0 or (timerData.ability.verifyPosition and not timerData.ability.positionVerify(squad, timerData.position1, timerData.position2)) then
						AIControl_MainControl.CombatUnitControlAbilityLockTimers[squadGameID] = nil
					else
						lockSquad = true
					end
				end
			elseif AIControl_MainControl_LockedSquads[team][squadGameID] == 6 and not inCombat then
				if AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] then
					AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] = AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] - 1
					if AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] <= 0 then
						AIControl_MainControl.CombatUnitControlHelpLockTimers[squadGameID] = nil
					else
						lockSquad = true
					end
				end
			else
				local lockChance = AIControl_MainControl_Settings_CombatUnitControl.BaseLockChance
				if setting and setting.lock_chance ~= nil then
					lockChance = setting.lock_chance
				end
				lockSquad = inCombat and World_GetRand(0, 100) < lockChance
				
				if lockSquad then
					local doingSomething = false
					
					local tryCastAnAbility = setting and World_GetRand(0, 100) < setting.ability_chance
					if tryCastAnAbility then
						local abilities = {}
						
						local totalAbilityWeight = 0
						for i=1,#setting.abilities do
							local ability = setting.abilities[i]
							if ability.preset and ability.overrides then
								local finalAbility = {}
								for j,v in pairs(ability.preset) do
									if ability.overrides[j] then
										finalAbility[j] = ability.overrides[j]
									else
										finalAbility[j] = v
									end
								end
								ability = finalAbility
							end
							if ability.weight then
								abilities[i] = ability
								totalAbilityWeight = totalAbilityWeight + ability.weight
							else
								print('error: squad ['..BP_GetName(Squad_GetBlueprint(squad))..'] ability ['..i..'] has no weight:')
								Dump(ability, 1)
							end
						end
						
						local weightRand = World_GetRand(0, totalAbilityWeight)
						local curWeight = 0
						for i=1,#abilities do
							local ability = abilities[i]
							curWeight = curWeight + ability.weight
							if curWeight >= weightRand then
								local shouldCast = true
								if ability.filter then
									shouldCast = ability.filter(squad)
								end
								if shouldCast then
									local position1, position2
									if ability.behavior then
										ability.behavior(squad, function()
											doingSomething, position1, position2 = AIControl_MainControl.ExecuteCombatUnitAbility(sg, squad, ability)
										end)
									else
										doingSomething, position1, position2 = AIControl_MainControl.ExecuteCombatUnitAbility(sg, squad, ability)
									end
									
									if doingSomething then
										lockType = 5
										AIControl_MainControl.CombatUnitControlAbilityLockTimers[squadGameID] = {
											timer = ability.lockDuration/AIControl_Grid.SplitUpdateCount,
											ability = ability,
											position1 = position1,
											position2 = position2
										}
									end
								end
								
								break
							end
						end
					end
					
					if not doingSomething then
						local closestSquadPos = targetSquadPos
						local closestSquadDist
						if targetSquadPos then
							closestSquadDist = World_DistancePointToPoint(pos, targetSquadPos)
						else
							closestSquadDist = 45
						end
						local sgNearby = SGroup_Create('aicontrol_cuc_tmpsurrounding')
						World_GetSquadsNearPoint(player, sgNearby, pos, closestSquadDist-10, OT_Enemy)
						for i=1,SGroup_CountSpawned(sgNearby) do
							local s = SGroup_GetSpawnedSquadAt(sgNearby, i)
							if not AIControl_IsSquadVehicle(s) then
								local sPos = Squad_GetPosition(s)
								local dist = World_DistancePointToPoint(pos, sPos)
								if dist < closestSquadDist then
									closestDist = dist
									closestSquadPos = sPos
								end
							end
						end
						SGroup_Destroy(sgNearby)
						
						local shouldAssault = closestSquadPos and setting
						if shouldAssault and setting.assault_troops ~= nil then
							if type(setting.assault_troops) == 'function' then
								shouldAssault = setting.assault_troops(squad)
							else
								shouldAssault = setting.assault_troops
							end
						end
						if shouldAssault then
							local closeInDistance = setting.close_in_distance or 25
							local posDiff = World_Pos(pos.x - closestSquadPos.x, 0, pos.z - closestSquadPos.z)
							local posDiffLength = sqrt(posDiff.x*posDiff.x + posDiff.z*posDiff.z)
							shouldAssault = posDiffLength > closeInDistance
							if shouldAssault then
								local posDiffLengthM = 1/posDiffLength
								posDiff.x = posDiff.x*posDiffLengthM
								posDiff.z = posDiff.z*posDiffLengthM
								
								local targetPos = World_Pos(
									closestSquadPos.x + posDiff.x*closeInDistance,
									0,
									closestSquadPos.z + posDiff.z*closeInDistance)
								
								local coverPos = Squad_FindCover(squad, targetPos, 7)
								if World_DistancePointToPoint(pos, coverPos) > 10 then
									Command_SquadPosFacing(player, sg, SCMD_Move, coverPos, closestSquadPos, false)
									--dr_drawline(World_Pos(pos.x, pos.y+1, pos.z), World_Pos(coverPos.x, coverPos.y+1, coverPos.z), 255, 0, 0, 'aicontrol_maincontrol')
								else
									Cmd_Stop(sg)
								end
							end
						end
						if not shouldAssault then
							local coverPos = AIControl_MainControl.GetSquadCoverPosition(squad, closestSquadPos)
							if coverPos then
								if World_DistancePointToPoint(pos, coverPos) > 6 then
									if closestSquadPos then
										Command_SquadPosFacing(player, sg, SCMD_Move, coverPos, closestSquadPos, false)
									else
										Command_SquadPos(player, sg, SCMD_Move, coverPos, false)
									end
								--else
								--	Cmd_Stop(sg)
								end
							end
						end
					end
				end
			end
			
			if lockSquad then
				if not AIControl_MainControl_LockedSquads[team][squadGameID] then
					AIControl_MainControl_LockedSquads[team][squadGameID] = lockType
					if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
						AI_LockSquad(player, squad)
					end
				end
			else
				if AIControl_MainControl_LockedSquads[team][squadGameID] then
					if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
						AI_UnlockSquad(player, squad)
					end
				end
				AIControl_MainControl_LockedSquads[team][squadGameID] = nil
			end
		end
		SGroup_Destroy(sg)
	end,
	
	Update = function()
		if g_AIControl_Pause then return end
		
		AIControl_MainControl.SecondaryUpdateTicks = AIControl_MainControl.SecondaryUpdateTicks + 1
		if AIControl_MainControl.SecondaryUpdateTicks >= AIControl_MainControl_Settings.SecondaryUpdateTicks then
			AIControl_MainControl.SecondaryUpdate()
			AIControl_MainControl.SecondaryUpdateTicks = 0
		end
		
		local function GetBestTerritoryPoint(sectorID, team)
			local AllChoices, SafeChoices, AllChoiceCount, SafeChoiceCount = {}, {}, 0, 0
			local function shuffleTable(t)
				local iterations = #t
				local j
				for i = iterations, 2, -1 do
					j = World_GetRand(1, i)
					t[i], t[j] = t[j], t[i]
				end
			end
			shuffleTable(AIControl_MainControl.TerritorySectors[sectorID].GridCells)
			local gridCellsCount = #AIControl_MainControl.TerritorySectors[sectorID].GridCells
			for i=1,min(6, gridCellsCount) do
				local x, y = AIControl_MainControl.TerritorySectors[sectorID].GridCells[i][1], AIControl_MainControl.TerritorySectors[sectorID].GridCells[i][2]
				if not AIControl_Grid.DisabledLocations[x][y] then
					local surroundingSafety = AIControl_MainControl.GetSurroundingSafety({x, y}, 0, 9, team)
					local collectiveDanger = 0
					local collectiveHistoryDanger = 0
					for j=1,#surroundingSafety do
						local v = surroundingSafety[j]
						collectiveDanger = collectiveDanger + v[3]
						collectiveHistoryDanger = collectiveHistoryDanger + v[4]
					end
					local result = {i, collectiveDanger, collectiveHistoryDanger}
					AllChoiceCount = AllChoiceCount + 1
					AllChoices[AllChoiceCount] = result
					if collectiveDanger + collectiveHistoryDanger*AIControl_MainControl_Settings_HQControl.HistoryDangerMultiplier < AIControl_MainControl_Settings_HQControl.DangerOnEnemyValue then 
						SafeChoiceCount = SafeChoiceCount + 1
						SafeChoices[SafeChoiceCount] = result
						if SafeChoiceCount >= 3 then
							break
						end
					end
				end
			end
			local safe
			local t
			if SafeChoiceCount > 0 then
				safe = true
				t = SafeChoices
			elseif AllChoiceCount > 0 then
				safe = false
				t = AllChoices
			else
				return nil
			end
			sort(t, function(a, b) return a[2] < b[2] end)
			local choiceCount = 1
			while choiceCount < SafeChoiceCount and t[1][2]+t[1][2]*AIControl_MainControl_Settings_HQControl.SafePositionChoiceRandomnessThreshold >= t[choiceCount + 1][2] do
				choiceCount = choiceCount + 1
			end
			local choice
			if choiceCount == 1 then
				choice = 1
			elseif choiceCount > 1 then
				choice = World_GetRand(1, choiceCount)
			else
				return nil
			end
			return safe, t[choice][1], t[choice][2], t[choice][3]
		end
		local function GetSectorImportance(sectorID, pos)
			local spPos = Entity_GetPosition(AIControl_MainControl.TerritorySectors[sectorID].Entity)
			local xDist, yDist = pos.x - spPos.x, pos.z - spPos.z
			return AIControl_MainControl.TerritorySectors[sectorID].Importance -
				min(
					AIControl_MainControl_Settings_HQControl.MaxImportanceDecreaseOverDistance,
					sqrt(xDist^2 + yDist^2)*AIControl_MainControl_Settings_HQControl.ImportanceByDistanceModifier
				)
		end
		
		local updateHQs = false
		AIControl_MainControl.HQUpdateWait = AIControl_MainControl.HQUpdateWait + 1
		if AIControl_MainControl.HQUpdateWait > AIControl_MainControl_Settings_HQControl.UpdateInterval then
			updateHQs = true
			--dr_clear('aicontrol_hqcontrol')
			
			-- Territory sector update
			for SID in pairs(AIControl_MainControl.TerritorySectors) do -- Determine which sectors are being captured
				AIControl_MainControl.TerritorySectors[SID].BeingCaptured = false
				local sectorPos = Entity_GetPosition(AIControl_MainControl.TerritorySectors[SID].Entity)
				local x, y = floor((sectorPos.x+wHalfWidth)/Dimensions[3])+1, floor((sectorPos.z+wHalfHeight)/Dimensions[4])+1
				if World_OwnsEntity(AIControl_MainControl.TerritorySectors[SID].Entity) then
					for team=1,2 do
						for i=-1,1 do
							for j=-1,1 do
								local curx, cury = x+i, y+j
								if curx>0 and curx <= Dimensions[1] and cury>0 and cury<=Dimensions[2] then
									for k=1,SGroup_CountSpawned(AIControl_Grid_DataSquads[curx][cury][team]) do
										local squad = SGroup_GetSpawnedSquadAt(AIControl_Grid_DataSquads[curx][cury][team], k)
										if Squad_HasActiveCommand(squad) and Squad_GetActiveCommand(squad) == SQUADSTATEID_Capture then
											AIControl_MainControl.TerritorySectors[SID].BeingCaptured = true
											break
										end
									end
								end
								if AIControl_MainControl.TerritorySectors[SID].BeingCaptured then break end
							end
							if AIControl_MainControl.TerritorySectors[SID].BeingCaptured then break end
						end
						if AIControl_MainControl.TerritorySectors[SID].BeingCaptured then break end
					end
				else
					local entityTeam = Player_GetTeam(Entity_GetPlayerOwner(AIControl_MainControl.TerritorySectors[SID].Entity))+1
					local entityEnemyTeam
					if entityTeam == 1 then entityEnemyTeam = 2
					else entityEnemyTeam = 1 end
					for i=1,SGroup_CountSpawned(AIControl_Grid_DataSquads[x][y][entityEnemyTeam]) do
						local squad = SGroup_GetSpawnedSquadAt(AIControl_Grid_DataSquads[x][y][entityEnemyTeam], i)
						if Squad_HasActiveCommand(squad) and Squad_GetActiveCommand(squad) == SQUADSTATEID_Capture then
							AIControl_MainControl.TerritorySectors[SID].BeingCaptured = true
							break
						end
					end
				end
			end
			
			AIControl_MainControl.HQUpdateWait = 0
		end
		for team=1,2 do
			local enemyTeam = Team_GetEnemyTeam(team-1)+1
			
			-- HQ Control
			if updateHQs then
				local HQPosImportanceLists = {} -- Sorted array by sector importance
				local HQPosImportanceListCount = 0
				local function getImportanceListIndex(importance)
					local index
					if not isSetup then
						for j=1,HQPosImportanceListCount do
							if HQPosImportanceLists[j].TerritoryImportance[1][2] <= importance or HQPosImportanceLists[j].IsSetup then
								index = j
								break
							end
						end
					else
						for j=1,HQPosImportanceListCount do
							if HQPosImportanceLists[j].IsSetup and HQPosImportanceLists[j].TerritoryImportance[1][2] <= importance then
								index = j
								break
							end
						end
					end
					if index == nil then index = HQPosImportanceListCount+1 end
					for k=HQPosImportanceListCount,index,-1 do
						HQPosImportanceLists[k+1] = HQPosImportanceLists[k]
					end
					return index
				end
				for i=1,SGroup_CountSpawned(AIControl_MainControl.HQs[team]) do
					local hq = SGroup_GetSpawnedSquadAt(AIControl_MainControl.HQs[team], i)
					local hqGameID = Squad_GetGameID(hq)
					local isSetup = Squad_HasUpgrade(hq, UPG.CW.MOBILEHQ)
					if isSetup then AIControl_MainControl.SettingUpHQs[team][hqGameID] = nil end
					if not isSetup or Squad_GetProductionQueueSize(hq) == 0 then
						--print("HQ "..i.." ["..BP_GetName(Squad_GetBlueprint(hq)).."] --------------------------")
						local hqOwner = Squad_GetPlayerOwner(hq)
						local hqBlueprint = Squad_GetBlueprint(hq)
						local pos = Squad_GetPosition(hq)
						local x, y = floor((pos.x+wHalfWidth)/Dimensions[3])+1, floor((pos.z+wHalfHeight)/Dimensions[4])+1
						
						local setupPoint
						local hqSectorID
						local currentImportance = 0
						local currentSafety
						local territoryImportance = {}
						local territoryImportanceCount = 0
						
						if isSetup then
							hqSectorID = World_GetTerritorySectorID(pos)
							AIControl_MainControl.HQTargets[team][hqGameID] = nil
							setupPoint = {x, y}
						elseif AIControl_MainControl.HQTargets[team][hqGameID] then
							hqSectorID = AIControl_MainControl.HQTargets[team][hqGameID][1]
							if AIControl_MainControl.TerritorySectors[hqSectorID] then
								setupPoint = {
									AIControl_MainControl.TerritorySectors[hqSectorID].GridCells[ AIControl_MainControl.HQTargets[team][hqGameID][3] ][1],
									AIControl_MainControl.TerritorySectors[hqSectorID].GridCells[ AIControl_MainControl.HQTargets[team][hqGameID][3] ][2]}
								local validTarget = true
								if World_OwnsEntity(AIControl_MainControl.TerritorySectors[hqSectorID].Entity)
										or AIControl_MainControl.TerritorySectors[hqSectorID].BeingCaptured
										or AIControl_Grid.DisabledLocations[ setupPoint[1] ][ setupPoint[2] ] then
									validTarget = false
								else
									local owner = Entity_GetPlayerOwner(AIControl_MainControl.TerritorySectors[hqSectorID].Entity)
									if Player_GetTeam(owner) ~= team-1 or (not World_IsInSupply(owner, World_GetTerritorySectorPosition(hqSectorID)) and hqBlueprint ~= SBP.CW.HQ and hqBlueprint ~= SBP.CW.HQ_REINFORCEMENT) then
										validTarget = false
									end
								end
								if not validTarget then
									setupPoint = {x, y}
									--dr_text3d('aicontrol_hqcontrol', pos.x, pos.y+0.35, pos.z, 'Invalidated target', 0, 255, 0)
									--print("Invalidated target")
									hqSectorID = nil
									AIControl_MainControl.TerritorySectors[ AIControl_MainControl.HQTargets[team][hqGameID][1] ].SetupHQCount[team] =
										AIControl_MainControl.TerritorySectors[ AIControl_MainControl.HQTargets[team][hqGameID][1] ].SetupHQCount[team] - 1
									--print("Sector "..AIControl_MainControl.HQTargets[team][hqGameID][1].." HQ Count: "..AIControl_MainControl.TerritorySectors[ AIControl_MainControl.HQTargets[team][hqGameID][1] ].SetupHQCount[team].." ( - )")
									AIControl_MainControl.HQTargets[team][hqGameID] = nil
								end
							end
						end
						if hqSectorID and AIControl_MainControl.TerritorySectors[hqSectorID] then
							-- Sector in which we're currently setup importance calculations
							currentImportance = GetSectorImportance(hqSectorID, pos) + AIControl_MainControl_Settings_HQControl.CurrentChoicePriority
							if AIControl_MainControl.TerritorySectors[hqSectorID].SetupHQCount[team] > 1 then
								currentImportance = currentImportance - AIControl_MainControl_Settings_HQControl.ImportanceDecreaseIfHQAlreadySetup
							end
							local surroundingSafety = AIControl_MainControl.GetSurroundingSafety({setupPoint[1], setupPoint[2]}, 0, 9, team)
							local collectiveDanger = 0
							for j=1,#surroundingSafety do
								local v = surroundingSafety[j]
								collectiveDanger = collectiveDanger + v[3] + v[4]*AIControl_MainControl_Settings_HQControl.HistoryDangerMultiplier
							end
							if collectiveDanger >= AIControl_MainControl_Settings_HQControl.DangerOnEnemyValue then 
								currentImportance = currentImportance - AIControl_MainControl_Settings_HQControl.ImportanceDecreaseIfNotSafe
							end
							currentImportance = currentImportance - min(AIControl_MainControl_Settings_HQControl.MaxImportanceDecreaseWithDanger,
								collectiveDanger*AIControl_MainControl_Settings_HQControl.ImportanceDecreaseWithDanger
								*(1+(1-Squad_GetHealthPercentage(hq))*AIControl_MainControl_Settings_HQControl.DangerMultiplierWithHealth))
							if not World_OwnsEntity(AIControl_MainControl.TerritorySectors[hqSectorID].Entity) then
								local owner = Entity_GetPlayerOwner(AIControl_MainControl.TerritorySectors[hqSectorID].Entity)
								if Player_GetTeam(owner) == team-1 and (World_IsInSupply(owner, World_GetTerritorySectorPosition(hqSectorID)) or hqBlueprint == SBP.CW.HQ or hqBlueprint == SBP.CW.HQ_REINFORCEMENT) and
										not isSetup and AIControl_MainControl.HQTargets[team][hqGameID] then
									AIControl_MainControl.HQTargets[team][hqGameID][2] = currentImportance
									territoryImportance[1] = AIControl_MainControl.HQTargets[team][hqGameID]
									territoryImportanceCount = 1
								end
							end
							--print("- current: SID="..hqSectorID.." importance="..currentImportance)
							--dr_text3d('aicontrol_hqcontrol', pos.x, pos.y+1, pos.z, "- current: SID="..hqSectorID.." importance="..currentImportance, 255, 255, 255)
						end
						
						for SID in pairs(AIControl_MainControl.TerritorySectors) do
							if SID ~= hqSectorID and not World_OwnsEntity(AIControl_MainControl.TerritorySectors[SID].Entity) and not AIControl_MainControl.TerritorySectors[SID].BeingCaptured then
								local owner = Entity_GetPlayerOwner(AIControl_MainControl.TerritorySectors[SID].Entity)
								if Player_GetTeam(owner) == team-1 and (World_IsInSupply(owner, World_GetTerritorySectorPosition(SID)) or hqBlueprint == SBP.CW.HQ or hqBlueprint == SBP.CW.HQ_REINFORCEMENT) then
									-- New sector importance calculations
									local sectorImportance = GetSectorImportance(SID, pos)
									if AIControl_MainControl.TerritorySectors[SID].SetupHQCount[team] > 0 then
										sectorImportance = sectorImportance - AIControl_MainControl_Settings_HQControl.ImportanceDecreaseIfHQAlreadySetup
									end
									if not hqSectorID or sectorImportance - currentImportance >= AIControl_MainControl_Settings_HQControl.ImportanceDifferenceToGoToANewPoint then
										local result, setupPoint, danger, historyDanger = GetBestTerritoryPoint(SID, team)
										if result ~= nil then
											if not result then -- if not safe
												sectorImportance = sectorImportance - AIControl_MainControl_Settings_HQControl.ImportanceDecreaseIfNotSafe
											end
											sectorImportance = sectorImportance - min(AIControl_MainControl_Settings_HQControl.MaxImportanceDecreaseWithDanger,
												(danger+historyDanger*AIControl_MainControl_Settings_HQControl.HistoryDangerMultiplier)*AIControl_MainControl_Settings_HQControl.ImportanceDecreaseWithDanger
												*(1+(1-Squad_GetHealthPercentage(hq))*AIControl_MainControl_Settings_HQControl.DangerMultiplierWithHealth))
											--print("- SID="..SID.." importance="..sectorImportance)
											if not hqSectorID or sectorImportance - currentImportance > AIControl_MainControl_Settings_HQControl.ImportanceDifferenceToGoToANewPoint then -- this is checked twice on purpose
												--print("+-- Added!")
												-- Sorted insert by importance (highest importance point is 1st)
												local index
												for j=1,territoryImportanceCount do
													if territoryImportance[j][2] <= sectorImportance then
														index = j
														break
													end
												end
												if index == nil then index = territoryImportanceCount + 1 end
												for k = territoryImportanceCount,index,-1 do
													territoryImportance[k+1] = territoryImportance[k]
												end
												territoryImportanceCount = territoryImportanceCount + 1
												territoryImportance[index] = { SID, sectorImportance, setupPoint }
											end
										end
									end
								end
							end
						end
						if territoryImportanceCount > 0 then
							-- Sorted insert by first importance (highest importance point is 1st) and setup state
							local index = getImportanceListIndex(territoryImportance[1][2])
							HQPosImportanceLists[index] = {
								HQ = i,
								HQSector = hqSectorID,
								IsSetup = isSetup,
								CurrentImportance = currentImportance,
								TerritoryImportance = territoryImportance,
								TerritoryImportanceCount = territoryImportanceCount,
							}
							HQPosImportanceListCount = HQPosImportanceListCount+1
						end
					end
				end
				
				local function getOccupiedSectorCount(i) -- or finds first onoccupied sector
					local result = 0
					for j=1,HQPosImportanceLists[i].TerritoryImportanceCount do
						if AIControl_MainControl.TerritorySectors[HQPosImportanceLists[i].TerritoryImportance[j][1]].SetupHQCount[team] > 0 then
							result = result + 1
						else
							break
						end
					end
					return result
				end
				local i = 1
				while i <= HQPosImportanceListCount and HQPosImportanceLists[i].IsSetup == false do
					local occupiedSectors = getOccupiedSectorCount(i)
					local moveSector
					if occupiedSectors == HQPosImportanceLists[i].TerritoryImportanceCount then moveSector = 1
					else moveSector = occupiedSectors + 1 end
					
					local hq = SGroup_GetSpawnedSquadAt(AIControl_MainControl.HQs[team], HQPosImportanceLists[i].HQ)
					local hqGameID = Squad_GetGameID(hq)
					
					if AIControl_MainControl.HQTargets[team][hqGameID] then
						if HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ~= AIControl_MainControl.HQTargets[team][hqGameID][1] then
							AIControl_MainControl.TerritorySectors[ AIControl_MainControl.HQTargets[team][hqGameID][1] ].SetupHQCount[team] =
								AIControl_MainControl.TerritorySectors[ AIControl_MainControl.HQTargets[team][hqGameID][1] ].SetupHQCount[team] - 1
							--print("Sector "..AIControl_MainControl.HQTargets[team][hqGameID][1].." HQ Count: "..AIControl_MainControl.TerritorySectors[ AIControl_MainControl.HQTargets[team][hqGameID][1] ].SetupHQCount[team].." ( - )")
							
							AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team] =
								AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team] + 1
							--print("Sector "..HQPosImportanceLists[i].TerritoryImportance[moveSector][1].." HQ Count: "..AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team].." ( + )")
						end
					else
						AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team] =
							AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team] + 1
						--print("Sector "..HQPosImportanceLists[i].TerritoryImportance[moveSector][1].." HQ Count: "..AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team].." ( + )")
					end
					
					local setupPointXY = AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].GridCells[ HQPosImportanceLists[i].TerritoryImportance[moveSector][3] ]
					local setupPointX = setupPointXY[1]
					local setupPointY = setupPointXY[2]
					local setupPoint = AIControl_Grid.ControlPoints[setupPointX][setupPointY]
					--print("Setup point xy: {"..setupPointX..", "..setupPointY.."}")
					
					local sg_hq = SGroup_Single(SGroup_CreateIfNotFound("AIControl_MainControl.HQSetupControlGroup"), hq)
					local pos = Squad_GetPosition(hq)
					
					--dr_text3d('aicontrol_hqcontrol', pos.x, pos.y+3, pos.z, "Setup point xy: {"..setupPointX..", "..setupPointY.."}", 255, 255, 255)
					--dr_text3d('aicontrol_hqcontrol', pos.x, pos.y+4, pos.z, "distance: "..string.format('%.1f', sqrt((pos.x-setupPoint.x)^2 + (pos.z-setupPoint.z)^2)), 255, 255, 255)
					--dr_text3d('aicontrol_hqcontrol', setupPoint.x, setupPoint.y+2, setupPoint.z, "SETUP POINT", 255, 255, 0)
					
					if World_GetTerritorySectorID(pos) == HQPosImportanceLists[i].TerritoryImportance[moveSector][1] and sqrt((pos.x-setupPoint.x)^2 + (pos.z-setupPoint.z)^2) < 20 then
						--print("Setting up")
						--dr_text3d('aicontrol_hqcontrol', pos.x, pos.y+2, pos.z, "Setting up", 255, 255, 255)
						Cmd_Ability(sg_hq, ABILITY.CW.HQ_SETUP_AI)
						if not AIControl_MainControl.SettingUpHQs[team][hqGameID] then
							AIControl_MainControl.SettingUpHQs[team][hqGameID] = {setupPointX, setupPointY, World_GetGameTime()}
						elseif AIControl_MainControl.SettingUpHQs[team][hqGameID][3] > AIControl_MainControl_Settings_HQControl.MaxSetupWaitTime then
							AIControl_Grid.DisabledLocations[setupPointX][setupPointY] = true
						end
					else
						--print("Moving unsetup HQ to ("..string.format('%d, %d, %d', setupPoint.x, setupPoint.y, setupPoint.z)..")")
						--dr_text3d('aicontrol_hqcontrol', pos.x, pos.y+2, pos.z, "Moving unsetup HQ to ("..string.format('%d, %d, %d', setupPoint.x, setupPoint.y, setupPoint.z)..")", 255, 255, 255)
						AIControl_MainControl.SettingUpHQs[team][hqGameID] = nil
						Cmd_Move(sg_hq, setupPoint)
					end
					
					AIControl_MainControl.HQTargets[team][hqGameID] = HQPosImportanceLists[i].TerritoryImportance[moveSector]
					
					i = i + 1
				end
				while i <= HQPosImportanceListCount do
					local occupiedSectors = getOccupiedSectorCount(i)
					if occupiedSectors < HQPosImportanceLists[i].TerritoryImportanceCount then
						local moveSector = occupiedSectors + 1
						if HQPosImportanceLists[i].HQSector then
							AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].HQSector ].SetupHQCount[team] =
								AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].HQSector ].SetupHQCount[team] - 1
							--print("Sector "..HQPosImportanceLists[i].HQSector.." HQ Count: "..AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].HQSector ].SetupHQCount[team].." ( - )")
						end
						
						AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team] =
							AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team] + 1
						--print("Sector "..HQPosImportanceLists[i].TerritoryImportance[moveSector][1].." HQ Count: "..AIControl_MainControl.TerritorySectors[ HQPosImportanceLists[i].TerritoryImportance[moveSector][1] ].SetupHQCount[team].." ( + )")
						
						local hq = SGroup_GetSpawnedSquadAt(AIControl_MainControl.HQs[team], HQPosImportanceLists[i].HQ)
						local hqGameID = Squad_GetGameID(hq)
						
						Cmd_Upgrade(SGroup_Single(SGroup_CreateIfNotFound("AIControl_MainControl.HQSetupControlGroup"), hq), UPG.CW.ENABLE_MOBILE_HQ)
						AIControl_MainControl.HQTargets[team][hqGameID] = HQPosImportanceLists[i].TerritoryImportance[moveSector]
						
						--print("Moving setup HQ")
					end
					
					i = i + 1
				end
			end
		end
	end,
	
	SecondaryUpdate = function()
		for i=1,#AIControl_MainControl.AICheatModifiers do
			Modifier_Remove(AIControl_MainControl.AICheatModifiers[i])
		end
		if AIControl_MainControl.InitUpdateComplete == false then
			if AIControl_MainControl_Settings.AICheats.StartingResources ~= 1 then
				for i=1,AIControl_PlayerCount do
					local player = World_GetPlayerAt(AIControl_Players[i])
					Player_SetResource(player, RT_Manpower, Player_GetResource(player, RT_Manpower)*AIControl_MainControl_Settings.AICheats.StartingResources)
					Player_SetResource(player, RT_Fuel, Player_GetResource(player, RT_Fuel)*AIControl_MainControl_Settings.AICheats.StartingResources)
					
					if Player_GetMaxPopulation(player, CT_Personnel) < AIControl_MainControl_Settings.AICheats.Popcap then
						Player_SetMaxPopulation(player, CT_Personnel, AIControl_MainControl_Settings.AICheats.Popcap)
						Player_SetMaxCapPopulation(player, CT_Personnel, AIControl_MainControl_Settings.AICheats.Popcap)
					end
					
					local rewardUnits = UPG.REWARD[Player_GetRaceName(player)]
					if rewardUnits then
						for j,v in pairs(rewardUnits) do
							if World_GetRand(1, 2) == 1 then
								Cmd_InstantUpgrade(player, v)
							end
						end
					end
				end
			end
			AIControl_MainControl.InitUpdateComplete = true
		end
		local cheatModifierCount = 0
		AIControl_MainControl.AICheatModifiers = {}
		for i=1,AIControl_PlayerCount do
			local player = World_GetPlayerAt(AIControl_Players[i])
			
			if AIControl_MainControl_Settings.AICheats.ExperienceReceived ~= 1 then
				cheatModifierCount = cheatModifierCount + 1
				AIControl_MainControl.AICheatModifiers[cheatModifierCount] = Modify_PlayerExperienceReceived(player, AIControl_MainControl_Settings.AICheats.ExperienceReceived)
			end
			if AIControl_MainControl_Settings.AICheats.ProductionRate ~= 1 then
				cheatModifierCount = cheatModifierCount + 1
				AIControl_MainControl.AICheatModifiers[cheatModifierCount] = Modify_PlayerProductionRate(player, AIControl_MainControl_Settings.AICheats.ProductionRate)
			end
			if AIControl_MainControl_Settings.AICheats.Upkeep ~= 1 then
				cheatModifierCount = cheatModifierCount + 1
				AIControl_MainControl.AICheatModifiers[cheatModifierCount] = Modify_Upkeep(player, AIControl_MainControl_Settings.AICheats.Upkeep)
			end
			if AIControl_MainControl_Settings.AICheats.VehicleRepairRate ~= 1 then
				cheatModifierCount = cheatModifierCount + 1
				AIControl_MainControl.AICheatModifiers[cheatModifierCount] = Modify_VehicleRepairRate(player, AIControl_MainControl_Settings.AICheats.VehicleRepairRate)
			end
			if AIControl_MainControl_Settings.AICheats.SightRadius ~= 1 then
				cheatModifierCount = cheatModifierCount + 1
				AIControl_MainControl.AICheatModifiers[cheatModifierCount] = Modify_PlayerSightRadius(player, AIControl_MainControl_Settings.AICheats.SightRadius)
			end
			if AIControl_MainControl_Settings.AICheats.CommandPointGainRate ~= 1 then
				cheatModifierCount = cheatModifierCount + 1
				AIControl_MainControl.AICheatModifiers[cheatModifierCount] = Modify_PlayerResourceRate(player, RT_Action, AIControl_MainControl_Settings.AICheats.CommandPointGainRate)
			end
		end
		
		for sectorID in pairs(AIControl_MainControl.TerritorySectors) do
			AIControl_MainControl.TerritorySectors[sectorID].SetupHQCount = {0, 0}
			local sectorNeutral = World_OwnsEntity(AIControl_MainControl.TerritorySectors[sectorID].Entity)
			for i=1,#AIControl_MainControl.TerritorySectors[sectorID].AIMarkers do
				if not sectorNeutral then
					--Entity_SetStrategicPointNeutral(AIControl_MainControl.TerritorySectors[sectorID].AIMarkers[i])
				--else
					Entity_SetPlayerOwner(AIControl_MainControl.TerritorySectors[sectorID].AIMarkers[i], Entity_GetPlayerOwner(AIControl_MainControl.TerritorySectors[sectorID].Entity))
				end
			end
		end
		
		-- Find all controlled squads and HQ targets
		local targets = {{}, {}}
		SGroup_Clear(AIControl_MainControl.HQs[1])
		SGroup_Clear(AIControl_MainControl.HQs[2])
		local sg_tmp = SGroup_Create('sg_tmp')
		local eg_tmp = EGroup_Create('eg_tmp')
		for i=1,AIControl_PlayerCount do
			local player = World_GetPlayerAt(AIControl_Players[i])
			local team = Player_GetTeam(player)+1
			AIControl_MainControl.HQPositions[AIControl_Players[i]] = Player_GetStartingPosition(player)
			
			local squads = Player_GetSquads(player)
			for j=1,SGroup_CountSpawned(squads) do
				local s = SGroup_GetSpawnedSquadAt(squads, j)
				local sbpID = BP_GetID(Squad_GetBlueprint(s))
				
				if AIControl_MainControl_Settings_HQControl.Blueprints[sbpID] then -- hq control
					if sbpID == BP_GetID(SBP.CW.HQ) or sbpID == BP_GetID(SBP.CW.HQ_REINFORCEMENT) then -- mobile HQ retreat position update
						local sPos = Squad_GetPosition(s)
						AIControl_MainControl.HQPositions[AIControl_Players[i]] = sPos
						EGroup_Single(eg_tmp, Squad_EntityAt(s, 0))
						Command_EntityPos(player, eg_tmp, CMD_RallyPoint, sPos)
					end
					local sectorID
					if Squad_HasUpgrade(s, UPG.CW.MOBILEHQ) then
						sectorID = World_GetTerritorySectorID(Squad_GetPosition(s))
						if AIControl_MainControl.TerritorySectors[sectorID] then
							AIControl_MainControl.TerritorySectors[sectorID].SetupHQCount[team] = AIControl_MainControl.TerritorySectors[sectorID].SetupHQCount[team] + 1
						end
					else
						local gameID = Squad_GetGameID(s)
						if AIControl_MainControl.HQTargets[team][gameID] then
							targets[team][gameID] = AIControl_MainControl.HQTargets[team][gameID]
							sectorID = AIControl_MainControl.HQTargets[team][gameID][1]
							if AIControl_MainControl.TerritorySectors[sectorID] then
								AIControl_MainControl.TerritorySectors[sectorID].SetupHQCount[team] = AIControl_MainControl.TerritorySectors[sectorID].SetupHQCount[team] + 1
							end
						end
					end
					if AI_IsAIPlayer(player) and AI_IsEnabled(player) then
						AI_LockSquad(player, s)
					end
					SGroup_Add(AIControl_MainControl.HQs[team], s)
				end
			end
			
			local entities = Player_GetEntities(player)
			for j=1,EGroup_CountSpawned(entities) do
				local e = EGroup_GetSpawnedEntityAt(entities, j)
				if Entity_IsBuilding(e) then
					local buildingProgress = Entity_GetBuildingProgress(e)
					if buildingProgress > 0 and buildingProgress < 1 then
						local pos = Entity_GetPosition(e)
						SGroup_Clear(sg_tmp)
						
						local hasConstructingSquad = false
						World_GetSquadsNearPoint(player, sg_tmp, pos, 15, OT_Player)
						for k=1,SGroup_CountSpawned(sg_tmp) do
							local s = SGroup_GetSpawnedSquadAt(sg_tmp, k)
							if Squad_HasActiveCommand(s) and Squad_GetActiveCommand(s) == SQUADSTATEID_Construction then
								hasConstructingSquad = true
								break
							end
						end
						if not hasConstructingSquad then
							EGroup_Single(eg_tmp, e)
							Command_Entity(player, eg_tmp, CMD_Destroy)
						end
					end
				end
			end
		end
		SGroup_Destroy(sg_tmp)
		EGroup_Destroy(eg_tmp)
		AIControl_MainControl.HQTargets = targets
	end,
	FindTerritorySectors = function()
		AIControl_MainControl.TerritorySectors = {}
		for i=0, World_GetNumEntities()-1 do
			local e = World_GetEntity(i)
			if Entity_IsStrategicPoint(e) and not Entity_IsVictoryPoint(e) then
				local sectorID = World_GetTerritorySectorID(Entity_GetPosition(e))
				local blueprint = Entity_GetBlueprint(e)
				local importance
				for j=1,#AIControl_MainControl_Settings_HQControl.StrategicPoints do
					if AIControl_MainControl_Settings_HQControl.StrategicPoints[j][1] == blueprint then
						importance = AIControl_MainControl_Settings_HQControl.StrategicPoints[j][2]
						break
					end
				end
				if not importance then importance = AIControl_MainControl_Settings_HQControl.UnrecognizedStrategicPointImportance end
				--print("SP :: ID="..sectorID.." BP="..BP_GetName(blueprint).." Importance="..importance)
				local gridCells, n = {}, 0
				for x=1,Dimensions[1] do
					for y=1,Dimensions[2] do
						if World_GetTerritorySectorID(AIControl_Grid.ControlPoints[x][y]) == sectorID then
							n = n + 1
							gridCells[n] = {x, y}
						end
					end
				end
				AIControl_MainControl.TerritorySectors[sectorID] = {
					SetupHQCount = {0, 0},
					AIMarkers = {},
					Importance = importance,
					Entity = e,
					GridCells = gridCells,
					BeingCaptured = false}
			end
		end
		for i=0,World_GetNumEntities()-1 do
			local e = World_GetEntity(i)
			local bp = Entity_GetBlueprint(e)
			if bp == EBP.STRAT_POINT.AI_LOW or bp == EBP.STRAT_POINT.AI_MEDIUM or bp == EBP.STRAT_POINT.AI_HIGH then
				local sectorID = World_GetTerritorySectorID(Entity_GetPosition(e))
				if sectorID and AIControl_MainControl.TerritorySectors[sectorID] then
					AIControl_MainControl.TerritorySectors[sectorID].AIMarkers[#AIControl_MainControl.TerritorySectors[sectorID].AIMarkers+1] = e
				end
			end
		end
	end,
}

--------------------------------------------------------------------------------------------------------------------

AIControl.__Init2 = function()
	AIControl_Grid.ResetData(true)
	AIControl_Grid.Update()
	AIControl_MainControl.Init()
	
	Rule_AddInterval(AIControl_Grid.Update, 0.25)
	--Rule_Add(AIControl.Grid.Update)
end
AIControl.__Init = function()
	if g_AIControl_Enable then
		wHalfWidth = World_GetWidth()*0.5
		wHalfHeight = World_GetLength()*0.5
		
		--dr_setdisplay("aicontrol_maincontrol", true)
		--dr_setautoclear("aicontrol_maincontrol", false)
		--dr_clear("aicontrol_maincontrol")
		--dr_setdisplay("aicontrol_hqcontrol", true)
		--dr_setautoclear("aicontrol_hqcontrol", false)
		--dr_clear("aicontrol_hqcontrol")
		--dr_setdisplay("aicontrol_grid", true)
		--dr_setautoclear("aicontrol_grid", false)
		--dr_clear("aicontrol_grid")
	
		AIControl_Grid = AIControl.Grid
		AIControl_Grid_Settings = AIControl_Grid.Settings
		Dimensions = AIControl_Grid.Dimensions
		
		AIControl_Grid_DataHistory = AIControl_Grid.DataHistory
		AIControl_Grid_t_DataHistory = AIControl_Grid.t_DataHistory
		
		AIControl_Grid_DataClump = AIControl_Grid.DataClump
		AIControl_Grid_DataClumpFOW = AIControl_Grid.DataClumpFOW
		
		AIControl_Grid_DataSquads = AIControl_Grid.DataSquads
		AIControl_Grid_t_DataSquads = AIControl_Grid.t_DataSquads
		AIControl_Grid_DataCounts = AIControl_Grid.DataCounts
		AIControl_Grid_t_DataCounts = AIControl_Grid.t_DataCounts
		AIControl_Grid_Data = AIControl_Grid.Data
		AIControl_Grid_t_Data = AIControl_Grid.t_Data
		AIControl_Grid_ArmorData = AIControl_Grid.ArmorData
		AIControl_Grid_t_ArmorData = AIControl_Grid.t_ArmorData
		AIControl_Grid_AveragePosData = AIControl_Grid.AveragePosData
		AIControl_Grid_t_AveragePosData = AIControl_Grid.t_AveragePosData
		
		AIControl_MainControl = AIControl.MainControl
		AIControl_MainControl_Settings = AIControl_MainControl.Settings
		AIControl_MainControl_Settings_UnitControl = AIControl_MainControl_Settings.UnitControl
		AIControl_MainControl_Settings_VehicleControl = AIControl_MainControl_Settings.VehicleControl
		AIControl_MainControl_Settings_BarrageControl = AIControl_MainControl_Settings.BarrageControl
		AIControl_MainControl_Settings_HQControl = AIControl_MainControl_Settings.HQControl
		AIControl_MainControl_Settings_CombatUnitControl = AIControl_MainControl_Settings.CombatUnitControl
		AIControl_MainControl_LockedSquads = AIControl_MainControl.LockedSquads
		
		AIControl_Grid.SetDimensions(AIControl_Grid_Settings.Init_Dimensions[1], AIControl_Grid_Settings.Init_Dimensions[2])
		AIControl_Grid.UpdateAIPlayers()
		AIControl_Grid.ReduceMarkerCount()
		--AIControl.Pathfinding.Init()
		
		Rule_AddOneShot(AIControl.__Init2, 0.125)
	end
end

AIControl_Init = function()
	Rule_Remove(AIControl.__Init)
	Rule_Remove(AIControl.__Init2)
	Rule_Remove(AIControl.Grid.Update)
	Rule_AddOneShot(AIControl.__Init, 1)
end

AIControl_Grid = AIControl.Grid
AIControl_Grid_Settings = AIControl_Grid.Settings
Dimensions = AIControl_Grid.Dimensions

AIControl_Grid_DataHistory = AIControl_Grid.DataHistory
AIControl_Grid_t_DataHistory = AIControl_Grid.t_DataHistory

AIControl_Grid_DataClump = AIControl_Grid.DataClump
AIControl_Grid_DataClumpFOW = AIControl_Grid.DataClumpFOW

AIControl_Grid_DataSquads = AIControl_Grid.DataSquads
AIControl_Grid_t_DataSquads = AIControl_Grid.t_DataSquads
AIControl_Grid_DataCounts = AIControl_Grid.DataCounts
AIControl_Grid_t_DataCounts = AIControl_Grid.t_DataCounts
AIControl_Grid_Data = AIControl_Grid.Data
AIControl_Grid_t_Data = AIControl_Grid.t_Data
AIControl_Grid_ArmorData = AIControl_Grid.ArmorData
AIControl_Grid_t_ArmorData = AIControl_Grid.t_ArmorData
AIControl_Grid_AveragePosData = AIControl_Grid.AveragePosData
AIControl_Grid_t_AveragePosData = AIControl_Grid.t_AveragePosData

AIControl_MainControl = AIControl.MainControl
AIControl_MainControl_Settings = AIControl_MainControl.Settings
AIControl_MainControl_Settings_UnitControl = AIControl_MainControl_Settings.UnitControl
AIControl_MainControl_Settings_VehicleControl = AIControl_MainControl_Settings.VehicleControl
AIControl_MainControl_Settings_BarrageControl = AIControl_MainControl_Settings.BarrageControl
AIControl_MainControl_Settings_HQControl = AIControl_MainControl_Settings.HQControl
AIControl_MainControl_Settings_CombatUnitControl = AIControl_MainControl_Settings.CombatUnitControl
AIControl_MainControl_LockedSquads = AIControl_MainControl.LockedSquads

Scar_AddInit(AIControl_Init)
