-- Targets

-- locals and table indexing optimization
local min = math.min
local max = math.max
local ceil = math.ceil
local sqrt = math.sqrt
local sort = table.sort

local k_maxDist = sqrt(World_GetWidth()*World_GetWidth() + World_GetLength()*World_GetLength())
local k_capPercentageCoefficient = 0.6-min(0.6, k_maxDist/700-0.3)
local k_longMapRatio = max(0, min(1, math.abs(World_GetWidth() - World_GetLength())/k_maxDist))
local k_frontlineCoefficient = 0.275 * (1 + k_longMapRatio*0.35)

-- should we consider targets owned by a certain mod player
function Target_ShouldDefendPlayer(player)
	local playerID = Player_GetID(player)
	if playerID == s_selfplayerid then return true end
	return false
end
function Target_ShouldAttackPlayer(player)
	local modplayer = Player_FromId(s_selfplayerid)
	local playerID = Player_GetID(player)
	
	-- if there is a target player, only target that player
	if military_targetPlayerID ~= PLAYER_INVALIDID then
		if playerID == military_targetPlayerID then
			return true
		else
			return false
		end
	end
	
	-- else target all enemies
	if Player_GetRelationship(modplayer, player) == R_ENEMY then return true end
	return false
end

--------------------------------------------------------------------------------
-- target priority

local capturePointMilitaryPoints = {}

local customCaptureModifiers = {
	[BP_GetName(EBP.STRAT_POINT.FUEL_HIGH)] = 1.25,
	[BP_GetName(EBP.STRAT_POINT.FUEL_MED)] = 1.25,
	[BP_GetName(EBP.STRAT_POINT.FUEL_LOW)] = 1.05,
	[BP_GetName(EBP.STRAT_POINT.MUN_HIGH)] = 1.22,
	[BP_GetName(EBP.STRAT_POINT.MUN_MED)] = 1.125,
}
local customDefendModifiers = {
	[BP_GetName(EBP.STRAT_POINT.FUEL_HIGH)] = 1.1,
	[BP_GetName(EBP.STRAT_POINT.FUEL_MED)] = 1.1,
	[BP_GetName(EBP.STRAT_POINT.MUN_HIGH)] = 1.1,
	[BP_GetName(EBP.STRAT_POINT.MUN_MED)] = 1.01,
	[BP_GetName(EBP.STRAT_POINT.AI_LOW)] = 1.0,
	[BP_GetName(EBP.STRAT_POINT.AI_MEDIUM)] = 1.05,
	[BP_GetName(EBP.STRAT_POINT.AI_HIGH)] = 1.15,
	[BP_GetName(SBP.CW.HQ)] = 1.15,
	[BP_GetName(SBP.CW.HQ_REINFORCEMENT)] = 1.15,
	[BP_GetName(SBP.CW.ARMOUR_HQ)] = 0.75,
	[BP_GetName(SBP.CW.INFANTRY_HQ)] = 0.75,
}
local customAttackModifiers = {
	[BP_GetName(EBP.STRAT_POINT.FUEL_HIGH)] = 1.3,
	[BP_GetName(EBP.STRAT_POINT.FUEL_MED)] = 1.27,
	[BP_GetName(EBP.STRAT_POINT.FUEL_LOW)] = 1.02,
	[BP_GetName(EBP.STRAT_POINT.MUN_HIGH)] = 1.2,
	[BP_GetName(EBP.STRAT_POINT.MUN_MED)] = 1.15,
	[BP_GetName(EBP.STRAT_POINT.AI_LOW)] = 0.5,
	[BP_GetName(EBP.STRAT_POINT.AI_MEDIUM)] = 1.01,
	[BP_GetName(EBP.STRAT_POINT.AI_HIGH)] = 1.24,
	[BP_GetName(SBP.CW.HQ)] = 0.75,
	[BP_GetName(SBP.CW.HQ_REINFORCEMENT)] = 0.75,
	[BP_GetName(SBP.CW.ARMOUR_HQ)] = 0.75,
	[BP_GetName(SBP.CW.INFANTRY_HQ)] = 0.75,
}

local militaryPointRandom = {}
local militaryPointRandomResetStep = 0

local hqDistCache = {}
local earlyGameTimeRule = 1
local frontlineMapConstant = 0
local baseMapConstant = -5.5

--------------------------------------------------------------------------------
-- target ranking

local defend_point_ranking = {}
local attack_point_ranking = {}
local attack_point_ranking_c = 0
local capture_point_ranking = {}

capture_points_available = 0

local firstPassDone = false

local militaryPercentValue = 1
local percentagePointsCaptured = 0
local closeToBaseThreshold = 0.55

local k_friendlyHQs = {}
local k_friendlyHQCount = 0
local k_enemyHQs = {}
local k_enemyHQCount = 0
local mapMid = World_Pos(0, 0, 0)
local midMapMultiplier = 0

local furthestPoint = 1
local closestEnemyPoint
local furthestFriendlyPoint
local frontlinePoints = {}
local frontlinePointCount = 0
local earlyGameScore = 0
local earlyGameFrontlineMultiplier = 0
local earlyGameThreatMultiplier = 0
function RankTargetsPrepass()
	local playerCount = World_GetPlayerCount()
	if not firstPassDone then
		firstPassDone = true
		
		dr_setautoclear("aicustomdebug3"..s_selfplayerid, false)
		dr_setdisplay("aicustomdebug3"..s_selfplayerid, true)
		
		local hqMid = World_Pos(0,0,0)
		local enemyHQMid = World_Pos(0,0,0)
		local friendlyHQMid = World_Pos(0,0,0)
		for i=1,playerCount do
			local p = World_GetPlayerAt(i)
			local pos = Player_GetStartingPosition(p)
			if Player_GetRelationship(s_self_modplayer, p) == R_ENEMY then
				k_enemyHQCount = k_enemyHQCount + 1
				k_enemyHQs[k_enemyHQCount] = pos
				enemyHQMid.x = enemyHQMid.x + pos.x
				enemyHQMid.z = enemyHQMid.z + pos.z
			else
				k_friendlyHQCount = k_friendlyHQCount + 1
				k_friendlyHQs[k_friendlyHQCount] = pos
				friendlyHQMid.x = friendlyHQMid.x + pos.x
				friendlyHQMid.z = friendlyHQMid.z + pos.z
			end
			hqMid.x = hqMid.x + pos.x
			hqMid.z = hqMid.z + pos.z
		end
		hqMid.x = hqMid.x/playerCount
		hqMid.z = hqMid.z/playerCount
		enemyHQMid.x = enemyHQMid.x/playerCount
		enemyHQMid.z = enemyHQMid.z/playerCount
		friendlyHQMid.x = friendlyHQMid.x/playerCount
		friendlyHQMid.z = friendlyHQMid.z/playerCount
		
		local distx = mapMid.x - hqMid.x
		local distz = mapMid.z - hqMid.z
		local midDist = sqrt(distx^2 + distz^2)/k_maxDist
		
		--CustomDebug.Print("midDist: "..midDist.."")
		if midDist < 0.15 then
			midMapMultiplier = 0
		else
			midMapMultiplier = min(6, 6*(midDist*2.5))
		end
		mapMid.x = max(-World_GetWidth()*0.5, min(World_GetWidth()*0.5, mapMid.x + distx*1.5))
		mapMid.z = max(-World_GetLength()*0.5, min(World_GetLength()*0.5, mapMid.z + distz*1.5))
		--logPrint("hqMid: ("..hqMid.x..", "..hqMid.z..")")
		--logPrint("mapMid: ("..mapMid.x..", "..mapMid.z..")")
		
		local hqMidDist = World_Pos(
			enemyHQMid.x-friendlyHQMid.x,
			0,
			enemyHQMid.z-friendlyHQMid.z
		)
		local hqMidDistRatio = sqrt(hqMidDist.x^2 + hqMidDist.z^2)/k_maxDist
		
		frontlineMapConstant = -3 - k_longMapRatio*1.5
		closeToBaseThreshold = 0.55 / (1 + midMapMultiplier*0.5)
		
		--CustomDebug.Print('k_longMapRatio: '..string.format('%.2f', k_longMapRatio))
		--CustomDebug.Print('k_frontlineCoefficient: '..string.format('%.2f', k_frontlineCoefficient))
		--CustomDebug.Print('frontlineMapConstant: '..string.format('%.2f', frontlineMapConstant))
		--CustomDebug.Print('closeToBaseThreshold: '..string.format('%.3f', closeToBaseThreshold))
	end
	
	frontlinePoints = {}
	frontlinePointCount = 0
	furthestPoint = -1
	closestEnemyPoint = nil
	furthestFriendlyPoint = Player_GetStartingPosition(Player_FromId(s_selfplayerid)) -- own hq position
	local closestEnemyPointDistRatio = 1
	local furthestFriendlyPointDistRatio = 0
	for i=1,playerCount do -- Get closest enemy and furthest friendly points
		local player = World_GetPlayerAt(i)
		-- for each military point
		local militaryPointCount = Military_GetMilitaryPointCount(s_selfplayer, player)
		for j=0,militaryPointCount-1 do
			local militaryPoint = Military_GetMilitaryPointAt(s_selfplayer, player, j)
			if Military_IsMilitaryPointValid(militaryPoint) then
				local entity = Military_GetMilitaryPointEntity(militaryPoint)
				local distRatio = Military_GetMilitaryPointDistanceToBase(s_selfplayer, militaryPoint)/k_maxDist
				-- we don't attack certain players
				if Target_ShouldAttackPlayer(player) then
					if midMapMultiplier == 0 then
						if Military_IsNextToSupply(s_selfplayer, militaryPoint) then
							frontlinePointCount = frontlinePointCount + 1
							frontlinePoints[frontlinePointCount] = Entity_GetPosition(entity)
						end
					else
						if is_friendly_entity(entity) then
							if not furthestFriendlyPointDistRatio or furthestFriendlyPointDistRatio < distRatio then
								furthestFriendlyPoint = Entity_GetPosition(entity)
								furthestFriendlyPointDistRatio = distRatio
							end
						else
							if not closestEnemyPointDistRatio or closestEnemyPointDistRatio > distRatio then
								closestEnemyPoint = Entity_GetPosition(entity)
								closestEnemyPointDistRatio = distRatio
							end
						end
					end
				end
				if furthestPoint < distRatio then
					furthestPoint = distRatio
				end
			end
		end
	end
	local neutralMilitaryPointCount = Military_GetNeutralMilitaryPointCount(s_selfplayer)
	for i=0,neutralMilitaryPointCount-1 do
		local militaryPoint = Military_GetNeutralMilitaryPointAt(s_selfplayer, i)
		if Military_IsMilitaryPointValid(militaryPoint) then
			local entity = Military_GetMilitaryPointEntity(militaryPoint)
			local distRatio = Military_GetMilitaryPointDistanceToBase(s_selfplayer, militaryPoint)/k_maxDist
			if midMapMultiplier == 0 then
				if Military_IsNextToSupply(s_selfplayer, militaryPoint) then
					frontlinePointCount = frontlinePointCount + 1
					frontlinePoints[frontlinePointCount] = Entity_GetPosition(entity)
				end
			end
			if Military_IsMilitaryPointBeingCapturedByEnemy(s_selfplayer, militaryPoint) then
				if not closestEnemyPointDistRatio or closestEnemyPointDistRatio > distRatio then
					closestEnemyPoint = Entity_GetPosition(entity)
					closestEnemyPointDistRatio = distRatio
				end
			--else
			--	if not furthestFriendlyPointDistRatio or furthestFriendlyPointDistRatio < distRatio then
			--		furthestFriendlyPointDistRatio = distRatio
			--	end
			end
			if furthestPoint < distRatio then
				furthestPoint = distRatio
			end
		end
	end
	if furthestPoint == -1 then furthestPoint = 1 end
	furthestPoint = 1
	
	if cache and cache.percentage_pts_captured then percentagePointsCaptured = cache.percentage_pts_captured end
	
	if World_GetGameTime() < 100 then
		if cache and cache.military_percent_value then militaryPercentValue = cache.military_percent_value end
		militaryPercentValue = max(0.7, min(1.55, militaryPercentValue+s_personality.threat_aggressiveness))
	else
		militaryPercentValue = 1.1
	end
	
	earlyGameTimeRule = max(0, 1 - min(1, World_GetGameTime()/260-0.35)) * min(1, 0.5 + k_longMapRatio*2)
	
	earlyGameScore = 7*earlyGameTimeRule + k_longMapRatio*earlyGameTimeRule*20
	earlyGameFrontlineMultiplier = (1 - earlyGameTimeRule) * min(1, (1+k_longMapRatio*2)*0.55+0.45)
	earlyGameThreatMultiplier = max(-1, min(1, (0.55 - earlyGameTimeRule)/0.45))
	
	militaryPointRandomResetStep = militaryPointRandomResetStep + 1
	if militaryPointRandomResetStep > 50 then
		militaryPointRandomResetStep = 0
		militaryPointRandom = {}
	end
	--CustomDebug.Clear()
	--CustomDebug.Print('k_frontlineCoefficient: '..k_frontlineCoefficient)
	--CustomDebug.Print('midMapMultiplier: '..midMapMultiplier)
end

function EnemyHQDistances(entityPos)
	local closestDistToEnemyHQ
	local totalDistToEnemyHQs = 0
	for i=1,k_enemyHQCount do
		local dist = World_DistancePointToPoint(entityPos, k_enemyHQs[i])
		if not closestDistToEnemyHQ or closestDistToEnemyHQ > dist then
			closestDistToEnemyHQ = dist
		end
		totalDistToEnemyHQs = totalDistToEnemyHQs + dist
	end
	local averageDistToEnemyHQs = totalDistToEnemyHQs / k_enemyHQCount
	return {averageDistToEnemyHQs, closestDistToEnemyHQ}
end
function RatePointsFromEnemyHQDistance(entityPos, enemyHQDistance) -- enemyHQDistance is used to avoid repeating calculations
	local result = 0
	if k_enemyHQCount ~= 0 then
		if not enemyHQDistance then enemyHQDistance = EnemyHQDistances(entityPos)[2] end
		local closestDistToEnemyHQ = enemyHQDistance
		
		local minRating = 8
		local minRatingRing1 = 80
		local minRatingRing2 = minRatingRing1 + 80*k_maxDist/400 + 30
		
		if closestDistToEnemyHQ < minRatingRing1 then
			result = result - minRating
		elseif closestDistToEnemyHQ < minRatingRing2 then
			result = result - min(minRating, minRating*( 1 - (closestDistToEnemyHQ-minRatingRing1)/(minRatingRing2-minRatingRing1) ))
		end
		closestDistToEnemyHQ = closestDistToEnemyHQ/k_maxDist/furthestPoint
		result = result - 10*(closestDistToEnemyHQ - 0.65)^2 + 3
	end
	return result
end

function Target_CalcMilitaryPointPriority(militaryPoint, is_neutral, is_defend, is_friendly)
	if is_defend == nil then is_defend = false end
	if is_neutral == nil then is_neutral = false end
	if is_friendly == nil then is_friendly = false end
	
	if not Military_IsMilitaryPointValid(militaryPoint) then return 0.0 end
	
	local result = 0
	
	local entity = Military_GetMilitaryPointEntity(militaryPoint)
	local entityID = Entity_GetGameID(entity)
	local entityPos = Entity_GetPosition(entity)
	
	local importance = Military_GetCombinedImportanceAtMilitaryPoint(s_selfplayer, militaryPoint) -- scale of 1 to 10ish
	if importance <= 0 then return 0 end
	
	--logPrint(" ")
	--logPrint(string.format("  [%s]: _________________________________________________________________________________", Military_GetMilitaryPointName(militaryPoint)))
	
	local maxImportance = Military_GetMaxCombinedImportanceAtMilitaryPoint(s_selfplayer)
	if maxImportance > 0 then importance = 2 * importance/maxImportance end
	
	local mapMidDistRatio = World_DistancePointToPoint(entityPos, mapMid)/k_maxDist/furthestPoint
	
	local enemyHQDistances = EnemyHQDistances(entityPos)
	
	local distFromAllHQs = 0
	local minDistFromAllHQs = k_maxDist
	local minDistFromFriendlyHQs = k_maxDist
	if hqDistCache[entityID] and hqDistCache[entityID][1] < 10 then
		hqDistCache[entityID][1] = hqDistCache[entityID][1] + 1
		minDistFromAllHQs = hqDistCache[entityID][2]
		distFromAllHQs = hqDistCache[entityID][3]
		minDistFromFriendlyHQs = hqDistCache[entityID][4]
	else
		for i=1,k_friendlyHQCount do
			local dist = World_DistancePointToPoint(entityPos, k_friendlyHQs[i])
			if minDistFromAllHQs > dist then
				minDistFromAllHQs = dist
			end
			if minDistFromFriendlyHQs > dist then
				minDistFromFriendlyHQs = dist
			end
			distFromAllHQs = distFromAllHQs + dist
		end
		for i=1,k_enemyHQCount do
			local dist = World_DistancePointToPoint(entityPos, k_enemyHQs[i])
			if minDistFromAllHQs > dist then
				minDistFromAllHQs = dist
			end
			distFromAllHQs = distFromAllHQs + dist
		end
		local hqCount = k_friendlyHQCount + k_enemyHQCount
		minDistFromAllHQs = minDistFromAllHQs / k_maxDist / furthestPoint
		distFromAllHQs = distFromAllHQs / hqCount / k_maxDist / furthestPoint
		hqDistCache[entityID] = {0, minDistFromAllHQs, distFromAllHQs, minDistFromFriendlyHQs}
	end
	
	--[[local distFromAllHQsCoefficient
	if distFromAllHQs < 0.35 then
		distFromAllHQsCoefficient = 4*(distFromAllHQs - 0.35)
	else
		distFromAllHQsCoefficient = 3*(distFromAllHQs - 0.35)
	end
	distFromAllHQsCoefficient = max(-0.1, distFromAllHQsCoefficient) * 12]]
	
	local distRatio = max(
		0.1,
		min(
			1,
			((minDistFromFriendlyHQs*1.1)/k_maxDist/furthestPoint - 0.22*(midMapMultiplier*0.2)) * (1 + midMapMultiplier*0.25) + (1 - k_longMapRatio*1.75)
		)*1.1 - 0.1
	)
	if is_defend then
		militaryPercentValue = min(1, militaryPercentValue) - 0.35
		enemyHQDistances[1] = enemyHQDistances[1]*0.8
		enemyHQDistances[2] = enemyHQDistances[2]*0.8
		result = result - 0.225
	end
	
	local frontlineDistRatio
	
	if midMapMultiplier == 0 and frontlinePointCount > 0 then
		local X = 0
		local Y = 0
		for i=1,frontlinePointCount do
			local v = frontlinePoints[i]
			X = X + v.x
			Y = Y + v.z
		end
		X = X / frontlinePointCount
		Y = Y / frontlinePointCount
		--(mapMid.x + furthestFriendlyPoint1.x + furthestFriendlyPoint2.x + closestEnemyPoint.x) / 4
		
		local m1 = 0
		local m2 = 0
		for i=1,frontlinePointCount do
			local v = frontlinePoints[i]
			m1 = m1 + (v.x - X) * (v.z - Y)
			m2 = m2 + (v.x - X)^2
		end
		local m = m1 / m2
		
		--[[( (mapMid.x - X) * (mapMid.z - Y) + (furthestFriendlyPoint1.x - X) * (furthestFriendlyPoint1.z - Y) + (furthestFriendlyPoint2.x - X) * (furthestFriendlyPoint2.z - Y) + (closestEnemyPoint.x - X) * (closestEnemyPoint.z - Y) )
			/ ( (mapMid.x - X) ^ 2 + (furthestFriendlyPoint1.x - X) ^ 2 + (furthestFriendlyPoint2.x - X) ^ 2 + (closestEnemyPoint.x - X) ^ 2 )]]
		
		local yintercept = Y - m * X
		-- frontline: m * x + yintercept
		
		local p1 = World_Pos(0, 0, yintercept)
		local p2 = World_Pos(1, 0, m + yintercept)
		
		frontlineDistRatio = min(1,
			math.abs( (p1.x-p2.x)*(p2.z-entityPos.z)-(p1.x-entityPos.x)*(p1.z-p2.z) )
				/ (sqrt((p1.x-p2.x)^2+(p2.z-p1.z)^2)*k_maxDist/furthestPoint)
				+ earlyGameTimeRule
		)
	else
		local secondFrontlinePoint = World_Pos((closestEnemyPoint.x + mapMid.x)*0.5, (closestEnemyPoint.z + mapMid.z)*0.5, 0)
		frontlineDistRatio = min(1,
			math.abs( (furthestFriendlyPoint.x-secondFrontlinePoint.x)*(furthestFriendlyPoint.z-entityPos.z)-(furthestFriendlyPoint.x-entityPos.x)*(furthestFriendlyPoint.z-secondFrontlinePoint.z) )
				/ (sqrt((furthestFriendlyPoint.x-secondFrontlinePoint.x)^2+(furthestFriendlyPoint.z-secondFrontlinePoint.z)^2)*k_maxDist/furthestPoint)
				+ earlyGameTimeRule
		)
	end
	
	if is_friendly then
		result = result - 1 - min(1, 1.1-militaryPercentValue)
	end
	
	local threat = Military_GetCombinedThreatAtMilitaryPoint(s_selfplayer, militaryPoint, is_defend) -- pass in true to get history anti-class added to this threat
	local threatScore = 0
	local threatAtBaseScore = 0
	if threat < 0 then
		--local maxFriendlyThreat = max(5, min(100, -Military_GetMinCombinedThreatAtMilitaryPoint(s_selfplayer)))
		--threatScore = 6.75*threat/maxFriendlyThreat -- attempt to unblob and spread out units by reducing priority for points that already have friendlies nearby
		--logPrint(string.format("  negative threat score: %.2f", threatScore))
	elseif threat >= 0 then
		local maxThreat = max(5, min(130, Military_GetMaxCombinedThreatAtMilitaryPoint(s_selfplayer)))
		if is_defend then
			threatScore = -10*threat/maxThreat
		else
			threatScore = 0.5*threat/maxThreat - min(0.5, max(-1, 2*(1-militaryPercentValue)*threat/maxThreat))
			if minDistFromFriendlyHQs / k_maxDist / furthestPoint < closeToBaseThreshold then -- we have to respond to threats near the HQ
				threatAtBaseScore = 23 * threat/maxThreat * (closeToBaseThreshold-minDistFromFriendlyHQs / k_maxDist / furthestPoint)/closeToBaseThreshold
			end
		end
	end
	
	local threatMultiplier = (enemyHQDistances[2]/k_maxDist/furthestPoint - 0.5)*(1.05 - max(0.75, min(1.75, (militaryPercentValue-1)*0.5+1))) + 0.5
	
	--if Military_IsMilitaryPointBeingCapturedByUs(s_selfplayer, militaryPoint) then importance = importance * min(1.5, max(1, World_GetGameTime()/700)) end
	if is_friendly_entity(entity) then
		importance = importance*max(0.1, distRatio-0.4)*2.2
		if Military_IsMilitaryPointBeingCapturedByEnemy(s_selfplayer, militaryPoint) then importance = importance*15 end
	elseif Military_IsNextToSupply(s_selfplayer, militaryPoint) then
		--importance = importance*(0.55-distRatio)*2
		if Military_IsMilitaryPointBeingCapturedByEnemy(s_selfplayer, militaryPoint) then importance = importance*10 end
	--elseif is_enemy_entity(entity) then
		--distScore = distScore + 7 - distRatio*7
	end
	
	-- if we want to capture this point, but it's secured by the enemy or it's under threat,
	-- increase its priority by the capture priority
	local captureScore = 0
	--if Military_MilitaryPointIsSecuredPoint(militaryPoint) then
		captureScore = Military_GetMilitaryPointCapturePriority(s_selfplayer, militaryPoint)
		if captureScore > 0 then
			local maxcapture = AIResource_GetMaxCapturePointPriority(s_selfplayer)
			if maxcapture > 0 then
				captureScore = captureScore/maxcapture
			end
		end
	--end
	
	local customMultiplier
	if is_defend then
		customMultiplier = customDefendModifiers[ Military_GetMilitaryPointName(militaryPoint) ]
	else
		customMultiplier = customAttackModifiers[ Military_GetMilitaryPointName(militaryPoint) ]
	end
	if not customMultiplier then customMultiplier = 1 end
	
	local frontlineScore =
		frontlineMapConstant
		+ earlyGameScore
		+ 5*(0.55 - distRatio)*(1 - militaryPercentValue/0.95)
		+ 25*max(-0.5, min(0.5, militaryPercentValue + percentagePointsCaptured - 1.35)*percentagePointsCaptured)*(0.65 - enemyHQDistances[2]/k_maxDist/furthestPoint)
		+ 2 * min(1, mapMidDistRatio-0.4)*(midMapMultiplier*3-6)
		+ 15 * (1 - min(1, frontlineDistRatio / k_frontlineCoefficient)) / (midMapMultiplier*(1/3) + 1) * earlyGameFrontlineMultiplier
		+ 15 * (0.55 - 1.25 * enemyHQDistances[2]/k_maxDist/furthestPoint) * percentagePointsCaptured
		+ RatePointsFromEnemyHQDistance(entityPos, enemyHQDistances[2]) * (1 - percentagePointsCaptured/1.5) / (midMapMultiplier*(1/3) + 1)
		+ captureScore
		+ importance
		+ threatScore*earlyGameThreatMultiplier
		+ (minDistFromAllHQs-0.25)*7*(1+midMapMultiplier*0.2)*max(-0.5, 3-k_longMapRatio*2.5)
		+ 35*min(0, minDistFromAllHQs - 0.285 / (1 + midMapMultiplier*0.2 + (1 - k_longMapRatio*0.4) * 2))
		--+ (Military_GetMilitaryPointDiceRoll(s_selfplayer, militaryPoint)*20 - 10) -- this is quite bugged, screws up early game and works wrong in lategame
	
	result = result
		+ baseMapConstant
		+ threatAtBaseScore
		+ 0.25*earlyGameTimeRule
		+ frontlineScore
			* max(0, (distRatio + (1-distRatio)*(0.45 - 1.325*earlyGameTimeRule)))
			--* (mapMidDistRatio + (1-mapMidDistRatio)*0.5)
			* (threatMultiplier + (1-threatMultiplier)*0.35)
			* sqrt(minDistFromAllHQs/min(1, 0.5+(k_longMapRatio-0.5)*0.5)+0.2)
			* max(0.2, min(1, distFromAllHQs/min(1, 0.5+(k_longMapRatio-0.5)*0.5)))
			* customMultiplier
	
	if not militaryPointRandom[entityID] then
		militaryPointRandom[entityID] = AI_RandMax(10) - 5
	end
	
	result = result + militaryPointRandom[entityID]
	
	return min(10, max(0, result*3))
end

function Target_CalcDefendPriority(militaryPoint, is_neutral)
	return Target_CalcMilitaryPointPriority(militaryPoint, is_neutral, true)
end
function RankDefendTargets()
	Military_ClearTargets(s_selfplayer, MTARGET_Defend)
	defend_point_ranking = {}
	
	-- for each player
	local targetCount = 0
	local playerCount = World_GetPlayerCount()
	for i=1,playerCount do
		local player = World_GetPlayerAt(i)
		-- don't defend certain players
		if Target_ShouldDefendPlayer(player) then
			-- for each military point
			local militaryPoint_count = Military_GetMilitaryPointCount(s_selfplayer, player)
			for j=0,militaryPoint_count-1 do
				local militaryPoint = Military_GetMilitaryPointAt(s_selfplayer, player, j)
				local priority = Target_CalcDefendPriority(militaryPoint, false)
				if priority > 0.0 then
					-- cache the priority
					local e = {
						Point = militaryPoint,
						PriorityValue = priority,
						Neutral = false,
					}
					table.insert(defend_point_ranking, e)
					Military_AddTarget(s_selfplayer, MTARGET_Defend, militaryPoint, 1+priority*2)
					targetCount = targetCount + 1
					if targetCount >= 6 then
						break
					end
				end
			end
		end
	end
	
	-- for each neutral military point
	--[[if s_components[COMPONENT_ForwardDefending] == true and World_GetGameTime() < 450 then
		local militaryPoint_count = Military_GetNeutralMilitaryPointCount(s_selfplayer)
		for i=0, militaryPoint_count-1 do
			local militaryPoint = Military_GetNeutralMilitaryPointAt(s_selfplayer, i)
			local priority = Target_CalcDefendPriority(militaryPoint, true)
			if priority > 0.0 then
				-- cache the priority
				local e = {
					Point = militaryPoint,
					PriorityValue = priority,
					Neutral = true
				}
				table.insert(defend_point_ranking, e)
				Military_AddTarget(s_selfplayer, MTARGET_Defend, militaryPoint, 1+priority*2)
			end
		end
	end]]
	
	Military_SortAndCapTargets(s_selfplayer, MTARGET_Defend)
	
	-- debug
	--[[CustomDebug.Clear()
	sort(defend_point_ranking, function(a,b) return a.PriorityValue > b.PriorityValue end)
	if table.getn(defend_point_ranking) > 0 then
		for idx,entry in pairs(defend_point_ranking) do
			if entry.PriorityValue > 0 then
				local neutral = "N"
				if entry.Neutral == false then neutral = "" end
				CustomDebug.Print(string.format("%d. (%3.1f) %s[%s]", idx, entry.PriorityValue, neutral, Military_GetMilitaryPointName(entry.Point)))
			end

			-- only show top ones
			if idx >= 20 then break end
		end
	end]]
	
	--[[if s_selfplayerid-999 == 2 then
		dr_clear("aicustomdebug2"..s_selfplayerid)
		
		local wWidth = World_GetWidth()
		local wHeight = World_GetLength()
		local wHalfWidth = wWidth*0.5
		local wHalfHeight = wHeight*0.5
		
		for idx,entry in pairs(defend_point_ranking) do
			if entry and entry.Point then
				if Military_IsMilitaryPointValid(entry.Point) then
					local entity = Military_GetMilitaryPointEntity(entry.Point)
					if entity then
						local entityPos = Entity_GetPosition(entity)
						if entityPos and entityPos.x and entityPos.z then
							local color
							if entry.PriorityValue == 0 then
								color = 0
							else
								color = min(255, max(0, ceil(255 * entry.PriorityValue*(1/3) * 1.5)+120))
							end
							
							dr_text2d("aicustomdebug2"..s_selfplayerid,
								0.005 + 0.8*     (entityPos.x+wHalfWidth ) / (wWidth +1)  * max(0.333, 1-min(1, wHeight/wWidth)),
								0.005 + 0.8*(1 - (entityPos.z+wHalfHeight) / (wHeight+1)) * max(0.333, 1-min(1, wWidth/wHeight)),
								string.format("%.0f", entry.PriorityValue),
								15+ceil(color*(1/3)), color, 15+ceil(color*(1/3)))
						end
					end
				end
			end
		end
	end]]
end

function Target_CalcAttackPriority(militaryPoint, is_neutral, is_friendly)
	return Target_CalcMilitaryPointPriority(militaryPoint, is_neutral, false, is_friendly)
end
function RankAttackTargets()
	Military_ClearTargets(s_selfplayer, MTARGET_Attack)
	attack_point_ranking = {}
	
	--[[logPrint(" ")
	logPrint("--------------------------------------------------------------------------------------------")
	logPrint("--------------------------------------------------------------------------------------------")
	logPrint("--------------------------------------------------------------------------------------------")
	logPrint("Ranking attack targets")]]
	
	local targetCount = 0
	local neutralMilitaryPointCount = Military_GetNeutralMilitaryPointCount(s_selfplayer)
	for i=0,neutralMilitaryPointCount-1 do
		local militaryPoint = Military_GetNeutralMilitaryPointAt(s_selfplayer, i)
		local priority = Target_CalcAttackPriority(militaryPoint, true, false)
		-- cache the priority
		local e = {
			Point = militaryPoint,
			PriorityValue = priority,
			Neutral = true,
		}
		attack_point_ranking_c = attack_point_ranking_c + 1
		attack_point_ranking[attack_point_ranking_c] = e
		if priority > 0 then
			Military_AddTarget(s_selfplayer, MTARGET_Attack, militaryPoint, 1+priority*2)
			targetCount = targetCount + 1
			if targetCount >= 7 then
				break
			end
		end
	end
	for i=1,World_GetPlayerCount() do
		local player = World_GetPlayerAt(i)
		-- don't attack certain players
		if Target_ShouldAttackPlayer(player) or Target_ShouldDefendPlayer(player) then
			-- for each military point
			local militaryPointCount = Military_GetMilitaryPointCount(s_selfplayer, player)
			for j=0,militaryPointCount-1 do
				local militaryPoint = Military_GetMilitaryPointAt(s_selfplayer, player, j)
				local priority = Target_CalcAttackPriority(militaryPoint, false, true)
				-- cache the priority
				local e = {	
					Point = militaryPoint,
					PriorityValue = priority,
					Neutral = false,
				}
				attack_point_ranking_c = attack_point_ranking_c + 1
				attack_point_ranking[attack_point_ranking_c] = e
				if priority > 0 then
					Military_AddTarget(s_selfplayer, MTARGET_Attack, militaryPoint, 1+priority*2)
					targetCount = targetCount + 1
					if targetCount >= 15 then
						break
					end
				end
			end
		end
	end
	
	Military_SortAndCapTargets(s_selfplayer, MTARGET_Attack)
	
	--debug
	
	--[[CustomDebug.Clear()
	sort(attack_point_ranking, function(a,b) return a.PriorityValue > b.PriorityValue end)
	if table.getn(attack_point_ranking) > 0 then
		for idx,entry in pairs(attack_point_ranking) do
			if entry.PriorityValue > 0 then
				local neutral = "N"
				if entry.Neutral == false then neutral = "" end
				CustomDebug.Print(string.format("%d. (%3.1f) %s[%s]", idx, entry.PriorityValue, neutral, Military_GetMilitaryPointName(entry.Point)))
			end

			-- only show top ones
			if idx >= 20 then break end
		end
	end]]
	
	--[[if s_selfplayerid-999 == 2 then
		dr_clear("aicustomdebug2"..s_selfplayerid)
		
		local wWidth = World_GetWidth()
		local wHeight = World_GetLength()
		local wHalfWidth = wWidth*0.5
		local wHalfHeight = wHeight*0.5
		
		for idx,entry in pairs(attack_point_ranking) do
			if entry and entry.Point and Military_IsMilitaryPointValid(entry.Point) then
				local entity = Military_GetMilitaryPointEntity(entry.Point)
				if entity then
					local entityPos = Entity_GetPosition(entity)
					if entityPos and entityPos.x and entityPos.z then
						local color
						if entry.PriorityValue == 0 then
							color = 0
						else
							color = min(255, max(0, ceil(255 * entry.PriorityValue/2 * 1.5)+120))
						end
						
						dr_text2d("aicustomdebug2"..s_selfplayerid,
							0.005 + 0.8*     (entityPos.x+wHalfWidth ) / (wWidth +1)  * max(0.333, 1-min(1, wHeight/wWidth)),
							0.005 + 0.8*(1 - (entityPos.z+wHalfHeight) / (wHeight+1)) * max(0.333, 1-min(1, wWidth/wHeight)),
							string.format("%.0f", entry.PriorityValue),
							color, 15+ceil(color*(1/3)), 15+ceil(color*(1/3)))
					end
				end
			end
		end
	end]]
end

function Target_CalcCapturePriority(capturePoint, vp_mult, fuel_mult, mt_mult)
	if not Capture_IsCapturePointValid(capturePoint) then return 0,0 end
	
	local capturePointType = Capture_GetCapturePointType(capturePoint)
	local capturePointID = AIResource_GetCapturePointID(s_selfplayer, capturePoint)
	
	--------------------------------------------------------------------------------
	-- score for type
	local typeScore = 0
	if capturePointType == CPT_FuelPoint then
		typeScore = typeScore + targetChoice_fuelPoint*fuel_mult
	elseif capturePointType == CPT_MunitionPoint then
		typeScore = typeScore + targetChoice_munitionPoint*mt_mult
	elseif capturePointType == CPT_NullPoint then
		typeScore = typeScore + targetChoice_nullPoint
	elseif capturePointType == CPT_VictoryPoint then
		typeScore = typeScore + targetChoice_victoryPoint*vp_mult
	end
	
	-- if we didn't get any type scoring, quit
	if typeScore <= 0.0 then return 0, 0 end
	
	-- if the victory point override percentage has been set
	if targetChoice_victoryPointPercentageOverride > 0.0 then
		local vpPercentage = Capture_GetVictoryPointPercentage(s_selfplayer)
	
		-- if this isn't a victory point, and we only want victory points
		if capturePointType ~= CPT_VictoryPoint and vpPercentage == 1.0 then return 0,0 end
		
		-- if this is a victory point and we already have enough
		if capturePointType == CPT_VictoryPoint and vpPercentage >= targetChoice_victoryPointPercentageOverride then return 0,0 end
	end
	
	local connectionScore = -1
	if Capture_IsNextToOutOfSupply(s_selfplayer, capturePoint) then connectionScore = connectionScore + 6 end
	if Capture_IsNextToSupply(s_selfplayer, capturePoint, true) then connectionScore = connectionScore + 1.25 end
	
	local entity = Entity_FromWorldID(capturePointID)
	
	--------------------------------------------------------------------------------
	-- score for distance
	
	local dist = Capture_GetCapturePointDistanceToBase(s_selfplayer, capturePoint)
	
	local distScore = 1 + max(0, dist/k_maxDist/furthestPoint * 2)
	local distMultiplier = 1
	
	-- Take enemy Bases into consideration (make AI setup proper frontline rather than only attacking in a circle around its HQ
	local entityPos = Entity_GetPosition(entity)
	distScore = distScore--[[ + RatePointsFromEnemyHQDistance(entityPos)/3.5]] + max(0, 2.5 - World_GetGameTime()/150) - 5.25
	
	--distMultiplier = distMultiplier + (1 - distMultiplier)*k_capPercentageCoefficient
	local priority = distMultiplier * (typeScore*0.5 + distScore) + 0.15
	
	if cache and cache.percentage_pts_captured and cache.percentage_pts_captured > 0.4 then
		distScore = distScore * min(1, max(0.35, 1.45-1.225*min(0.9, cache.percentage_pts_captured)))
	end
	
	--------------------------------------------------------------------------------
	-- Get military point and threat
	
	--if Capture_CapturingTeam(s_selfplayer, capturePoint) == s_self_team then priority =  priority + 2 end
	
	--CustomDebug.Print(string.format("[%s]---", AIResource_GetCapturePointName(capturePoint)))
	
	local threat = 0
	local maxThreat = 1
	if capturePointMilitaryPoints[capturePointID] then
		threat = Military_GetCombinedThreatAtMilitaryPoint(s_selfplayer, capturePointMilitaryPoints[capturePointID], true) + 0.225
		if threat < 0 then
			threat = 0
		end
		--if threat < 2 then
		--	threat = (threat-2) * 0.05
		--	maxThreat = max(5, min(40, -Military_GetMinCombinedThreatAtMilitaryPoint(s_selfplayer)))
			--CustomDebug.Print(string.format("  Negative threat: %.2f maxThreat: %.2f", threat, maxThreat))
		--else
			maxThreat = 1 -- max(5, min(40, Military_GetMaxCombinedThreatAtMilitaryPoint(s_selfplayer)))
			--CustomDebug.Print(string.format("  Positive threat: %.2f maxThreat: %.2f", threat, maxThreat))
		--end
	end
	local priorityWithThreat = priority - threat/maxThreat*30
	
	--CustomDebug.Print(string.format("  %2.1f threat: %2.2f  priority+threat: %2.2f", priority, threat, priorityWithThreat))
	
	if Capture_AlreadyCapturedByUs(s_selfplayer, capturePoint) or Capture_BeingCapturedByTeammate(s_selfplayer, capturePoint) then
		return 0, max(0, priority - threat/maxThreat*(1/3))
	end
	
	if priorityWithThreat <= 0 then -- don't want to capture points that are dangerous
		--CustomDebug.Print("  IGNORED")
		return 0, max(0, priority - threat/maxThreat*0.5)
	else
		local customMultiplier = customCaptureModifiers[AIResource_GetCapturePointName(capturePoint)]
		if customMultiplier then priorityWithThreat = priorityWithThreat * customMultiplier end
		
		--------------------------------------------------------------------------------
		-- final score
		
		-- if we aren't looking for enemy territory, don't consider resource points (non-VP points) that aren't in supply
		--[[if capturePointType ~= CPT_VictoryPoint and not Capture_IsNextToSupply(s_selfplayer, capturePoint, true) then
			-- want to consider this point as a neighbour so return non-zero for neighbour priority value
			local result = priority*0.75 - threat/maxThreat*20
			return max(0, result), priority
		end]]
		
		--CustomDebug.Print(string.format("  Final result: %2.2f", priorityWithThreat + connectionScore))
		return priorityWithThreat + connectionScore, priorityWithThreat
	end
end
function RankCapturePoints(vp_mult, vp_max, fuel_mult, mt_mult)
	AIResource_ClearCapturePointPriorities(s_selfplayer)
	
	local neighbour_mult = 0.2
	-- for each capture point
	local capturePointCount = AIResource_GetCapturePointsTotal(s_selfplayer)
	
	-- priority cache
	capture_point_ranking = {}
	capture_points_available = 0
	capturePointMilitaryPoints = {}
	
	-- calculate priorities for points
	for i=0,capturePointCount-1 do
		local capturePoint = AIResource_GetCapturePointAt(s_selfplayer, i)
		local capturePointID = AIResource_GetCapturePointID(s_selfplayer, capturePoint)
		
		-- getting military point
		local entity = Entity_FromWorldID(capturePointID)
		local playerCount = World_GetPlayerCount()
		for i=1,playerCount do
			local player = World_GetPlayerAt(i)
			local militaryPointCount = Military_GetMilitaryPointCount(s_selfplayer, player)
			for j=0,militaryPointCount-1 do
				local curMilitaryPoint = Military_GetMilitaryPointAt(s_selfplayer, player, j)
				if Military_IsMilitaryPointValid(curMilitaryPoint) then
					local militaryPointEntity = Military_GetMilitaryPointEntity(curMilitaryPoint)
					if militaryPointEntity == entity then
						capturePointMilitaryPoints[capturePointID] = curMilitaryPoint
						break
					end
				end
			end
		end
		if not capturePointMilitaryPoints[capturePointID] then
			local militaryPointCount = Military_GetNeutralMilitaryPointCount(s_selfplayer)
			for i=0,militaryPointCount-1 do
				local curMilitaryPoint = Military_GetNeutralMilitaryPointAt(s_selfplayer, i)
				if Military_IsMilitaryPointValid(curMilitaryPoint) then
					local militaryPointEntity = Military_GetMilitaryPointEntity(curMilitaryPoint)
					if militaryPointEntity == entity then
						capturePointMilitaryPoints[capturePointID] = curMilitaryPoint
						break
					end
				end
			end
		end
		
		--capture_point_ranking.trace(string.format("[%s] [%s]", capturePointID, AIResource_GetCapturePointName(capturePoint)))
		
		-- calc priority
		local priority, neighbour_priority = Target_CalcCapturePriority(capturePoint, vp_mult, fuel_mult, mt_mult)
		-- this is here to degrade the vp demand as its applied
		if priority > 0 then
			if vp_max and vp_max > 0 then
				if Capture_GetCapturePointType(capturePoint) == CPT_VictoryPoint then
					vp_max = vp_max - 1
					if vp_max <= 0 then
						vp_mult = 1.0
					end
				end
			end
			capture_points_available = capture_points_available + 1
		end
		
		-- cache the priority for use in the 2nd pass
		local e = {
			Point = capturePoint,
			PointID = capturePointID,
			PriorityValue = priority,
			NeighbourValue = neighbour_priority,
			NeighbourScore = 0
		}
		table.insert(capture_point_ranking, e)
	end
	
	-- second pass, add neighbour bonus and set priority
	for idx, entry in pairs(capture_point_ranking) do
		-- only do neighbour logic for chosen points ('chosen' if priority > 0)
		if entry.PriorityValue > 0.0 then
			-- add up neighbour values to make the neighbour score
			local neighbourCount = AIResource_GetNeighbourPointCount(s_selfplayer, entry.Point)
			for i=0, neighbourCount-1 do
				local neighbourPoint = AIResource_GetNeighbourPointAt(s_selfplayer, entry.Point, i)
				local neighbourPointID = AIResource_GetCapturePointID(s_selfplayer, neighbourPoint)
				if neighbourPoint ~= nil then
					for idx2, entry2 in pairs(capture_point_ranking) do
						if entry2.PointID == neighbourPointID then
							entry.NeighbourScore = entry.NeighbourScore + entry2.NeighbourValue
							break
						end
					end
				end
			end
			
			-- apply a percentage
			entry.NeighbourScore = entry.NeighbourScore * neighbour_mult / neighbourCount
		
			-- set the priority
			AIResource_SetCapturePointPriority(s_selfplayer, entry.Point, entry.PriorityValue + entry.NeighbourScore)
		end
	end
	
	-- debug
	--[[CustomDebug.Clear()
	sort(capture_point_ranking, function(a,b) return a.PriorityValue > b.PriorityValue end)
	if table.getn(capture_point_ranking) > 0 then
		for idx,entry in pairs(capture_point_ranking) do
			if entry.PriorityValue > 0 then
				CustomDebug.Print(string.format("%d. %2.1f+%2.1f=%2.1f [%s]", idx, entry.PriorityValue, entry.NeighbourScore, entry.PriorityValue+entry.NeighbourScore, AIResource_GetCapturePointName(entry.Point)))
			end

			-- only show top ones
			if idx > 15 then break end
		end
	end]]
	
	--[[if s_selfplayerid-999 == 2 then
		dr_clear("aicustomdebug2"..s_selfplayerid)
		
		local wWidth = World_GetWidth()
		local wHeight = World_GetLength()
		local wHalfWidth = wWidth*0.5
		local wHalfHeight = wHeight*0.5
		
		for idx,entry in pairs(capture_point_ranking) do
			if entry and entry.Point then
				local capturePointID = AIResource_GetCapturePointID(s_selfplayer, entry.Point)
				local entity = Entity_FromWorldID(capturePointID)
				if entity then
					local entityPos = Entity_GetPosition(entity)
					if entityPos and entityPos.x and entityPos.z then
						local color
						if entry.PriorityValue == 0 then
							color = 0
						else
							color = min(255, max(0, ceil(255 * entry.PriorityValue*0.5 * 1.5)+120))
						end
						
						dr_text2d("aicustomdebug2"..s_selfplayerid,
							0.005 + 0.8*     (entityPos.x+wHalfWidth ) / (wWidth +1)  * max(0.333, 1-min(1, wHeight/wWidth)),
							0.005 + 0.8*(1 - (entityPos.z+wHalfHeight) / (wHeight+1)) * max(0.333, 1-min(1, wWidth/wHeight)),
							string.format("%.0f", entry.PriorityValue),
							15+ceil(color*(1/3)), color, 15+ceil(color*(1/3)))
					end
				end
			end
		end
	end]]
end
