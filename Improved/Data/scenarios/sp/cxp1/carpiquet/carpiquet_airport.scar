-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Mission Name

-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")



-------------------------------------------------------------------------

-- [[ SETUP ]]

-------------------------------------------------------------------------

function OnGameSetup()
	-- string numbers should reference dat files
	
	player1 = Setup_Player(1, 1309050, "allies_commonwealth", 1)
	player2 = Setup_Player(2, 1309051, "axis", 2) -- "base/static defense" axis player
	player3 = Setup_Player(3, 1309050, "allies_commonwealth", 1) -- 
	player4 = Setup_Player(4, 1309051, "axis", 2) -- "counterattack" axis player
	
	Setup_SetPlayerTeam(player3, TEAM_NEUTRAL)
	
end

function OnGameRestore()
	player1 = World_GetPlayerAt(1)
	player2 = World_GetPlayerAt(2)
	player3 = World_GetPlayerAt(3)
	player4 = World_GetPlayerAt(4)
	-- function takes care of restoring all global mission parameters after a save/load
	Game_DefaultGameRestore()
	
end




-------------------------------------------------------------------------

-- [[ ONINIT ]]

-------------------------------------------------------------------------

function OnInit()
	g_MissionSpeechPath="Caen\\sp2\\Mission3"	
	
	g_AIControl_Enable = false
	g_AIControl_Pause = true
	
	-- a constant that stores the mission number for use with
	-- setting the global speech paths, tech tree setup, and 
	-- the player's starting resources
	MISSION_NUMBER = 0103
	
	--[[ PRESET GAME STATE ]]
	Setup_MissionPreset(MISSION_NUMBER)
	
	--[[ PRESET GAME STATE ]]
	AutoCinematic(true, 0)
	
	--[[ REGISTER OBJECTIVES ]]
	Carpiquet_Airport_ObjectiveRegister()
	
	--[[ MOD INITIAL STATS ]]
	Carpiquet_Airport_ModifyStats()
	
	--[[ SET RESTRICTIONS ]]
	Carpiquet_Airport_Restrictions()
	
	--[[ SET DIFFICULTY ]]
	Carpiquet_Airport_Difficulty()
	
	--[[ MISSION PRESETS ]]
	Carpiquet_Airport_MissionPreset()
	
	--[[ DEBUG KEYS ]]
	Carpiquet_Debug()
	
	Modify_PlayerSightRadius(player2, 0.5)
	Modify_PlayerSightRadius(player4, 0.5)
	
	--[[ GAME START CHECK ]]
	Rule_Add(Carpiquet_Airport_MissionStart)

end

Scar_AddInit(OnInit)


function Carpiquet_Debug()

	Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS01)')]])")
	Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS02)')]])")

end


function Carpiquet_Airport_ObjectiveRegister()

	--[[ *** MUST INITIALIZE THE OBJ TABLE BEFORE REGISTERING *** ]]
	Initialize_OBJ_Commando_Action()
	Initialize_OBJ_Capture_Points()
	Initialize_OBJ_Capture_Carpiquet()
	Initialize_OBJ_Medal_Action()
	Initialize_OBJ_Tetrarch()
	
	--[[ Registering Objectives ]]
	
	OBJ_Commando_Action.ID = Objective_Register(OBJ_Commando_Action)
	OBJ_Capture_Points.ID = Objective_Register(OBJ_Capture_Points)
	OBJ_Capture_Carpiquet.ID = Objective_Register(OBJ_Capture_Carpiquet)
	OBJ_Medal_Action.ID = Objective_Register(OBJ_Medal_Action)
	OBJ_Tetrarch.ID = Objective_Register(OBJ_Tetrarch)
end


function Carpiquet_Airport_ModifyStats()
	
	--[[ saved as example - deg
	Player_SetDefaultSquadMoodMode(player1, MM_Auto)
	Player_SetDefaultSquadMoodMode(player2, MM_Auto)
	Player_SetDefaultSquadMoodMode(player3, MM_ForceTense)
	
	-- shorten vision ranges
	Modify_PlayerSightRadius(player1, 0.75)

	-- mod resource rates
	player1resourcemodifiers = {}
	player1resourcemodifiers[1] = Modify_PlayerResourceRate(player1, RT_Manpower, 2)
	player1resourcemodifiers[2] = Modify_PlayerResourceRate(player1, RT_Munition, 2)
	player1resourcemodifiers[3] = Modify_PlayerResourceRate(player1, RT_Fuel, 1)
	
	]]	
	Player_SetPopCapOverride(player1, 18)
	--Player_SetMaxPopulation(player1, CT_Personnel, 18 )
end

function Carpiquet_Airport_Restrictions()

	--[[ UN/RESTRICT UPGRADES 
	Cmd_InstantUpgrade(player1, UPG.ALLIED_PHASE2)
	]]
	
	--[[ RESOURCES ]]
	Player_SetResource(player1, RT_Manpower, 1000)
	Player_SetResource(player1, RT_Munition, 600)
	Player_SetResource(player1, RT_Fuel, 150)
	World_SetDesignerSupply(EGroup_GetPosition(eg_invisible_resource_point), true)

	mod_resourcechanges = Modify_PlayerResourceRate(player1, RT_Manpower, 0.75)
	
	
	UI_ForceCommanderTreeChoice(player1, UPG.COMMANDER_TREE.CW.COMMANDOS)
	
	--Player_SetAbilityAvailability(player1, ABILITY.SP.GLIDER_COMMANDOS, ITEM_UNLOCKED)
	
	-- locks HQ at beginning
	Player_SetAbilityAvailability(player1, ABILITY.CW.HQ_REINFORCE, ITEM_REMOVED) -- put back to default when you switch it off
	
	Player_SetSquadProductionAvailability(player1, SBP.CW.CAPTAIN, ITEM_REMOVED) -- NEW
	Player_SetSquadProductionAvailability(player1, SBP.CW.SAPPER, ITEM_REMOVED) -- NEW
	
	Player_SetSquadProductionAvailability(player1, SBP.CW.ARMOUR_HQ, ITEM_LOCKED) -- NEW -- locked Armour HQ production
	Player_SetSquadProductionAvailability(player1, SBP.CW.INFANTRY_HQ, ITEM_LOCKED) -- NEW -- locked Inf HQ production
	
	
	Cmd_InstantUpgrade(player1, UPG.SP.UNLOCK_CANADIAN, 1)
	
	
	Cmd_InstantUpgrade(player1, UPG.CW.CAPTAIN_TECH_UNLOCK, 1)
	
	Player_SetUpgradeAvailability(player1, UPG.CW.CONVERT_AMBIENT_BUILDING, ITEM_LOCKED)
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_00, ITEM_LOCKED)
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_01, ITEM_LOCKED)
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_02, ITEM_LOCKED)

	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_10, ITEM_LOCKED)
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_11, ITEM_LOCKED)
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_12, ITEM_LOCKED)
	
	
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_10)
	--Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_01)
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_00)
	
    mod_actionpoints = Modify_PlayerResourceRate(player1, RT_Action, 0.0)
    UI_EnableResourceTypeKicker(RT_Action, false)      

	
	
	--[[ UN/RESTRICT FOW 
	World_EnablePlayerToPlayerFOW(player1, player3, true)
	]]
	
	--[[ UN/RESTRICT POP CAP 
	Player_SetMaxPopulation(player1, CT_Personnel, 100)
	]]
	
	--[[ UN/RESTRICT UI 
	UI_BindingSetEnabled("company_commander", false)
	UI_BindingSetEnabled("squadcap", false)
	]]
	
	--[[ UN/RESTRICT SBPS 
	local sbps = {SBP.ALLIED_SHERMAN, SBP.ALLIED_CROCODILE, SBP.ALLIED_GREYHOUN, SBP.ALLIED_PERSHING }
	for i = 1, table.getn(sbps) do
		local id = Util_GetSquadBlueprintID(sbps[i])
		Player_SetSquadProductionAvailability(player1, id, ITEM_LOCKED)
	end
	]]
end


function Carpiquet_Airport_Difficulty()

	-- get the difficulty
	g_difficulty = Game_GetSPDifficulty()  -- set a global difficulty variable
	print("********* DIFFICULTY: "..g_difficulty)

	Setup_Difficulty(player1, g_difficulty) -- pass the player and difficulty global variable into the Set Health function
	Setup_Difficulty(player2, g_difficulty) -- do it for each player that you have defined
	Setup_Difficulty(player3, g_difficulty)
	Setup_Difficulty(player4, g_difficulty)
	-- Troops changing according to difficulty:
	--[[
	if g_difficulty == GD_EASY then
	
		g_soldier_type1 = SBP.AXIS.GRENADIER
		g_soldier_type2 = SBP.AXIS.VOLKSGRENADIER
		g_soldier_type3 = SBP.AXIS.VOLKSGRENADIER
		
	else
	
		g_soldier_type1 = SBP.ELITE.PANZERGRENADIER
		g_soldier_type2 = SBP.AXIS.VOLKSGRENADIER
		g_soldier_type3 = SBP.AXIS.VOLKSGRENADIER
		
	end]]
	
	t_difficulty = {
	
		g_soldier_type1 = Util_DifVar({SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.GRENADIER, SBP.AXIS.GRENADIER, SBP.ELITE.PANZERGRENADIER}),
		g_soldier_type2 = Util_DifVar({SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.VOLKSGRENADIER}),
		g_soldier_type3 = Util_DifVar({SBP.AXIS.GRENADIER, SBP.AXIS.GRENADIER, SBP.ELITE.PANZERGRENADIER, SBP.ELITE.PANZERGRENADIER}),
	
	
	}
	
	
	t_dif_numbers = {
	
		g_dif_add_number = Util_DifVar({0, 0, 1, 2}),
	
	}
	
	--[[ left as an example 
	
	-- set health bonus for player 1
	
	t_difficulty = {
		base_def_spawn 			= Util_DifVar( {2*60, 1.5*60, 1*60, 0.75*60} ),			-- amount of time required before spawning base defense soldiers
		base_def_squad_num		= Util_DifVar( {1, 1, 2, 3} ),							-- number of squads to spawn for the base defense
		sniper_vulnerability 	= Util_DifVar( {2.5, 2, 1.5, 1} ),						-- the vulnerability factor on the snipers
		sniper_number			= Util_DifVar( {1, 2, 2, 3} ),							-- number of snipers to spawn
		sniper_wpn_cooldown		= Util_DifVar( {2, 1.5, 1, 1} ),						-- weapon cooldown time for the snipers
		stronghold_attack_num	= Util_DifVar( {1, 1, 2, 2} ),							-- number of squads to spawn from the guard tower to spawn and attack the player on alert
		aa_def_sbps				= Util_DifVar( {SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.GRENADIER, SBP.AXIS.STORMTROOPER, SBP.AXIS.KNIGHTSCROSS} ), -- types of squads to defend the AA Guns
	}
	
	]]
	
end



-------------------------------------------------------------------------

-- [[ MISSION Preset ]]

-------------------------------------------------------------------------

function Carpiquet_Airport_MissionPreset()

	Game_LoadAtmosphere("data:art/scenarios/presets/atmosphere/CXP1_CARPIQUET_NIGHT_00.aps", 0)
	Game_LoadAtmosphere("data:art/scenarios/presets/atmosphere/CXP1_Carpiquet_Dawn_00.aps", 2700) -- will transition to day in 45 mins
	
	--FOW_RevealMarker(mkr_opening_FOW, 120)-- reveal marker area by the glider so the area is revealed early on
	
	
	EGroup_SetInvulnerable(eg_control_tower, 0.75)
		
	-- new entry point
	eg_new_entry_point = EGroup_CreateIfNotFound("eg_new_entry_point")
	
	
	-- create the temporary starting units for player 1
	
	eg_temp_glider = EGroup_CreateIfNotFound("eg_temp_glider")
	--Util_CreateEntities(player1, eg_temp_glider, EBP.CW.GLIDER_COMMANDOS, mkr_commando_drop_zone1, 1) 
	
	sg_all_axis_soldiers = SGroup_CreateIfNotFound("sg_all_axis_soldiers")
	eg_all_axis_buildings = EGroup_CreateIfNotFound("eg_all_axis_buildings")
	
	sg_player_init_groups = SGroup_CreateTable("sg_player_init_group%d", 4) -- reference [t_carp.initial_p1_spawn] below
	sg_player_target1 = SGroup_CreateIfNotFound("sg_player_target1") -- target for FF
	sg_player_target2 = SGroup_CreateIfNotFound("sg_player_target2") -- target for FF
	sg_player_target3 = SGroup_CreateIfNotFound("sg_player_target3") -- target for FF
	sg_player_units = SGroup_CreateIfNotFound("sg_player_units")
	sg_all_units = SGroup_CreateIfNotFound("sg_all_units")
	eg_all_buildings = EGroup_CreateIfNotFound("eg_all_buildings")
	
	eg_initial_glider = EGroup_CreateIfNotFound("eg_initial_glider")
	
	sg_vehicle_retreat_group = SGroup_CreateIfNotFound("sg_vehicle_retreat_group")
	
	t_carp = {
		-- for ff artillery related variables
		artillery = {
			
			{sgroup1 = sg_player_target1, marker1 = mkr_ff_artillery_trigger1, pos1 = false, dialogueflag1 = false, retreatlocation1 = mkr_ff_artillery_retreat1, rule1 = function() Rule_AddOneShot(Carpiquet_Airport_FF_Artillery_Retreat, 1) end},
			{sgroup1 = sg_player_target2, marker1 = mkr_ff_artillery_trigger2, pos1 = false, dialogueflag1 = false, retreatlocation1 = mkr_ff_artillery_retreat2, rule1 = function() Rule_AddOneShot(Carpiquet_Airport_FF_Artillery_Retreat, 1) end},
			{sgroup1 = sg_player_target3, marker1 = mkr_ff_artillery_trigger3, pos1 = false, dialogueflag1 = false, retreatlocation1 = mkr_ff_artillery_retreat3, rule1 = function() Rule_AddOneShot(Carpiquet_Airport_FF_Artillery_Retreat, 1) end},
		},
		-- initial squad spawns
		initial_p1_spawn = {
			
			--{SBP.CW.LIEUTENANT, mkr_player_start1, 1},
			{SBP.CW.COMMANDOS, mkr_player_start4, 1, mkr_glider1_end}, --mkr_init_facing2
			{SBP.CW.COMMANDOS, mkr_player_start1, 1, mkr_commando_drop_zone1_facing}, --mkr_init_facing1
			--{SBP.CW.TOMMIES_CANADIAN_SP, mkr_player_start3, 2},
			
			
		},
		
		-- EVENTS
		--[[
		event_triggered = {
			
			{ACTOR.GenericAlly, LOC("Get out of there!  You don't want to be pounded by `friendly` artillery do you?!")}
			
		},]]
	}
	
	
	g_ff_arty_dialogue_reset = 0
	g_ff_arty_dialogue_limit = 3
	
	--[[
	-- initial spawners
	for a = 1, table.getn(t_carp.initial_p1_spawn) do
		--Util_CreateSquadsAtMarker(player1, sg_player_init_groups[a], t_carp.initial_p1_spawn[a][1] , t_carp.initial_p1_spawn[a][2], t_carp.initial_p1_spawn[a][3])
		Util_CreateSquads(player1, sg_player_init_groups[a], t_carp.initial_p1_spawn[a][1], t_carp.initial_p1_spawn[a][2], nil, 1, 6, nil, Marker_GetPosition(t_carp.initial_p1_spawn[a][4]))
		
		
		--SGroup_FaceMarker(sg_player_init_groups[a],  t_carp.initial_p1_spawn[a][4])
		Cmd_Move(sg_player_init_groups[a], t_carp.initial_p1_spawn[a][4])
		
		SGroup_AddGroup(sg_player_units, sg_player_init_groups[a])
		

	end]]
	
	
	
	-- enemy flag points 
	teg_flag_group = {eg_ammo_flag, eg_flag1, eg_flag2, eg_flag3, eg_flag4, eg_flag5, eg_flag6, eg_control_tower_flag, eg_88s_flag, eg_hangar_flag, 
		eg_barracks_control, eg_carp_flag1, eg_carpiquet_fuel}
	
	for i = 1, table.getn(teg_flag_group) do
	
		EGroup_InstantCaptureStrategicPoint(teg_flag_group[i], player2)
		
	end
	
	g_retreat_in_progress = false 
		
	--despawn carpiquet victory flags for now
	if EGroup_IsEmpty(eg_carpiquet_b_victory_flags) == false then
		
		EGroup_DeSpawn(eg_carpiquet_b_victory_flags)
		
	end

	--[[
	t_first_encounter = {
		detection = {
			
			{ACTOR.GenericAlly, LOC("Achtung!!")},
			
		},
		
		advice = {
			
		
			{ACTOR.GenericAlly, LOC("Lads, don't forget to use our smoke grenades!")},
			{ACTOR.GenericAlly, LOC("They can't hit what they can't see!")},
			{ACTOR.GenericAlly, LOC("We can also reinforce from our gliders, too!")},
			{ACTOR.GenericAlly, LOC("Thank goodness we took along grenades, lads!")},
			
		},
	
	}]]
	t_first_encounter = {}
	--[[
	--NOT USED ANYMORE?
	t_first_encounter.detection = { -- or use events
		{ACTOR.GenericAxis, LOC("Achtung!!")},
	}
	]]
	t_first_encounter.advice = { -- TACTICAL EVENT: Take out Axis Squads
		--{ACTOR.GenericAlly, LOC("Thank goodness we took along grenades, lads!")},
		{ACTOR.CXP1.Hazard, 1330510}, -- Ready grenades lads.
		--{ACTOR.CXP1.Hazard, 1330511}, -- Flank that emplacement and use grenades.
		--{ACTOR.CXP1.Hazard, 1330512}, -- Call in more troops from the glider mate.
		{ACTOR.CXP1.Hazard, 1330513}, -- Listen up, reinforcments available from the Glider
	}
	
	t_first_encounter.move_out = {
		{ACTOR.CXP1.Hazard, 1330500}, --Alright Commandos let's move!
		{ACTOR.CXP1.Hazard, 1330501}, --Keep your eyes peeled gents!
		{ACTOR.CXP1.Hazard, 1331000}, --We've got our work cut out for us, men.
	}
	
	t_first_encounter.pre_sit_rep03_01 = {
	
		{ACTOR.CXP1.Hazard, 1330540}, --"O" group, gather round.
		{ACTOR.CXP1.Hazard, 1330541}, --Take a knee and listen up.
		{ACTOR.CXP1.Hazard, 1330542}, --Situation is as follows…
	}
	
	-- HENSCHELS used for next mission. Created here for persistance/continuity
	tmkr_stationary_plane = Marker_GetTable("mkr_stationary_plane%d")
	teg_henschels = EGroup_CreateTable("eg_henschel%d", table.getn(tmkr_stationary_plane))
	eg_henschel_group = EGroup_CreateIfNotFound("eg_henschel_group")
	eg_stationary_planes = EGroup_CreateIfNotFound("eg_stationary_planes")
	
	t_henschels = {}
	
	--[[
	for i = 1, table.getn(tmkr_stationary_plane) do
		
		table.insert(t_henschels, {name = teg_henschels[i], blueprint = EBP.SP.HENSCHEL, loc = tmkr_stationary_plane[i], number = 1})
		
	end
	
	for k, v in pairs(t_henschels) do
		
		Util_CreateEntities(nil, v.name, v.blueprint, v.loc, v.number)
		--Modify_ReceivedDamage(v.name, 3)
		EGroup_AddEGroup(eg_henschel_group, v.name)
	end]]
		
		
		
	g_grenade_hint = 1339130 --LOC("Commandos can use grenades") -- hint text for grenade use in first encounter
	
	--alarm sound init
	g_alarm_soundpath = "SpecialFX/alarm_02"
	Sound_PreCacheSound (g_alarm_soundpath)
	eg_speaker1 = EGroup_CreateIfNotFound("eg_speaker1") -- makes sure eg_speaker1 exists
	eg_speaker2 = EGroup_CreateIfNotFound("eg_speaker2") -- makes sure eg_speaker2 exists
	eg_speaker3 = EGroup_CreateIfNotFound("eg_speaker3") -- makes sure eg_speaker3 exists
	
	
	if EGroup_IsEmpty(eg_barracks_gun) == false then
		Modify_DisableHold(eg_barracks_gun, true)
	end
	
	-- makes it so the player can't occupy the objective
	if EGroup_IsEmpty(eg_factory_a) == false then
		Modify_DisableHold(eg_factory_a, true)
	end
	
	
	-- makes the first garrison easier to destroy
	
	if EGroup_IsEmpty(eg_ammo_driver_spawn1) == false then
	
		--Modify_ReceivedDamage(eg_ammo_driver_spawn1, 5)
	
	end
	
	if EGroup_IsEmpty(eg_bunker6) == false then
		Modify_DisableHold(eg_bunker6, true)
	end
	
	
	--Modify_DisableHold(eg_runway_88_gun1, true)
	--Modify_DisableHold(eg_runway_88_gun2, true)
	
	-------------------------
	
	--halfbuilt_entity = {}
	
	t_bunker_status = {
	
		{name = eg_runway_bunker2, statepercent = 0.75, entname = nil},
		{name = eg_runway_bunker4, statepercent = 0.75, entname = nil},
		{name = eg_runway_bunker5, statepercent = 0.75, entname = nil},
		{name = eg_runway_bunker6, statepercent = 0.75, entname = nil},
	
	}
	
	for k, v in pairs(t_bunker_status) do
				
		if EGroup_IsEmpty(v.name) == false then
		
			Modify_DisableHold(v.name, true)
			--table.insert(halfbuilt_entity, EGroup_GetSpawnedEntityAt(v.name, 1))
			v.entname = EGroup_GetSpawnedEntityAt(v.name, 1)
			--v.entname = halfbuilt_entity[k]
			Entity_SetAnimatorVariable(v.entname, "Build", v.statepercent)
			
		end
		
	end
	------------------------------------
	
	--NO GLIDER ZONES
	--mkr_glider_allow3, --mkr_no_glider_zone8 is redundant
	t_no_glider_zones = {mkr_no_glider_zone1, mkr_no_glider_zone2, mkr_no_glider_zone3, mkr_no_glider_zone4, mkr_no_glider_zone5, mkr_no_glider_zone6,  mkr_no_glider_zone7, mkr_no_glider_zone9,
		mkr_glider_allow1, mkr_glider_allow2, mkr_glider_allow4, mkr_glider_allow5, mkr_glider_allow6, mkr_no_glider_fuel_sheds1, mkr_no_glider_fuel_sheds2, mkr_no_glider_fuel_tanks, mkr_no_glider_ammo_dump, mkr_no_glider_carpiquet}
	
	for i = 1, table.getn(t_no_glider_zones) do
		
		Player_AddAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, t_no_glider_zones[i] )
		Player_AddAbilityLockoutZone(player1, ABILITY.SP.GLIDER_TETRARCH, t_no_glider_zones[i] )
	
	end
	

	----------------------
	
	--TEMPORARY SIT-REPs
	
	--SIT REP 1
	t_carpiquet_sitrep = {}
	--[[
	t_carpiquet_sitrep.temp_01 ={
		{camPos = mkr_player_start1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330550}},--1st British Commando support is landing as we speak.
		{camPos = eg_carp_flag1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330551}},
		{camPos = mkr_ambient_barrage5, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330552}}, -- focus on airfield!
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330553}},
		{camPos = eg_ammo_flag, waitType = NISLET_TIME, waitValue = 2}, 
		{camPos = eg_factory_a, waitType = NISLET_TIME, waitValue = 2}, 
		--{camPos = pos1, waitType = NISLET_TIME, waitValue = 2}, 
		--{camPos = pos1, waitType = NISLET_TIME, waitValue = 2}, 
		--{camPos = pos1, waitType = NISLET_TIME, waitValue = 2}, 
		{camPos = eg_factory_a, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330554}},
		{camPos = mkr_player_start1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330555}},
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330556}},
		{camPos = mkr_player_start1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330557}},
	}]]
	
	
	t_carpiquet_sitrep.temp_01 ={
		{camPos = mkr_player_start1, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Hazard, 1331101}},--1st British Commando support is landing as we speak.
		{camPos = eg_carp_flag1, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Hazard, 1331102}}, --The Canadians are waiting outside Carpiquet for our signal before moving in.
		{camPos = mkr_ambient_barrage3, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Hazard, 1331103}}, --The Royal Scott's on Hill 112 are providing artillery fire on the airfield during our assault.  -- focus on airfield!
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Hazard, 1331104}}, --That should keep most Jerries in their bunkers.
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Hazard, 1331105}}, --The French Resistance suggests elements of the 12th SS have moved in to defend the airfield.  
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Blackmore, 1331106}}, --If their intel is right, the 12th SS has set up Command Posts at these locations.
		{camPos = eg_ammo_flag, waitType = NISLET_TIME, waitValue = 2}, 
		{camPos = eg_factory_a, waitType = NISLET_TIME, waitValue = 2}, 
		--{camPos = pos1, waitType = NISLET_TIME, waitValue = 2}, 
		--{camPos = pos1, waitType = NISLET_TIME, waitValue = 2}, 
		--{camPos = pos1, waitType = NISLET_TIME, waitValue = 2}, 
		{camPos = eg_factory_a, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Blackmore, 1331107}}, --Captain, have the Commandos move in and use demo charges to destory the Command Posts and any other targets of opportunity.
		{camPos = mkr_player_start1, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Blackmore, 1331108}}, --Until all targets have been eliminated stay well back from the airfield.
		{camPos = mkr_player_start1, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Blackmore, 1331109}}, --Once neutralized the RCR will move in to secure our frontline.
		{camPos = mkr_player_start1, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Blackmore, 1331111}}, --If the commandos are ineffective, our morning assault of the Airfield will be at a loss. 
		{camPos = mkr_player_start1, waitType = NISLET_VO, waitValue = {ACTOR.CXP1.Blackmore, 1331112}}, --Good luck...

	}
	
	
	--SIT REP 2 -- Fuel tanks and Generators -- Not used anymore
--~ 	t_carpiquet_sitrep.temp_02 ={
--~ 		--{camPos = mkr_glider1_arrow, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330580}}, --The next targets are Ammo and Fuel Depots. Once destroyed, the boys from 3rd Battalion will have a fighting chance in the morning.
--~ 		{camPos = mkr_glider1_arrow, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330581}}, --Pathfinders have identified landing locations for our GLIDERS.
--~ 		
--~ 		{camPos = mkr_glider1_arrow, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1332000}}, --Land Gilders HERE and HERE before moving in on the targets.
--~ 		{camPos = mkr_glider1_arrow, waitType = NISLET_TIME, waitValue = 1}, 
--~ 		{camPos = mkr_glider2_arrow, waitType = NISLET_TIME, waitValue = 2}, 
--~ 		
--~ 		{camPos = eg_generators, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330582}}, --Once on the ground we will need to utilize demolitions to neutralize the depots.
--~ 		{camPos = eg_generators, waitType = NISLET_TIME, waitValue = 1}, 
--~ 		{camPos = eg_fuel_tanks, waitType = NISLET_TIME, waitValue = 2}, 
--~ 		
--~ 		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330583}}, --The artillery barrage from the chaps on Hill 112 will allow us to operate without alerting the Airfield Garrison.
--~ 		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330584}}, --Remember boys, once the demo charges blow get the hell out, and back to friendly lines.
--~ 		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1332020}}, --Once we’ve lost the element of surprise we do not stand a chance, so pick your fights wisely gentlemen! 
--~ 		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330586}}, --We have a job to do Commandos. Dismissed.
--~ 	}
	
	--SIT REP 3 -- Factory stuff

	t_carpiquet_sitrep.temp_03 ={
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330600}}, --We're not out of the woods yet 1st Commandos.
		{camPos = eg_carp_flag1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330601}}, --Royal Canadian Rifles have reported elements of the 12th SS Panzer Division holed up in town of Carpiquet. 
		{camPos = eg_carp_flag1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330602}}, --3rd Bat will not make it through with out Commando support. 
		{camPos = eg_carp_flag1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1332030}}, --We need to clear them out.
		{camPos = mkr_tetrarch_arrow, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330604}}, --We can land our heavy gliders HERE and deploy the TETRARCH tanks to support our push.
		{camPos = eg_factory_a, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330605}}, --We need to clear the area before the Canadians arrive. 

		{camPos = mkr_tetrarch_arrow, waitType = NISLET_TIME, waitValue = 1}, 
	}
	

	
	
	t_carpiquet_sitrep.temp_04 ={
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330700}}, --Major Blackmore, 1st Commando reports all targets have been neutralized.
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330701}}, --Remaining units are now linking up with the Royal Canadian Rifles here.
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330702}}, --3rd Battalion is clear to proceed.
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330703}}, --Excellent, the 12th SS has collapsed to this location.
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1332040}}, --Deploy the Mobile Command Post to the area and begin offensive operations.
		{camPos = eg_flag1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330704}}, --LT Seville, have RCR move into position and capture these strategic objectives before sunrise.
		--{camPos = eg_flag1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1332050}},
		{camPos = eg_flag2, waitType = NISLET_TIME, waitValue = 2}, 
		{camPos = eg_flag3, waitType = NISLET_TIME, waitValue = 2}, 
		{camPos = eg_flag4, waitType = NISLET_TIME, waitValue = 2}, 
		{camPos = mkr_counterattack_defense1, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1332060}}, --Once secured we will launch our assault on the Airbase from this defensive line.
		{camPos = eg_ammo_flag, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 1330705}}, --I expect great things from you Lieutenant and the RCR.
	}
	
	
	t_carpiquet_sitrep.temp_03_after1 = {
		{ACTOR.CXP1.Hazard, 1331710}, -- HQ has given us the use of Tetrarchs to help achieve this.
		--{ACTOR.GenericAlly, 1330660}, -- Glider landing zones have been marked
		--{ACTOR.CXP1.Hazard, 1330661}, -- Deploy Tetrarch Tanks on the double gents!
		{ACTOR.CXP1.Hazard, 1331720}, -- We’ve highlighted a possible landing zone for them, note the marker on your map.
		{ACTOR.CXP1.Hazard, 1331730}, -- Use them wisely - they are well suited for taking out infantry holed up there.	
	
	}
	
	
	t_carpiquet_sitrep.temp_03_after2 = {
		
		{ACTOR.CXP1.Hazard, 1330661}, -- Deploy Tetrarch Tanks on the double gents!
	
	}
	
	-- middle squad retreat stuff
	f_middle_squad_first_retreat = false
	sg_middle_retreat_squad = SGroup_CreateIfNotFound("sg_middle_retreat_squad")
	
	
	
	g_carp_fuel_captured = false
	g_carp_flag1_captured = false
	
	g_smoke_on = false
	g_grenade_icon_timer = 0
	g_grenade_on = false
	g_smoke_icon_timer = 0
	
	g_generator_commandos_modified = false
	g_fuel_tank_commandos_modified = false
	
	
	
	-------------------------
	
	
	Capture_Points_Init()
	Capture_Carpiquet_Init()
	--Destroy_Bunkers_Init()
	Medal_Action_Init()	-- medal stuff
	
	--Minefield_Init() --disabled for now, will enable once we set special artillery that doesn't damage this
	
	Ammo_Dump_Init()
	Anti_Air_Init()
	Airport_Fence_Init()
	Airport_Gate_Init()
	AT_Gun_Init()
	Field_Init()
	Mortar_Init()
	Flak88_Init()
	Patrol1_Init()
	Patrol2_Init()
	Commando_Factory_Init()
	Shed_Chain_Reaction_Init()
	Forward_Chain_Reaction_Init()
	Hangar2_Chain_Reaction_Init()
	Hangar3_Chain_Reaction_Init()
	
	
	Ambient_Artillery_Init() -- ambient artillery
	Commando_Tetrarch_Landing_Init()
	
	Capture_Carpiquet_Preset()
	Ammo_Dump_Preset() -- will eventually be called with an activation function
	Anti_Air_Preset() -- will eventually be called with an activation function
	Airport_Fence_Preset() -- will eventually be called with an activation function
	Airport_Gate_Preset() -- will eventually be called with an activation function
	AT_Gun_Preset()
	Field_Preset()
	Mortar_Preset()
	Flak88_Preset()
	Patrol1_Preset()
	Patrol2_Preset()
	Commando_Factory_Preset()
	
	--Minefield_Preset() --disabled for now, will enable once we set special artillery that doesn't damage this
	
	--called after everything commando related is spawned
	Commando_Action_Init()
	Commando_Action_Preset()
	
	
end






-------------------------------------------------------------------------

-- [[ MISSION START ]]

-------------------------------------------------------------------------

function Carpiquet_Airport_MissionStart()

	Rule_RemoveMe()
	
	-- out of cinematic
	AutoCinematic(false, 2)
	
	Util_StartNIS(EVENTS.NIS01)
	Rule_Add(Carpiquet_Airport_First_Spawn, 0)
	Rule_Add(Carpiquet_Airport_MissionStartB)
	
end


function Carpiquet_Airport_First_Spawn()
	
	if Event_IsAnyRunning() == false then
		-- initial spawners
		for a = 1, table.getn(t_carp.initial_p1_spawn) do
			--Util_CreateSquadsAtMarker(player1, sg_player_init_groups[a], t_carp.initial_p1_spawn[a][1] , t_carp.initial_p1_spawn[a][2], t_carp.initial_p1_spawn[a][3])
			Util_CreateSquads(player1, sg_player_init_groups[a], t_carp.initial_p1_spawn[a][1], t_carp.initial_p1_spawn[a][2], nil, 1, 6, nil, Marker_GetPosition(t_carp.initial_p1_spawn[a][4]))
			
			
			--SGroup_FaceMarker(sg_player_init_groups[a],  t_carp.initial_p1_spawn[a][4])
			Cmd_Move(sg_player_init_groups[a], t_carp.initial_p1_spawn[a][4])
			
			SGroup_AddGroup(sg_player_units, sg_player_init_groups[a])
			
	
		end
		
		Rule_RemoveMe()
		
	end

end


function Carpiquet_Airport_MissionStartB()

	if Event_IsAnyRunning() == false then
		
		--Camera_ResetToDefault() -- set camera back to default
		
		--[[
		local opening_glider = EGroup_CreateIfNotFound("opening_glider")
		
		Player_GetAllEntitiesNearMarker(player1, opening_glider, mkr_opening_glider_detect)
			
		if EGroup_ContainsBlueprints(opening_glider, EBP.CW.GLIDER_COMMANDOS, false) then
			
			Entity_SetAnimatorState(EGroup_GetSpawnedEntityAt(opening_glider, 1), "animate_open", "on")
			
		end]]
		
		
		-- delay first objective
		--Rule_AddOneShot(Carpiquet_Airport_Activate_Capture_Points, 5)
		
		Rule_AddOneShot(Carpiquet_Get_Enemies, 6)	
		
		Rule_AddOneShot(Carpiquet_Airport_Activate_Commandos, 3) -- 5
		
		-- delay opening encounter
		Rule_AddOneShot(Carpiquet_Patrol1_Activate, 5)
		Rule_AddOneShot(Carpiquet_Patrol2_Activate, 2)
		
		-- delays bunker secondary objective until after 6 seconds, iterating it every second after that
		--Rule_AddDelayedInterval(Carpiquet_Airport_Activate_Destroy_Bunkers, 10, 1) 
		--Rule_AddDelayedInterval(Carpiquet_Airport_Activate_Clear_Tetrarch_LZ, 5, 1) 
		
		-- delay for fence guard stuff
		Rule_AddOneShot(Carpiquet_Airport_Activate_Fence_Guard, 1)

		-- delay for field guard stuff
		Rule_AddInterval(Carpiquet_Airport_Activate_Field_Guard, 1)
		
		-- delay for gate guard stuff
		Rule_AddOneShot(Carpiquet_Airport_Activate_Gate_Guard, 1)
		
		
		-- delay activation of carpiquet secondary objective
		Rule_AddInterval(Capture_Carpiquet_Activation1, 3)
		
		-- add the tracker for the artillery
		Rule_AddDelayedInterval(Carpiquet_Airport_FF_Artillery_Trigger, 1, 3)
		Rule_AddDelayedInterval(Carpiquet_Airport_FF_Artillery_Vehicle_Check, 2, 3)
		Rule_AddDelayedInterval(Carpiquet_Airport_FF_Artillery_Dialogue_Reset, 3, 3)
		
		-- ambient artillery
		Rule_AddOneShot(Ambient_Artillery_Kickoff, 0)
		
		Rule_AddInterval(Carp_Flag_Tracker, 1)
		
		-- control tower fuel shed chain reaction
		Rule_AddInterval(Shed_Chain_Reaction, 1)
		Rule_AddInterval(Forward_Chain_Reaction, 1)
		Rule_AddInterval(Hangar2_Chain_Reaction, 1)
		Rule_AddInterval(Hangar3_Chain_Reaction, 1)
		
		--Rule_AddDelayedInterval(Carpiquet_Airport_General_Lose_Condition, 10, 1)
		
		--Rule_AddOneShot(Carpiquet_Airport_Init_Glider_Spawner, 5) -- we may call this in later, initial glider troops
		
		Rule_RemoveMe()
	end
end



function Carpiquet_Airport_Switch_Entry()

	if EGroup_IsEmpty(eg_init_entry_point) == false then
	
		EGroup_DestroyAllEntities(eg_init_entry_point)
		
		eg_new_entry_point = EGroup_CreateIfNotFound("eg_new_entry_point")
		
		Util_CreateEntities(player1, eg_new_entry_point, EBP.STRAT_POINT.ENTRY, mkr_new_map_entry_point, 1)
		
	end

end



function Carpiquet_Airport_Activate_Commandos()
	
	Objective_Start(OBJ_Commando_Action)

end


function Carpiquet_Patrol1_Activate()

	Rule_AddOneShot(Patrol1_Activation, 1)

end


function Carpiquet_Patrol2_Activate()

	Rule_AddOneShot(Patrol2_Activation, 1)

end


--[[
function Carpiquet_Airport_Activate_Destroy_Bunkers()
	
	-- if bunkers are attacking the player, and the commando objectives are completed
	if EGroup_IsDoingAttack(eg_bunker_group, false, 1) then --and t_commando.action.fg_commandos_all_objectives_ok == true then 
		
		--Objective_Start(OBJ_Destroy_Bunkers)
		
		Rule_AddInterval(Destroy_Bunkers_All_Destroyed_Check, 1)
		Rule_AddInterval(Destroy_Bunkers_Remove_Pings, 1)
		
		Rule_RemoveMe()
		
	end

end]]


function Carpiquet_Airport_Activate_Fence_Guard()
	
	Rule_AddOneShot(Airport_Fence_Kickoff, 1)

end

function Carpiquet_Airport_Activate_Gate_Guard()
	
	Rule_AddOneShot(Airport_Gate_Kickoff, 1)

end


function Carpiquet_Airport_Activate_Field_Guard()
	
	if SGroup_IsEmpty(sg_field_force) == true then
	
		Rule_RemoveMe()
	
	elseif SGroup_IsEmpty(sg_field_force) == false then
	
		if Player_CanSeeSGroup(player1, sg_field_force, false) and SGroup_IsUnderAttack(sg_field_force,false, 5)  then
		
			Rule_AddOneShot(Field_Kickoff, 1)
			
			Rule_RemoveMe()
		
		end
		
	end

end



-- works for whenever the player encounters the enemy
function Carpiquet_Get_Enemies()

	Player_GetAll(player2, sg_all_axis_soldiers, eg_all_axis_buildings)
	
	Rule_AddInterval(Carpiquet_First_Encounter, 1)

end



function Carpiquet_First_Encounter()

	if Event_IsAnyRunning() == false then
	
		if SGroup_IsUnderAttackByPlayer(sg_all_axis_soldiers, player1, 1) then --and f_patrol1_seen_once == true then
			
			--Util_AutoIntel(t_first_encounter.detection) -- or use events file
			
			Util_StartIntel(EVENTS.FIRST_ENCOUNTER_DETECTION)
			
			Rule_AddInterval(Carpiquet_First_Encounter_Delay, 1)
			
			Rule_RemoveMe()
			
		end
		
	end

end

function Carpiquet_First_Encounter_Delay()

	if Event_IsAnyRunning() == false then
		
		flashID_grenade_button = UI_FlashAbilityButton( ABILITY.CW.GRENADE_COMMANDO, true, BT_UI_Strong_AbilityBtn ) -- to highlight smoke grenade button
		hp_ID_grenade_button = HintPoint_AddToAbilityButton(ABILITY.CW.GRENADE_COMMANDO, g_grenade_hint, true)
		
		g_grenade_on = true
		
		Util_AutoIntel(t_first_encounter.advice)
		--UI_FlashAbilityButton( ABILITY.SP.GLIDER_COMMANDOS, true, BT_UI_Strong_AbilityBtn ) -- to highlight glider button
		
		--Rule_AddOneShot(Carpiquet_First_Encounter_Delay_B, 15)
		
		Rule_AddInterval(Carpiquet_First_Encounter_Delay_B, 1)
		
		Rule_RemoveMe()

	end


end


function Carpiquet_First_Encounter_Delay_B()

	if g_smoke_on == true or g_grenade_icon_timer == 15 then
	
		UI_StopFlashing(flashID_grenade_button)
		HintPoint_Remove(hp_ID_grenade_button)
		
		Rule_RemoveMe()
		
	elseif g_grenade_icon_timer < 15 then
	
		g_grenade_icon_timer = g_grenade_icon_timer + 1
		
	end

end
------------------------------------------------
--[[Commando Objectives]]
------------------------------------------------



-------------------------------------------------------------------------
-- Objective Name 
-------------------------------------------------------------------------
-- Short descriptive name of what the player is cht_eventsed to do
-- give a brief description of win conditions and loose conditions if any 
-- also describe the kind of challenges the player will face
-------------------------------------------------------------------------
function Initialize_OBJ_Commando_Action()

	OBJ_Commando_Action = {
		
		SetupUI = function() 
			-- mark a point or position
			-- OBJ_Commando_Action.mapElementID = Objective_AddUIElements(OBJ_Commando_Action, mkr_marker, true, 000000, true)
			
			--LOC("Eliminate the officer and his staff!")
			OBJ_Commando_Action.mapElementID1 = Objective_AddUIElements(OBJ_Commando_Action, mkr_patrol1_reveal, true, 1339106) --eg_ammo_driver_spawn1
			
			local soft_elements = {OBJ_Commando_Action.mapElementID1}
			
			for k,v in pairs(t_commando.first_objective_data) do 
				v.indicatorID = soft_elements[k]
			end
			
			--[[
			OBJ_Commando_Action.mapElementID3 = Objective_AddUIElements(OBJ_Commando_Action, eg_fuel_sheds, true, LOC("Destroy this objective!"), true)
			OBJ_Commando_Action.mapElementID4 = Objective_AddUIElements(OBJ_Commando_Action, eg_fuel_tanks, true, LOC("Destroy this objective!"), true)
			
			local elements = {OBJ_Commando_Action.mapElementID3, OBJ_Commando_Action.mapElementID4}
			
			for k,v in pairs(t_commando.explosion_data) do 
				v.indicatorID = elements[k]
			end]]
			
			
			
			
	
			
		end,
		
		OnStart = function()
			
			Sound_PlayStreamed("Ambiences/Ambiences_Streamed/CXP2/SP/Artillery_Bombardment")
			-- announce the goal
			-- Util_AutoIntel(t_commando.action.EventStart)
			
			-- win/lose check
			Rule_AddInterval(Commando_Action_WinCheck, 2)
			
			-- start related action
			Commando_Action_Kickoff()
			-- EncounterName_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		
		Title = 1339106,-- LOC("Commando Raid"),
		Description = 1339117, --LOC("Use the Royal Commandos to destroy or kill the German targets of opportunity."),
		TitleEnd = 1339120, --LOC("Commando Raid Targets Eliminated"),
		
		Type = OT_Primary,
		
	}
	
	-- Register Objective
	--Objective_Register(OBJ_Commando_Action)
	-- Initialize Data
	--Commando_Action_Init()
	
end

-------------------------------------------------------------------------
-- Objective Name - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Commando_Action_Init()

	-- define sgroups, egroups, etc associated with this obj
	tmkr_commando_drop_zones = Marker_GetTable("mkr_commando_drop_zone%d")
	
	t_commando = {
		action = {
			
			fg_commandos_all_dead 		= false,			-- flag to indicate that all the commando units are dead
			fg_commandos_all_retreated 	= false,			-- flag to check whether all the commando units have retreated
			fg_commandos_all_objectives_ok = false, 	-- flag to check if all the commando objectives have blown up
			g_number_commando_objectives_done = 0, 	-- variable to show how many objectives hav	e been blown up
			
		},
		--[[
		explosion_data = {
			
			
			{name = eg_fuel_sheds_blowup, count = EGroup_Count(eg_fuel_sheds_blowup), destroyed = false, 
				indicatorID = false, dialogue = 1, FOWArea = mkr_fuel_sheds_reveal }, --{{ACTOR.GenericAlly, LOC("<insert British gloat here>!")}}
			
			{name = eg_fuel_tanks_blowup, count = EGroup_Count(eg_fuel_tanks_blowup), destroyed = false, 
				indicatorID = false, dialogue = 2, FOWArea = mkr_fuel_tanks_reveal }, -- {{ACTOR.GenericAlly, LOC("<insert another British gloat here>!")}}
		},
		-- 'indicatorID' is defined ...
		]]
		
		-- target changed to HQ now
		first_objective_data = {
			--contains pre sitrep 03_02
			--t_commando.action.event_hq_eliminated
			--{name = sg_ammo_command_section, count = SGroup_Count(sg_ammo_command_section), destroyed = false, 
				--indicatorID = false, dialogue = nil, FOWArea = mkr_ammo_dump_reveal},
			{name = eg_ammo_driver_spawn1, count = EGroup_Count(eg_ammo_driver_spawn1), destroyed = false, 
				indicatorID = false, dialogue = nil, FOWArea = mkr_ammo_dump_reveal},
			
		},
		
				
		factory_data = {
			-- contains
			{name = eg_factory_a, count = EGroup_Count(eg_factory_a), destroyed = false, 
				indicatorID = false, dialogue = nil, FOWArea = mkr_factory_reveal},
				
		},
		
		
			
		g_glider_base_count = 4,
		g_glider_count = 0,
		player_start_marker = mkr_commando_drop_zone1,
		
		
		g_objective_base_count = 3,
		g_objectives_completed = 0,
		
		g_asset_counter = 0,
		g_manpower_limit = 400,
		g_asset_time_limit = 10, --seconds
		
		f_last_chance = false,
		g_last_chance_counter = 0,
		g_last_chance_time_limit = 60 -- in seconds
		
	}
	
	
	t_commando.action.event_hq_eliminated = {
		{ACTOR.CXP1.Hazard, 1330620}, -- Target 1 is down, I say again, Target 1 is eliminated.
		{ACTOR.CXP1.Hazard, 1330621}, -- Feel that boys? That's the might of Brittan!
		{ACTOR.CXP1.Hazard, 1330622}, -- There'll be no shaking the crown from this kings head! --For King and country you fuckin' Hun bastards.
	}
	
	-- AMBIENT SPEECH LATER, called whenever the last 
	t_commando.action.event_ambient_blown = {
		{ACTOR.CXP1.Hazard, 1330640}, -- Target eliminated!
		--{ACTOR.CXP1.Hazard, 1330641}, --She's the last one gents!
		{ACTOR.CXP1.Hazard, 1330642}, -- Right lads, that was the Jolly part, time to move in.
		--{ACTOR.CXP1.Hazard, 1331370}, -- <We need to get back to friendly lines...>
	}
	
	t_commando.action.event_factory_blown = {
		--{ACTOR.CXP1.Hazard, 1331470}, -- Our final objective has been completed.
		{ACTOR.CXP1.Hazard, 1331480}, -- Stand easy lads, it's time for the Royal Canadian Rifles to earn their keep!
		{ACTOR.CXP1.Hazard, 1331490}, -- Number 1 Commando will remain in the area for support.
	
	}
	
	
	
	
	
	-------------------------
	
	
	--Objective_SetCounter( OBJ_Commando_Action, t_commando.g_glider_count, t_commando.g_glider_base_count)
	
	-- set up intel event tables
	t_commando.action.event_start = {
		{ACTOR.GenericAlly, 000000}, 
		{ACTOR.GenericAlly, 000000},
	}
	
	t_commando.action.event_end = {
		{ACTOR.GenericAlly, 000000}, 
		{ACTOR.GenericAlly, 000000},
	}	
	
	-- not used?  now used for factory
	--[[
	t_commando.action.garrison_hq = {
		{ACTOR.CXP1.Hazard, 1330560}, --Target 1 is the Garrison HQ.
		{ACTOR.CXP1.Hazard, 1330561}, --Use Grenades and Smoke to cover our forward advance.
		{ACTOR.CXP1.Hazard, 1330562}, --He who dares, wins, lads. Get to it!
		{ACTOR.CXP1.Hazard, 1330563}, --Time for execution! I want that target eliminated. 
	
	}]]
	
	t_commando.action.factory_hq = {
		--{ACTOR.CXP1.Hazard, 1330560}, --Target 1 is the Garrison HQ.
		
		{ACTOR.CXP1.Hazard, 1330563}, --Time for execution! I want that target eliminated. 
		--{ACTOR.CXP1.Hazard, 1330561}, --Use Grenades and Smoke to cover our forward advance.
		{ACTOR.CXP1.Hazard, 1330562}, --He who dares, wins, lads. Get to it!
		
	
	}
	
	
	
	
	-- pre sitrep 03_02
	--[[
	t_commando.action.officer_eliminated = {
		{ACTOR.GenericAlly, 1330570}, --Confirmed, Target 1 eliminated.
		{ACTOR.GenericAlly, 1330571}, --Well done, 1 Cadu.
	}]]
	
	t_commando.action.pre_sit_rep03_02 = {
		--{ACTOR.CXP1.Blackmore, 1330690}, -- Number 1 Commando reports all targets destroyed.?
		--{ACTOR.CXP1.Cutting, 1330570}, --Target eliminated.
		{ACTOR.CXP1.Cutting, 1330571}, --1st Commandos, well done.
	}
	
	t_commando.action.alt_event_go_for_carpiquet = {
	
		{ACTOR.CXP1.Hazard, 1330572}, --Reorg and advance to our next target.
		{ACTOR.CXP1.Hazard, 1330573}, --Stay away from the Hun's forward position and move in towards Carpiquet.
		{ACTOR.CXP1.Hazard, 1330574}, --Heavy Glider support is now available.
		{ACTOR.CXP1.Hazard, 1330575}, --Landing Zones have been marked.
	
	}
	

	t_commando.action.event_garrison_objs = {
		{ACTOR.CXP1.Hazard, 1331160}, -- There she is, target 1, the HQ structure.
		{ACTOR.CXP1.Hazard, 1331170}, -- Prep' charges and light it up gents.
		{ACTOR.CXP1.Hazard, 1331180}, -- Shite, any explosives will work. Just grenade the sorry lot.
	
	}

--[[	
	t_commando.action.event_fuel_objs = {
	
		{ACTOR.GenericAlly, 1331300}, -- Targets have been updated, the LANDING ZONES are marked!
		{ACTOR.GenericAlly, 1331310}, -- Call in Gliders and drop 'em on those marked locations!
		{ACTOR.GenericAlly, 1331320}, -- <Move quickly, we need to detory our targets before dawn>
	
	}]]
	
	-- actually different that t_commando.action.event_fuel_objs!!! 
	--[[ -- NOT USED ANYMORE?
	t_commando.action.event_fuel_objs2 = {
	
		{ACTOR.GenericAlly, 1331200}, -- We've got our next targets lads. The LANDING ZONES are marked!
		{ACTOR.GenericAlly, 1331210}, -- Call in Gliders at the indicated map locations.
		{ACTOR.GenericAlly, 1331220}, -- These targets must be eliminated before dawn, let's not cock this up.
	
	}]]
	-- OBJECTIVE_EVENT: LAND THE TANKS probably not needed anymore
	t_commando.action.event_land_tetrarchs = {
	}
	
	-- after sit rep 3
	t_commando.action.event_factory1= {
		
		--{ACTOR.CXP1.Hazard, LOC("HQ has decided we should take out that factory as well.  They've provided us with Tetrarchs!")}
		--{ACTOR.CXP1.Blackmore, 1330691}, -- Cutting, get me a Sit-Rep.
		{ACTOR.CXP1.Hazard, 1331700}, -- Destroying that command post is of vital importance to the operation!
			--{ACTOR.CXP1.Hazard, 1331710}, -- HQ has given us the use of Tetrarchs to help achieve this.
			--{ACTOR.CXP1.Hazard, 1331720}, -- We’ve highlighted a possible landing zone for them, note the marker on your map. -- now used in place of 1330661
			--{ACTOR.CXP1.Hazard, 1331730}, -- Use them wisely - they are well suited for taking out infantry holed up there.
	}
	
	
	t_commando.action.event_factory2= {
		
		{ACTOR.CXP1.Hazard, 1331730}, -- Use them wisely - they are well suited for taking out infantry holed up there.	
	
	}
		
	
	t_commando.action.last_chance = {
		
		--{ACTOR.GenericAlly, LOC("You have the resources to call in more troops.  Hurry, before you lose momentum!")}
		{ACTOR.CXP1.Hazard, 1330670}, -- We can still call in more Gliders.
		{ACTOR.CXP1.Hazard, 1330671}, -- Hurry, before we lose momentum!
		{ACTOR.CXP1.Hazard, 1330672}, -- Dawn is rapidly approaching!

	}
	
	--[[
	t_commando.action.event_demo = {
	
		{ACTOR.GenericAlly, LOC("Perfect!  We can use our demolition charges here!")},
	}]]
	
	
	t_commando.action.event_demo1 = {
	
		{ACTOR.CXP1.GenericCommando, 1331230}, -- Target sighted.
		{ACTOR.CXP1.GenericCommando, 1331240}, -- Get Demolition CHARGES on that target double quick lads!
		{ACTOR.CXP1.GenericCommando, 1331250}, -- Keep an eye out for patrols!
	}
	
	t_commando.action.event_demo2 = {
	
		{ACTOR.CXP1.GenericCommando, 1331340}, -- That's are target chaps.
		{ACTOR.CXP1.GenericCommando, 1331350}, -- I want DET CHARGES on there double quick!
		{ACTOR.CXP1.GenericCommando, 1331360}, -- Keep it to a minimum lads.  Jerry's got patrols through the area.

	}
	
	-- NOT USED YET
	t_commando.action.event_demo1_ready = {
		
		{ACTOR.CXP1.GenericCommonwealth, 1331260}, -- Get a message up the chain, Det Charges ready.
		{ACTOR.CXP1.Hazard, 1331270}, -- Listen up chaps... Once we blow those charges the whole will go to hell.
		--{ACTOR.GenericCommonwealth, 1331280}, -- Fallback!  Rendesvous back in our area of control!
		--{ACTOR.GenericCommonwealth, 1331290}, -- Break contact!  Head back to our LZ!
	
	}
	
	-- NOT USED YET
	t_commando.action.event_demo2_ready = {
		
		{ACTOR.CXP1.GenericCommonwealth, 1331260}, -- <Demo Charges ready>
		{ACTOR.CXP1.Hazard, 1331270}, -- <Listen up... Once we blow the chrages the whole base will know we're here>
		{ACTOR.CXP1.GenericCommonwealth, 1331280}, -- <That does it, time to vanish>
		{ACTOR.CXP1.GenericCommonwealth, 1331290}, -- <Get back to friendly territory>
	
	}
	
	--AMBIENT -- NOT USED ANYMORE!
	t_commando.action.event_nag = {
			
		{ACTOR.CXP1.Hazard, 1330890}, -- Get those fuckin' gliders on the marked LZ's! 
		{ACTOR.CXP1.Hazard, 1330891}, -- Get your head out of your ass and bring those gliders in!
		{ACTOR.CXP1.Hazard, 1330892}, -- Click on the Commando Glider button, then click and drag on the designated landing zone!
		
	}
	--AMBIENT -- EQUIVALENT IN EVENTS FILE THUS NOT USED ANYMORE
	--[[
	t_commando.action.event_tetrarch_nag = {
	
		{ACTOR.GenericAlly, 1330900}, -- Land the fuckin' Heavy Glider on the marked LZ!
		{ACTOR.GenericAlly, 1330910}, -- Get that fuckin' light armor on the ground!
		{ACTOR.GenericAlly, 1330920}, -- Heavy Glider LZ marked! Get that air dropped tank on the ground
	
	}]]
	
	
	--AMBIENT? German voices
	t_commando.action.event_alarm = {
	
		{ACTOR.CXP1.GenericAxis, 1331380}, -- ALARM!
		{ACTOR.CXP1.GenericAxis, 1331390}, -- We have enemy in the perimeter!
		{ACTOR.CXP1.GenericAxis, 1331400}, -- Mobilize the patrols
	
	}
	

	
	t_commando.action.event_get_moving = {
	
		{ACTOR.CXP1.Hazard, 1331410}, -- Arse and elbows lads...
		--{ACTOR.CXP1.Hazard, 1331420}, -- German counter attack mustering!
		--{ACTOR.CXP1.Hazard, 1331430}, -- Back to friendly lines, 1 Cadu!
	
	}
	
	
	
	--Objective_SetCounter( OBJ_Commando_Action, t_commando.g_objectives_completed, t_commando.g_objective_base_count)
	
	g_tetrarch_hint = 1339131 --LOC("Tetrarchs are now available for use")
	
	g_flag_indicator = false
	
	g_det_button_activated1 = false
	g_det_button_activated2 = false
	
	--detonation charge
	eg_detcharge = EGroup_CreateIfNotFound("eg_detcharge")
	
	g_demo_hint = 1339132 --LOC("Use demolition charges to destroy objectives!")
	
	f_counterattack_over = false
	f_counterattack_over_b = false
	
	f_counter_timer_start = false

	g_ammo_dump_reinforcements_no_attack_timer = 0
	g_ammo_dump_reinforcements_no_attack_timer_b = 0
	
	g_first_objective_over = false
	
	
end

-- preset any units or events needed before the kickoff, but you do not
-- want them to occur at the outset of the map.
-- Example: Often units are needed to exist before the objective start (because they start the objective)
-- then spawn those units here when they need to be spawned
function Commando_Action_Preset()

	-- alternate method of spawning, if we want guys to glide in at the beginning -- currently only slides in from a central spot, so disabled
	--Cmd_Ability(player1, ABILITY.SP.GLIDER_COMMANDOS , Marker_GetPosition(t_commando.player_start_marker), Marker_GetPosition(t_commando.player_start_marker), true)
	
	-- spawn commando squads -- DO NOT DELETE in case we want the commandos all spawned on the map for some reason or for debug purposes
	--[[
	for i = 1, table.getn(sg_commandos) do
		Cmd_Ability(player1, ABILITY.SP.GLIDER_COMMANDOS , Marker_GetPosition(t_commando_data[i].loc), Marker_GetPosition(t_commando_data[i].loc), true)
		print("spawned")
	end]]
	--[[
	for k,commando in pairs(t_commando_data) do
		Cmd_Ability(player1, ABILITY.SP.GLIDER_COMMANDOS , Marker_GetPosition(commando.loc), Marker_GetPosition(commando.loc), true)
		print("spawned")
	end]]
	
	
	-- start enemy behavior
	
	-- do other cool things
	--Rule_AddPlayerEvent(Commando_Glider_Use_Detect, player1, GE_AbilityExecuted)
	
	


end

-- adds pings for the player, to help guilde them on where to drop their gliders.
function Commando_Landing_Init()


	sg_fuel_tanks_aggressor = SGroup_CreateIfNotFound("sg_fuel_tanks_aggressor")
	sg_hangar_aggressor = SGroup_CreateIfNotFound("sg_hangar_aggressor")
	sg_generator_commandos = SGroup_CreateIfNotFound("sg_generator_commandos")
	sg_fuel_tank_commandos = SGroup_CreateIfNotFound("sg_fuel_tank_commandos")
	
	tsg_commando_groups = {sg_generator_commandos, sg_fuel_tank_commandos}
	
	eg_generators_glider = EGroup_CreateIfNotFound("eg_generators_glider")
	eg_fuel_tanks_glider = EGroup_CreateIfNotFound("eg_fuel_tanks_glider")
	
	eg_gen_charge = EGroup_CreateIfNotFound("eg_gen_charge")
	eg_fuel_charge = EGroup_CreateIfNotFound("eg_fuel_charge")
	teg_medal_charges = {eg_gen_charge, eg_fuel_charge}
	
	eg_medal_charges_overgroup = EGroup_CreateIfNotFound("eg_medal_charges_overgroup")
	
	tmkr_fuel_tank_counter = Marker_GetTable("mkr_fuel_tank_counter%d")
	tmkr_generator_counter = Marker_GetTable("mkr_generator_counter%d")
	tsg_generator_counter = SGroup_CreateTable("sg_generator_counter%d", table.getn(tmkr_generator_counter))
	tsg_fuel_tank_counter = SGroup_CreateTable("sg_fuel_tank_counter%d", table.getn(tmkr_fuel_tank_counter))
	
	tmkr_fuel_tank_boundaries = Marker_GetTable("mkr_fuel_tank_boundary%d")
	tmkr_generator_boundaries = Marker_GetTable("mkr_generator_boundary%d")
	
	t_fuel_tank_hard_counter_data = {}
	t_generator_hard_counter_data = {}
	
	for i = 1, table.getn(tmkr_fuel_tank_boundaries) do
	
		table.insert(t_fuel_tank_hard_counter_data, {boundary = tmkr_fuel_tank_boundaries[i], counter_spawn = tmkr_fuel_tank_counter[i], activated = false, 
					countername = tsg_fuel_tank_counter[i], countertype = t_difficulty.g_soldier_type3, counterspawn = tmkr_fuel_tank_counter[i], timetospawn = 0})
	
	end
	
	for i = 1, table.getn(tmkr_generator_boundaries) do
	
		table.insert(t_generator_hard_counter_data, {boundary = tmkr_generator_boundaries[i], counter_spawn = tmkr_generator_counter[i], activated = false, 
					countername = tsg_generator_counter[i], countertype = t_difficulty.g_soldier_type3, counterspawn = tmkr_generator_counter[i], timetospawn = 0})
	
	end
	
	
	g_fuel_tank_counter_units = 0
	g_generator_counter_units = 0
	
	
	sg_commando_hangar_reinforcement_group = SGroup_CreateIfNotFound("sg_commando_hangar_reinforcement_group")
	sg_fuel_tanks_reinforcements = SGroup_CreateIfNotFound("sg_fuel_tanks_reinforcements")
	
	sg_holding1 = SGroup_CreateIfNotFound("sg_holding1")
	sg_holding2 = SGroup_CreateIfNotFound("sg_holding2")
	eg_carp_a_gliders = EGroup_CreateIfNotFound("eg_carp_a_gliders") -- for use in next mission
	
	t_landing_data = {}
	tmkr_landings = {mkr_glider1_arrow, mkr_glider2_arrow}
	teg_landed_glider = EGroup_CreateTable("eg_landed_glider%d", table.getn(tmkr_landings))
	teg_target_buildings = {eg_generators, eg_fuel_tanks} -- eg_fuel_sheds
	teg_hideouts = {eg_hideout1, eg_hideout2}
	tsg_aggressors = {sg_hangar_aggressor, sg_fuel_tanks_aggressor}
	tsg_holding = {sg_holding1, sg_holding2}
	tsg_reinforcements = {sg_commando_hangar_reinforcement_group, sg_fuel_tanks_reinforcements}
	tmkr_landing_zones = {mkr_glider_allow1, mkr_glider_allow2}
	tmkr_blast_zone = {mkr_generator_blast_radius1, mkr_fuel_blast_radius}
	
	
		
	OBJ_Commando_Action.LandingID = {}
	OBJ_Commando_Action.LandingHintID = {}
	
	for i = 1, table.getn(tmkr_landings) do
		table.insert(t_landing_data, {name = teg_landed_glider[i], loc = tmkr_landings[i], landed = false,
						indicatorID = nil, hintindicatorID = nil, text = 1339133, --LOC("Land gliders in this area!"), 
						fighting = false,
						glider_type = {EBP.CW.GLIDER_COMMANDOS}, target_building = teg_target_buildings[i],
						target_destroyed = false, targetID = nil,
						hideout = teg_hideouts[i], hideout_hint_ID = false, hideout_blip_ID = false, aggressor = tsg_aggressors[i],
						holding = tsg_holding[i], respawn_next = false, respawn_count = 0, reinforcement_minder = tsg_reinforcements[i], 
						reinforcement_area = nil, landing_zone = tmkr_landing_zones[i], planted = false, gone = false, next_step = false,
						commando_group = tsg_commando_groups[i], fled = false, blast_zone = tmkr_blast_zone[i], charge = teg_medal_charges[i],
						})
	end
	
	for i = 1, table.getn(t_landing_data) do
		
		--table.insert(OBJ_Commando_Action.LandingID, UI_CreateMinimapBlip(Marker_GetPosition(tmkr_landings[i]), -1, BT_DefendHerePing) ) --HintPoint_Add(t_landing_data[i].loc, true, LOC("Land a glider here!"))
		--table.insert(OBJ_Commando_Action.LandingHintID, HintPoint_Add(t_landing_data[i].loc, true, 1339133)) -- LOC("Land a glider here!")
		--table.insert(OBJ_Medal_Action.LandingID, Objective_AddUIElements(OBJ_Medal_Action, tmkr_landings[i], true, 1339133, true)) 
		
	end
	--[[
	for k,v in pairs(t_landing_data) do 
		v.indicatorID = OBJ_Commando_Action.LandingID[k]
		v.hintindicatorID = OBJ_Commando_Action.LandingHintID[k]
	end]]
	
	g_glider_timer = 0
	g_gliders_landed = 0
	g_commandos_deployed = 0
	
	g_hangar_fighting = false
	g_hangar_fighting = false
	
	g_medal_targets_destroyed = 0

	g_hidden = 0
	sg_hiding_commandos = SGroup_CreateIfNotFound("sg_hiding_commandos")
	sg_fled_commandos = SGroup_CreateIfNotFound("sg_fled_commandos")
	

	t_respawn = {}
	
	f_medal_sitrep_played = false
	
	eg_target_op_1 = EGroup_CreateIfNotFound("eg_target_op_1")
	eg_target_op_2 = EGroup_CreateIfNotFound("eg_target_op_2")
	
	sg_gen_glider_killer = SGroup_CreateIfNotFound("sg_gen_glider_killer")
	sg_ft_glider_killer = SGroup_CreateIfNotFound("sg_ft_glider_killer")
	
end



function Commando_Medal_Generator_Soldier_Grab()

	local sg_temp_gen_soldiers = SGroup_CreateIfNotFound("sg_temp_gen_soldiers")
	Player_GetAllSquadsNearMarker(player1, sg_temp_gen_soldiers, mkr_glider1_arrow, 30)
			
	if SGroup_ContainsBlueprints(sg_temp_gen_soldiers, SBP.CW.COMMANDOS, false) then
		
		SGroup_Filter(sg_temp_gen_soldiers, SBP.CW.COMMANDOS, FILTER_KEEP)
		SGroup_AddGroup(sg_generator_commandos, sg_temp_gen_soldiers)
		
		g_commandos_deployed = g_commandos_deployed + 1
		
		Rule_AddInterval(Commando_Hangar_Hard_Counter_Spawn, 1)
		
		if EGroup_IsEmpty(eg_generators_glider) == false then
		
			--EGroup_Kill(eg_generators_glider)
			
			Modify_Vulnerability(eg_generators_glider, 5)
			
			Rule_AddInterval(Commando_Medal_Generator_Glider_Killer_Spawn,1)
		
		end
		
		Rule_RemoveMe()
		
	end


end


function Commando_Medal_Generator_Glider_Killer_Spawn()

	if EGroup_IsEmpty(eg_generators_glider) == true then
	
		Rule_RemoveMe()

	else
	
		if EGroup_IsEmpty(eg_generators_glider) == false then
	
			Util_CreateSquads(player2, sg_gen_glider_killer, SBP.ELITE.PANZERGRENADIER, mkr_panzergrenadier_spawn1, EGroup_GetPosition(eg_generators_glider)) 
			
			Cmd_Move(sg_gen_glider_killer, EGroup_GetPosition(eg_generators_glider))
			
			Rule_AddInterval(Commando_Medal_Generator_Glider_Kill, 4)
			
			Rule_RemoveMe()
	
		end
	
	end

end

function Commando_Medal_Generator_Glider_Kill()

	if SGroup_IsEmpty(sg_gen_glider_killer) == true or EGroup_IsEmpty(eg_generators_glider) then
	
		Rule_RemoveMe()
		
	else
	
		if SGroup_IsEmpty(sg_gen_glider_killer) == false and EGroup_IsEmpty(eg_generators_glider) == false then
			
			if Prox_SquadsInProximityOfEntities(sg_gen_glider_killer, eg_generators_glider, 20, false) then
			
				Cmd_Ability(sg_gen_glider_killer, ABILITY.ELITE.INCENDIARY_GRENADE_GREN, eg_generators_glider, nil, true, nil)
			
				Rule_AddOneShot(Commando_Medal_Generator_Glider_Kill2, 10)
			
				Rule_RemoveMe()
			
			end
			
		elseif SGroup_IsEmpty(sg_gen_glider_killer) == false and EGroup_IsEmpty(eg_generators_glider) == true then
			
			Cmd_Move(sg_gen_glider_killer, EGroup_GetPosition(eg_generators_glider), nil, nil, nil, nil, nil, 20)
			
		end
	
	end

end

function Commando_Medal_Generator_Glider_Kill2()

	if EGroup_IsEmpty(eg_generators_glider) == false then
		
		EGroup_Kill(eg_generators_glider)
		
	end

end



function Commando_Medal_Fuel_Tanks_Soldier_Grab()

	local sg_temp_fuel_soldiers = SGroup_CreateIfNotFound("sg_temp_fuel_soldiers")
	Player_GetAllSquadsNearMarker(player1, sg_temp_fuel_soldiers, mkr_glider2_arrow, 30)
			
	if SGroup_ContainsBlueprints(sg_temp_fuel_soldiers, SBP.CW.COMMANDOS, false) then
		
		SGroup_Filter(sg_temp_fuel_soldiers, SBP.CW.COMMANDOS, FILTER_KEEP)
		SGroup_AddGroup(sg_fuel_tank_commandos, sg_temp_fuel_soldiers)
		
		g_commandos_deployed = g_commandos_deployed + 1
		
		Rule_AddInterval(Commando_Fuel_Tanks_Hard_Counter_Spawn, 1)
		
		if EGroup_IsEmpty(eg_fuel_tanks_glider) == false then
		
			--EGroup_Kill(eg_fuel_tanks_glider)
			Modify_Vulnerability(eg_fuel_tanks_glider, 5)
			
			Rule_AddDelayedInterval(Commando_Medal_Fuel_Tanks_Glider_Killer_Spawn, 5, 1)
		
		end
			
		Rule_RemoveMe()
		
	end



end


function Commando_Medal_Fuel_Tanks_Glider_Killer_Spawn()

	if EGroup_IsEmpty(eg_fuel_tanks_glider) == true then
	
		Rule_RemoveMe()

	else
	
		if EGroup_IsEmpty(eg_fuel_tanks_glider) == false then
	
			Util_CreateSquads(player2, sg_ft_glider_killer, SBP.ELITE.PANZERGRENADIER, mkr_panzergrenadier_spawn2, EGroup_GetPosition(eg_fuel_tanks_glider)) 
			
			Cmd_Move(sg_ft_glider_killer, EGroup_GetPosition(eg_fuel_tanks_glider))
			
			Rule_AddInterval(Commando_Medal_Fuel_Tanks_Glider_Kill, 2)
			
			Rule_RemoveMe()
	
		end
	
	end

end

function Commando_Medal_Fuel_Tanks_Glider_Kill()

	if SGroup_IsEmpty(sg_ft_glider_killer) == true or EGroup_IsEmpty(eg_fuel_tanks_glider) then
	
		Rule_RemoveMe()
		
	else
	
		if SGroup_IsEmpty(sg_ft_glider_killer) == false and EGroup_IsEmpty(eg_fuel_tanks_glider) == false then
			
			if Prox_SquadsInProximityOfEntities(sg_ft_glider_killer, eg_fuel_tanks_glider, 20, false) then
			
				Cmd_Ability(sg_ft_glider_killer, ABILITY.ELITE.INCENDIARY_GRENADE_GREN, eg_fuel_tanks_glider, nil, true, nil)
				
				Rule_AddOneShot(Commando_Medal_Fuel_Tanks_Glider_Kill2, 10)
				
				Rule_RemoveMe()
				
			end
			
		elseif SGroup_IsEmpty(sg_ft_glider_killer) == false and EGroup_IsEmpty(eg_fuel_tanks_glider) == true then
			
			Cmd_Move(sg_ft_glider_killer, EGroup_GetPosition(eg_fuel_tanks_glider), nil, nil, nil, nil, nil, 20)
			
		end
		
	
	end

end

function Commando_Medal_Fuel_Tanks_Glider_Kill2()

	if EGroup_IsEmpty(eg_fuel_tanks_glider) == false then
		
		EGroup_Kill(eg_fuel_tanks_glider)
		
	end

end


-- function to remove glider guide pings for the player
function Commando_Medal_Remove_Ping()

	for i = 1, table.getn(t_landing_data) do
	
		local e_data = t_landing_data
		
		if e_data[i].landed == false then 
			
			local eg_nearmarker = EGroup_CreateIfNotFound("eg_nearmarker")
			Player_GetAllEntitiesNearMarker(player1, eg_nearmarker, e_data[i].loc)
			
			if EGroup_ContainsBlueprints(eg_nearmarker, e_data[i].glider_type, false) or EGroup_IsEmpty(e_data[i].target_building) then
				
				EGroup_Filter(eg_nearmarker, e_data[i].glider_type, FILTER_KEEP)
				EGroup_CallEntityFunction(eg_nearmarker, Entity_EnableProductionQueue, false)
				
				EGroup_AddEGroup(eg_carp_a_gliders, eg_nearmarker)
				
				
				
				e_data[i].landed = true
				e_data[i].fighting = true
				--[[
				if f_medal_sitrep_played == false then
					
					Rule_AddOneShot(Commando_Medal_Sitrep_Delay, 1)
					f_medal_sitrep_played = true
				
				end]]
				
				if i == 1 and e_data[i].next_step == false then
					
					OBJ_Medal_Action.mapElementID1 = Objective_AddUIElements(OBJ_Medal_Action, mkr_generator_arrow, true, 1339159, true, 0) --LOC("Destroy this target of opportunity")
					e_data[i].targetID = OBJ_Medal_Action.mapElementID1
					e_data[i].next_step = true
					
					EGroup_AddEGroup(eg_generators_glider, eg_nearmarker)
					
					Rule_AddInterval(Commando_Medal_Generator_Soldier_Grab, 1)
					
				elseif i == 2 and e_data[i].next_step == false then
					
					OBJ_Medal_Action.mapElementID2 = Objective_AddUIElements(OBJ_Medal_Action, mkr_fuel_tank_arrow, true, 1339141, true, 0) --LOC("Destroy this target of opportunity")
					e_data[i].targetID = OBJ_Medal_Action.mapElementID2
					e_data[i].next_step = true
					
					EGroup_AddEGroup(eg_fuel_tanks_glider, eg_nearmarker)
					
					Rule_AddInterval(Commando_Medal_Fuel_Tanks_Soldier_Grab, 1)
					
				end
				
				Objective_RemoveUIElements(OBJ_Medal_Action, OBJ_Medal_Action.LandingID[i])
				--UI_DeleteMinimapBlip(e_data[i].indicatorID)
				--HintPoint_Remove(e_data[i].hintindicatorID)
				
				Player_AddAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, e_data[i].landing_zone)
				
				--Player_SetEntityProductionAvailability(player1, EBP.CW.GLIDER_COMMANDOS, ITEM_LOCKED)
				
				
				-- delay here to make the count get performed after soldiers get spawned.  Otherwise the gliders landed are counted before the creation of the squads, leading to problems in medal resolution.
				Rule_AddOneShot(Medal_Glider_Land_Count_Delay, 1)
				
			end
			
			EGroup_Clear(eg_nearmarker)
			
		elseif e_data[i].landed == true then 
			
			if EGroup_IsEmpty(e_data[i].target_building) and e_data[i].target_destroyed == false then
				
				
				Objective_RemoveUIElements(OBJ_Medal_Action, e_data[i].targetID) -- remove ping
				
				
				if i == 1 then
				
					if EGroup_IsEmpty(e_data[i].hideout) == false and t_medal.g_complete == false and (SGroup_IsEmpty(e_data[i].aggressor) == false or SGroup_IsEmpty(sg_generator_commandos) == false)  then
						
						--e_data[i].targetID = Objective_AddUIElements(OBJ_Medal_Action, e_data[i].hideout, true, 1339140, true)
											
						
						if SGroup_IsRetreating(sg_generator_commandos, false) == false then
							
							Cmd_Ability(sg_generator_commandos, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true, nil)
							
							Rule_AddOneShot(Generator_Commandos_Go_AI, 1)
							
						end
						
					end
				
				elseif i == 2 then
					
					if EGroup_IsEmpty(e_data[i].hideout) == false and t_medal.g_complete == false and (SGroup_IsEmpty(e_data[i].aggressor) == false or SGroup_IsEmpty(sg_fuel_tank_commandos) == false)  then
						
						--e_data[i].targetID = Objective_AddUIElements(OBJ_Medal_Action, e_data[i].hideout, true, 1339140, true)
											
						
						if SGroup_IsRetreating(sg_fuel_tank_commandos, false) == false then
						
							Cmd_Ability(sg_fuel_tank_commandos, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true, nil)
							
							Rule_AddOneShot(Fuel_Tank_Commandos_Go_AI, 1)
						
						end
						
					end
					
				end
				
				
				e_data[i].target_destroyed = true
				g_medal_targets_destroyed = g_medal_targets_destroyed + 1
				
			end
			
		end
		
		
	end

	if g_medal_targets_destroyed >= 2 then --g_gliders_landed
	
		Rule_RemoveMe()
		
	end
	
end


function Generator_Commandos_Go_AI()

	if SGroup_IsEmpty(sg_generator_commandos) == true then
	
		Rule_RemoveMe()
	
	else
		SGroup_SetPlayerOwner(sg_generator_commandos, player3)

		-- checks to see if the commandos are already in a building 
		if SGroup_IsInHoldEntity(sg_generator_commandos, ANY) == true then
		
			SGroup_DestroyAllSquads(sg_generator_commandos)
			
			Util_CreateSquads(player3, sg_generator_commandos, SBP.CW.COMMANDOS, eg_hideout1)
			
			mod_generator_commandos = Modify_WeaponDamage(sg_generator_commandos, "hardpoint_01" , 0.0)
			
			g_generator_commandos_modified = true
			
			SGroup_SetInvulnerable(sg_generator_commandos, true)
			
			
		else
			
			-- if not, moved to hideout 1
			if EGroup_IsEmpty(eg_hideout1) == false then
				
				Cmd_Garrison(sg_generator_commandos, eg_hideout1)
				
				mod_generator_commandos = Modify_WeaponDamage(sg_generator_commandos, "hardpoint_01" , 0.0)
				
				g_generator_commandos_modified = true
				
				SGroup_SetInvulnerable(sg_generator_commandos, true)
				
				FOW_RevealSGroup(sg_generator_commandos, 20)
				
			end
			
		end
		
	end

end

function Fuel_Tank_Commandos_Go_AI()

	if SGroup_IsEmpty(sg_fuel_tank_commandos) == true then
	
		Rule_RemoveMe()
	
	else
	
		SGroup_SetPlayerOwner(sg_fuel_tank_commandos, player3)
		
		-- checks to see if the commandos are already in a building 
		if SGroup_IsInHoldEntity(sg_fuel_tank_commandos, ANY) == true then
		
			SGroup_DestroyAllSquads(sg_fuel_tank_commandos)
			
			Util_CreateSquads(player3, sg_fuel_tank_commandos, SBP.CW.COMMANDOS, eg_hideout2)
			
			mod_fuel_tank_commandos = Modify_WeaponDamage(sg_fuel_tank_commandos, "hardpoint_01" , 0.0)
				
			g_fuel_tank_commandos_modified = true
				
			SGroup_SetInvulnerable(sg_fuel_tank_commandos, true)
		
		else
			-- if not, move to hideout 2
			if EGroup_IsEmpty(eg_hideout2) == false then
				
				Cmd_Garrison(sg_fuel_tank_commandos, eg_hideout2)
				
				mod_fuel_tank_commandos = Modify_WeaponDamage(sg_fuel_tank_commandos, "hardpoint_01" , 0.0)
				
				g_fuel_tank_commandos_modified = true
				
				SGroup_SetInvulnerable(sg_fuel_tank_commandos, true)
				
				FOW_RevealSGroup(sg_fuel_tank_commandos, 20)
				
			end
		
		end

	end
	
end



function Medal_Glider_Land_Count_Delay()

	Rule_AddOneShot(Medal_Glider_Land_Count, 2)

end

function Medal_Glider_Land_Count()
	
	g_gliders_landed = g_gliders_landed + 1
	
end




---NOTE FOR FUTURE REFERENCE
---IF WE'RE TO MAKE THIS WORK FOR DIFFERENT COMMANDO UNITS (I.E. COMMANDO A BLOWS UP TARGET B) PERHAPS WE CAN USE THE V.AGGRESSOR TO DETERMINE IT TO THAT END.
---WE CAN USE THE V.AGGRESSOR CHECK IN CONJUNCTION WITH THE TSG_COMMANDO_GROUPS CHECK.  AGGRESSOR TAKES PRIORITY, THEN IF NONE, THEN TSG_COMMANDO_GROUPS?
-- removes pings for the hideouts
function Commando_Medal_Hideout_Remove_Ping()
--print("medal remove ping test")
	if g_hidden >= 2 or t_medal.g_complete == true then
	
		Rule_RemoveMe()
		
	else
	
		for k, v in pairs(t_landing_data) do
		
			
			if v.target_destroyed == true then
			
			--if SGroup_IsEmpty(v.aggressor) == false then
			
				if EGroup_IsEmpty(v.hideout) == false then
					print("checking squad")
					local check_squad = SGroup_CreateIfNotFound("check_squad")
			
					--EGroup_GetSquadsHeld(v.hideout, check_squad)
			
					--print(SGroup_IsEmpty(check_squad))
			
					for w = 1, table.getn(tsg_commando_groups) do -- tsg_aggressors
						
						EGroup_GetSquadsHeld(v.hideout, check_squad)
						
						if SGroup_IsEmpty(check_squad) == false and SGroup_ContainsSGroup(check_squad, tsg_commando_groups[w], false) and v.respawn_next == false then -- and SGroup_IsInHoldEntity(v.aggressor, true) -- tsg_aggressors
						
						
							--Objective_RemoveUIElements(OBJ_Medal_Action, v.targetID) -- remove ping
							
							
							SGroup_SetPlayerOwner(check_squad, player3) -- v.aggressor
							
							
							
							EGroup_SetPlayerOwner(v.hideout, player3) -- v.hideout
							EGroup_SetInvulnerable(v.hideout, true, 0.5)
							
							EGroup_SetHealthMinCap( v.hideout, 25)
							
							SGroup_SetInvulnerable(check_squad, true) -- v.aggressor
							
							SGroup_AddGroup(v.holding, check_squad) -- v.aggressor
							
							SGroup_AddGroup(sg_hiding_commandos, check_squad) -- v.aggressor
							
							-- here we take down its information.  hacky but should work
							if w == 1 then
							
								g_group1_population = SGroup_TotalMembersCount(v.holding)
								
								fg_group1_active = true
								
							
							elseif w == 2 then
							
								g_group2_population = SGroup_TotalMembersCount(v.holding)
							
								fg_group2_active = true
							
							end
							
							SGroup_DeSpawn(v.holding)
							SGroup_DestroyAllSquads(v.holding)
							
							
							
							print("commando count = "..SGroup_Count(sg_hiding_commandos))
							
							SGroup_Clear(check_squad) -- refer to spawn patrol functions, they depend on this being clear eventually
							
							
							--Util_StartIntel(EVENTS.MEDAL_OBJECTIVE_NPC)
							
							if g_hidden == 0 then
							
								Util_AutoAmbient(t_medal.dialogue.event_npc1)
							
							elseif g_hidden == 1 then
							
								Util_AutoAmbient(t_medal.dialogue.event_npc2)
							
							end
							
							
								
							if Rule_Exists(Commando_Ambient_Speech) == false and Rule_Exists(Commando_Ambient_Speech_Control) == false then
								
								Rule_AddDelayedInterval(Commando_Ambient_Speech_Control, 10, 1)
								
							end
								
							
							
							
							--SGroup_DeSpawn(v.aggressor)
							v.respawn_next = true
				
							
							g_hidden = g_hidden + 1
						
						else
	
	
						end
					
					end
				
				else
					Objective_RemoveUIElements(OBJ_Medal_Action, v.targetID) -- remove ping				
					--HintPoint_Remove(v.hideout_hint_ID)
				
				end
			end
		end
		
	end
	
end



function Commando_Medal_Despawner(despawngroup) --despawns to save for later

	if SGroup_IsEmpty(despawngroup) == false then
		
		--SGroup_DestroyAllSquads(despawngroup)
		
	end


end

function Commando_Ambient_Speech_Control() -- kicks off random speech when they become NPCs

	--if Rule_Exists(Commando_Ambient_Speech) == false then
	
		local random_time = World_GetRand(60, 120)
		
		Rule_AddDelayedInterval(Commando_Ambient_Speech, random_time, 1)
		
		Rule_RemoveMe()
	
	--end

end



function Commando_Ambient_Speech() -- NPC Speech_SetGlobalStealthRead

	if Rule_Exists(Commando_Ambient_Speech_Control) == false then
	
		local random_speech_table = World_GetRand(1, 2)

		if g_hidden == 0 then
			
			Util_StartIntel(EVENTS.MEDAL_OBJECTIVE_NPC_AMBIENT1)
			
		elseif g_hidden == 1 then
			
			Util_StartIntel(EVENTS.MEDAL_OBJECTIVE_NPC_AMBIENT2)
			
		end
		
		
		--Rule_AddInterval(Commando_Ambient_Speech_Control, 1)
		Rule_RemoveMe()
		
	end
	
end

--[[
function Commando_Medal_Targets_Remove_Ping()

	for i = 1, table.getn(t_landing_data) do
		
		local e_data = t_landing_data
		
		if e_data[i].landed == true then 
			
			if EGroup_IsEmpty(e_data[i].target_building) and e_data[i].target_destroyed == false then
				
				UI_DeleteMinimapBlip(e_data[i].indicatorID)
				e_data[i].target_destroyed = true
				g_medal_targets_destroyed = g_medal_targets_destroyed + 1
				
			end
			
		end
		
		
	end

	if g_medal_targets_destroyed >= 2 then
	
		Rule_RemoveMe()
		
	end
	
end]]




function Commando_Glider_Nag()

	if EGroup_IsEmpty(eg_generators) and EGroup_IsEmpty(eg_fuel_tanks) then -- eg_fuel_sheds
		
		Rule_RemoveMe()
		
	else
		
		if t_landing_data[1].fighting == true or t_landing_data[2].fighting == true then
		
			g_glider_timer = 0
		
		elseif t_landing_data[1].fighting == false and t_landing_data[2].fighting == false then
		
			if g_glider_timer < 120 then
		
				g_glider_timer = g_glider_timer + 1
			
			elseif  g_glider_timer >= 120 then
			
				--NAG SPEECH HERE
			
				--Util_AutoIntel(t_commando.action.event_nag)
			
				g_glider_timer = 0
			
			
			end
		
		end
	
	end

end


function Commando_Glider_Fighting_Detector()

	if EGroup_IsEmpty(eg_generators) then -- eg_fuel_sheds
		t_landing_data[1].fighting = false
	end
	
	if EGroup_IsEmpty(eg_fuel_tanks) then
		t_landing_data[2].fighting = false
	end

	if EGroup_IsEmpty(eg_generators) and EGroup_IsEmpty(eg_fuel_tanks) then -- eg_fuel_sheds
	
		Rule_RemoveMe()
	
	end
	
	
end

function Commando_Fuel_Sheds_Flash()

	if EGroup_IsEmpty(eg_generators) == false or g_det_button_activated1 == false then -- eg_fuel_sheds
	
		if Prox_PlayerSquadsInProximityOfEntities(player1, eg_generators, 25, false) then -- eg_fuel_sheds
		
			flash_ID_gen_charge_button = UI_FlashCommandButton(SCMD_PlaceCharge, true, BT_UI_Strong_AbilityBtn)
		
			hp_ID_gen_charge_button = HintPoint_AddToCommandButton(SCMD_PlaceCharge, g_demo_hint, true)
		
			Rule_AddOneShot(Commando_Fuel_Sheds_Flash_Stop, 15)
			
			g_det_button_activated1 = true
			
			Util_AutoIntel(t_commando.action.event_demo1)
		
			Rule_RemoveMe()
		
		end

	elseif EGroup_IsEmpty(eg_generators) == true or g_det_button_activated1 == true then -- eg_fuel_sheds
	
		Rule_RemoveMe()
		
	end

end

function Commando_Fuel_Sheds_Flash_Stop()

	UI_StopFlashing(flash_ID_gen_charge_button)
	HintPoint_Remove(hp_ID_gen_charge_button)

end



function Commando_Fuel_Tanks_Flash()

	if EGroup_IsEmpty(eg_fuel_tanks) == false or g_det_button_activated2 == false then
		
		if Prox_ArePlayerMembersNearMarker(player1, mkr_fuel_tank_arrow, false, 20) then
			
			flash_ID_ft_charge_button = UI_FlashCommandButton(SCMD_PlaceCharge, true, BT_UI_Strong_AbilityBtn)
			
			hp_ID_ft_charge_button = HintPoint_AddToCommandButton(SCMD_PlaceCharge, g_demo_hint, true)
			
			Rule_AddOneShot(Commando_Fuel_Tanks_Flash_Stop, 15)
			
			g_det_button_activated2 = true
				
			Util_AutoIntel(t_commando.action.event_demo2)
		
			Rule_RemoveMe()
		
		end

	elseif EGroup_IsEmpty(eg_fuel_tanks) == true or g_det_button_activated2 == true then
	
		Rule_RemoveMe()
		
	end

end


function Commando_Fuel_Tanks_Flash_Stop()

	UI_StopFlashing(flash_ID_ft_charge_button)
	HintPoint_Remove(hp_ID_ft_charge_button)

end



function Commando_Asset_Check() -- for the Commando Action lose condition

	if t_commando.action.fg_commandos_all_dead == true or Objective_IsComplete(OBJ_Commando_Action) then
		
		Rule_RemoveMe()
		
	else
		
		Player_GetAll(player1, sg_all_units, eg_all_buildings)
		
		if g_difficulty == GD_NORMAL or g_difficulty == GD_HARD or g_difficulty == GD_EXPERT then
			
			if SGroup_CountSpawned(sg_all_units) == 0 and (Player_GetResource(player1, RT_Manpower ) < t_commando.g_manpower_limit) then
				
				--t_commando.action.fg_commandos_all_dead = true
				
				Rule_AddInterval(Commando_Asset_Counter, 1) -- starts countdown to see if player can get people within specified time
				
				Rule_RemoveMe()
				
			elseif SGroup_CountSpawned(sg_all_units) == 0 and (Player_GetResource(player1, RT_Manpower ) >= t_commando.g_manpower_limit) and t_commando.f_last_chance == false then
				
				t_commando.f_last_chance = true
				
				Util_AutoIntel(t_commando.action.last_chance)
				
				Rule_AddInterval(Commando_Asset_Last_Chance_Dialogue_Counter, 1) -- makes sure that time elapses before the setting gets changed to false
				
				Rule_RemoveMe()
				
			end
			
		elseif g_difficulty == GD_EASY then
		
			if SGroup_CountSpawned(sg_all_units) == 0 and (Player_GetResource(player1, RT_Manpower ) >= t_commando.g_manpower_limit) and t_commando.f_last_chance == false then	
				
				t_commando.f_last_chance = true
				
				Util_AutoIntel(t_commando.action.last_chance)
				
				Rule_AddInterval(Commando_Asset_Check_Easy_Counter, 1) -- makes sure that time elapses before the setting gets changed to false
				
				Rule_RemoveMe()
				
			end
		
		
		end
		
		
		
	end
	
end


function Commando_Asset_Check_Easy_Counter()

	if t_commando.g_last_chance_counter <= t_commando.g_last_chance_time_limit then
		
		t_commando.g_last_chance_counter = t_commando.g_last_chance_counter + 1
		
	elseif t_commando.g_last_chance_counter > t_commando.g_last_chance_time_limit then
		
		Player_GetAll(player1, sg_all_units, eg_all_buildings)
		
		if SGroup_CountSpawned(sg_all_units) >= 0 then -- if there's at least 1 squad then restart the original population check
			
			t_commando.g_last_chance_counter = 0
			
			t_commando.f_last_chance = false
			
			Rule_AddInterval(Commando_Asset_Check, 5)
			
			Rule_RemoveMe()
			
		end
		
	end

end


function Commando_Asset_Last_Chance_Dialogue_Counter()

	if  t_commando.action.fg_commandos_all_dead == true  or Objective_IsComplete(OBJ_Commando_Action) then
	
		Rule_RemoveMe()
		
	else
	
		if t_commando.g_last_chance_counter <= t_commando.g_last_chance_time_limit then
			
			t_commando.g_last_chance_counter = t_commando.g_last_chance_counter + 1
			
		elseif t_commando.g_last_chance_counter > t_commando.g_last_chance_time_limit then
		
			Player_GetAll(player1, sg_all_units, eg_all_buildings)
		
			if SGroup_CountSpawned(sg_all_units) == 0 and ((Player_GetResource(player1, RT_Manpower ) <= t_commando.g_manpower_limit) 
				or (Player_GetResource(player1, RT_Manpower ) > t_commando.g_manpower_limit)) then -- if nobody then everyone is dead
			
				t_commando.action.fg_commandos_all_dead = true
				
				Rule_RemoveMe()
			
			elseif SGroup_CountSpawned(sg_all_units) > 0 then -- if there's at least 1 squad then restart the original population check
				
				t_commando.g_last_chance_counter = 0
				
				t_commando.f_last_chance = false
				
				Rule_AddInterval(Commando_Asset_Check, 5)
				
				Rule_RemoveMe()
			
			end
				
			
			
		end

	end
end


function Commando_Asset_Counter()

	if t_commando.action.fg_commandos_all_dead == true  or Objective_IsComplete(OBJ_Commando_Action) then
	
		Rule_RemoveMe()
		
	else
	
		if t_commando.g_asset_counter <= t_commando.g_asset_time_limit then -- counts to specified time limit
		
			t_commando.g_asset_counter = t_commando.g_asset_counter + 1
			
		elseif t_commando.g_asset_counter > t_commando.g_asset_time_limit then -- after specified time limit, this will check to see the status of the population
		
			Player_GetAll(player1, sg_all_units, eg_all_buildings)
		
			if SGroup_CountSpawned(sg_all_units) == 0 and (Player_GetResource(player1, RT_Manpower ) <= t_commando.g_manpower_limit) then -- if nobody then everyone is dead
			
				t_commando.action.fg_commandos_all_dead = true
				
				Rule_RemoveMe()
			
			elseif SGroup_CountSpawned(sg_all_units) > 0 then -- if there's at least 1 squad then restart the original population check
			
				
				t_commando.g_asset_counter = 0
				
				Rule_AddInterval(Commando_Asset_Check, 5)
				
				Rule_RemoveMe()
			
			end
		
		
		end

	end
		
end


function Commando_Action_WinCheck()

	if t_commando.action.fg_commandos_all_objectives_ok then
		
		if Event_IsAnyRunning() == false then
			-- the player has just won
			Objective_Complete(OBJ_Commando_Action)
			--Util_AutoIntel(t_commando.action.pre_sit_rep03_02) -- optional?
			
			Rule_AddOneShot(Commando_Action_Pre_WinDelay, 0)
			
			Rule_AddOneShot(Capture_Points_Axis_Town_Exiting, 2)
			
			Rule_RemoveMe()
			
		end
		
	elseif t_commando.action.fg_commandos_all_dead then
		
		if Event_IsAnyRunning() == false then
			-- the player has just failed
			Objective_Fail(OBJ_Commando_Action)
			Game_EndSP(false)
			Rule_RemoveMe()
		end
		
	end
	
end

function Commando_Action_Pre_WinDelay()
--[[
	if b_Capture_CarpiquetOBJComplete == true then
		
		Rule_AddInterval(Capture_Carpiquet_Delay_Reinforcements, 1)
	
	end]]
	
	Rule_AddInterval(Commando_Action_WinDelay, 1)
	

end


function Commando_Action_WinDelay()

	if Event_IsAnyRunning() == false then
		
		Util_AutoIntel(t_commando.action.pre_sit_rep03_02) -- optional?
		
		Objective_Start(OBJ_Capture_Points)
		
		if EGroup_IsCapturedByPlayer(eg_strat_points, player1, true) == false then
		-- surreptitiously add in the sitrep and pretend it was always there
			OBJ_Capture_Points.OnStart = function() end
			OBJ_Capture_Points.SitRep = {
					Movie = "CXP1_SR_03-04",
					Force = true,
					SpeechTiming =
					{
						{ 1,	ACTOR.CXP1.Cutting, 1330700 },
						{ 4.8,	ACTOR.CXP1.Cutting, 1330701 },
						{ 9,	ACTOR.CXP1.Cutting, 1330702 },
						{ 11.6,	ACTOR.CXP1.Blackmore, 1330703 },
						{ 16,	ACTOR.CXP1.Blackmore, 1332040 },
						{ 21,	ACTOR.CXP1.Blackmore, 1330704 },
						{ 29,	ACTOR.CXP1.Blackmore, 1332060 },
						{ 33.8,	ACTOR.CXP1.Blackmore, 1330705 },
						
						
					},
				}
					
			Obj_SetObjectiveFunction(OBJ_Capture_Points.ID, FN_OnActivate, __ObjectiveOnActivateCallback)
			Objective_ForceSitRep(OBJ_Capture_Points)
			
		end
		
		
		if EGroup_IsEmpty(eg_new_entry_point) == true then -- if the new entry point hasn't been made yet....
			
			Carpiquet_Airport_Switch_Entry()
			
		end
		
		Rule_AddInterval(Commando_Objective_Medal_Delay, 1)
		
		Rule_AddOneShot(Final_Flag_Init, 1)
		
		Rule_AddOneShot(Final_Flag_Giveaway_Delay, 2)
		
		Rule_AddOneShot(Carpiquet_Ambient_Speech_Delay, 150)
			
		Rule_RemoveMe()
	end
	
end

function Carpiquet_Ambient_Speech_Delay()

	Rule_AddDelayedInterval(Carpiquet_Ambient_Speech_Delay, 10, 1)

end



function Carpiquet_Ambient_Speech_Delay()

	if Event_IsAnyRunning() == false then
		
		Rule_AddDelayedInterval(Axis_Taunt_Speech_Control, 15, 1) -- Taunt Speech
		Rule_AddDelayedInterval(Capture_Points_Nag_Control, 30, 1) -- capture points nag speech
		Rule_AddDelayedInterval(Capture_Points_Movement_Control, 20, 1) -- capture points CW attack speech
		Rule_AddDelayedInterval(Capture_Points_Under_Attack_Control, 25, 1) -- capture points CW under attackspeech
		
		Rule_RemoveMe()
		
	end
	
end	


--[[
function Commando_Objective_Medal_Delay()
-- if any captured is true then start counter
	if EGroup_IsCapturedByPlayer(eg_strat_points, player1, false) == true then
	
		if g_medal_delay_timer < g_medal_delay_timer_number then
			
			g_medal_delay_timer = g_medal_delay_timer + 1
			
		elseif g_medal_delay_timer >= g_medal_delay_timer_number then
		
			Objective_Start(OBJ_Medal_Action)
			Rule_RemoveMe()
		
		end
		
	end

end]]





----------------------------------------------------

-- start the related action
function Commando_Action_Kickoff()

	-- action that starts with the Obj being granted
	--Rule_AddInterval(Commando_Glider_Remove, 1)
	--Rule_AddInterval(Commando_Medal_Dialogue_Tracker, 1)
	--Rule_AddInterval(Commando_Objective_Detonate, 1)
	Rule_AddInterval(Commando_Ammo_Dump_Objective_Tracker, 1)
	
	-- making it so that on Easy, there won't be any check for player assets for purposes of mission failure.
--	if g_difficulty == GD_NORMAL or g_difficulty == GD_HARD or g_difficulty == GD_EXPERT then
		
		Rule_AddInterval(Commando_Asset_Check, 5)
		
	--end
	
	--Rule_AddOneShot(Commando_Camera_Delay1, 7)
	
	
	--Rule_AddInterval(Commando_Ammo_Dump_Capture_Flag_Indicator, 1)
	
	------
	--Hangar Commando Stuff
	Commando_Hangar_Init()
	Commando_Hangar_Preset()
	
	--Fuel Tank Commando Stuff
	Commando_Fuel_Tanks_Init()
	Commando_Fuel_Tanks_Preset()
	
	Rule_AddInterval(Detonation_Grab, 1)
	
	-- Ammo Dump is covered elsewhere already as Ammo_Dump_Init/Ammo_Dump_Preset
	
	
end



function Commando_Reveal_Ammo_Dump_Objective_Start()

	
	if Event_IsAnyRunning() == false then
	
		Objective_UpdateText(OBJ_Commando_Action, 1339100, 1339110, true)
		
		for k, v in pairs (t_commando.first_objective_data) do
			
			if EGroup_IsEmpty(v.name) == false then
				
				FOW_RevealMarker(v.FOWArea, 60)
				
			end
			
		end
		
		--Rule_AddInterval(Commando_Reveal_Objectives, 60)
		
		Rule_AddInterval(Commando_Reveal_Ammo_Dump_Objective, 60)
		
		
		Rule_RemoveMe()
	
	end

end


function Commando_Reveal_Ammo_Dump_Objective()

	if t_commando.action.fg_commandos_all_objectives_ok == true then
	
		Rule_RemoveMe()
	
	else
	
		for k, v in pairs (t_commando.first_objective_data) do
				
				if EGroup_IsEmpty(v.name) == false then
					
					FOW_RevealMarker(v.FOWArea, 60)
					
				end
				
		end

	end
		
end


function Commando_Ammo_Dump_Objective_Tracker() -- tracks Ammo Dump objective

	for k, v in pairs (t_commando.first_objective_data) do 
	
		if (EGroup_IsEmpty(v.name) and v.destroyed == false) or (Player_OwnsEGroup(player2, v.name, false) == false and v.destroyed == false) then
		
			v.destroyed = true
			
			--Objective_RemoveUIElements(OBJ_Commando_Action, v.indicatorID) -- remove ping
			Objective_RemoveUIElements(OBJ_Commando_Action, OBJ_Commando_Action.mapElementID1) -- remove ping

			--Util_AutoIntel(v.dialogue)
			
			--Util_AutoIntel(t_commando.action.officer_eliminated)
			
			Util_AutoIntel(t_commando.action.event_hq_eliminated)
			Util_AutoIntel(t_capture_points_dialogue.pre_sit_rep03_03)
			
			
			
			--Util_AutoIntel(t_commando.action.pre_sit_rep03_02)
			
			--Util_AutoNISlet( NISLET_GAME2GAME, t_carpiquet_sitrep.temp_02 )
			
			t_commando.g_objectives_completed = t_commando.g_objectives_completed + 1
			
			--Objective_SetCounter( OBJ_Commando_Action, t_commando.g_objectives_completed, t_commando.g_objective_base_count)
			
			if EGroup_IsCapturedByPlayer(eg_ammo_flag, player1, false) == false then
				
				if Rule_Exists(Commando_Ammo_Dump_Capture_Flag_Indicator) == false then
					Rule_AddInterval(Commando_Ammo_Dump_Capture_Flag_Indicator, 1)
				end
				
			end
			
			if Rule_Exists(Commando_Ammo_Dump_Reinforcements_Activity_Timer) == false then
				Rule_AddDelayedInterval(Commando_Ammo_Dump_Reinforcements_Activity_Timer, 8, 1)
			end
			
			if Rule_Exists(Commando_Ammo_Dump_Reinforcements_Activity_Timer_B) == false then
				Rule_AddInterval(Commando_Ammo_Dump_Reinforcements_Activity_Timer_B, 1) -- timer in case player doesn't fight
			end
			
		end
		
		
		
	end

	if EGroup_IsEmpty(eg_ammo_driver_spawn1) or (Player_OwnsEGroup(player2, eg_ammo_driver_spawn1, false) == false) then -- when all enemies in this group are destroyed
		
		--g_first_objective_over = true
		
		--Rule_AddOneShot(Commando_Objective_Medal_Action, 1)
		
		
		-- call when the counterattack force is destroyed, or timer occurs when the player doesn't get attacked
		
		-- replaced sg_ammo_dump_reinforcements with sg_ammo_dump_reinforcement_overgroup
		if SGroup_IsEmpty(sg_ammo_dump_reinforcement_overgroup) or (SGroup_IsEmpty(sg_ammo_dump_reinforcement_overgroup) == false and f_counterattack_over == true) -- if reinforcement group is dead or nothing is happening
			or (f_counterattack_over_b == true and SGroup_IsUnderAttackByPlayer(sg_all_units, player2, 10) == false) then -- if the player does nothing
		
			--Rule_AddDelayedInterval(Commando_Objective_Factory_Pre_Delay1, 5, 1)
			
			Rule_AddOneShot(Commando_Objective_Factory_Pre_Delay1, 5)
			
			--Util_AutoIntel(t_capture_points_dialogue.pre_sit_rep03_03_alt)
			--Rule_AddDelayedInterval(Commando_Objective_Factory_Sitrep_Delay, 5, 1)
			
			Rule_RemoveMe()
			
		end
		
	end
	

end

function Commando_Objective_Factory_Pre_Delay1()


	Rule_AddInterval(Commando_Objective_Factory_Pre_Delay, 1)
	

end



function Commando_Objective_Factory_Pre_Delay()

	if Event_IsAnyRunning() == false then
		
		if SGroup_IsEmpty(sg_ammo_dump_reinforcement_overgroup) 
			or (SGroup_IsEmpty(sg_ammo_dump_reinforcement_overgroup) == false and f_counterattack_over == true) -- if reinforcement group is dead or nothing is happening
			or (f_counterattack_over_b == true and SGroup_IsUnderAttackByPlayer(sg_all_units, player2, 5) == false) then -- if the player does nothing
		
			--Util_AutoIntel(t_capture_points_dialogue.pre_sit_rep03_03_alt)
			Rule_AddDelayedInterval(Commando_Objective_Factory_Sitrep_Delay, 5, 1)
			Rule_RemoveMe()
			
		end
		
	end

end



function Commando_Ammo_Dump_Reinforcements_Activity_Timer()

	if SGroup_IsEmpty(sg_ammo_dump_reinforcement_overgroup) == true then
	
		f_counterattack_over = true
		
		Rule_RemoveMe()
		
	else
	
		if f_counterattack_over == false then
		--replaced sg_ammo_dump_reinforcements with sg_ammo_dump_reinforcement_overgroup
			
			
			
		
			if f_counter_timer_start == false then
				
				if SGroup_IsUnderAttackByPlayer(sg_ammo_dump_reinforcement_overgroup, player1, 1) == true then
			
					f_counter_timer_start = true
				
				end
		
			elseif f_counter_timer_start == true then
		
				if g_ammo_dump_reinforcements_no_attack_timer < 7 then
				
					if SGroup_IsUnderAttackByPlayer(sg_ammo_dump_reinforcement_overgroup, player1, 1) == false then
					
						g_ammo_dump_reinforcements_no_attack_timer = g_ammo_dump_reinforcements_no_attack_timer + 1
					
					elseif SGroup_IsUnderAttackByPlayer(sg_ammo_dump_reinforcement_overgroup, player1, 1) == true then
					
						g_ammo_dump_reinforcements_no_attack_timer = 0
						
					end
								
				elseif g_ammo_dump_reinforcements_no_attack_timer >= 7 then
					
					f_counterattack_over = true
					
					Rule_RemoveMe()
					
				end
				
			end
		
		else		
			
			
			
		end
		
	end


end

function Commando_Ammo_Dump_Reinforcements_Activity_Timer_B()	-- timer in case player DOESN'T fight the reinforcements group

	if g_ammo_dump_reinforcements_no_attack_timer_b < 60 then
		
		g_ammo_dump_reinforcements_no_attack_timer_b = g_ammo_dump_reinforcements_no_attack_timer_b + 1
		
	elseif g_ammo_dump_reinforcements_no_attack_timer_b >= 60 then
		
		f_counterattack_over_b = true
		
		Rule_RemoveMe()
		
	end
	

end



function Commando_Ammo_Dump_Capture_Flag_Indicator()

	if g_flag_indicator == false then
	
		--if SGroup_IsEmpty(sg_ammo_command_section) then
		
		if EGroup_IsEmpty(eg_ammo_driver_spawn1) then
			
			g_flag_indicator = true
			
			ammo_flag_ping_id = HintPoint_Add(eg_ammo_flag, true, 1339155)  -- add ping --LOC("Capture this flag!")
			
			
		end
		
	elseif g_flag_indicator == true then
	
		if EGroup_IsCapturedByPlayer(eg_ammo_flag, player1, false) then
			
			HintPoint_Remove(ammo_flag_ping_id)
			
			Rule_RemoveMe()
			
		end
		
	end
	
end







function Commando_Siren()

	--Sound_Play2D("CXP1\BIA\Root\WW2\Data\SOUND\SpecialFX\alarm_02")

end

--[[
function Commando_Objective_Detonate() -- makes a BIG explosion at the objectives!

	for k, v in pairs (t_commando.explosion_data) do 
		
		if EGroup_Count(v.name) < v.count then
			
			EGroup_Kill(v.name)
			
		end
		
	end
end]]

function Commando_Objective_Factory_Sitrep_Delay()
--print("testing delay")
	if Event_IsAnyRunning() == false then	
		
		
		
		Rule_AddInterval(Commando_Objective_Factory_Action, 1)
	
		Rule_RemoveMe()
		
	end

end



function Commando_Objective_Factory_Action() -- kicks off the second part of the objectives

	if Event_IsAnyRunning() == false then
	
		--Objective_StopCounter(OBJ_Commando_Action)
		
		--Objective_UpdateText(OBJ_Commando_Action, LOC("Take out the factory at the edge of Carpiquet"), LOC("Destroy this factory to open a way into Carpiquet"), false)
			
		Player_RemoveAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_no_glider_carpiquet )
		
		Objective_UpdateText(OBJ_Commando_Action, 1339100, 1339116) -- update text
		
		OBJ_Commando_Action.mapElementID2 = Objective_AddUIElements(OBJ_Commando_Action, eg_factory_a, true, 1339156, true) --LOC("Destroy this objective!")
		
		local factory_element = {OBJ_Commando_Action.mapElementID2}
		
		-- remember, t_commando.factory_data was already defined earlier!
		for k,v in pairs(t_commando.factory_data) do 
			v.indicatorID = factory_element[k]
		end
		
		
	--	Util_AutoIntel(t_capture_points_dialogue.pre_sit_rep03_03)
	--	Util_AutoIntel(t_capture_points_dialogue.pre_sit_rep03_03_alt)
		
		if EGroup_IsEmpty(eg_factory_a) == false then -- if the target is not destroyed then...
			
			Util_AutoIntel(t_commando.action.event_factory1)
			
		end
		
		Rule_AddDelayedInterval(Commando_Objective_Factory_Tracker, 1, 1)
		Rule_AddOneShot(Commando_Reveal_Factory, 1)
		
		Rule_AddInterval(Commando_Factory_Flash, 2) -- detects if player is close to factory to kick off the detonation pack stuff
		
		
		
		-- had to put this here or else conflicts may occur
		Rule_AddOneShot(Commando_Tetrarch_Landing_Preset, 0)
		--Rule_AddOneShot(Commando_Tetrarch_Start_Delay_Activate, 0)
		Rule_AddInterval(Commando_Tetrarch_Start_Delay, 1)
		
		-- grants player additional population to get the tank!
		Player_SetPopCapOverride(player1, 30) -- 30
		--Player_SetMaxPopulation(player1, CT_Personnel, 30 ) -- originally 30
		
		--g_first_objective_over = true -- set true in case carpiquet gets captured too early.  false is there to prevent allied reinforcements from showing up too early
	
		Rule_RemoveMe()
	
	end
end




function Commando_Objective_Factory_Tracker() -- tracks to see when the factory is destroyed

	for k, v in pairs (t_commando.factory_data) do 
		
		if (EGroup_IsEmpty(v.name) and v.destroyed == false and v.indicatorID ~= false) or (Player_OwnsEGroup(player2, v.name, false) == false) then
			
			v.destroyed = true
			
			
			Objective_RemoveUIElements(OBJ_Commando_Action, v.indicatorID) -- remove ping
			
			
			--Util_AutoIntel(v.dialogue)
			
			Util_AutoAmbient(t_commando.action.event_ambient_blown)
			
			Util_AutoIntel(t_commando.action.event_factory_blown)
			
			Player_SetPopCapOverride(player1, 60)
			--Player_SetMaxPopulation(player1, CT_Personnel, 56 ) -- gives the player additional population to work with (48 originally, 75)
		
			Rule_AddOneShot(Capture_Points_HQ_Reinforcements_Spawning, 5)
			
			--Util_AutoIntel(t_commando.action.event_get_moving)
			--Rule_AddOneShot(Commando_Siren, 3)
			Rule_AddOneShot(Commando_Factory_Aggressors_Get, 15)
		end
		
	end
	
	if EGroup_IsEmpty(eg_factory_a) == true or (Player_OwnsEGroup(player2, eg_factory_a, false) == false) then
		
		t_commando.action.fg_commandos_all_objectives_ok = true
		
		--Util_AutoIntel(t_commando.action.pre_sit_rep03_02) -- optional?
		
		Rule_RemoveMe()
		
	end
	
end



function Commando_Factory_Aggressors_Get()

	Player_GetAllSquadsNearMarker(player1, sg_factory_aggressors, mkr_factory_detect)
	
	Rule_AddInterval(Commando_Under_Attack_At_Factory, 1)
	
end
	
function Commando_Under_Attack_At_Factory()

	if SGroup_IsEmpty(sg_factory_aggressors) then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttack(sg_factory_aggressors, false, 1) then
			
			-- text to run away
			Util_AutoIntel(t_commando.action.event_get_moving)
			
			Rule_RemoveMe()
			
		end
		
	end

end







function Commando_Reveal_Factory()

	for k, v in pairs (t_commando.factory_data) do
		
		if EGroup_IsEmpty(v.name) == false then
			
			FOW_RevealMarker(v.FOWArea, 60)
			
		end
		
	end
	
	Rule_AddInterval(Commando_Reveal_Factory_Loop, 60)

end


function Commando_Reveal_Factory_Loop()

	if t_commando.action.fg_commandos_all_objectives_ok == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs (t_commando.factory_data) do
			
			if EGroup_IsEmpty(v.name) == false then
				
				FOW_RevealMarker(v.FOWArea, 60)
				
			end
			
		end
		
	end	

end



function Commando_Factory_Flash()
	
	if EGroup_IsEmpty(eg_factory_a) == true then
	
		Rule_RemoveMe()
	
	else
	
		if Prox_PlayerSquadsInProximityOfEntities(player1, eg_factory_a, 25, false) then
			
				Util_AutoIntel(t_commando.action.factory_hq)
				
				flash_ID_factory_charge_button = UI_FlashCommandButton(SCMD_PlaceCharge, true, BT_UI_Strong_AbilityBtn)
				
				hp_ID_factory_charge_button = HintPoint_AddToCommandButton(SCMD_PlaceCharge, g_demo_hint, true)
				
				Rule_AddOneShot(Commando_Factory_Flash_Stop, 15)
				
				
			
				
			
				Rule_RemoveMe()
			
		end
		
	end
	

end


function Commando_Factory_Flash_Stop()

	UI_StopFlashing(flash_ID_factory_charge_button)
	HintPoint_Remove(hp_ID_factory_charge_button)

end




----------------------------
--MEDAL STUFF
-----------------------------

-------------------------------------------------------------------------
-- Medal Opportunity - Sabotage!
-------------------------------------------------------------------------
-------------------------------------------------------------------------
function Initialize_OBJ_Medal_Action()

	OBJ_Medal_Action = {
		
		SetupUI = function() 
			
			OBJ_Medal_Action.LandingID = {}
			
			Objective_SetAlwaysShowDetails(OBJ_Medal_Action, false, true, true)
			
			-- mark a point or position
			tmkr_glider_loc = {mkr_glider1_arrow, mkr_glider2_arrow}
			for i = 1, (table.getn(tmkr_glider_loc)) do
				
				table.insert(OBJ_Medal_Action.LandingID, Objective_AddUIElements(OBJ_Medal_Action, tmkr_glider_loc[i], true, 1339133, true)) 
				
			end
			--LOC("Eliminate the officer and his staff!")
			--OBJ_Medal_Action.mapElementID1 = Objective_AddUIElements(OBJ_Commando_Action, eg_ammo_driver_spawn1, true, 1339158, true) --eg_ammo_driver_spawn1
			
			--local soft_elements = {OBJ_Commando_Action.mapElementID1}
			
			--for k,v in pairs(t_commando.first_objective_data) do 
				--v.indicatorID = soft_elements[k]
			--end
			
			--[[
			OBJ_Commando_Action.mapElementID3 = Objective_AddUIElements(OBJ_Commando_Action, eg_fuel_sheds, true, LOC("Destroy this objective!"), true)
			OBJ_Commando_Action.mapElementID4 = Objective_AddUIElements(OBJ_Commando_Action, eg_fuel_tanks, true, LOC("Destroy this objective!"), true)
			
			local elements = {OBJ_Commando_Action.mapElementID3, OBJ_Commando_Action.mapElementID4}
			
			for k,v in pairs(t_commando.explosion_data) do 
				v.indicatorID = elements[k]
			end]]
			
		end,
		
		OnStart = function()
			
			-- announce the goal
			
			
			-- win/lose check
			--Rule_AddInterval(Commando_Action_WinCheck, 5)
			
			
			Rule_AddDelayedInterval(Commando_Medal_Dialogue_Tracker, 3, 5)
			Rule_AddDelayedInterval(Commando_Medal_Complete_Tracker, 4, 5)
			Rule_AddDelayedInterval(Medal_Detonation_Grab, 5, 1)
			
			-- start related action
			Rule_AddOneShot(Commando_Objective_Medal_Action, 1)
			Rule_AddDelayedInterval(Commando_Fleeing, 4, 5)
			-- EncounterName_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		
		Title = 1339103, --Destroy Targets of Opportunity
		Description = 1339113, -- Use the Royal Commandos to destroy targets of opportunity
		TitleEnd = 1339123 , --Targets of Opportunity Destroyed
		
		Type = OT_Medal,
		MedalID			= MEDALS.CXP1.CARPIQUET,
	}
	
	-- Register Objective
	--Objective_Register(OBJ_Medal_Action)
	-- Initialize Data
	--Commando_Action_Init()
	
end

function Medal_Action_Init()
	t_medal = {
		explosion_data = {
			
			
			{name = eg_generators_blowup, count = EGroup_Count(eg_generators_blowup), destroyed = false,  -- eg_fuel_sheds_blowup
				indicatorID = false, dialogue = 1, FOWArea = mkr_fuel_sheds_reveal, FOWArea2 = mkr_glider1_reveal}, --{{ACTOR.GenericAlly, LOC("<insert British gloat here>!")}}
			
			{name = eg_fuel_tanks_blowup, count = EGroup_Count(eg_fuel_tanks_blowup), destroyed = false, 
				indicatorID = false, dialogue = 2, FOWArea = mkr_fuel_tanks_reveal, FOWArea2 = mkr_glider2_reveal}, -- {{ACTOR.GenericAlly, LOC("<insert another British gloat here>!")}}
		},
		dialogue = {},
		
		--hiding_spots = {eg_hideout1, eg_hideout2},
		
		g_objectives_completed = 0,
		g_complete = false,
	}

	-- DISABLE LATER TO MAKE IT NOT USED?
	t_medal.dialogue.event_fuel_objs = {
	
		{ACTOR.CXP1.Hazard, 1331300}, -- Targets have been updated, the LANDING ZONES are marked!
		{ACTOR.CXP1.Hazard, 1331310}, --Call in Gliders and drop 'em on those marked locations!
		{ACTOR.CXP1.Hazard, 1331320}, -- Quickly men!  We can't be caught out here in the daylight!

	
	}
	--
	--t_medal.dialogue.event_demo1_blown = {
		--{ACTOR.GenericAlly, 1331280}, -- Fallback!  Rendesvous back in our area of control!
		--{ACTOR.GenericAlly, 1331290}, -- Break contact!  Head back to our LZ!
	--}
	
	-- NOT USED YET
	--t_medal.dialogue.event_demo2_blown = {
		--{ACTOR.GenericAlly, 1330650}, -- So much for staying in the dark lads!
		--{ACTOR.GenericAlly, 1330651}, -- Get back to friendly lines right fuckin' quick. 
		--{ACTOR.GenericAlly, 1330652}, -- Bloody Huns didn't see us coming.

	--}
	
	t_medal.dialogue.event_demo1_blown = {
		
		{ACTOR.CXP1.Hazard, 1331465}, -- Into that building. We must hold out until 3rd Bat can relieve us in the morning.
	}
	
	t_medal.dialogue.event_demo2_blown = {
		{ACTOR.CXP1.Hazard, 1331466}, -- Move it. Garrison that building. We must hold until morning.
	}
	
	t_medal.dialogue.event_npc1 = {
		{ACTOR.CXP1.Hazard, 1331462}, -- Hope those 3rd Battalion chaps get here right quick in the morning.
	}
	
	t_medal.dialogue.event_npc2 = {
		{ACTOR.CXP1.Hazard, 1331463}, -- Commandos, that's it for us. We're holding tight until 3rd Battalion can relieve us in the morning.
	}
	
	g_medal_delay_timer = 0
	g_medal_delay_timer_number = 10
	
	
end

------------------------------


function Commando_Objective_Medal_Action()


	--Util_AutoIntel(t_medal.dialogue.event_fuel_objs)
		
	for k, v in pairs (t_medal.explosion_data) do
		
		if EGroup_IsEmpty(v.name) == false then
			
			FOW_RevealMarker(v.FOWArea, 15) -- reveals specified areas
			FOW_RevealMarker(v.FOWArea2, 15) -- reveals specified areas
		end
		
	end
		
	Rule_AddInterval(Medal_Reveal_Objectives, 15)
	
	-- adds fuel tanks and fuel sheds pings
	--[[
	OBJ_Medal_Action.mapElementID1 = Objective_AddUIElements(OBJ_Medal_Action, eg_generators, true, 1339159, true) --LOC("Destroy this target of opportunity")
	OBJ_Medal_Action.mapElementID2 = Objective_AddUIElements(OBJ_Medal_Action, eg_fuel_tanks, true, 1339159, true) --LOC("Destroy this target of opportunity")
		
	local elements = {OBJ_Medal_Action.mapElementID1, OBJ_Medal_Action.mapElementID2}
	
	
	for k,v in pairs(t_medal.explosion_data) do 
		v.indicatorID = elements[k]
	end]]
	
--	Rule_AddDelayedInterval(Commando_Medal_Dialogue_Tracker, 2, 2)
	
	Rule_AddDelayedInterval(Commando_Fuel_Sheds_Flash, 3, 2)
	Rule_AddDelayedInterval(Commando_Fuel_Tanks_Flash, 4, 2)
	
	Rule_AddOneShot(Commando_Landing_Init, 1)
	Rule_AddDelayedInterval(Commando_Medal_Remove_Ping, 1, 1)
	Rule_AddDelayedInterval(Commando_Medal_Hideout_Remove_Ping, 2, 1)
	
	
	
	--Rule_AddDelayedInterval(Commando_Glider_Nag, 1, 1)
	Rule_AddInterval(Commando_Glider_Fighting_Detector, 1)
	
	
	Player_RemoveAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_glider_allow1 )
	Player_RemoveAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_glider_allow2 )
	
	
	-- grants player more population to finish task
	--Player_SetMaxPopulation(player1, CT_Personnel, 24 )
	
	--Util_AutoIntel(t_medal.dialogue.pre_sit_rep03_02)
	
	--Rule_AddOneShot(Commando_Medal_Sitrep_Delay, 5)
	
	
end


function Commando_Medal_Sitrep_Delay()
	--sitrep here! or maybe we can get it to be called once the player drops in a glider
	--Util_AutoNISlet( NISLET_GAME2GAME, t_carpiquet_sitrep.temp_02 )


end
function Medal_Reveal_Objectives()

	if 	t_medal.g_complete == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs (t_medal.explosion_data) do
			
			if EGroup_IsEmpty(v.name) == false then
				
				FOW_RevealMarker(v.FOWArea, 15)
				FOW_RevealMarker(v.FOWArea2, 15) -- reveals specified areas
			end
			
		end

	end	
end



function Commando_Medal_Dialogue_Tracker() -- tracks to see which objective gets destroyed, and if so, remove their ping, also checks to see if all groups are destroyed

	for k, v in pairs (t_medal.explosion_data) do 
	
		if EGroup_IsEmpty(v.name) and v.destroyed == false  then --and v.indicatorID ~= false
		
			v.destroyed = true
		

			if v.dialogue == 1 and SGroup_IsEmpty(sg_hangar_aggressor) == false then
			
				--Util_AutoIntel(t_medal.dialogue.event_demo1_blown)
			
				Util_StartIntel(EVENTS.MEDAL_OBJECTIVE_VANISH)
			
			elseif v.dialogue == 2 and SGroup_IsEmpty(sg_fuel_tanks_aggressor) == false  then
			
				--Util_AutoIntel(t_medal.dialogue.event_demo2_blown)
				
				Util_StartIntel(EVENTS.MEDAL_OBJECTIVE_VANISH)
			
			end
			t_medal.g_objectives_completed = t_medal.g_objectives_completed + 1
			
		end
		
	end
	
end


	
-- tracks to see which objective gets destroyed, and if so, remove their ping, also checks to see if all groups are destroyed
function Commando_Medal_Complete_Tracker()	
	local done = false
	-- if both fuel tanks and generators dead then

	if (EGroup_IsEmpty(eg_fuel_tanks) and EGroup_IsEmpty(eg_generators)) or (f_fuel_tanks_chain_reaction == true and f_generators_chain_reaction == true) then
		
		--if there are commandos hiding or commandos fleeing, etc.
		if SGroup_IsEmpty(sg_hiding_commandos) == false and (t_landing_data[1].fled == true or t_landing_data[2].fled == true)  then
			
			done = true
			
		elseif SGroup_IsEmpty(sg_hiding_commandos) == true then -- if no hiding commandos
			
			if (t_landing_data[1].fled == true or t_landing_data[2].fled == true) then -- if one squad fled and survived (remember, both objectives have been destroyed already)
				
				done = true
				
				-- assumed that nobody fled, then ask if every commando squad is dead
			elseif (SGroup_IsEmpty(sg_generator_commandos) and SGroup_IsEmpty(sg_fuel_tank_commandos)) then
				
				done = true
				
			end
		end
		
	else
		
		-- if 2 gliders landed, yet only 1 or none of the targets got destroyed, and nobody is left or one squad gets destroyed while the other one flees, then fail	
		if g_gliders_landed >= 2 and g_commandos_deployed >= 2 and 
		((SGroup_IsEmpty(sg_fuel_tank_commandos) and SGroup_IsEmpty(sg_generator_commandos)) or
		 (SGroup_IsEmpty(sg_fuel_tank_commandos) and t_landing_data[1].fled == true) or
		 (SGroup_IsEmpty(sg_generator_commandos) and t_landing_data[2].fled == true) or
		 (t_landing_data[1].fled == true and t_landing_data[2].fled == true)) 
		then
			
			if EGroup_IsEmpty(t_landing_data[1].charge) and EGroup_IsEmpty(t_landing_data[2].charge) then
				
				t_medal.g_complete = true -- medal phase is complete but this is a loss
				
				Objective_Fail(OBJ_Medal_Action)
				
				Rule_RemoveMe()
				return
			
			elseif EGroup_IsEmpty(t_landing_data[1].charge) == false or EGroup_IsEmpty(t_landing_data[2].charge) == false then
			-- if at least 1 charge left!  flag set for end
			
				g_medal_pending = true
		
			end
		end
		
	end
	
	if done == true then
		t_medal.g_complete = true
		
		Objective_Complete(OBJ_Medal_Action)
		
		Rule_RemoveMe()
	end
	
end



function Medal_Detonation_Grab()
	
	if EGroup_IsEmpty(eg_fuel_tanks) == true and EGroup_IsEmpty(eg_generators) then
	
		Rule_RemoveMe()
	
	else
		
		for k, v in pairs(t_landing_data) do 
		
			Player_GetAllEntitiesNearMarker(player1, v.charge, v.blast_zone, 35)
		
			EGroup_Filter(v.charge, EBP.CW.DEMOLITION_CHARGE, FILTER_KEEP)
		
		end
		
	end
	
end




function Commando_Fleeing()

	if t_medal.g_complete == true then
	
		Rule_RemoveMe()
	
	else	
		
		for r, s in pairs(t_landing_data) do
		
			if SGroup_IsEmpty(s.aggressor) == false then
			
				if Prox_AreSquadsNearMarker(s.aggressor, mkr_enemy_territory, true) == false then
				
					if SGroup_ContainsSGroup(sg_fled_commandos, s.aggressor, false) == false then
						
						s.fled = true
					
						SGroup_AddGroup(sg_fled_commandos, s.aggressor)
						SGroup_Clear(s.aggressor) -- Maybe...
						
						
					
					end
					
				end
				
			end
			
			if SGroup_IsEmpty(s.commando_group) == false then

				if Prox_AreSquadsNearMarker(s.commando_group, mkr_enemy_territory, true) == false then	
					if SGroup_ContainsSGroup(sg_fled_commandos, s.commando_group, false) == false then
					
					
						if SGroup_Compare(s.aggressor, s.commando_group) == false then
						
							s.fled = true
							SGroup_AddGroup(sg_fled_commandos, s.commando_group)
							--SGroup_Clear(s.aggressor) -- Maybe...
					
						end
					
					end
				
				end
				
			end
		
		end

	end
	
end





--------------------------------
-- Hangar mini-encounter
--------------------------------
function Commando_Hangar_Init()

	tmkr_sentry_spawns = {mkr_hangar3_guard3, mkr_hangar3_guard3}

	sg_commando_hangar_sentry = SGroup_CreateIfNotFound("sg_commando_hangar_sentry")
	
	sg_commando_hangar_reinforcement_runner = SGroup_CreateIfNotFound("sg_commando_hangar_reinforcement_runner")
	
	sg_commando_hangar_reinforcements = SGroup_CreateTable("sg_commando_hangar_reinforcement%d", table.getn(tmkr_sentry_spawns))
	sg_commando_hangar_reinforcement_group = SGroup_CreateIfNotFound("sg_commando_hangar_reinforcement_group")
	sg_commando_hangar_group = SGroup_CreateIfNotFound("sg_commando_hangar_group")
	tsg_commando_hangar_reinforcements_cmd = {} --sg_commando_hangar_reinforcement_runner, sg_commando_hangar_reinforcements[1], sg_commando_hangar_reinforcements[2]
	
	g_hangar_reinforcement_destination = mkr_hangar3_guard3
	
	eg_commando_hangar_hmg = EGroup_CreateIfNotFound("eg_commando_hangar_hmg")
	eg_commando_hangar_munitions = EGroup_CreateIfNotFound("eg_commando_hangar_munitions")
	
	--sg_commando_hangar_tank1 = SGroup_CreateIfNotFound("sg_commando_hangar_tank1")
	--sg_commando_hangar_tank2 = SGroup_CreateIfNotFound("sg_commando_hangar_tank2")
	
	sg_alerted_soldiers = SGroup_CreateTable("sg_alerted_soldiers%d", 3)
	sg_alerted_soldiers_force = SGroup_CreateIfNotFound("sg_alerted_soldiers_force")
	
	sg_alerted_tanks = SGroup_CreateTable("sg_alerted_soldiers%d", 2)
	sg_alerted_tanks_force = SGroup_CreateIfNotFound("sg_alerted_tanks_force")
	
	sg_hangar_aggressor = SGroup_CreateIfNotFound("sg_hangar_aggressor")
	
	sg_hangar_collateral = SGroup_CreateIfNotFound("sg_hangar_collateral")
	eg_hangar_object_collateral = EGroup_CreateIfNotFound("eg_hangar_object_collateral")
	
	t_commando_hangar_data = {
		
		pickups ={
			{name = eg_commando_hangar_hmg, blueprint = EBP.PICKUP.AXIS.LMG_42, loc = mkr_commando_hangar_pickup1},
			{name = eg_commando_hangar_munitions, blueprint = EBP.PICKUP.MUNITIONS, loc = mkr_commando_hangar_pickup2},
		},
		
		tanks = {
			{name = sg_alerted_tanks[1], blueprint = SBP.AXIS.PANZER, loc = mkr_generator_tank},
			--{name = sg_alerted_tanks[2], blueprint = SBP.AXIS.PANZER, loc = mkr_hangar_tank2},
			
		},
		
		alerted = {
			{name = sg_alerted_soldiers[1], blueprint = t_difficulty.g_soldier_type1, loc = mkr_hangar2_guard2, number = 3},
			{name = sg_alerted_soldiers[2], blueprint = t_difficulty.g_soldier_type3, loc = mkr_hangar2_guard2, number = 3},
			--{name = sg_alerted_soldiers[3], blueprint = SBP.AXIS.GRENADIER, loc = mkr_hangar2_guard2, number = 3},
		
		},
	
		
	}
	
	--[[
	t_commando_hangar_dialogue = {
		axis_reinforcements = {
			{ACTOR.GenericAlly, LOC("Damn, they're running to get help!")}
		},
		
		sheds_destroyed = {
			{ACTOR.GenericAlly, LOC("Excellent work! Now make your way back to friendly lines!")}
		
		},
	}]]
	t_commando_hangar_dialogue = {}
	
	-- not used anymore
	--[[
	t_commando_hangar_dialogue.axis_reinforcements = {
		
		--{ACTOR.GenericAlly, LOC("Damn, they're running to get help!")}
		{ACTOR.CXP1.GenericCommonwealth, 1330630}, -- Shite!  Don't let them get away!
		{ACTOR.CXP1.GenericCommonwealth, 1330631}, -- Drop those arse bandits!
		{ACTOR.CXP1.GenericCommonwealth, 1330632}, -- We mustn't let them escape!
		
	}]]
	
	--[[ not used anymore?
	t_commando_hangar_dialogue.sheds_destroyed = {
	
		{ACTOR.GenericAlly, LOC("Excellent work! Now make your way back to friendly lines!")}
		
	}]]
	
	
	t_hangar_sentry_patrol = {
		
		{destination = mkr_sheds_patrol1},
		{destination = mkr_sheds_patrol2},
		{destination = mkr_sheds_patrol3},
		{destination = mkr_sheds_patrol4},
		{destination = mkr_sheds_patrol5},
		{destination = mkr_sheds_patrol6},
		{destination = mkr_sheds_patrol7},
	}
	
	g_hangar_patrol_point_count = table.getn(t_hangar_sentry_patrol)
	
	f_hangar_sentry_garrisoned = false
	
	g_hangar_patrol_place = 1
	
	
		
	--tmkr_fuel_tanks_blast = Marker_GetTable("mkr_fuel_tanks_blast%d")
	--tsg_fuel_tanks_collateral = SGroup_CreateTable("sg_fuel_tanks_collateral%d", 3)
	t_generators_explodegroup = {
	
		--{egroup = eg_generators_blowup, count = EGroup_Count(eg_generators_blowup), collateral = sg_hangar_collateral, blast = mkr_shed_blast_radius }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators1, count = EGroup_CountSpawned(eg_generators1), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius1 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators2, count = EGroup_CountSpawned(eg_generators2), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius1 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators3, count = EGroup_CountSpawned(eg_generators3), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius1 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators4, count = EGroup_CountSpawned(eg_generators4), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators5, count = EGroup_CountSpawned(eg_generators5), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators6, count = EGroup_CountSpawned(eg_generators6), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators7, count = EGroup_CountSpawned(eg_generators7), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators8, count = EGroup_CountSpawned(eg_generators8), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators9, count = EGroup_CountSpawned(eg_generators9), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators10, count = EGroup_CountSpawned(eg_generators10), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators11, count = EGroup_CountSpawned(eg_generators11), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators12, count = EGroup_CountSpawned(eg_generators12), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
		{egroup = eg_generators13, count = EGroup_CountSpawned(eg_generators13), collateral = sg_hangar_collateral, blast = mkr_generator_blast_radius2 }, -- eg_fuel_sheds_blowup
	}
	
	
	
	g_generators_destroyed_count = 0
	g_generators_group_number = table.getn(t_generators_explodegroup)
	
	f_generators_chain_reaction = false --f_fuel_sheds_chain_reaction
	
	
	

end

function Commando_Hangar_Preset()

	-- spawn sentry
	Util_CreateSquads(player2, sg_commando_hangar_sentry, t_difficulty.g_soldier_type1, mkr_commando_sheds_patrol, nil, 1, 5)
	SGroup_AddGroup(sg_commando_hangar_group, sg_commando_hangar_sentry)
	
	Util_CreateSquads(player2, sg_commando_hangar_reinforcement_runner, t_difficulty.g_soldier_type2, mkr_reinforcement_runner_spawn, nil, 1, 5)
	SGroup_AddGroup(sg_commando_hangar_group, sg_commando_hangar_reinforcement_runner)
	SGroup_AddGroup(sg_commando_hangar_reinforcement_group, sg_commando_hangar_reinforcement_runner)
	
	
	for m = 1, table.getn(tmkr_sentry_spawns) do

		Util_CreateSquads(player2, sg_commando_hangar_reinforcements[m], t_difficulty.g_soldier_type1, tmkr_sentry_spawns[m], nil, 1, 4)
		SGroup_AddGroup(sg_commando_hangar_reinforcement_group, sg_commando_hangar_reinforcements[m])
		tsg_commando_hangar_reinforcements_cmd[m] = sg_commando_hangar_reinforcements[m]
	end
	
	tsg_commando_hangar_reinforcements_cmd[table.getn(tmkr_sentry_spawns) + 1] = sg_commando_hangar_reinforcement_runner
	
	
	
	for k, v in pairs(t_commando_hangar_data.pickups) do -- spawning goodies for the player
		local pickup = v
		Util_CreateEntities(nil, pickup.name, pickup.blueprint, pickup.loc, 1)
	end
	
	for k, v in pairs(t_commando_hangar_data.alerted) do -- spawn enemies
		
		Util_CreateSquads(player2, v.name, v.blueprint, v.loc, nil, 1, v.number)
		SGroup_AddGroup(sg_alerted_soldiers_force, v.name)
		SGroup_AddGroup(sg_commando_hangar_group, sg_alerted_soldiers_force)
	end
	
		
	for k, v in pairs(t_commando_hangar_data.tanks) do -- spawn tanks
		
		Util_CreateSquads(player2, v.name, v.blueprint, v.loc)
		SGroup_AddGroup(sg_alerted_tanks_force, v.name)
		SGroup_AddGroup(sg_commando_hangar_group, sg_alerted_soldiers_force)
		
		Modify_WeaponAccuracy(v.name, "hardpoint_01", 0.50)
		Modify_WeaponDamage(v.name, "hardpoint_01", 0.80)
		
	end
	
	Commando_Hangar_Kickoff()

end

function Commando_Hangar_Kickoff()

	Rule_AddInterval(Commando_Hangar_Reinforcements, 2)
	Rule_AddInterval(Commando_Hangar_Patrol, 15)
	Rule_AddInterval(Commando_Hangar_Find_Attacker, 5)
	Rule_AddInterval(Commando_Hangar_Chain_Reaction, 0.5)

end




--makes soldiers run to reinforcements
function Commando_Hangar_Reinforcements()

	if SGroup_IsUnderAttackByPlayer(sg_commando_hangar_group, player1, 1) or EGroup_IsUnderAttackByPlayer(eg_generators, player1, 1) or EGroup_IsEmpty(eg_fuel_sheds) then -- eg_fuel_sheds
	
		--Cmd_UngarrisonSquad(sg_commando_hangar_reinforcement_runner, g_hangar_reinforcement_destination, false)
		
		if SGroup_IsEmpty(sg_commando_hangar_reinforcement_group) == false then
		
			Cmd_Retreat(sg_commando_hangar_reinforcement_runner, mkr_hangar3_guard3)
			
			--Util_AutoIntel(t_commando_hangar_dialogue.axis_reinforcements)
			--Rule_AddOneShot(Commando_Hangar_Retreat_Delay, 10)
			
			Rule_AddDelayedInterval(Commando_Hangar_Reinforcement_Control, 20, 10)

			
		
		end
		
		--SGroup_GetLastAttacker(sg_commando_hangar_group, sg_hangar_aggressor)
		--EGroup_GetLastAttacker(eg_fuel_sheds, sg_hangar_aggressor)
		
		Rule_AddDelayedInterval(Commando_Hangar_Swarm_Control, 10, 1)

		
		Rule_RemoveMe()
	
	end
	


end
--[[
function Commando_Hangar_Retreat_Delay()

	Cmd_Retreat(sg_commando_hangar_reinforcement_runner, mkr_hangar3_guard3)

	--Util_AutoIntel(t_commando_hangar_dialogue.axis_reinforcements)
	
end]]

function Commando_Hangar_Find_Attacker() -- function to find the player units who are attacking the fence forces

	if SGroup_IsEmpty(sg_commando_hangar_group) == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttackByPlayer(sg_commando_hangar_group, player1, 1) then
			
			SGroup_GetLastAttacker(sg_commando_hangar_group, sg_hangar_aggressor)
			
		end
		
		--if EGroup_IsUnderAttackByPlayer(eg_fuel_sheds, player1, 1) then
			
			--EGroup_GetLastAttacker(eg_fuel_sheds, sg_hangar_aggressor)	
				
		--end
		
		
		if EGroup_IsEmpty(eg_generators) == false then -- eg_fuel_sheds
				
			if EGroup_IsUnderAttackByPlayer(eg_generators, player1, 1) then -- eg_fuel_sheds
			
				EGroup_GetLastAttacker(eg_generators, sg_hangar_aggressor)	 -- eg_fuel_sheds
				
			end
				
		else
			
			Player_GetAllSquadsNearMarker(player1, sg_hangar_aggressor, mkr_fuel_sheds_patrol_range)
			
			
		end
		
	end

end



-- moves reinforcements to shed
function Commando_Hangar_Reinforcement_Control()


	if SGroup_IsEmpty(sg_commando_hangar_reinforcement_group) then --EGroup_IsEmpty(eg_fuel_sheds) or?
	
		Rule_RemoveMe()
		
	else
	
		if SGroup_IsEmpty(sg_commando_hangar_reinforcement_group) == false or SGroup_IsUnderAttackByPlayer(sg_commando_hangar_reinforcement_group, player1, 1) == false then
		
			--Cmd_Move(sg_commando_hangar_reinforcement_group, eg_fuel_sheds)
			
			--Cmd_SquadPatrolMarker( sg_commando_hangar_reinforcement_group, mkr_fuel_sheds_patrol_range )
			
			
			--Cmd_Move(sg_commando_hangar_reinforcement_group, mkr_commando_sheds_patrol, nil, nil, nil, nil, nil, 20)
			
			for y = 1, table.getn(tsg_commando_hangar_reinforcements_cmd) do--SGroup_Count(sg_commando_hangar_reinforcement_group) do
			
				
				local force_random = Util_GetRandomPosition(mkr_commando_sheds_patrol, 15)
				
				
				Cmd_Move(tsg_commando_hangar_reinforcements_cmd[y], force_random, nil, nil, nil, nil, nil, 5)
			
			
			end
			
			
			
		end
		
	end
	
end

function Commando_Hangar_Swarm_Control()

	if EGroup_IsEmpty(eg_generators) == true then -- moves them into the area -- eg_fuel_sheds
		
		--Player_AddAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_glider_allow1 )
		
		Rule_AddOneShot(Commando_Hangar_Swarm_Delay, 5)
		Rule_AddOneShot(Commando_Hangar_Tank_Swarm_Delay, 15)
		Rule_RemoveMe()
		
	end

end


function Commando_Hangar_Swarm_Delay()
	--print("alerted soldiers moved!")
		Cmd_SquadPatrolMarker(sg_alerted_soldiers_force, mkr_hangar_patrol_area )

end


function Commando_Hangar_Tank_Swarm_Delay()

	
	
		Cmd_SquadPatrolMarker(sg_alerted_tanks_force, mkr_hangar_patrol_area ) -- moves them into the area mkr_fuel_sheds_patrol_range
		Rule_AddDelayedInterval(Commando_Hangar_Tank_Swarm, 10, 5) 
		
end

--[[
-- detects to see if the sheds are gone and if so then send guys to attack
function Commando_Hangar_Swarm()

	if EGroup_IsEmpty(eg_fuel_sheds) == true then
	
		if SGroup_IsEmpty(sg_hangar_aggressor) then
		
			Rule_RemoveMe()
			
		else
		
			local playerpos = SGroup_GetPosition(sg_hangar_aggressor)
			
			Cmd_AttackMove(sg_alerted_soldiers_force, playerpos)
	
		end
	
	end


end]]


function Commando_Hangar_Tank_Swarm()

	if EGroup_IsEmpty(eg_generators) == true then -- eg_fuel_sheds
		
		if SGroup_IsEmpty(sg_alerted_tanks_force) == false then
		
			-- grab non-aggressor player assets in area including gliders
			local remaining_stuff = SGroup_CreateIfNotFound("remaining_stuff")
			local remaining_entities = EGroup_CreateIfNotFound("remaining_entities")
			Player_GetAllSquadsNearMarker(player1, remaining_stuff, mkr_hangar_patrol_area) 
			Player_GetAllEntitiesNearMarker(player1, remaining_entities, mkr_hangar_patrol_area)
			
			
			if EGroup_IsEmpty(remaining_entities) == false then 
				
				if Player_CanSeeEGroup(player2, remaining_entities, false) then -- if player 2 can see the non-aggressor player assets...
				
					Cmd_Attack(sg_alerted_tanks_force, remaining_entities) -- attack!
					
				else -- if not...
				
					Cmd_Move(sg_alerted_tanks_force, remaining_entities, nil, nil, nil, nil, 15) -- move closer
				
				end
				
				
			else
				if SGroup_IsEmpty(sg_hangar_aggressor) then -- if player 1's aggressor unit gone
						
					if SGroup_IsEmpty(remaining_stuff) == false then
					
						if Player_CanSeeSGroup(player2, remaining_stuff, false) then
						
							Cmd_Attack(sg_alerted_tanks_force, remaining_stuff)
						
						else
							
							Cmd_Move(sg_alerted_tanks_force, remaining_stuff, nil, nil, nil, nil, 15)
							
						end
						
					else
						
						if Prox_AreSquadsNearMarker(sg_alerted_tanks_force, mkr_hangar_patrol_area, false) then
							
							Cmd_Stop(sg_alerted_tanks_force)
							
						else
							
							Cmd_SquadPatrolMarker( sg_alerted_tanks_force, mkr_hangar_patrol_area ) -- mkr_fuel_sheds_patrol_range
						
						end
					
					end
					
					
				else
					
								
					if  Prox_ArePlayersNearMarker(player1, mkr_hangar_patrol_area, false) then-- or SGroup_IsUnderAttackByPlayer(sg_commando_hangar_group, player1, 1) or SGroup_IsUnderAttackByPlayer(sg_alerted_tanks_force, player1, 1) or?
					
						Cmd_SquadPatrolMarker( sg_alerted_tanks_force, mkr_hangar_patrol_area ) --mkr_fuel_sheds_patrol_range
						
					else
						
						if Prox_AreSquadsNearMarker(sg_alerted_tanks_force, mkr_hangar_patrol_area, false) then
							
							Cmd_Stop(sg_alerted_tanks_force)
							
						else
							
							Cmd_SquadPatrolMarker( sg_alerted_tanks_force, mkr_hangar_patrol_area )					
							
						end
						
					end
					
					
				end
			end
		else
			
			Rule_RemoveMe()
			
		end
		
	end

end




function Commando_Hangar_Patrol()

	if SGroup_IsEmpty(sg_commando_hangar_sentry) == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttack(sg_commando_hangar_group, false, 1) == false then
			
			if f_hangar_sentry_garrisoned == true then
				
				--Cmd_UngarrisonSquad(sg_commando_hangar_sentry)
				f_hangar_sentry_garrisoned = false
				
			end
				
			--for y = 1, table.getn(t_officer_patrol) do
				
				if SGroup_IsMoving(sg_commando_hangar_sentry, false) == false then
				
					if g_hangar_patrol_place >= g_hangar_patrol_point_count then
						
						g_hangar_patrol_place = 1
						
					elseif g_hangar_patrol_place <= (g_hangar_patrol_point_count - 1) then
						
						g_hangar_patrol_place = g_hangar_patrol_place + 1
						
					end
					
					Cmd_Move(sg_commando_hangar_sentry, t_hangar_sentry_patrol[g_hangar_patrol_place].destination, nil, nil, nil, nil, nil, 30)
	
				end
				
			--end
			
		elseif SGroup_IsUnderAttack(sg_commando_hangar_group, false, 1) == true then
		
			--if EGroup_IsEmpty(eg_hangar_spawn) == false then
				
				--local last_attacker = SGroup_GetLastAttacker(sg_commando_hangar_group, sg_last_attacker)
				
				Cmd_Move(sg_commando_hangar_sentry, mkr_fuel_sheds_patrol_range, nil, nil, nil, nil, nil, 10) -- use commando_hangar_group for an interesting effect
				--Cmd_Garrison(sg_commando_hangar_sentry, eg_hangar_spawn)
				
				f_hangar_sentry_garrisoned = true
				
			--end
			
		end
		
		
	end
end



function Commando_Hangar_Chain_Reaction()

	for k, v in pairs (t_generators_explodegroup) do
	
		
		if f_generators_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
			
			if EGroup_CountSpawned(v.egroup) < v.count then
				
				EGroup_SetDemolitions(player1, v.egroup, 5)
				Cmd_DetonateDemolitions(player1, v.egroup)
				
				if EGroup_IsEmpty(v.egroup) == false then
					
					EGroup_Kill(v.egroup)
					
				end
				
				--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
				--Commando_Hangar_Collateral(v.collateral)
				
--~ 				Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
--~ 				
--~ 				if SGroup_IsEmpty(v.collateral) == false then
--~ 				
--~ 					Commando_Hangar_Collateral(v.collateral)
--~ 					
--~ 				end
				
				
				f_generators_chain_reaction = true
				
				g_generators_destroyed_count = g_generators_destroyed_count + 1
				
				break
			
			end
			
		elseif f_generators_chain_reaction == true then -- the rest goes boom
			
			if EGroup_IsEmpty(v.egroup) == false then
			
				EGroup_SetDemolitions(player1, v.egroup, 5)
				Cmd_DetonateDemolitions(player1, v.egroup)
				
				EGroup_Kill(v.egroup)
				
				--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
				--Commando_Hangar_Collateral(v.collateral)
				
--~ 				Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
--~ 				
--~ 				if SGroup_IsEmpty(v.collateral) == false then
--~ 					
--~ 					Commando_Hangar_Collateral(v.collateral)
--~ 					
--~ 				end
				
				
				
				g_generators_destroyed_count = g_generators_destroyed_count + 1
				
				break
				
			end
			
		end	
	
	end
	
	if g_generators_destroyed_count == g_generators_group_number then
	
		EGroup_Kill(eg_generators_blowup) -- eg_fuel_sheds_blowup
	
	
		Rule_AddOneShot(Commando_Hangar_Alarm_Delay, 3)
	
		Rule_RemoveMe()
	
	end
	
end

-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Hangar_Collateral(collateral)
--print(SGroup_GetName(collateral))
	SGroup_Kill(collateral)

end


function Commando_Hangar_Alarm_Delay()

	Alarm_Sound(eg_speaker1)

end


----------------------------------
-- Commando Fuel Tanks/Barracks Mini Encounter
----------------------------------


function Commando_Fuel_Tanks_Init()

	sg_fuel_tanks_defenders = SGroup_CreateTable("sg_fuel_tanks_defender%d", 4)
	sg_fuel_tanks_guards = SGroup_CreateTable("sg_fuel_tanks_guard%d", 4)
	sg_fuel_tanks_swarmers = SGroup_CreateTable("sg_fuel_tanks_swarmer%d", 4)
	sg_fuel_tanks_vehicle = SGroup_CreateIfNotFound("sg_fuel_tanks_vehicle")
	
	sg_fuel_tanks_aggressor = SGroup_CreateIfNotFound("sg_fuel_tanks_aggressor")
	
	sg_fuel_tanks_infantry_swarm = SGroup_CreateIfNotFound("sg_fuel_tanks_infantry_swarm")
	sg_fuel_tanks_vehicle_swarm = SGroup_CreateIfNotFound("sg_fuel_tanks_vehicle_swarm")
	
	sg_fuel_tanks_force = SGroup_CreateIfNotFound("sg_fuel_tanks_force")

	sg_fuel_tanks_reinforcements = SGroup_Create("sg_fuel_tanks_reinforcements")
	
	
	
	--eg_fuel_tanks_munitions = EGroup_Create("eg_fuel_tanks_munitions")
	--eg_fuel_tanks_lmg42 = EGroup_Create("eg_fuel_tanks_lmg42")
	
	tmkr_pickup_spots = Marker_GetTable("mkr_fuel_tanks_pickup%d")
	eg_fuel_tanks_pickup = EGroup_CreateTable("eg_fuel_tanks_pickup%d", table.getn(tmkr_pickup_spots))
	
	t_fuel_tanks_soldiers = {
		
		--{name = sg_fuel_tanks_defenders[1], blueprint = t_difficulty.g_soldier_type2, loc = eg_runway_bunker2, number = 5},
		{name = sg_fuel_tanks_defenders[2], blueprint = t_difficulty.g_soldier_type2, loc = eg_runway_bunker3, number = 5},
		{name = sg_fuel_tanks_defenders[3], blueprint = t_difficulty.g_soldier_type1, loc = mkr_counterattack1_rally, number = 3},--eg_fuel_tanks
		{name = sg_fuel_tanks_reinforcements, blueprint = t_difficulty.g_soldier_type2, loc = mkr_fuel_tanks_responders, number = 5},
		{name = sg_fuel_tanks_guards[1], blueprint = t_difficulty.g_soldier_type3, loc = mkr_fuel_tanks_guard1, number = 2},
		{name = sg_fuel_tanks_guards[2], blueprint = t_difficulty.g_soldier_type3, loc = mkr_fuel_tanks_guard2, number = 2},
		{name = sg_fuel_tanks_guards[3], blueprint = SBP.AXIS.HEAVYMG, loc = eg_runway_building_guard, number = 3},
		
	}
	
	t_fuel_tanks_swarmers = {
		infantry = {
			
			{name = sg_fuel_tanks_swarmers[1], blueprint = t_difficulty.g_soldier_type2, loc = eg_barracks2, number = 4},
			
		},
		
		vehicles = {
			
			{name = sg_fuel_tanks_vehicle, blueprint = SBP.AXIS.PANZER, loc = mkr_fuel_tanks_vehicle1, number = 1},
			
		},
	}
	
	t_fuel_tanks_data = {
			
		pickups ={
			{name = eg_fuel_tanks_pickup[1], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = mkr_fuel_tanks_pickup1},
			{name = eg_fuel_tanks_pickup[2], blueprint = EBP.PICKUP.AXIS.LMG_42, loc = mkr_fuel_tanks_pickup2},
			{name = eg_fuel_tanks_pickup[3], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = mkr_fuel_tanks_pickup3},
		},
	}
	
	tmkr_fuel_tanks_blast = Marker_GetTable("mkr_fuel_tanks_blast%d")
	tsg_fuel_tanks_collateral = SGroup_CreateTable("sg_fuel_tanks_collateral%d", 3)
	t_fuel_tanks_explodegroup = {
	
		{egroup = eg_fuel_tanks_explodegroup1, count = EGroup_Count(eg_fuel_tanks_explodegroup1), collateral = tsg_fuel_tanks_collateral[1], blast = tmkr_fuel_tanks_blast[1], destroyed = false},
		{egroup = eg_fuel_tanks_explodegroup2, count = EGroup_Count(eg_fuel_tanks_explodegroup2), collateral = tsg_fuel_tanks_collateral[2], blast = tmkr_fuel_tanks_blast[2], destroyed = false},
		{egroup = eg_fuel_tanks_explodegroup3, count = EGroup_Count(eg_fuel_tanks_explodegroup3), collateral = tsg_fuel_tanks_collateral[3], blast = tmkr_fuel_tanks_blast[3], destroyed = false},
	}
	
	sg_escape_enemies = SGroup_CreateIfNotFound("sg_escape_enemies")
	
	t_fuel_tanks_escape_enemies = {
	
		{name = sg_escape_enemies, blueprint = SBP.AXIS.VOLKSGRENADIER, loc = mkr_gate_bunker_door1, number = 3},
	
	}
	
	g_escape_timer = 0
	g_escape_time_limit = 150
	
	g_fuel_tanks_destroyed_count = 0
	g_fuel_tanks_group_number = table.getn(t_fuel_tanks_explodegroup)
	
	f_fuel_tanks_chain_reaction = false
	
	LAYER_FENCE = EGroup_CreateIfNotFound("LAYER_FENCE")
	
	teg_fencegroup = {eg_fence1, eg_fence2, eg_fence3}
	
	g_fence_attacked = false
	
	--[[
	t_fuel_tanks_dialogue = {
		
		escape = {
			
			{ACTOR.GenericAlly, LOC("Hello, that looks like a weak spot in their fence...")}
			
		},
		
	}
	]]
	t_fuel_tanks_dialogue = {}
	t_fuel_tanks_dialogue.escape = {
	-- will be disabled and NOT USED soon
		--{ACTOR.GenericAlly, LOC("Hello, that looks like a weak spot in their fence...")}
		{ACTOR.CXP1.GenericCommonwealth, 1331440}, -- Looks like  an escape route to me, eh!
		{ACTOR.CXP1.GenericCommonwealth, 1331450}, -- Let's blow open a new route! Get some grenades on it gents!
		{ACTOR.CXP1.GenericCommonwealth, 1331460}, -- We got it, now let's move!

	}
	
	
	--[[
	teg_fuel_tanks_explodeobject_count = {}
	
	for z = 1, table.getn(teg_fuel_tanks_explodegroup) do
		
		table.insert(teg_fuel_tanks_explodeobject_count, EGroup_Count(eg_fuel_tanks_explodegroup1[z]))
	
	end]]
	
	
	--[[
	t_fuel_tanks_explode_data = {}
	t_fuel_tanks_explode_data[1] = {egroup = eg_explodegroup1}
	t_fuel_tanks_explode_data[2] = {egroup = eg_explodegroup2}
	
	for n = 1, table.getn(t_fuel_tanks_explode_data) do
		t_fuel_tanks_explode_data[n].count = EGroup_Count(t_fuel_tanks_explode_data[n].egroup)
	end]]
	
	
end


function Commando_Fuel_Tanks_Preset()

	--EGroup_SetPlayerOwner(eg_runway_bunker2, nil) -- player2
	EGroup_SetPlayerOwner(eg_runway_bunker3, player2) -- player2
	
	for k, v in pairs (t_fuel_tanks_soldiers) do
		
		Util_CreateSquads(player2, v.name, v.blueprint, v.loc,  nil, 1, v.number)
		SGroup_AddGroup(sg_fuel_tanks_force, v.name)
		--SGroup_AddGroup(sg_fuel_tanks_infantry_swarm, v.name)	
		
	end

	--Cmd_InstantUpgrade(eg_runway_bunker2, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	Cmd_InstantUpgrade(eg_runway_bunker3, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	
	for k, v in pairs(t_fuel_tanks_data.pickups) do -- spawning goodies for the player
		
		Util_CreateEntities(nil, v.name, v.blueprint, v.loc, 1)
		

		
	end
	
	Rule_AddOneShot(Commando_Fuel_Tanks_Kickoff,0)

end

function Commando_Fuel_Tanks_Kickoff()

	Rule_AddInterval(Commando_Fuel_Tanks_Reinforcements, 1)
	Rule_AddDelayedInterval(Commando_Fuel_Tanks_Swarm_Creator, 1, 10)
	Rule_AddInterval(Commando_Fuel_Tanks_Chain_Reaction, 1)
	
end


function Commando_Fuel_Tanks_Reinforcements() -- kicks off reinforcement stuff, makes the pre-placed reinforcements attack
	
	if SGroup_IsUnderAttackByPlayer(sg_fuel_tanks_force, player1, 1) or EGroup_IsUnderAttackByPlayer(eg_fuel_tanks_blowup, player1, 1) or EGroup_IsEmpty(eg_fuel_tanks) then 
	
		Rule_AddOneShot(Commando_Fuel_Tanks_Reinforcements_Move, 5)
		
		Rule_AddInterval(Commando_Fuel_Tanks_Find_Attacker, 5)
		
		--Rule_AddInterval(Commando_Escape_Trigger, 3)
		
		
		Rule_RemoveMe()
		
	end


end

function Commando_Fuel_Tanks_Reinforcements_Move()

	if SGroup_IsEmpty(sg_fuel_tanks_reinforcements) == false then
		
		Cmd_Move(sg_fuel_tanks_reinforcements, mkr_fuel_tanks_defense_location3, nil, nil, nil, nil, nil, 10)
		SGroup_AddGroup(sg_fuel_tanks_infantry_swarm, sg_fuel_tanks_reinforcements)
		
		Rule_AddDelayedInterval(Commando_Fuel_Tanks_Reinforcements_Control, 40, 5)
		
	else
	
		Rule_RemoveMe()
	
	end

end


function Commando_Fuel_Tanks_Reinforcements_Control()

	if SGroup_IsEmpty(sg_fuel_tanks_reinforcements) == false and SGroup_IsUnderAttack(sg_fuel_tanks_reinforcements, false, 1) then

		Cmd_SquadPatrolMarker(sg_fuel_tanks_reinforcements, mkr_fuel_tanks_reveal)-- tells infantry to patrol the marker area
	
	else
	
		Rule_RemoveMe()
		
		
	end
	
end


function Commando_Fuel_Tanks_Find_Attacker() -- function to find the player units who are attacking the fence forces

	if SGroup_IsEmpty(sg_fuel_tanks_force) == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttackByPlayer(sg_fuel_tanks_force, player1, 1) then
			
			if SGroup_IsEmpty(sg_fuel_tanks_aggressor) then
				SGroup_GetLastAttacker(sg_fuel_tanks_force, sg_fuel_tanks_aggressor)
			end
			--print("aha")
			
		end
		
		--if EGroup_IsUnderAttackByPlayer(eg_fuel_tanks, player1, 1) then
			
			--print("debug1")
			--EGroup_GetLastAttacker(eg_fuel_tanks, sg_fuel_tanks_aggressor)
			
		--end
		
		if EGroup_IsEmpty(eg_fuel_tanks) == false then
			
			if EGroup_IsUnderAttackByPlayer(eg_fuel_tanks, player1, 1) then
				
				if SGroup_IsEmpty(sg_fuel_tanks_aggressor) then
					EGroup_GetLastAttacker(eg_fuel_tanks, sg_fuel_tanks_aggressor)
					
				end
				
			end
			
		else
			if SGroup_IsEmpty(sg_fuel_tanks_aggressor) then
				Player_GetAllSquadsNearMarker(player1, sg_fuel_tanks_aggressor, mkr_fuel_tanks_reveal)
			end
			
		end
		
		
		
	end

end


function Commando_Fuel_Tanks_Swarm_Creator() -- creates the swarm that will attack the player after the objective is destroyed

	if EGroup_IsEmpty(eg_fuel_tanks) then
		
		--Player_AddAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_glider_allow2 )
		
		
		if EGroup_IsEmpty(eg_barracks2) == false then
			
			for k, v in pairs (t_fuel_tanks_swarmers.infantry) do
				
				Util_CreateSquads(player2, v.name, v.blueprint, v.loc, mkr_fuel_tanks_defense_location1, 1, v.number)
				SGroup_AddGroup(sg_fuel_tanks_force, v.name)
				SGroup_AddGroup(sg_fuel_tanks_infantry_swarm, v.name)
				
				--print("1")
				
			end
		end
		
		if EGroup_IsEmpty(eg_barracks2) == false then
			
			for k, v in pairs (t_fuel_tanks_swarmers.vehicles) do
				
				Util_CreateSquads(player2, v.name, v.blueprint, v.loc,  nil, 1, v.number)
				SGroup_AddGroup(sg_fuel_tanks_force, v.name)
				SGroup_AddGroup(sg_fuel_tanks_vehicle_swarm, v.name)
				
				Modify_WeaponAccuracy(v.name, "hardpoint_01", 0.50)
				Modify_WeaponDamage(v.name, "hardpoint_01", 0.85)
				
				
				--print("2")
			end	
		end
		
		
		if SGroup_IsEmpty(sg_fuel_tanks_guards[1]) == false then -- kept seperate from swarm to prevent clumping
		
			Cmd_SquadPatrolMarker(sg_fuel_tanks_guards[1], mkr_fuel_tanks_reveal)-- tells infantry to patrol the marker area
		
		end
		
		
		if SGroup_IsEmpty(sg_fuel_tanks_guards[2]) == false then -- kept seperate from swarm to prevent clumping
		
			Cmd_SquadPatrolMarker(sg_fuel_tanks_guards[2], mkr_fuel_tanks_reveal)-- tells infantry to patrol the marker area
		
		end
		
		
		Cmd_SquadPatrolMarker(sg_fuel_tanks_infantry_swarm, mkr_fuel_tanks_reveal)-- tells infantry to patrol the marker area
		--Cmd_SquadPatrolMarker(sg_fuel_tanks_vehicle_swarm, mkr_fuel_tanks_reveal)-- tells tanks to patrol the marker area
		Cmd_Move(sg_fuel_tanks_vehicle_swarm, mkr_axis_tank_guard)
		
		
		--Rule_AddDelayedInterval(Commando_Fuel_Tanks_Infantry_Swarm, 1, 10) -- might not need because we don't care what the infantry does
		
		-- WE DO care about this because vehicles run over stuff and we don't want that.. ^_^;;; HOWEVER, we need this to kick in once the tank gets into the marker area
		-- To let this happen, we'll just give the tank 20 seconds to get to the marker area before any potential stop commands are given to it (via Commando_Fuel_Tanks_Vehicle_Swarm)
		Rule_AddDelayedInterval(Commando_Fuel_Tanks_Vehicle_Swarm, 20, 5) 
		
		Rule_RemoveMe()
		
	end
	
end


--[[
function Commando_Fuel_Tanks_Infantry_Swarm()

	
	if EGroup_IsEmpty(eg_fuel_tanks) == true then
		
		if SGroup_IsEmpty(sg_fuel_tanks_aggressor) then
			
			Rule_RemoveMe()
			
		else
			
			Cmd_SquadPatrolMarker( sg_fuel_tanks_infantry_swarm, mkr_fuel_tanks_reveal )
			

			
			--local playerpos = SGroup_GetPosition(sg_fuel_tanks_aggressor)
			
			--Cmd_AttackMove(sg_fuel_tanks_infantry_swarm, playerpos)
			
		end
		
	end
	
end]]

function Commando_Fuel_Tanks_Vehicle_Swarm()

	
	if EGroup_IsEmpty(eg_fuel_tanks) == true then
		
		if SGroup_IsEmpty(sg_fuel_tanks_vehicle_swarm) == false then
		
			
			-- grab non-aggressor player assets in area including gliders
			local remaining_stuff2 = SGroup_CreateIfNotFound("remaining_stuff2")
			local remaining_entities2 = EGroup_CreateIfNotFound("remaining_entities2")
			Player_GetAllSquadsNearMarker(player1, remaining_stuff2, mkr_fuel_tanks_patrol_area) 
			Player_GetAllEntitiesNearMarker(player1, remaining_entities2, mkr_fuel_tanks_patrol_area)
			
			if EGroup_IsEmpty(remaining_entities2) == false then
				
				if Player_CanSeeEGroup(player2, remaining_entities2, false) then -- if the computer can see these entities
					
					Cmd_Attack(sg_fuel_tanks_vehicle_swarm, remaining_entities2) -- attack!
					
				else -- if not...
					
					Cmd_Move(sg_fuel_tanks_vehicle_swarm, remaining_entities2, nil, nil, nil, nil, 15)  -- move closer!
					
				end
			
			else	
				if SGroup_IsEmpty(sg_fuel_tanks_aggressor) then -- if the player has hidden already..
				
					if SGroup_IsEmpty(remaining_stuff2) == false then
						
						if Player_CanSeeSGroup(player2, remaining_stuff2, false) then
						
							Cmd_Attack(sg_fuel_tanks_vehicle_swarm, remaining_stuff2)
						
						else
						
							Cmd_Move(sg_fuel_tanks_vehicle_swarm, remaining_stuff2, nil, nil, nil, nil, 15)
						
						end
						
					else
						
						if Prox_AreSquadsNearMarker(sg_fuel_tanks_vehicle_swarm, mkr_fuel_tanks_patrol_area, false) then
							
							Cmd_Stop(sg_fuel_tanks_vehicle_swarm)
							
						else
							
							Cmd_SquadPatrolMarker( sg_fuel_tanks_vehicle_swarm, mkr_fuel_tanks_patrol_area )
						
						end
					end
				
				else
					
					if Prox_ArePlayersNearMarker(player1, mkr_fuel_tanks_reveal, false) then-- or SGroup_IsUnderAttackByPlayer(sg_fuel_tanks_force, player1, 1) or SGroup_IsUnderAttackByPlayer(sg_fuel_tanks_infantry_swarm, player1, 1)?
						
						Cmd_SquadPatrolMarker( sg_fuel_tanks_vehicle_swarm, mkr_fuel_tanks_patrol_area ) -- mkr_fuel_tanks_reveal
						
					else
						
						if Prox_AreSquadsNearMarker(sg_fuel_tanks_vehicle_swarm, mkr_fuel_tanks_patrol_area, false) then
						
							Cmd_Stop(sg_fuel_tanks_vehicle_swarm)
						
						else
							
							--Cmd_SquadPatrolMarker( sg_fuel_tanks_vehicle_swarm, mkr_fuel_tanks_reveal )					
							Cmd_Move(sg_fuel_tanks_vehicle_swarm, mkr_axis_tank_guard)
							
						end
						
					end
					
					--[[
					local playerpos = SGroup_GetPosition(sg_fuel_tanks_aggressor)
					
					Cmd_AttackMove(sg_fuel_tanks_vehicle_swarm, playerpos)]]
				end
				
			end
			
		else
		
			Rule_RemoveMe()
		
		end
		
	end
	
end


function Commando_Fuel_Tanks_Chain_Reaction()

	for k, v in pairs (t_fuel_tanks_explodegroup) do
	
		
		if f_fuel_tanks_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
			
			if EGroup_Count(v.egroup) < v.count then
				
				EGroup_Kill(v.egroup)
				
				--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
				--Commando_Fuel_Tanks_Collateral(v.collateral)
				Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
				
				if SGroup_IsEmpty(v.collateral) == false then
					
					Commando_Fuel_Tanks_Collateral(v.collateral)
					
				end
				
				f_fuel_tanks_chain_reaction = true
				
				g_fuel_tanks_destroyed_count = g_fuel_tanks_destroyed_count + 1
				
				break
			
			end
			
		elseif f_fuel_tanks_chain_reaction == true then -- the rest goes boom
			
			if EGroup_IsEmpty(v.egroup) == false then
			
				EGroup_Kill(v.egroup)
				
				--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
				--Commando_Fuel_Tanks_Collateral(v.collateral)
				Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
				
				if SGroup_IsEmpty(v.collateral) == false then
					Commando_Fuel_Tanks_Collateral(v.collateral)
				end
				
				g_fuel_tanks_destroyed_count = g_fuel_tanks_destroyed_count + 1
				
				break
				
			end
			
		end	
	
	end
	
	if g_fuel_tanks_destroyed_count == g_fuel_tanks_group_number then
	
		EGroup_Kill(eg_fuel_tanks_blowup)
		
		Rule_AddOneShot(Commando_Fuel_Tanks_Alarm_Delay, 3)
		
		Rule_RemoveMe()
	
	end
	
end


function Commando_Fuel_Tanks_Alarm_Delay()

	Alarm_Sound(eg_speaker2)

end



-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Fuel_Tanks_Collateral(collateral)

	SGroup_Kill(collateral)

end


-- for when the player moves out of the area
function Commando_Fuel_Tanks_Hard_Counter_Spawn()

	if t_medal.g_complete == true or g_fuel_tank_counter_units == 2 then
		
		Rule_RemoveMe()
		
	else	
		
		if SGroup_IsEmpty(sg_fuel_tank_commandos) == false then
		
			for k, v in pairs(t_fuel_tank_hard_counter_data) do
			
				if v.activated == false then
				
					if Prox_AreSquadsNearMarker(sg_fuel_tank_commandos, v.boundary, false) then
					
						Util_CreateSquads(player2, v.countername, v.countertype, v.counterspawn, nil, 1)
						
						
						if Rule_Exists(Commando_Fuel_Tanks_Hard_Counter_Manager) == false then
							
							Rule_AddInterval(Commando_Fuel_Tanks_Hard_Counter_Manager, 1)
							
						end
						
						v.activated = true
						
						g_fuel_tank_counter_units = g_fuel_tank_counter_units + 1
					
					end
					
				end
			
			end
			
		end
	end

end


function Commando_Fuel_Tanks_Hard_Counter_Manager()

	if t_medal.g_complete == true and SGroup_IsEmpty(sg_fuel_tank_commandos) == true then

		Rule_RemoveMe()
		
	else
	
		if SGroup_IsEmpty(sg_fuel_tank_commandos) == false then
		
			for k, v in pairs(t_fuel_tank_hard_counter_data) do
			
				if v.activated == true then
				
					if SGroup_IsEmpty(v.countername) == true and v.timetospawn < 10 then
					
						v.timetospawn = v.timetospawn + 1
					
					elseif SGroup_IsEmpty(v.countername) == true and v.timetospawn >= 10 then

						Util_CreateSquads(player2, v.countername, v.countertype, v.counterspawn, nil, 1)
						
						v.timetospawn = 0
						
					elseif SGroup_IsEmpty(v.countername) == false then
						
						Cmd_AttackMove(v.countername, SGroup_GetPosition(sg_fuel_tank_commandos), false, nil, 20)
						
					end
				end
			end
		end
	end
end


function Commando_Hangar_Hard_Counter_Spawn()

	if t_medal.g_complete == true or g_generator_counter_units == 2 then
		
		Rule_RemoveMe()
		
	else	
		
		if SGroup_IsEmpty(sg_generator_commandos) == false then
		
			for k, v in pairs(t_generator_hard_counter_data) do
			
				if v.activated == false then
				
					if Prox_AreSquadsNearMarker(sg_generator_commandos, v.boundary, false) then
					
						Util_CreateSquads(player2, v.countername, v.countertype, v.counterspawn, nil, 1)
						
						if Rule_Exists(Commando_Hangar_Hard_Counter_Manager) == false then
						
							Rule_AddInterval(Commando_Hangar_Hard_Counter_Manager, 1)
							
						end
						
						v.activated = true
						
						g_generator_counter_units = g_generator_counter_units + 1
					
					end
					
				end
			
			end
			
		end
	end

end


function Commando_Hangar_Hard_Counter_Manager()

	if t_medal.g_complete == true and SGroup_IsEmpty(sg_generator_commandos) == true then

		Rule_RemoveMe()
		
	else
	
		if SGroup_IsEmpty(sg_generator_commandos) == false then
		
			for k, v in pairs(t_generator_hard_counter_data) do
			
				if v.activated == true then
				
					if SGroup_IsEmpty(v.countername) == true and v.timetospawn < 10 then
					
						v.timetospawn = v.timetospawn + 1
					
					elseif SGroup_IsEmpty(v.countername) == true and v.timetospawn >= 10 then

						Util_CreateSquads(player2, v.countername, v.countertype, v.counterspawn, nil, 1)
						
						v.timetospawn = 0
						
					elseif SGroup_IsEmpty(v.countername) == false then
						
						Cmd_AttackMove(v.countername, SGroup_GetPosition(sg_generator_commandos), false, nil, 20)
						
					end
				end
			end
		end
	end
end

---------------
-- Carpiquet Factory mini-encounter stuff 
----------------

function Commando_Factory_Init()

	sg_factory_defenders = SGroup_CreateIfNotFound("sg_factory_defenders")
	sg_factory_guards = SGroup_CreateIfNotFound("sg_factory_guards")
	sg_factory_patrol = SGroup_CreateIfNotFound("sg_factory_patrol")
	sg_factory_officer = SGroup_CreateIfNotFound("sg_factory_officer")
	sg_factory_car_patrol = SGroup_CreateIfNotFound("sg_factory_car_patrol")
	sg_factory_reinforcements = SGroup_CreateIfNotFound("sg_reinforcements")
	sg_factory_force = SGroup_CreateIfNotFound("sg_factory_force")
	sg_factory_aa = SGroup_CreateIfNotFound("sg_factory_aa")
	sg_factory_aggressors = SGroup_CreateIfNotFound("sg_factory_aggressors") -- player's attackers
	
	EGroup_SetPlayerOwner(eg_factory_a, player2) -- player2
	Cmd_InstantUpgrade(eg_factory_a, UPG.AXIS.CONVERT_AMBIENT_BUILDING)
	
	
	g_factory_reinforcement_spawn = eg_carpiquet_building4
	
	tmkr_factory_pickup_spots = Marker_GetTable("mkr_factory_pickup%d")
	eg_factory_pickup = EGroup_CreateTable("eg_factory_pickup%d", table.getn(tmkr_factory_pickup_spots))
	
	tmkr_factory_patrol = Marker_GetTable("mkr_factory_patrol%d")
	tmkr_factory_2ndpatrol = Marker_GetTable("mkr_factory_2ndpatrol%d")
	tmkr_factory_car_patrol = Marker_GetTable("mkr_factory_car_patrol%d")
	
	t_commando_factory_data = {
		
		soldiers = {
		
			{name = sg_factory_defenders, blueprint = t_difficulty.g_soldier_type3, loc = mkr_factory_spawn, number = 3},
			{name = sg_factory_guards, blueprint = t_difficulty.g_soldier_type1, loc = mkr_factory_guards_spawn, number = 3},
			{name = sg_factory_patrol, blueprint = t_difficulty.g_soldier_type2, loc = mkr_factory_patrol_spawn, number = 3},
			{name = sg_factory_officer, blueprint = SBP.AXIS.OFFICER, loc = mkr_factory_officer, number = 1},
			
		},
		
		vehicles = {
			
			--{name = sg_factory_car_patrol, blueprint = SBP.AXIS.MOTORCYCLE, loc = mkr_factory_car_patrol_spawn, number = 1},
			{name = sg_factory_car_patrol, blueprint = SBP.ELITE.ARMOURCAR_221, loc = mkr_factory_car_patrol_spawn, number = 1},
		},
		
		pickups ={
			
			{name = eg_factory_pickup[1], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_factory_pickup_spots[1]},
			{name = eg_factory_pickup[2], blueprint = EBP.PICKUP.AXIS.LMG_42, loc = tmkr_factory_pickup_spots[2]},
			{name = eg_factory_pickup[3], blueprint = EBP.PICKUP.AXIS.LMG_42, loc = tmkr_factory_pickup_spots[3]},
			{name = eg_factory_pickup[4], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_factory_pickup_spots[4]},
			{name = eg_factory_pickup[5], blueprint = EBP.PICKUP.AXIS.LMG_42, loc = tmkr_factory_pickup_spots[5]},
		},
		
		patrolpath = {},
		secondpatrolpath = {},
		car_patrolpath = {},
		
		objective_data = {
			
			
			
		},
	}
	
	-- fills in patrol path so all we have to do is drop in a new marker every time we want to extend the patrol
	for z = 1, table.getn(tmkr_factory_patrol) do
		
		table.insert(t_commando_factory_data.patrolpath, tmkr_factory_patrol[z] )
	
	end
	
	g_factory_patrol_place = 1
	g_factory_patrol_point_count = table.getn(tmkr_factory_patrol)
	
	f_factory_garrisoned = false
	
	for z = 1, table.getn(tmkr_factory_2ndpatrol) do
		
		table.insert(t_commando_factory_data.secondpatrolpath, tmkr_factory_2ndpatrol[z] )
	
	end
	
	g_factory_2ndpatrol_place = 1
	g_factory_2ndpatrol_point_count = table.getn(tmkr_factory_2ndpatrol)
	
	
	for z = 1, table.getn(tmkr_factory_car_patrol) do
		
		table.insert(t_commando_factory_data.car_patrolpath, tmkr_factory_car_patrol[z] )
	
	end
	
	g_factory_car_patrol_place = 1
	g_factory_car_patrol_point_count = table.getn(tmkr_factory_car_patrol)
	
	f_factory_garrisoned = false
	f_factory_guard_garrisoned = false
end

function Commando_Factory_Preset()
	--soldiers
	for k, v in pairs (t_commando_factory_data.soldiers) do
		
		Util_CreateSquads(player2, v.name, v.blueprint, v.loc,  nil, 1, v.number)
		SGroup_AddGroup(sg_factory_force, v.name)
		
	end
	
	-- pickups
	for k, v in pairs (t_commando_factory_data.pickups) do
		
		Util_CreateEntities(player2, v.name, v.blueprint, v.loc,  1)
		
	end
	
	--vehicles
	for k, v in pairs (t_commando_factory_data.vehicles) do
		
		Util_CreateSquads(player2, v.name, v.blueprint, v.loc,  nil, 1, v.number)
		SGroup_AddGroup(sg_factory_force, v.name)
		
		Modify_SightRadius(v.name, 0.5)
		Modify_WeaponRange(v.name, "hardpoint_01", 0.75)
		--Modify_WeaponAccuracy(v.name, "hardpoint_01", 0.5)
		Modify_UnitSpeed(v.name, 0.5)
		
	end
	Rule_AddOneShot(Commando_Factory_Kickoff,0)
	
	g_ff_count = SGroup_TotalMembersCount(sg_factory_force)
		
end



function Commando_Factory_Kickoff()

	Rule_AddInterval(Commando_Factory_Patrol, 10)
	Rule_AddInterval(Commando_Factory_2ndPatrol, 5)
	Rule_AddInterval(Commando_Factory_Car_Patrol, 15)
	--Rule_AddInterval(Commando_Factory_Guard_Action, 5)
	Rule_AddInterval(Commando_Factory_AA_Grab, 5)
	Rule_AddInterval(Commando_Factory_Alarm_Delay, 3)
	Rule_AddInterval(Commando_Factory_Carpiquet_Secondary_Objective_Kickoff, 3)
	
	--Rule_AddInterval(Commando_Factory_Alarm_Detect, 5)
	Rule_Add(Commando_Factory_Detonation_Detect)
	
	

	
end


function Commando_Factory_Patrol() -- controls the patrol near the Factory

	if SGroup_IsEmpty(sg_factory_patrol) == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttack(sg_factory_force, false, 1) == false then
			
			--[[
			if f_factory_garrisoned == true then
				
				
				f_factory_garrisoned = false
				
			end]]
				
			if SGroup_IsMoving(sg_factory_patrol, false) == false then
			
				if g_factory_patrol_place >= g_factory_patrol_point_count then
					
					g_factory_patrol_place = 1
					
				elseif g_factory_patrol_place <= (g_factory_patrol_point_count - 1) then
					
					g_factory_patrol_place = g_factory_patrol_place + 1
					
				end
				
				Cmd_Move(sg_factory_patrol, t_commando_factory_data.patrolpath[g_factory_patrol_place], nil, nil, nil, nil, nil, 30)
				
			end
			
			
			
		elseif SGroup_IsUnderAttack(sg_factory_force, false, 1) == true then
			--[[
			if EGroup_IsEmpty(eg_factory_a) == false then
				
				f_factory_garrisoned = true
				
			end]]
			
		end
		
	end

end

--[[
function Commando_Factory_Alarm_Detect()

	if SGroup_IsUnderAttackByPlayer(sg_factory_force, player1, 1) then
			
		Rule_AddOneShot(Commando_Factory_Alarm_Delay, 3)
			
		Rule_RemoveMe()		
		
	end

end]]


function Commando_Factory_Alarm_Delay()

	if (SGroup_IsUnderAttack(sg_factory_force, false, 1) == true or SGroup_IsUnderAttack(sg_carpiquet_enemies, false, 1) == true) then
	
		Alarm_Sound(eg_speaker3)

		Util_AutoAmbient(t_commando.action.event_alarm)
		
		Rule_AddOneShot(Commando_Factory_Mortar_Pickup, 5)
		
		Rule_AddOneShot(Commando_Factory_AA_Pickup, 5)
	
		Rule_RemoveMe()
		
	end
	
	
	
end

function Commando_Factory_Mortar_Pickup()

	if EGroup_IsEmpty(t_at_gun.pickups[1].name) == false then
		
		t_at_gun.pickups[1].hintpoint_ID = HintPoint_Add(t_at_gun.pickups[1].name, true, t_at_gun.pickups[1].hintpoint_text)  -- hint to pick up panzershreck if the player hasn't done it yet
		
	end

end

function Commando_Factory_AA_Pickup() -- arrow on top of alternate weapon for player

	if EGroup_IsEmpty(eg_factory_aa) == false then --eg_factory_pickup[2] -- eg_factory_aa
		aa_pickup_ID = HintPoint_Add(eg_factory_aa, true, 1419142)  -- hint to pick up weapon if the player hasn't done it yet -- eg_factory_pickup[2] --eg_factory_aa
	end

	Rule_AddInterval(Commando_Factory_AA_Pickup_Remove, 1)
	
end


function Commando_Factory_AA_Pickup_Remove()

	if SGroup_IsEmpty(sg_factory_force) or EGroup_IsEmpty(eg_factory_a) then
		
		HintPoint_Remove(aa_pickup_ID)
		
		Rule_RemoveMe()
		
	end

end


----------
-- Detonations! -- Factory
------------

function Commando_Factory_Detonation_Detect()

	if EGroup_IsEmpty(eg_factory_a) == false then -- checks to see if the factory is empty

		local factoryid = EGroup_GetSpawnedEntityAt(eg_factory_a, 1) -- grabs the factory entity id
		
		if Entity_IsDemolitionReady(factoryid) then -- if factory is demo ready then...

			Entity_SetDemolitions(player1, factoryid, 8) -- plant additional demo charges :D
			EGroup_SetDemolitions(player1, eg_factory_a, 8)
			
			Rule_Add(Commando_Factory_Detonation_Check)
			
			Rule_RemoveMe()
		
		elseif EGroup_GetAvgHealth(eg_factory_a) <= 0.75 then
			
			Rule_Add(Commando_Factory_Detonation_Check)
			
			Rule_RemoveMe()
			
		end
		
	end
	
end

function Commando_Factory_Detonation_Check()

	if EGroup_IsEmpty(eg_factory_a) == false then
		
		EGroup_NotifyOnPlayerDemolition(eg_factory_a, Commando_Factory_Detonation)  -- once player tries to detonate... call the Commando_Factory_Detonation function

	else
	
		Rule_RemoveMe()
		
	end


end

function Commando_Factory_Detonation()

	if EGroup_IsEmpty(eg_factory_a) == false then
	
	
		Cmd_DetonateDemolitions(player1, eg_factory_a)
	
		if EGroup_IsEmpty(eg_factory_a) == false then
			EGroup_Kill(eg_factory_a) -- BOOM, factory is dead.
			
		end
	
	end


end





-----------------

--[[

function Commando_Factory_Guard_Action() -- makes small group of guards run into the guardhouse

	if SGroup_IsUnderAttack(sg_factory_force, false, 1) then
	
		if SGroup_IsEmpty(sg_factory_guards) == false then
			
			Cmd_Garrison(sg_factory_guards, eg_factory_guard_house)
			
		end
	
		Rule_RemoveMe()
	
	end

end]]

function Commando_Factory_Defender_Action()




end


function Commando_Factory_Carpiquet_Secondary_Objective_Kickoff() -- links into Carpiquet Secondary Objective

	if Event_IsAnyRunning() == false then
		
		if SGroup_IsEmpty(sg_factory_force) == false and SGroup_IsEmpty(sg_carpiquet_enemies) == false then
			
			-- if factory or carpiquet enemies are under attack by player
			if (SGroup_IsUnderAttack(sg_factory_force, false, 1) == true or SGroup_IsUnderAttack(sg_carpiquet_enemies, false, 1) == true) then
				
				--Rule_AddOneShot(Commando_Factory_Alarm_Delay, 3)
				
				
				Rule_AddDelayedInterval(Capture_Carpiquet_Delay, 3, 1)
				
				Rule_RemoveMe()
				
			end
		
		-- if factory force or carp enemies are dead, and the first objective is done, then allow the Carpiquet secondary objective
		elseif (SGroup_IsEmpty(sg_factory_force) == true or SGroup_IsEmpty(sg_carpiquet_enemies) == true) then
			
			Rule_AddDelayedInterval(Capture_Carpiquet_Delay, 3, 1)
			
			Rule_RemoveMe()
			
			
		end
		
	end


end

function Commando_Factory_AA_Grab()

	if SGroup_IsUnderAttack(sg_factory_force, false, 1) and (SGroup_TotalMembersCount(sg_factory_force) <= (g_ff_count * (0.60))) then
	
		if SGroup_IsEmpty(sg_factory_defenders) == false then
		
			Cmd_CaptureTeamWeapon(sg_factory_defenders, eg_factory_aa)
			
			Rule_AddInterval(Commando_Factory_AA_Grabber, 1)
		
		end
		
		Rule_RemoveMe()
		
	end
	
end


function Commando_Factory_AA_Grabber() -- takes the sgroup inside the aa gun and adds it to factory force and then modifies its stats

	if SGroup_IsEmpty(sg_factory_aa) then
	
		Player_GetAllSquadsNearMarker(player2, sg_factory_aa, mkr_carpiquet_aa1)
		
		if SGroup_IsEmpty(sg_factory_aa) == false then	
	
			SGroup_AddGroup(sg_factory_force, sg_factory_aa)
			
			Modify_SightRadius(sg_factory_aa, 0.5)
			Modify_WeaponRange(sg_factory_aa, "hardpoint_01", 0.5)
			Modify_WeaponAccuracy(sg_factory_aa, "hardpoint_01", 0.5)
			Modify_WeaponDamage(sg_factory_aa, "hardpoint_01", 0.5)
		end
	
	elseif SGroup_IsEmpty(sg_factory_aa) == false then -- this function only ends when sg_fence_gun is no longer empty
			
			Rule_RemoveMe()
			
		--end
	end
	
end


function Commando_Factory_Car_Patrol()

	if SGroup_IsEmpty(sg_factory_car_patrol) == true or EGroup_IsEmpty(eg_factory_a) then
		
			Rule_RemoveMe()
			
	else
		
		if SGroup_IsUnderAttack(sg_factory_force, false, 1) == false then
			
			if SGroup_IsMoving(sg_factory_car_patrol, false) == false then
				
				if g_factory_car_patrol_place >= g_factory_car_patrol_point_count then
					
					g_factory_car_patrol_place = 1
					
				elseif g_factory_car_patrol_place <= (g_factory_car_patrol_point_count - 1) then
					
					g_factory_car_patrol_place = g_factory_car_patrol_place + 1
					
				end
				
				Cmd_Move(sg_factory_car_patrol, t_commando_factory_data.car_patrolpath[g_factory_car_patrol_place])
				
			end
			
		elseif SGroup_IsUnderAttack(sg_factory_force, false, 1) == true then
			
		end
		
	end

end


function Commando_Factory_2ndPatrol()

	if SGroup_IsEmpty(sg_factory_guards) == true or EGroup_IsEmpty(eg_factory_a) then
		
			Rule_RemoveMe()
			
	else
		
		if SGroup_IsUnderAttack(sg_factory_force, false, 1) == false then
			
			if f_factory_guard_garrisoned == true then
			
				Cmd_UngarrisonSquad(sg_factory_guards)
				
				f_factory_guard_garrisoned = false
				
			end
			
			if SGroup_IsMoving(sg_factory_guards, false) == false then
				
				if g_factory_2ndpatrol_place >= g_factory_2ndpatrol_point_count then
					
					g_factory_2ndpatrol_place = 1
					
				elseif g_factory_2ndpatrol_place <= (g_factory_2ndpatrol_point_count - 1) then
					
					g_factory_2ndpatrol_place = g_factory_2ndpatrol_place + 1
					
				end
				
				Cmd_Move(sg_factory_guards, t_commando_factory_data.secondpatrolpath[g_factory_2ndpatrol_place], nil, nil, nil, nil, nil, 20)
				
			end
			
		elseif SGroup_IsUnderAttack(sg_factory_force, false, 1) == true then
			
			if EGroup_IsEmpty(eg_factory_guard_house) == false then
				
				
				Cmd_Garrison(sg_factory_guards, eg_factory_guard_house)
				
				f_factory_guard_garrisoned = true
				
			end
			
			
		end
		
	end

end

------------------------------------------
-- TETRARCH SECONDARY OBJECTIVE--
------------------------------------------
-- for the purposes of introducing the Tetrarch mechanic

function Initialize_OBJ_Tetrarch()

	OBJ_Tetrarch = {
		
		SetupUI = function() 
			-- mark a point or position
			--[[
			for i = 1, table.getn(t_tetrarch_landing_data) do
				
				table.insert(OBJ_Tetrarch.tetrarch_landingID, UI_CreateMinimapBlip(Marker_GetPosition(tmkr_tetrarch_landings[i]), -1, BT_DefendHerePing) ) --HintPoint_Add(t_tetrarch_landing_data[i].loc, true, LOC("Land a glider here!"))
				table.insert(OBJ_Tetrarch.tetrarch_landingHintID, HintPoint_Add(t_tetrarch_landing_data[i].loc, true, 1339136)) --LOC("Land a Tetrarch here!")
			end
			
			for k,v in pairs(t_tetrarch_landing_data) do 
				v.indicatorID = OBJ_Tetrarch.tetrarch_landingID[k]
				v.hintindicatorID = OBJ_Tetrarch.tetrarch_landingHintID[k]
			end]]

			
		end,
		
		OnStart = function()
			
			-- announce the goal
			
			
			-- win/lose check
			--Rule_AddInterval(Commando_Action_WinCheck, 5)
			
			
			-- start related action
			--Rule_AddOneShot(Commando_Objective_Medal_Action, 1)
			-- EncounterName_Kickoff()
			
		end,
		
		OnComplete = function()
			
			Sound_PlayMusic("Music/SP/Caen/motivation/coh_commando_assault.bsc",2,0)
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		
		Title = 1339104, --Deploy a Tetrarch
		Description = 1339114, -- Deploy a Tetrarch at the indicated location
		TitleEnd = 1339124, -- Deployed a Tetrarch
		
		Type = OT_Secondary,
		
	}
	
	-- Register Objective
	--Objective_Register(OBJ_Medal_Action)
	-- Initialize Data
	--Commando_Action_Init()
	
end






-------------------------------

--[[
function Commando_Tetrarch_Start()


	if Event_IsAnyRunning() == false then

--		Util_AutoIntel(t_carpiquet_sitrep.temp_03_after1)
		
		--Player_SetAbilityAvailability(player1, ABILITY.SP.GLIDER_TETRARCH, ITEM_UNLOCKED)
		
		--UI_FlashAbilityButton( ABILITY.SP.GLIDER_TETRARCH, true, BT_UI_Strong_AbilityBtn ) -- to highlight tetrarch button
		
		Util_AutoIntel(t_commando.action.event_factory2)
		
		
		-- had to put this here or else conflicts may occur
		Rule_AddOneShot(Commando_Tetrarch_Landing_Preset, 0)
		Rule_AddOneShot(Commando_Tetrarch_Start_Delay_Activate, 0)

		Rule_RemoveMe()
		
	end



end]]

function Commando_Tetrarch_Start_Delay_Activate()

	Rule_AddInterval(Commando_Tetrarch_Start_Delay, 1)

end

function Commando_Tetrarch_Start_Delay()

	if Event_IsAnyRunning() == false then

		
		
		Rule_AddDelayedInterval(Commando_Tetrarch_Landing_Remove_Ping, 2, 1)
		Rule_AddDelayedInterval(Commando_Tetrarch_Glider_Nag, 3, 1)
		
		--Rule_AddInterval(Commando_Objective_Medal_Delay, 1)
		
		if EGroup_IsEmpty(eg_factory_a) == false then	
			Util_AutoIntel(t_carpiquet_sitrep.temp_03_after1)
			
			Objective_Start(OBJ_Tetrarch)
			for i = 1, table.getn(t_tetrarch_landing_data) do
				
				table.insert(OBJ_Tetrarch.tetrarch_landingID, UI_CreateMinimapBlip(Marker_GetPosition(tmkr_tetrarch_landings[i]), -1, BT_DefendHerePing) ) --HintPoint_Add(t_tetrarch_landing_data[i].loc, true, LOC("Land a glider here!"))
				table.insert(OBJ_Tetrarch.tetrarch_landingHintID, HintPoint_Add(t_tetrarch_landing_data[i].loc, true, 1339136)) --LOC("Land a Tetrarch here!")
			end
			
			for k,v in pairs(t_tetrarch_landing_data) do 
				v.indicatorID = OBJ_Tetrarch.tetrarch_landingID[k]
				v.hintindicatorID = OBJ_Tetrarch.tetrarch_landingHintID[k]
			end
			
			Camera_FocusOnPosition(Marker_GetPosition(mkr_tetrarch_arrow), true)
			
			
			Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.COMMANDOS_13)
			--Player_SetAbilityAvailability(player1, ABILITY.SP.GLIDER_TETRARCH, ITEM_UNLOCKED)		
			UI_FlashAbilityButton( ABILITY.SP.GLIDER_TETRARCH, true, BT_UI_Strong_AbilityBtn ) -- to highlight tetrarch button
			
		else -- if the factory is destroyed, skip the dialogue, and just give the objective
			
			Objective_Start(OBJ_Tetrarch)
			Player_SetAbilityAvailability(player1, ABILITY.SP.GLIDER_TETRARCH, ITEM_UNLOCKED)		
			UI_FlashAbilityButton( ABILITY.SP.GLIDER_TETRARCH, true, BT_UI_Strong_AbilityBtn ) -- to highlight tetrarch button
			
		end
		
		
		Util_AutoIntel(t_carpiquet_sitrep.temp_03_after2)
		
		
		Rule_RemoveMe()

	end
	
end



function Commando_Objective_Medal_Delay()
-- if any captured is true then start counter
	--if EGroup_IsCapturedByPlayer(eg_strat_points, player1, false) == true then
	
		if Event_IsAnyRunning() == false then
			
			if g_medal_delay_timer < g_medal_delay_timer_number then
				
				g_medal_delay_timer = g_medal_delay_timer + 1
				
			elseif g_medal_delay_timer >= g_medal_delay_timer_number then
			
				Objective_Start(OBJ_Medal_Action)
				Rule_RemoveMe()
			
			end
		
		end
		
	--end

end








-- preset for tetrarchs
function Commando_Tetrarch_Landing_Init()

	t_tetrarch_landing_data = {}
	tmkr_tetrarch_landings = {mkr_tetrarch_arrow}
	teg_tetrarch_landed_glider = EGroup_CreateTable("eg_tetrarch_landed_glider%d", table.getn(tmkr_tetrarch_landings))
	
	OBJ_Tetrarch.tetrarch_landingID = {}
	OBJ_Tetrarch.tetrarch_landingHintID = {}
	
	g_gliders_tetrarch_landed = 0
	g_tetrarch_glider_timer = 0
	
end

-- mainly to add pings for the tetrarchs
function Commando_Tetrarch_Landing_Preset()

	for i = 1, table.getn(tmkr_tetrarch_landings) do
		table.insert(t_tetrarch_landing_data, {name = teg_tetrarch_landed_glider[i], loc = tmkr_tetrarch_landings[i], tetrarch_landed = false,
						indicatorID = nil, hintindicatorID = nil, ping_removed = false, text = 1339136, --LOC("Land Tetrarchs here!"), 
						glider_type = {EBP.CW.GLIDER_TETRARCH}, target_building = eg_factory_a})
	end
	
end


-- function to remove glider guide pings for the player -- set up this way to allow for multiple gliders if needed
function Commando_Tetrarch_Landing_Remove_Ping()

	for i = 1, table.getn(t_tetrarch_landing_data) do
	
		local e_data = t_tetrarch_landing_data
		local tetrarch_group = Player_GetEntities(player1)
		local tetrarch_squad = Player_GetSquads(player1)
		local tetrarch_deployed = SGroup_ContainsBlueprints(tetrarch_squad, SBP.CW.TETRARCH, true)
		
		if e_data[i].tetrarch_landed == false then 
			
			
			if EGroup_IsEmpty(e_data[i].target_building) == false then
			
				Player_GetAllEntitiesNearMarker(player1, e_data[i].name, e_data[i].loc)
				
				
				
				if EGroup_ContainsBlueprints(e_data[i].name, e_data[i].glider_type, false) or EGroup_ContainsBlueprints(tetrarch_group, e_data[i].glider_type, false) then -- or EGroup_IsEmpty(e_data[i].target_building)
				
					e_data[i].tetrarch_landed = true
					
					if e_data[i].indicatorID ~= nil then
						UI_DeleteMinimapBlip(e_data[i].indicatorID)
					end
					
					if e_data[i].hintindicatorID ~= nil then
						HintPoint_Remove(e_data[i].hintindicatorID)
					end
					
					e_data[i].ping_removed = true
					
				end
			
			elseif EGroup_IsEmpty(e_data[i].target_building) == true then
			
				-- removes the ping so that it's not centered on Carpiquet anymore... but objective can still be fulfilled elsewhere....
				if e_data[i].ping_removed == false then
				
					
					if e_data[i].indicatorID ~= nil then
						UI_DeleteMinimapBlip(e_data[i].indicatorID)
					end
					
					if e_data[i].hintindicatorID ~= nil then
						HintPoint_Remove(e_data[i].hintindicatorID)
					end
					
					e_data[i].ping_removed = true
					
					
					e_data[i].tetrarch_landed = true -- tetrarch landed is auto granted because now the player can land anywhere, not just the specified location
				
				end

			end
		

		elseif e_data[i].tetrarch_landed == true and tetrarch_deployed == true then 
	
			--if g_gliders_tetrarch_landed >= 1 then
			g_gliders_tetrarch_landed = 1
			Objective_Complete(OBJ_Tetrarch)
			Rule_RemoveMe()
		
			--end
	
		end
		
		
	end

	
	
end


-- nags until tetrarch glider lands
function Commando_Tetrarch_Glider_Nag()

	if g_gliders_tetrarch_landed >= 1 then
		
		Rule_RemoveMe()
		
	else
		
		if g_tetrarch_glider_timer >= 120 then -- if timer is 2 mins then say nag speech
		
			g_tetrarch_glider_timer = 0
			
			
			--nag speech
			
			--Util_AutoIntel(t_commando.action.event_tetrarch_nag)
			if Event_IsAnyRunning() == false then
				
				Util_StartIntel (EVENTS.TETRARCH_LANDING_NAG)
			
			end
		
		elseif g_tetrarch_glider_timer < 120 then
		
			g_tetrarch_glider_timer = g_tetrarch_glider_timer + 1
			
			
		end
	end

end















------------------


-------------------------------------------------------------------------
-- [[ Capture Points ]]
-------------------------------------------------------------------------
-- Short descriptive name of what the player is charged to do
-- give a brief description of win conditions and loose conditions if any 
-- also describe the kind of challenges the player will face
-------------------------------------------------------------------------
function Initialize_OBJ_Capture_Points()

	OBJ_Capture_Points = {
		
		SetupUI = function() 
			-- mark a point or position
			
			
			-- defines each seperate element and addes to a table
			--OBJ_Capture_Points.MapElementID7 = Objective_AddUIElements(OBJ_Capture_Points, eg_ammo_flag, true, LOC("Capture this point to make the frontline!"), true)
			--OBJ_Capture_Points.MapElementID1 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag1, true, LOC("Capture this point to make the frontline!"), true)
			--OBJ_Capture_Points.MapElementID2 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag2, true, LOC("Capture this point to make the frontline!"), true)
			--OBJ_Capture_Points.MapElementID3 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag3, true, LOC("Capture this point to make the frontline!"), true)
			--OBJ_Capture_Points.MapElementID4 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag4, true, LOC("Capture this point to make the frontline!"), true)
			--OBJ_Capture_Points.MapElementID5 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag5, true, LOC("Capture this point to make the frontline!"), true)
			--OBJ_Capture_Points.MapElementID6 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag6, true, LOC("Capture this point to make the frontline!"), true)
			

		end,
		
		OnStart = function()
			
			Sound_PlayMusic("Music/SP/Caen/Preparation/COH_Build_Or_Fail.bsc",0,0)
			-- announce the goal
			-- Util_AutoIntel({ACTOR.GenericAlly, "Rock out you crazy fools!"}, {ACTOR.GenericAlly, "You said it man!"})
			
			-- start timer
			--Objective_StartTimer(OBJ_Capture_Points, COUNT_DOWN, g_stratpoint_countdown, -1)  -- we could change g_ stratpoint_countdown depending on difficulty
			
			
			-- win/lose check
			Rule_AddInterval(Capture_Points_WinCheck, 5)
			--Rule_AddInterval(Capture_Points_Flag_Checker, 0, 5)
			
			-- start related action
			Rule_AddInterval(Capture_Points_ActionKickoff, 1)
			-- EncounterName_ActionKickoff()
			
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		
		Title = 1339101, --LOC("Establish a Frontline"),--000000
		Description = 1339111, --LOC("Capture as many of the frontline strategic points as you can to establish a frontline before the timer runs out"),
		TitleEnd = 1339121, --LOC("Frontline Established"),
		Type = OT_Primary,
		--[[
		SitRep = {
			Movie = "CXP1_SR_03-04",
			Force = true,
			SpeechTiming =
			{
				{ 1,	ACTOR.CXP1.Cutting, 1330700 },
				{ 4.8,	ACTOR.CXP1.Cutting, 1330701 },
				{ 9,	ACTOR.CXP1.Cutting, 1330702 },
				{ 11.6,	ACTOR.CXP1.Blackmore, 1330703 },
				{ 16,	ACTOR.CXP1.Blackmore, 1332040 },
				{ 21,	ACTOR.CXP1.Blackmore, 1330704 },
				{ 29,	ACTOR.CXP1.Blackmore, 1332060 },
				{ 33.8,	ACTOR.CXP1.Blackmore, 1330705 },
				
				
			},
		}]]
		
		
	}

end

	

-------------------------------------------------------------------------
-- [[ Capture Points - Functions ]]
-------------------------------------------------------------------------
-- 'Init()' is used to preset the Obj
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Capture_Points_Init()

	-- define sgroups, egroups, etc associated with this obj
	-- table of flags and their capture state
	t_flag_checklist = {
	
		--{eg_ammo_flag, --[[capture state]] false, mkr_ammo_flag_pointer}, 
		{eg_flag1, --[[capture state]] false, mkr_flag1_pointer},
		{eg_flag2, --[[capture state]] false, mkr_flag2_pointer}, 
		{eg_flag3, --[[capture state]] false, mkr_flag3_pointer}, 
		{eg_flag4, --[[capture state]] false, mkr_flag4_pointer}, 
		--{eg_flag5, --[[capture state]] false, mkr_flag5_pointer}, 
		--{eg_flag6, --[[capture state]] false, mkr_flag6_pointer},
		
	}
	
	-- spawn squads
	
	-- start enemy behavior
	
	-- do other cool things
	
	t_capture_points_dialogue = {
		--[[not used anymore
		sappers = {
			
			{ACTOR.GenericAlly, LOC("Royal Engineers reporting for duty!")},
			{ACTOR.GenericAlly, LOC("It's about bloody time!  Hurry, we only have a few minutes before the attack!")}
			
		},]]

	}
	
	t_capture_points_dialogue.pre_sit_rep03_03 = {
		--{ACTOR.CXP1.Hazard, 1330590}, -- Target eliminated.
		{ACTOR.CXP1.Hazard, 1330591}, -- Re-org'in and waiting out.
	
	}
	
	t_capture_points_dialogue.pre_sit_rep03_03_alt = {
		--{ACTOR.CXP1.Blackmore, 1330690}, -- Number 1 Commando reports all targets destroyed.
		--{ACTOR.CXP1.Blackmore, 1330691}, -- Cutting, get me a Sit-Rep.
	
	}
	
	
	t_capture_points_dialogue.frontline_trigger = {
		{ACTOR.CXP1.Cutting, 1330710}, -- We need to establish a defensive line.
		--{ACTOR.CXP1.Cutting, 1330711}, -- Set up some hasty defenses and kill zones.
		--{ACTOR.CXP1.Cutting, 1330712}, -- Have the Battalion establish a defensive line.
		{ACTOR.CXP1.Chubb, 1330720}, -- Go time gents. H-hour is at dawn. We need all the objectives captured.
		--{ACTOR.CXP1.Chubb, 1330721}, -- HQ Command Truck is in position and awaiting orders. 
		{ACTOR.CXP1.Chubb, 1330722}, -- Have the Infantry move into position.
		--{ACTOR.CXP1.Chubb, 1330723}, -- Capture the points and watch for defensive positions. Jerry might be slow, but he ain't stupid. The Airbase is on high alert!
		--{ACTOR.CXP1.Chubb, 1330724}, -- Armored support is mustered near Carpiquet.  Keep the road clear or they'll never make the front line. 
		
	}
	
	t_capture_points_dialogue.hq_in_position = {
		
		{ACTOR.CXP1.Chubb, 1330721}, -- HQ Command Truck is in position and awaiting orders. 
		
	}
	
	--[[
	t_capture_points_dialogue.nag = {
		{ACTOR.GenericAlly, 1330730}, -- Go! Go! Give her boys!
		{ACTOR.GenericAlly, 1330731}, -- Establish a defensive line!
		{ACTOR.GenericAlly, 1330732}, -- Macdonald, you heard your orders, establish a defensive line!
	
	}]]
	
	--AMBIENT -- IN EVENTS FILE
	--[[
	t_capture_points_dialogue.rcr_arrives = {
	
	 -- currently no text -- NOT USED AT THE MOMENT, PUT IN EVENTS FILE?
		{ACTOR.GenericAlly, 1330800}, --Chrisse de calisse du taburnack cave!
		{ACTOR.GenericAlly, 1331510}, --Jerry packs quite a bite!
		{ACTOR.GenericAlly, 1330801}, --Let's give 'em one for Canada boys!
		{ACTOR.GenericAlly, 1331520}, --Mangy German fucks, let's show 'em what real men are man of!
		{ACTOR.GenericAlly, 1330802}, --Rifles at ready!
		{ACTOR.GenericAlly, 1330803}, --The RCR will show 'em, eh?
		{ACTOR.GenericAlly, 1331530}, --Poor Jerry won't know what hit him!
	}
	
	--AMBIENT --  in events file too
	t_capture_points_dialogue.canadian_movement = {
		
		{ACTOR.GenericAlly, 1330740}, --Coming up quick sir!
		{ACTOR.GenericAlly, 1330741}, --Keep her coming boys!
		{ACTOR.GenericAlly, 1330742}, --God damn Huns don't even know what's coming!
		{ACTOR.GenericAlly, 1330743}, --Doing her now sir. 
		{ACTOR.GenericAlly, 1330744}, --This place is thick with Jerry!
	
	
	}
	]]
	
	t_capture_points_dialogue.german_retreat = {
		{ACTOR.CXP1.Seville, 1330770}, -- Excellent job men!  Jerry's trying to save his ass!
		{ACTOR.CXP1.Seville, 1330771}, -- Do 'em all in! Tabarnac de chrisse!
	}
	
	t_capture_points_dialogue.german_retreat_finished = {
		{ACTOR.CXP1.Chubb, 1330775}, -- Ceasefire. The Frontline is ours!
		{ACTOR.CXP1.Chubb, 1330776}, -- Stand down 3rd Battalion, Jerry's pulling out!
	}
	
	-- NOT USED ANYMORE?
	t_capture_points_dialogue.times_up = {
		{ACTOR.CXP1.Chubb, 1330780}, -- Our time is up!  Good work, troops!
		{ACTOR.CXP1.Chubb, 1330781}, -- We're gonna have to make do with what we have.

	}
	
	t_capture_points_dialogue.frontline_established = {
		
		{ACTOR.CXP1.Seville, 1331610}, -- RCR has established a defensive line.  All targets of opportunity have been neutralized.
		{ACTOR.CXP1.Seville, 1331620}, -- Recce group Bravo, move up that hill and let's see what the Huns left us! 
		--{ACTOR.CXP1.Seville, 1331630}, -- Caution I hear something ahead...
	
	}
	
	-- NOT USED YET
	t_capture_points_dialogue.no_soldiers_left = { -- similar to t_cap_points.last_chance_talk - redundant?
	
		{ACTOR.CXP1.Seville, 1330790}, -- Message over!  (beat)  Message over!  RCR requests immediate support!  Do you read?
		{ACTOR.CXP1.Seville, 1331540}, -- Get over to the HQ and call up more Infantry sections or we're fucked!
	
	}
	-- NOT USED YET
	t_capture_points_dialogue.no_soldiers_left2 = {
		
		{ACTOR.CXP1.Seville, 1330790}, -- Message over!  (beat)  Message over!  RCR requests immediate support!  Do you read?
	
	}
	
	-- AMBIENT EVENT -- USE EVENTS FILE NOT USED ANYMORE
	--[[
	t_capture_points_dialogue.dawn = { -- CURRENTLY NOT USED YET? Events file?
		-- currently no text
		{ACTOR.GenericAlly, 1331550}, --Reminds me of back home on the prairies.
		{ACTOR.GenericAlly, 1331560}, --About time the sun came up, I was forgetting what it looked like.
		{ACTOR.GenericAlly, 1331570}, --Another day... closer to home
		{ACTOR.GenericAlly, 1331580}, --I can't wait to be back on the St. Lawrence.
		{ACTOR.GenericAlly, 1331590}, --I wish Claire was here to see this with men.
		{ACTOR.GenericAlly, 1331600}, --Bon matin?!?
	}]]
	
	
	g_stratpoint_countdown = 300 -- time limit for the objective.  we could scale this depending on difficulty as well
	b_Capture_Points_OBJComplete = false -- boolean to indicate if objective is complete
	b_points_captured = false -- boolean to indicate if any of the points are captured
	b_all_points_captured = false -- boolean to indicate if all of the points are captured
	b_all_points_captured_medal_earned = false -- boolean to indicate if all points are captured (for medal purposes?)
	g_number_of_points_captured = 0 -- number of points captured
	g_minimum_points_needed = 3 -- number of points needed to win objective
	
	t_cap_points = {
		
		fg_everyone_dead = false,
		g_asset_counter = 0,
		g_manpower_limit = 400,
		g_asset_time_limit = 10, --seconds
		
		f_last_chance = false,
		g_last_chance_counter = 0,
		g_last_chance_time_limit = 40 -- in seconds
		
		
		
	}
	
	
	-- NOTE: ALSO USED EARLIER IN t_commando.action.last_chance
	t_cap_points.last_chance_talk = { 
		--{ACTOR.GenericAlly, LOC("You have the resources to call in more troops.  Hurry, before you lose momentum!!")}
		{ACTOR.CXP1.Cutting, 1330670}, -- We can still call in more Gliders.
		{ACTOR.CXP1.Cutting, 1330671}, -- Hurry, before we lose momentum!
		{ACTOR.CXP1.Cutting, 1330672}, -- Dawn is rapidly approaching!
	}
	
	
	
	
	
	-- brw 07/19/07 Resource rates are way too high at the end of the mission reducing them.
	g_mod_scalefactor = 1.08 --1.25 originally
	
	g_visible_retreat_timer = 0
	-- start counter?
	--Objective_SetCounter( OBJ_Capture_Points, g_number_of_points_captured, g_minimum_points_needed)
	
	
	--[[			
	t_capture_point_ui_ids = {
		OBJ_Capture_Points.MapElementID1, OBJ_Capture_Points.MapElementID2, OBJ_Capture_Points.MapElementID3, 
		OBJ_Capture_Points.MapElementID4,
		
	} --OBJ_Capture_Points.MapElementID5, OBJ_Capture_Points.MapElementID6}
	]]
	
	g_backup_timer = 0
	
	sg_gunner_force = SGroup_CreateIfNotFound("sg_gunner_force") -- for retreating gunners
	
end

-- start the related action
function Capture_Points_ActionKickoff()
	if Event_IsAnyRunning() == false then

		OBJ_Capture_Points.MapElementID1 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag1, true, 1339157, true, 2) --LOC("Capture this point to make the frontline!")
		OBJ_Capture_Points.MapElementID2 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag2, true, 1339157, true, 2) --LOC("Capture this point to make the frontline!")
		OBJ_Capture_Points.MapElementID3 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag3, true, 1339157, true, 2) --LOC("Capture this point to make the frontline!")
		OBJ_Capture_Points.MapElementID4 = Objective_AddUIElements(OBJ_Capture_Points, eg_flag4, true, 1339157, true, 2) --LOC("Capture this point to make the frontline!")
				
		t_capture_point_ui_ids = {
			OBJ_Capture_Points.MapElementID1, OBJ_Capture_Points.MapElementID2, OBJ_Capture_Points.MapElementID3, 
			OBJ_Capture_Points.MapElementID4,
			
		}


		--Player_RemoveAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_glider_allow3 )
		Player_RemoveAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_glider_allow4 )
		Player_RemoveAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_glider_allow5 )
		Player_RemoveAbilityLockoutZone(player1, ABILITY.SP.GLIDER_COMMANDOS, mkr_glider_allow6 )

		--unlock for Tetrarch too?
		
		
		
		
		
		-- action that starts with the Obj being granted
		Rule_AddInterval(Capture_Points_Asset_Check, 5)
		Rule_AddInterval(Capture_Points_Remove_Pings, 1)
		
		--Util_AutoNISlet( NISLET_GAME2GAME, t_carpiquet_sitrep.temp_04 )
		
		
		if EGroup_IsCapturedByPlayer(eg_strat_points, player1, true) == false then
			
			Util_AutoIntel(t_capture_points_dialogue.frontline_trigger)
			
		end
		
		
		
		Rule_AddInterval(Capture_Points_HQ_Focus, 1)
		
		Rule_RemoveMe()
		
	end
end


function Capture_Points_HQ_Focus()

	if Event_IsAnyRunning() == false then
		
		--Camera_FocusOnPosition(Marker_GetPosition(mkr_temp_hq2), true)
		--Camera_FocusOnPosition(Marker_GetPosition(mkr_carpiquet_hq_destination3), true)
		
		if SGroup_IsEmpty(sg_player_tommy_hq) == false then
			
			Util_AutoIntel(t_capture_points_dialogue.hq_in_position)
			
			Camera_FocusOnPosition(SGroup_GetPosition(sg_player_tommy_hq), true)
			
		end
	
		Rule_RemoveMe()
	
	end


end



function Capture_Points_Asset_Check() -- for the Capture_Points Action lose condition

	if t_cap_points.fg_everyone_dead == true then
	
		Rule_RemoveMe()
		
	else
	
		Player_GetAll(player1, sg_all_units, eg_all_buildings)
	
		if SGroup_CountSpawned(sg_all_units) == 0 and (Player_GetResource(player1, RT_Manpower ) < t_cap_points.g_manpower_limit) then
		
			
			
			Rule_AddInterval(Capture_Points_Asset_Counter, 1) -- starts countdown to see if player can get people within specified time
			
			Rule_RemoveMe()
		
		elseif SGroup_CountSpawned(sg_all_units) == 0 and (Player_GetResource(player1, RT_Manpower ) >= t_cap_points.g_manpower_limit) and t_cap_points.f_last_chance == false then
		
			t_cap_points.f_last_chance = true
			
			
			Util_AutoIntel(t_cap_points.last_chance_talk)
			
			Rule_AddInterval(Capture_Points_Asset_Last_Chance_Dialogue_Counter, 1) -- makes sure that time elapses before the setting gets changed to false
		
			Rule_RemoveMe()
		
		end
	
	end
	
end


function Capture_Points_Asset_Last_Chance_Dialogue_Counter()

	if t_cap_points.fg_everyone_dead == true then
	
		Rule_RemoveMe()
		
	else
	
		if t_cap_points.g_last_chance_counter <= t_cap_points.g_last_chance_time_limit then
			
			t_cap_points.g_last_chance_counter = t_cap_points.g_last_chance_counter + 1
			
		elseif t_cap_points.g_last_chance_counter > t_cap_points.g_last_chance_time_limit then
		
			Player_GetAll(player1, sg_all_units, eg_all_buildings)
		
			if SGroup_CountSpawned(sg_all_units) == 0 and ((Player_GetResource(player1, RT_Manpower ) <= t_cap_points.g_manpower_limit) 
				or (Player_GetResource(player1, RT_Manpower ) > t_cap_points.g_manpower_limit)) then -- if nobody then everyone is dead
			
				t_cap_points.fg_everyone_dead = true
				
				Rule_RemoveMe()
			
			elseif SGroup_CountSpawned(sg_all_units) > 0 then -- if there's at least 1 squad then restart the original population check
				
				t_cap_points.g_last_chance_counter = 0
				
				t_cap_points.f_last_chance = false
				
				Rule_AddInterval(Capture_Points_Asset_Check, 5)
				
				Rule_RemoveMe()
			
			end				
			
			
		end
	end

end


function Capture_Points_Asset_Counter()

	if t_cap_points.fg_everyone_dead == true then
	
		Rule_RemoveMe()
		
	else
	
		if t_cap_points.g_asset_counter <= t_cap_points.g_asset_time_limit then -- counts to specified time limit
		
			t_cap_points.g_asset_counter = t_cap_points.g_asset_counter + 1
			
		elseif t_cap_points.g_asset_counter > t_cap_points.g_asset_time_limit then -- after specified time limit, this will check to see the status of the population
		
			Player_GetAll(player1, sg_all_units, eg_all_buildings)
		
			if SGroup_CountSpawned(sg_all_units) == 0 and (Player_GetResource(player1, RT_Manpower ) <= t_cap_points.g_manpower_limit) then -- if nobody then everyone is dead
			
				t_cap_points.fg_everyone_dead = true
				
				Rule_RemoveMe()
			
			elseif SGroup_CountSpawned(sg_all_units) > 0 then -- if there's at least 1 squad then restart the original population check
			
				
				t_cap_points.g_asset_counter = 0
				
				Rule_AddInterval(Capture_Points_Asset_Check, 5)
				
				Rule_RemoveMe()
			
			end
		
		
		end
	end

end


function Capture_Points_WinCheck()
	
	if EGroup_IsCapturedByPlayer(eg_strat_points, player1, true) then
		-- go in here if all points captured
		
		b_all_points_captured = true
		
		b_all_points_captured_medal_earned = true -- medal for capturing all points?
		
	elseif EGroup_IsCapturedByPlayer(eg_strat_points, player1, false) then
		-- go in here if at least 1 point is captured  (we could always scale this according to difficulty)
		
		b_points_captured = true
		
	elseif EGroup_IsCapturedByPlayer(eg_strat_points, player1, false) == false then
		-- go in here if no points are captured
		
		b_points_captured = false
		
	end
	
	-- if all points captured, and countdown hasn't finished yet
	if b_all_points_captured == true  then -- and g_stratpoint_countdown > 0 
	
		
		b_Capture_Points_OBJComplete = true
		
		Rule_AddInterval(Capture_Points_Axis_Mass_Retreat, 1)
		
		Rule_RemoveMe()
		
	
	elseif (b_points_captured == false and t_cap_points.fg_everyone_dead == true) then
		
		if Event_IsAnyRunning() == false then
			
			-- the player has just failed
			Objective_Fail(OBJ_Capture_Points)
			
			Game_EndSP(false, 1339160) --LOC("You failed to establish a strong foothold.  Our attack will be doomed from the beginning. Fall back...")
			
			Rule_RemoveMe()
		
		end
		
	end	
	
end



function Capture_Points_Win()

	if Event_IsAnyRunning() == false then
		
		Game_EndSP(true, 1339161) --LOC("Time is up!  We'll use what we've got to launch an attack, right and proper.")
		
		Rule_RemoveMe()
		
	end
	
end



function Capture_Points_Axis_Mass_Retreat()
	
	
	
	Util_AutoIntel(t_capture_points_dialogue.german_retreat)
	
	
	if b_Capture_Points_OBJComplete == true then
		
		
		if SGroup_IsEmpty(sg_anti_air_force) == false then
			
			Cmd_Retreat(sg_anti_air_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false)
			FOW_RevealSGroup(sg_anti_air_force, 5)
			
		end
		
		
		
		if SGroup_IsEmpty(sg_at_gun_force) == false then
			
			Cmd_Retreat(sg_at_gun_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_at_gun_force, 5)
			
		end
		
		if SGroup_IsEmpty(sg_fence_force) == false then
			
			Cmd_Retreat(sg_fence_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_fence_force, 5)
			
		end
		
		if SGroup_IsEmpty(sg_gate_force) == false then
			
			Cmd_Retreat(sg_gate_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_gate_force, 5)
			
		end
		
		if SGroup_IsEmpty(sg_field_force) == false then
			
			Cmd_Retreat(sg_field_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_field_force, 5)
			
		end
		
			
		if SGroup_IsEmpty(sg_airport_fence_raiders) == false then
			
			Cmd_Retreat(sg_airport_fence_raiders, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_airport_fence_raiders, 5)
			
		end
		
		if SGroup_IsEmpty(sg_airport_gate_raiders) == false then
			
			Cmd_Retreat(sg_airport_gate_raiders, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_airport_gate_raiders, 5)
			
		end
		
		if SGroup_IsEmpty(sg_flak88_soldiers) == false then
			
			Cmd_Retreat(sg_flak88_soldiers, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_flak88_soldiers, 5)
			
		end
		
		if SGroup_IsEmpty(sg_field_extra) == false then
			
			Cmd_Retreat(sg_field_extra, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_field_extra, 5)
			
		end
		
		if SGroup_IsEmpty(sg_mortar_guard1) == false then
			
			Cmd_Retreat(sg_mortar_guard1, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false) -- made to delete when squad at marker, in case player follows unit within sight range
			FOW_RevealSGroup(sg_mortar_guard1, 5)
			SGroup_AddGroup(sg_gunner_force, sg_mortar_guard1)
		end
		
		
	
		
		local temp_player2_squads = SGroup_CreateIfNotFound("temp_player2_squads")
		local temp_player2_entities = EGroup_CreateIfNotFound("temp_player2_entities")
		
		Player_GetAll(player2, temp_player2_squads, temp_player2_entities)
		
		SGroup_Filter(temp_player2_squads, {SBP.AXIS.CAPTURE_88_AXIS, SBP.AXIS.CAPTURE_AT_AXIS, SBP.AXIS.CAPTURE_MORTAR_AXIS}, FILTER_KEEP)
		
		Cmd_AbandonTeamWeapon(temp_player2_squads, true)
		
		Rule_AddOneShot(Capture_Points_Axis_Gunner_Retreat, 5)
		
		Rule_AddInterval(Capture_Points_Axis_Mass_Retreat_Detector, 1)
		
		
		Rule_AddOneShot(Capture_Points_Bunker_Abandon, 1)
		
		Rule_RemoveMe()
		
	end
	


end



function Capture_Points_Bunker_Abandon()

	g_bunker_number = 1

	sg_bunker_forces = SGroup_CreateIfNotFound("sg_bunker_forces")
	
	tsg_occupiers = SGroup_CreateTable("sg_occupiers%d", 6)
	
	t_bunker_info = {
		
		{bunkername = eg_bunker1, occupiers = tsg_occupiers[1]},
		{bunkername = eg_bunker2, occupiers = tsg_occupiers[2]},
		{bunkername = eg_bunker3, occupiers = tsg_occupiers[3]},
		{bunkername = eg_bunker4, occupiers = tsg_occupiers[4]},
		{bunkername = eg_bunker5, occupiers = tsg_occupiers[5]},
		{bunkername = eg_bunker6, occupiers = tsg_occupiers[6]},
	}
	

	for k, v in pairs(t_bunker_info) do
		-- abandon the bunkers
		if EGroup_IsEmpty(v.bunkername) == false then
			
			EGroup_GetSquadsHeld(v.bunkername, v.occupiers)
			SGroup_AddGroup(sg_bunker_forces, v.occupiers)
			
			if SGroup_IsEmpty(v.occupiers) == false then
				Cmd_UngarrisonSquad(v.occupiers, mkr_counterattack_spawn1)
				
				
			end

			EGroup_SetPlayerOwner(v.bunkername, player3)
			
		end
		
	end
	
	Rule_AddOneShot(Capture_Points_Bunker_Retreat, 6)

	Rule_AddDelayedInterval(Capture_Points_Bunker_Destroy, 6, 1)

end


function Capture_Points_Bunker_Retreat()

	if SGroup_IsEmpty(sg_bunker_forces) == false then
	
		Cmd_Retreat(sg_bunker_forces, mkr_counterattack_spawn1, mkr_counterattack_spawn1)
		
	end

	

end


function Capture_Points_Bunker_Destroy()

	if g_bunker_number > 6 then
	
		Rule_RemoveMe()
		
	else
	
		if EGroup_IsEmpty(t_bunker_info[g_bunker_number].bunkername) == false then
			
			EGroup_Kill(t_bunker_info[g_bunker_number].bunkername)
			
		end
		
		g_bunker_number = g_bunker_number + 1
		
	end
	
end

function Capture_Points_Axis_Gunner_Retreat()

	tmkr_crew_grab = {mkr_fence_88, mkr_fence_pak38_grabber, mkr_field_pak38_grabber, mkr_field_88, mkr_gate_88_detect, mkr_mortar1_detect}
	local temp_squads = SGroup_CreateIfNotFound("temp_squads")
	
	for i = 1, table.getn(tmkr_crew_grab) do
	
		Player_GetAllSquadsNearMarker(player2, temp_squads, tmkr_crew_grab[i])
		
		if SGroup_IsEmpty(temp_squads) == false then
			
			SGroup_AddGroup(sg_gunner_force, temp_squads)
			
		end
	
	end
	
	if SGroup_IsEmpty(sg_gunner_force) == false then
		Cmd_Retreat(sg_gunner_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1, false)
	end

end


function Capture_Points_Axis_Mass_Retreat_Detector()

	if (Player_CanSeeSGroup(player1, sg_anti_air_force, false) == false and Player_CanSeeSGroup(player1, sg_at_gun_force, false) == false 
		and g_visible_retreat_timer >= 6) or g_backup_timer >= 7 then
	
		if Event_IsAnyRunning() == false then
		
			Objective_Complete(OBJ_Capture_Points)
			
			Util_StartIntel(EVENTS.DAWN)
			
			Rule_AddDelayedInterval(Letterbox_Delay, 2,1)
			
			
			Modifier_Remove(mod_actionpoints)
			Modifier_Remove(mod_resourcechanges)
			
			if g_fuel_tank_commandos_modified == true then
				Modifier_Remove(mod_fuel_tank_commandos)
			end
			
			if g_generator_commandos_modified == true then
				Modifier_Remove(mod_generator_commandos)
			end
			
			UI_EnableResourceTypeKicker(RT_Action, true)  
			
			Rule_RemoveMe()
		
		end
		
		
		
	elseif Player_CanSeeSGroup(player1, sg_anti_air_force, false) == false and Player_CanSeeSGroup(player1, sg_at_gun_force, false) == false 
		and g_visible_retreat_timer <= 5 then
		
		g_visible_retreat_timer = g_visible_retreat_timer + 1
		
	
	elseif Player_CanSeeSGroup(player1, sg_anti_air_force, false) == true and Player_CanSeeSGroup(player1, sg_at_gun_force, false) == true then
		
		g_visible_retreat_timer = 0


	end
	
	--backup timer 
	if g_backup_timer < 7 then
	
		g_backup_timer = g_backup_timer + 1
	
	elseif g_backup_timer >= 7 then
	
	
	
	end
	

end

function Letterbox_Delay()
	
	if Event_IsAnyRunning() == false then
		
		Game_Letterbox(true, 2)
		
		Rule_AddDelayedInterval(Capture_Points_Win_Delay, 2,1)
		
		Rule_RemoveMe()
		
	end

end


function Capture_Points_Win_Delay()
	
	if Event_IsAnyRunning() == false then
		
		
		
		Util_AutoIntel(t_capture_points_dialogue.german_retreat_finished)
		
		Rule_AddInterval(Capture_Points_Win_Delay2, 1)
		Rule_RemoveMe()
		
	end


end


function Capture_Points_Win_Delay2()

	if Event_IsAnyRunning() == false then
		
		
		
		Util_AutoIntel(t_capture_points_dialogue.frontline_established)
		
		Rule_Add(Capture_Points_Win)
		
		Util_StartNIS(EVENTS.NIS02)			
		
		if EGroup_IsCapturedByPlayer(eg_flag5, player1, false) == false then
			
			EGroup_InstantCaptureStrategicPoint(eg_flag5, player1)
			
		end
	
		if EGroup_IsCapturedByPlayer(eg_flag6, player1, false) == false then
			
			EGroup_InstantCaptureStrategicPoint(eg_flag6, player1)
			
		end
		
		SGroup_DestroyAllSquads(sg_anti_air_force)
		SGroup_DestroyAllSquads(sg_at_gun_force)
		SGroup_DestroyAllSquads(sg_gunner_force)
		SGroup_DestroyAllSquads(sg_gate_force)
		SGroup_DestroyAllSquads(sg_ammo_dump_force)
		
		Rule_RemoveMe()
		
	end

end




function Capture_Points_HQ_Reinforcements_Spawning()

	sg_lieutenant = SGroup_CreateIfNotFound("sg_lieutenant")
	sg_reinforcement_tommies = SGroup_CreateIfNotFound("sg_reinforcement_tommies")
	sg_player_infantry_hq = SGroup_CreateIfNotFound("sg_player_infantry_hq")
	sg_player_tommy_hq = SGroup_CreateIfNotFound("sg_player_tommy_hq")
	
	sg_player_regular_reinforcements = SGroup_CreateIfNotFound("sg_player_regular_reinforcements")
	
	t_capture_points_hq_reinforcement_data = {
	
		capture_points_hq_reinforcements_spawn = {
		
			{name = sg_reinforcement_tommies, blueprint = SBP.CW.TOMMIES_CANADIAN_SP, loc = mkr_allied_infantry_carpiquet_reinforcement, numberofsquads = 1}, -- loc = mkr_player_start3
			{name = sg_lieutenant, blueprint = SBP.CW.LIEUTENANT, loc = mkr_allied_infantry_carpiquet_reinforcement, numberofsquads = 1}, --loc = mkr_player_start4
			
		},	
		
		capture_points_hq = {
		
			--{name = sg_player_infantry_hq, blueprint = SBP.CW.INFANTRY_HQ, loc = mkr_player_hq, numberofentities = 1, destination = mkr_infantry_hq},
			{name = sg_player_tommy_hq, blueprint = SBP.CW.HQ, loc = mkr_carpiquet_hq, numberofentities = 1, destination = mkr_carpiquet_hq_destination3}, -- mkr_temp_hq2
		},
		
		capture_points_hq2 = {
			{name = sg_player_infantry_hq, blueprint = SBP.CW.INFANTRY_HQ, loc = mkr_carpiquet_hq, numberofentities = 1, destination = mkr_carpiquet_hq_destination1}, 
		},
		
		reinforcement_dialogue = {
			
			--{ACTOR.GenericAlly, LOC("Reinforcements have arrived!  Time to establish our frontline!  Assault the enemy!")},
		},
	}
	
	
	--soldiers
	for k, v in pairs (t_capture_points_hq_reinforcement_data.capture_points_hq_reinforcements_spawn) do
		
		Util_CreateSquads(player1, v.name, v.blueprint, v.loc,  nil, v.numberofsquads)
		
			--if EGroup_IsCapturedByPlayer(eg_ammo_flag, player1, false) then
		
				Cmd_Move(v.name, mkr_carpiquet_reinforcement_infantry, nil, nil, nil, nil, nil, 10) --mkr_ammo_dump_officer_spawn
				SGroup_AddGroup(sg_player_regular_reinforcements, v.name)
			--end
		
	end
	
	EventCue_Create(CUE.NORMAL_REPEATING, nil, nil, sg_player_regular_reinforcements)

	for k, v in pairs (t_capture_points_hq_reinforcement_data.capture_points_hq) do
		
		Util_CreateSquads(player1, v.name, v.blueprint, v.loc, nil, v.numberofentities)
		
		if SGroup_ContainsBlueprints(v.name, SBP.CW.HQ, false) then
		
			Util_SetCommonwealthHQMobility(v.name, true, true)
		
		end
		
		Rule_AddOneShot(HQ_Move_Delay, 3)
		
	end
	
	
	-- unlocks HQ which was diabled at beginning
	Player_SetAbilityAvailability(player1, ABILITY.CW.HQ_REINFORCE, ITEM_DEFAULT) -- put back to default when you switch it off
	
	--Camera_FocusOnPosition(Marker_GetPosition(mkr_player_start1), true)
	--Camera_FocusOnPosition(EGroup_GetPosition(eg_carp_flag1), true)
	
	
	Rule_AddOneShot(Capture_Points_HQ_Reinforcements_Spawning2, 10)

end

function HQ_Move_Delay()

	if SGroup_IsEmpty(sg_player_tommy_hq) == false then
		
		Cmd_Move(sg_player_tommy_hq, mkr_carpiquet_hq_destination3)
		
	end

end


function Capture_Points_HQ_Reinforcements_Spawning2()

	
	for k, v in pairs (t_capture_points_hq_reinforcement_data.capture_points_hq2) do
		
		Util_CreateSquads(player1, v.name, v.blueprint, v.loc, nil, v.numberofentities)
		
		if SGroup_ContainsBlueprints(v.name, SBP.CW.INFANTRY_HQ, false) then
			
			Util_SetCommonwealthHQMobility(v.name, true, true)
			
		end
		
		Cmd_Move(v.name, v.destination)
		
	end
	
	Player_SetSquadProductionAvailability(player1, SBP.CW.INFANTRY_HQ, ITEM_DEFAULT) -- re-enable Infantry HQ once one actually gets granted to the player
	

end


function Capture_Points_Axis_Town_Exiting() -- to get infantry out of buildings

	if SGroup_IsEmpty(sg_carpiquet_enemies) == false then
	
		for i = 1, table.getn(t_carpiquet_town_spawn_table) do -- run this through the whole table of Carpiquet building units
		 
			if SGroup_IsEmpty(t_carpiquet_town_spawn_table[i][1]) == false then
			
			-- if building squad has people in it, and is garrisoned
				if SGroup_IsInHoldEntity(t_carpiquet_town_spawn_table[i][1], false) then
					
					Cmd_UngarrisonSquad(t_carpiquet_town_spawn_table[i][1]) -- make the squad ungarrison
					
				end	
				--[[
				if SGroup_IsRetreating(t_carpiquet_town_spawn_table[i][1], true) == false then
				
					Cmd_Retreat(t_carpiquet_town_spawn_table[i][1], mkr_counterattack_spawn1, mkr_counterattack_spawn1, false)
				
				end]]

			end
			
		end
		
		if SGroup_IsEmpty(sg_enemy_reinforcement_minders) == false and SGroup_IsInHoldEntity(sg_enemy_reinforcement_minders, false) then
			
			Cmd_UngarrisonSquad(sg_enemy_reinforcement_minders)
			
		end
		
		for i = 1, table.getn(t_carpiquet_town_mg_spawn_table) do
			
			if SGroup_IsEmpty(t_carpiquet_town_mg_spawn_table[i][1]) == false then
				
				Cmd_AbandonTeamWeapon(t_carpiquet_town_mg_spawn_table[i][1], true)
				
			end
			
		end
		
	end
	
	if SGroup_IsEmpty(sg_factory_force) == false then
		
		Player_GetAllSquadsNearMarker(player2, sg_factory_aa, mkr_carpiquet_aa1)
		
		if SGroup_IsEmpty(sg_factory_aa) == false then
			
			Cmd_AbandonTeamWeapon(sg_factory_aa, true)
			
		end
		
		if SGroup_IsEmpty(sg_factory_guards) == false and SGroup_IsInHoldEntity(sg_factory_guards, false) then
			
			Cmd_UngarrisonSquad(sg_factory_guards, mkr_factory_2ndpatrol2)
			
		end
		
		
	end
	
	Rule_AddOneShot(Capture_Points_Axis_Town_Retreat, 4)
	
end

function Capture_Points_Axis_Town_Retreat()

	
	for i = 1, table.getn(t_carpiquet_town_spawn_table) do -- run this through the whole table of Carpiquet building units
	
		if SGroup_IsEmpty(t_carpiquet_town_spawn_table[i][1]) == false then
		
			Cmd_Retreat(t_carpiquet_town_spawn_table[i][1], mkr_hangar_spawn_backup, mkr_hangar_spawn_backup, false)
		
		end
		
	end
	
	if SGroup_IsEmpty(sg_carpiquet_enemies) == false then
		
		Cmd_Retreat(sg_carpiquet_enemies, mkr_hangar_spawn_backup, mkr_hangar_spawn_backup, false)
		
	end
	
	if SGroup_IsEmpty(sg_factory_force) == false then
		
		Cmd_Retreat(sg_factory_force, mkr_hangar_spawn_backup, mkr_hangar_spawn_backup, false)
		
	end
	
	Player_GetAllSquadsNearMarker(player2, sg_factory_aa, mkr_carpiquet_aa1, 5)
	
	if SGroup_IsEmpty(sg_factory_aa) == false then
		
		Cmd_Retreat(sg_factory_aa, mkr_hangar_spawn_backup, mkr_hangar_spawn_backup, false)
		
	end
	
end




function Capture_Points_Build_Defences_Spawning() -- currently unused

	sg_sappers = SGroup_CreateIfNotFound("sg_sappers")
	
	tmkr_emplacements = Marker_GetTable("mkr_emplacement%d")
	teg_built_emplacement = EGroup_CreateTable("eg_built_emplacement%d", table.getn(tmkr_emplacements))
	
	t_build_defences_data = {
		capture_points_build_defences_spawn = {
			
			{name = sg_sappers, blueprint = SBP.CW.SAPPER, loc = mkr_player_start4, numberofsquads = 2},
			
		},
		
		capture_points_emplacement_data = {
			--[[
			-- emplacement 1
			{name = tmkr_emplacement[1],text = LOC("Build a machine gun nest here!"),  indicatorID = nil},
			-- emplacement 2
			{name = tmkr_emplacement[2],text = LOC("Build a machine gun nest here!"),  indicatorID = nil},
			-- emplacement 3
			{name = tmkr_emplacement[3],text = LOC("Build a machine gun nest here!"),  indicatorID = nil},
			]]
		},
		--[[
		built_emplacement_data = {
			
			
		},]]
	}
	
	OBJ_Capture_Points.EmplacementElementID = {}
	
	for i = 1, table.getn(tmkr_emplacements) do
		table.insert(t_build_defences_data.capture_points_emplacement_data, {name = teg_built_emplacement[i], loc = tmkr_emplacements[i], built = false,
						indicatorID = nil, text = LOC("Build defences in this area!"), 
						emplacement_type = {EBP.CW.MG_NEST, EBP.CW.ANTITANK_NEST, EBP.CW.HOWITZER_NEST, EBP.CW.MORTAR_NEST, EBP.CW.SLITTRENCH_NEST}})
	end
	
	for i = 1, table.getn(t_build_defences_data.capture_points_emplacement_data) do
		
		table.insert(OBJ_Capture_Points.EmplacementElementID, Objective_AddUIElements(OBJ_Capture_Points, t_build_defences_data.capture_points_emplacement_data[i].loc, true, t_build_defences_data.capture_points_emplacement_data[i].text, true, 1) )
		
	end
	
	for k,v in pairs(t_build_defences_data.capture_points_emplacement_data) do 
		v.indicatorID = OBJ_Capture_Points.EmplacementElementID[k]
	end
	
	for k, v in pairs (t_build_defences_data.capture_points_build_defences_spawn) do
		
		Util_CreateSquads(player1, v.name, v.blueprint, v.loc,  mkr_infantry_hq, v.numberofsquads)
		--Cmd_Move(v.name, v.loc, nil, nil, nil, nil, nil, 20)
		
	end
	
	g_emplacements_built = 0
	
	--Sapper_Ping_ID = Objective_AddPing(OBJ_Capture_Points, sg_sappers, 1)
	Sapper_Ping_ID = UI_CreateMinimapBlip(sg_sappers, 10, BT_GeneralPing)
	
	--Rule_AddOneShot(Capture_Points_Remove_Sapper_Ping, 10)
	
	--Util_AutoIntel(t_capture_points_dialogue.sappers)
	
	Rule_AddInterval(Capture_Points_Build_Defenses_Remove_Ping, 3)
	
	
	
	
end


function Capture_Points_Build_Defenses_Remove_Ping()

	for i = 1, table.getn(t_build_defences_data.capture_points_emplacement_data) do
	
		local e_data = t_build_defences_data.capture_points_emplacement_data
		
		if e_data[i].built == false then 
		
			Player_GetAllEntitiesNearMarker(player1, e_data[i].name, e_data[i].loc)
			
			if EGroup_ContainsBlueprints(e_data[i].name, e_data[i].emplacement_type, false) then
			
				e_data[i].built = true
			
				Objective_RemoveUIElements(OBJ_Capture_Points, e_data[i].indicatorID)
			
				g_emplacements_built = g_emplacements_built + 1
			
			end
			
		end
		

		
		
	end

	if g_emplacements_built >= 3 then
	
		Rule_RemoveMe()
		
	end
	
end




function Capture_Points_Remove_Pings() -- function for removing pings from the map once a strategic point is captured
	
	if b_Capture_Points_OBJComplete == true then--or g_stratpoint_countdown <= 0 then --or b_Capture_Points_OBJComplete == true
		
		for c = 1, table.getn(t_flag_checklist) do
			
			if t_flag_checklist[c][2] == false then
				
				Objective_RemoveUIElements(OBJ_Capture_Points, t_capture_point_ui_ids[c])
				
				t_flag_checklist[c][2] = true
				
			end
			
			
		end
		-- if countdown is over, or the objective is complete, then remove the rule
		Rule_RemoveMe()
		
	else

		for c = 1, table.getn(t_flag_checklist) do

			-- if the flag egroup in question is captured by the player, and the "captured" boolean flag for it is set to false

			
			if EGroup_IsCapturedByPlayer(t_flag_checklist[c][1], player1, false) and (t_flag_checklist[c][2] == false) then

				-- remove ping
				Objective_RemoveUIElements(OBJ_Capture_Points, t_capture_point_ui_ids[c])
				
				t_flag_checklist[c][2] = true
				
				g_number_of_points_captured = g_number_of_points_captured + 1
				
				--[[
				-- modifier for resources when a point is captured, here
				if g_res_mod_id ~= nil then
					Modifier_Remove(g_res_mod_id) 
				end
				g_res_mod_id = Modify_PlayerResourceRate(player1, RT_Manpower, g_mod_scalefactor ) 
				g_mod_scalefactor = g_mod_scalefactor - 0.02 -- modifies this for next round
				]]
				
			end
		end
	
	end
	
end


-------------------------------------------------------------------------
-- [[ Capture Carpiquet ]]
-------------------------------------------------------------------------
-- Secondary objective of the player capturing Carpiquet
-- Need Officer in the area...
--
-------------------------------------------------------------------------

function Initialize_OBJ_Capture_Carpiquet()

	OBJ_Capture_Carpiquet = {
		
		SetupUI = function() 
			-- mark a point or position
			
			for i = 1, table.getn(t_carp_flag_checklist) do
				--t_carp_flag_checklist[i].MapElementID = Objective_AddUIElements(OBJ_Capture_Carpiquet, t_carp_flag_checklist[i][1], true, 1339154, true) --LOC("Capture this flag to capture Carpiquet")
				t_carp_flag_checklist[i][2] = Objective_AddUIElements(OBJ_Capture_Carpiquet, t_carp_flag_checklist[i][1], true, 1339154, true, 2) --LOC("Capture this flag to capture Carpiquet")
			end
			--t_carp_flag_checklist[2].MapElementID = Objective_AddUIElements(OBJ_Capture_Carpiquet, mkr_carp_flag2_pointer, true, LOC("Carpiquet section"), false, true, true)
			--t_carp_flag_checklist[3].MapElementID = Objective_AddUIElements(OBJ_Capture_Carpiquet, mkr_carp_flag3_pointer, true, LOC("Carpiquet section"), false, true, true)
			
		end,
		
		OnStart = function()
			Sound_PlayMusic("Music/SP/Caen/trepidation/coh_silent_descent.bsc",2,0)
			-- announce the goal
			-- Util_AutoIntel(t_obj_capture_carpiquet.EventStart)
			
			-- win/lose check
			Rule_AddInterval(Capture_Carpiquet_WinCheck, 2)
			
			-- start related action
			Rule_AddOneShot(Capture_Carpiquet_Kickoff,1)
			-- EncounterName_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1339102, --LOC("Capture Carpiquet"),
		Description = 1339112, -- LOC("Carpiquet is heavily defended by the Germans.  However, if we capture it they will be at a severe disadvantage in the region."),
		TitleEnd = 1339122, -- LOC("Town of Carpiquet captured"),
		Type = OT_Secondary,
		
		
	}
	
	-- Register Objective
	--Objective_Register(OBJ_Capture_Carpiquet)
	-- Initialize Data
	--Capture_Carpiquet_Init()
	
end


-------------------------------------------------------------------------
-- Capture Carpiquet - Functions 
-------------------------------------------------------------------------


-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Capture_Carpiquet_Init()

	sg_carpiquet_enemies = SGroup_CreateIfNotFound("sg_carpiquet_enemies")

	-- define sgroups, egroups, etc associated with this obj
	teg_carpiquet_buildings = {eg_carpiquet_building1, eg_carpiquet_building2, eg_carpiquet_building3, 
		eg_carpiquet_building4, eg_carpiquet_building5, eg_carpiquet_building6, eg_carpiquet_building7, eg_carpiquet_building8}
	
	
	sg_carpiquet_car1_patrol = SGroup_CreateIfNotFound("sg_carpiquet_car1_patrol")
	tmkr_carpiquet_car1_patrol = Marker_GetTable("mkr_carpiquet_car1_patrol_point%d")
	sg_car1_patrol_attacker = SGroup_CreateIfNotFound("sg_car1_patrol_attacker")
	
	--print(table.getn(teg_carpiquet_buildings))
	
	tsg_carpiquet_defender = SGroup_CreateTable("sg_carpiquet_defender_unit%d", table.getn(teg_carpiquet_buildings))
	tsg_carpiquet_attacker = SGroup_CreateTable("sg_carpiquet_attacker%d", table.getn(tsg_carpiquet_defender))
	
	t_carpiquet_town_spawn_table = {
		{tsg_carpiquet_defender[1], t_difficulty.g_soldier_type2, teg_carpiquet_buildings[1], 1, (3 + t_dif_numbers.g_dif_add_number), mkr_fallback1},
		{tsg_carpiquet_defender[2], t_difficulty.g_soldier_type2, teg_carpiquet_buildings[2], 1, (3 + t_dif_numbers.g_dif_add_number), mkr_fallback2},
		{tsg_carpiquet_defender[3], t_difficulty.g_soldier_type2, teg_carpiquet_buildings[3], 1, (3 + t_dif_numbers.g_dif_add_number), mkr_fallback3},
		{tsg_carpiquet_defender[4], t_difficulty.g_soldier_type3, teg_carpiquet_buildings[4], 1, (3 + t_dif_numbers.g_dif_add_number), mkr_fallback4},
		--{tsg_carpiquet_defender[4], SBP.AXIS.OFFICER, teg_carpiquet_buildings[4], 1, 1, mkr_fallback4},
		{tsg_carpiquet_defender[5], t_difficulty.g_soldier_type2, teg_carpiquet_buildings[5], 1, (3 + t_dif_numbers.g_dif_add_number), mkr_fallback5},
		{tsg_carpiquet_defender[6], t_difficulty.g_soldier_type2, teg_carpiquet_buildings[6], 1, (3 + t_dif_numbers.g_dif_add_number), mkr_fallback6},
		{tsg_carpiquet_defender[7], t_difficulty.g_soldier_type1, teg_carpiquet_buildings[7], 1, (3 + t_dif_numbers.g_dif_add_number), mkr_fallback7},
		{tsg_carpiquet_defender[8], t_difficulty.g_soldier_type2, teg_carpiquet_buildings[8], 1, (2 + t_dif_numbers.g_dif_add_number), mkr_fallback8},
	}
	
	
	if EGroup_IsEmpty(eg_carpiquet_building9) == false then -- sets crew spawn building to enemy and upgrades it
		--EGroup_SetPlayerOwner(eg_carpiquet_building9, player2)
		--Cmd_InstantUpgrade(eg_carpiquet_building9, UPG.AXIS.CONVERT_AMBIENT_BUILDING, 1)
    end
	
	
	-- dudes in the southern trench
	sg_south_trench1 = SGroup_CreateIfNotFound("sg_south_trench1")
	sg_south_trench2 = SGroup_CreateIfNotFound("sg_south_trench2")
	
	
	--field mgs, not in buildings
	tmkr_carpiquet_mgs = {mkr_carpiquet_mg1, mkr_carpiquet_mg2}
	
	tsg_carpiquet_mgs = SGroup_CreateTable("sg_carpiquet_mg%d", table.getn(tmkr_carpiquet_mgs))
	sg_mg_attackers = SGroup_CreateIfNotFound("sg_mg_attackers")
	
	
	t_carpiquet_town_mg_spawn_table = {
		{tsg_carpiquet_mgs[1], SBP.AXIS.HEAVYMG, tmkr_carpiquet_mgs[1], 1, 3, mkr_carpiquet_mg1_facing},
		{tsg_carpiquet_mgs[2], SBP.AXIS.HEAVYMG, tmkr_carpiquet_mgs[2], 1, 3, mkr_carpiquet_mg2_facing},
	}
	
	eg_axis_hq = EGroup_CreateIfNotFound("eg_axis_hq")
	EGroup_AddEGroup(eg_axis_hq, eg_carpiquet_building9) -- designates building 9 as the garrison reinforcement HQ (not true HQ)
	g_axis_hq_position = EGroup_GetPosition(eg_axis_hq)
	
	
	
	t_carp_flag_checklist = {
		
		{eg_carp_flag1, true, mkr_carp_flag1_pointer}, 
		--{eg_carp_flag2, MapElementID = nil, mkr_carp_flag2_pointer}, 
		--{eg_carp_flag3, MapElementID = nil, mkr_carp_flag3_pointer}, 
		
	}
	
    sg_carpiquet_reinforcements = SGroup_CreateTable("sg_carpiquet_reinforcement%d", 2)
	sg_carpiquet_stuart_reinforcement1 = SGroup_CreateIfNotFound("sg_carpiquet_stuart_reinforcement1")
	sg_carpiquet_stuart_reinforcement2 = SGroup_CreateIfNotFound("sg_carpiquet_stuart_reinforcement2")
	sg_carpiquet_reinforcements_group = SGroup_CreateIfNotFound("sg_carpqiuet_reinforcement_group")
	
	sg_enemy_reinforcement_minders = SGroup_CreateIfNotFound("sg_enemy_reinforcement_minders")
	
	sg_player_infantry_hq = SGroup_CreateIfNotFound("sg_player_infantry_hq")
	sg_player_tommy_hq = SGroup_CreateIfNotFound("sg_player_tommy_hq")
	
	t_obj_capture_carpiquet = {}
	-- set up intel event tables
--[[
	t_carpiquet_dialogue = {
		
		warning = {
			{ACTOR.GenericAlly, LOC("We're on the outskirts of Carpiquet.  I hope we have enough firepower to drive out the Germans, if we attack!")}
		},
		
		detection = {
			{ACTOR.GenericAlly, LOC("Hans! I think I heard something by the trenches...")}
		},
	}]]
	
	t_carpiquet_dialogue = {}
	
	--AMBIENT
	t_carpiquet_dialogue.warning = {
		--{ACTOR.GenericAlly, LOC("We're on the outskirts of Carpiquet.  I hope we have enough firepower to drive out the Germans, if we attack!")}
		{ACTOR.CXP1.GenericCommando, 1330830}, --We're on approach from the north.  We have Carpiquet in view.
		{ACTOR.CXP1.GenericCommando, 1331500}, --Let's hope we have enough firepower to take it on…
	}
	
	--AMBIENT
	t_carpiquet_dialogue.detection = {
		--{ACTOR.GenericAlly, LOC("Hans! I think I heard something by the trenches...")}
		{ACTOR.CXP1.GenericAxis, 1330820}, --Wilhelm, I think something's out by the barricade.
		{ACTOR.CXP1.GenericAxis, 1330821}, --Are you sure you didn't have too much cider? Let's go take a look.
	}
	
	--AMBIENT -- only said when canadians capture it (ie. after the canadians arrive when the commandos blow up the last raid objective)
	--otherwise when Carpiquet is captured by the British nothing is said, except for the canadian reinforcements that arrive when the town gets taken over.
	-- ADDED TO EVENTS FILE
	--t_carpiquet_dialogue.captured = {
		--{ACTOR.GenericAlly, 1330840}, -- Carpiquet is ours! Add another for Canada boys!
		--{ACTOR.GenericAlly, 1330842}, -- Ah hell. Darwin is down and he isn't moving!
		--{ACTOR.GenericAlly, 1330841}, -- Excellent job RCR, let's keep up the momentum! 
		
		
	--}

	
	t_carpiquet_reinforcements = {
		
		soldiers = {
			
			{name = sg_carpiquet_reinforcements[1], blueprint = SBP.CW.TOMMIES_CANADIAN_SP, loc = mkr_allied_infantry_carpiquet_reinforcement, number = 6},
			{name = sg_carpiquet_reinforcements[2], blueprint = SBP.CW.LIEUTENANT, loc = mkr_allied_infantry_carpiquet_reinforcement, number = 1},
			--{name = sg_carpiquet_reinforcements[2], blueprint = SBP.CW.TOMMIES_CANADIAN_SP, loc = mkr_allied_vehicle_carpiquet_reinforcement, number = 3},
		},
		
		vehicles = {
			
			{name = sg_carpiquet_stuart_reinforcement1, blueprint = SBP.CW.STUART, loc = mkr_allied_vehicle_carpiquet_reinforcement1, number = 1, destination = mkr_stuart_destination1},
			{name = sg_carpiquet_stuart_reinforcement2, blueprint = SBP.CW.STUART, loc = mkr_allied_vehicle_carpiquet_reinforcement2, number = 1, destination = mkr_stuart_destination2},
			
		},

		
		
		
	}
	
	
	t_carpiquet_reinforcements.greeting = {
		--{ACTOR.GenericAlly, LOC("More reinforcements have arrived")}
		{ACTOR.CXP1.GenericCommonwealth, 1330870}, --Canadian Rifles reporting for duty, where's the fight!
		{ACTOR.CXP1.Chubb, 1330871}, --Our orders are to support the Commandos in their advance.

	}
	
	
	
	b_Capture_CarpiquetOBJComplete = false
	
	t_capture_carpiquet_car_patrol_data = {
	
		car1 = {name = sg_carpiquet_car1_patrol,
		--blueprint = SBP.AXIS.MOTORCYCLE,
		blueprint = SBP.ELITE.ARMOURCAR_221,
		spawn = mkr_car1_spawn, 
		g_car1_patrol_place = 1,
		g_car1_patrol_point_count = table.getn(tmkr_carpiquet_car1_patrol),
		patrolpath = {},
		},
	}
	
	--patrol data for car 1
	for z = 1, table.getn(tmkr_carpiquet_car1_patrol) do
		
		table.insert(t_capture_carpiquet_car_patrol_data.car1.patrolpath, tmkr_carpiquet_car1_patrol[z] )
	
	end
	
	
end


-- preset any units or events needed before the kickoff, but you do not
-- want them to occur at the outset of the map.
-- Example: Often units are needed to exist before the objective start (because they start the objective)
-- then spawn those units here when they need to be spawned
function Capture_Carpiquet_Preset()

	-- spawn squads
	
	for d = 1, table.getn(t_carpiquet_town_spawn_table) do 
		
		
		local temp = t_carpiquet_town_spawn_table[d]
 		
		if EGroup_IsEmpty(temp[3]) == false then		
			Util_CreateSquads(player2, temp[1], temp[2], temp[3], nil, 1, temp[5])			
			SGroup_AddGroup(sg_carpiquet_enemies, temp[1])
			
		end
		
 	end
	
	-- spawning MG squads
	for d = 1, table.getn(t_carpiquet_town_mg_spawn_table) do 
		
		local temp = t_carpiquet_town_mg_spawn_table[d]
 			
		Util_CreateSquads(player2, temp[1], temp[2], temp[3], nil, 1, nil, nil, temp[4], nil)
		
		
		SGroup_FaceMarker(temp[1], mkr_carpiquet_mg2_facing)
		
		Cmd_InstantSetupTeamWeapon(temp[1])
		
		SGroup_AddGroup(sg_carpiquet_enemies, temp[1])
		
 	end
	
	-- spawn occupiers for the reinforcement building
	
	if EGroup_IsEmpty(eg_carpiquet_building9) == false then
		Util_CreateSquads(player2, sg_enemy_reinforcement_minders, SBP.AXIS.GRENADIER, eg_carpiquet_building9, nil, 1)
		
		SGroup_AddGroup(sg_carpiquet_enemies, sg_enemy_reinforcement_minders)
	end
	

	
	
	-- spawn car1
	
	Util_CreateSquads(player2, t_capture_carpiquet_car_patrol_data.car1.name, t_capture_carpiquet_car_patrol_data.car1.blueprint, 
	t_capture_carpiquet_car_patrol_data.car1.spawn)
		
	SGroup_AddGroup(sg_carpiquet_enemies, t_capture_carpiquet_car_patrol_data.car1.name)
	
	Modify_SightRadius(t_capture_carpiquet_car_patrol_data.car1.name, 0.5)
	Modify_WeaponRange(t_capture_carpiquet_car_patrol_data.car1.name, "hardpoint_01", 0.75)
	--Modify_WeaponAccuracy(t_capture_carpiquet_car_patrol_data.car1.name, "hardpoint_01", 0.5)
	Modify_UnitSpeed(t_capture_carpiquet_car_patrol_data.car1.name, 0.5)
	
	
	-- start enemy behavior
	
	Rule_AddInterval(Capture_Carpiquet_Troop_Exit, 3)
	Rule_AddInterval(Capture_Carpiquet_Car1_Patrol, 1)
	
	Rule_AddInterval(Capture_Carpiquet_MG_Control, 5)
	
	-- do other cool things
	--[[
	for y = 1, table.getn(teg_carpiquet_buildings) do
		--print(EGroup_FromName(teg_carpiquet_buildings[y]))
		
		print(EGroup_IsEmpty(teg_carpiquet_buildings[y]))
		
		EGroup_SetAvgHealth(teg_carpiquet_buildings[y], 0.05)
		EGroup_SetAvgHealth(eg_factory_a, 0.05)
		
	end]]
	

end

function Capture_Carpiquet_MG_Control()

	if SGroup_IsEmpty(tsg_carpiquet_mgs[1]) and SGroup_IsEmpty(tsg_carpiquet_mgs[2]) then
	
		Rule_RemoveMe()
		
	else
	
	
		for u = 1, table.getn(tsg_carpiquet_mgs) do
		
			if SGroup_IsUnderAttack(tsg_carpiquet_mgs[u], false, 5) then
				
				SGroup_GetLastAttacker(tsg_carpiquet_mgs[u], sg_mg_attackers)
				
				if SGroup_IsEmpty(sg_mg_attackers) == false then
					
					Cmd_AttackMove(tsg_carpiquet_mgs[u], sg_mg_attackers, nil, nil, 25)
					
				end
				
			end
		
		end

	end

end


-- gives dialogue when player moves into either Carpiquet Zone. Rule removes itself once activated
function Capture_Carpiquet_Activation1()

	
	if Prox_ArePlayersNearMarker(player1, mkr_secondary_activation1, false) then -- if player steps in zone 1
		
		if EGroup_IsEmpty(eg_carpiquet_trench_spawn) == false then
		
			Util_AutoAmbient(t_carpiquet_dialogue.detection)
				
			Util_CreateSquads(player2, sg_south_trench1, t_difficulty.g_soldier_type3, eg_carpiquet_trench_spawn, mkr_carpiquet_trench1, 1, 4)
			SGroup_AddGroup(sg_carpiquet_enemies, sg_south_trench1)
			--Cmd_AttackMove(sg_south_trench1, mkr_carpiquet_trench1, nil, nil, 10)
			
			Util_CreateSquads(player2, sg_south_trench2, t_difficulty.g_soldier_type1, eg_carpiquet_trench_spawn, mkr_carpiquet_trench2, 1, 4)
			SGroup_AddGroup(sg_carpiquet_enemies, sg_south_trench2)
			--Cmd_AttackMove(sg_south_trench2, mkr_carpiquet_trench2, nil, nil, 10)
			--Rule_AddOneShot(Capture_Carpiquet_Delay, 6) -- delays activation by 2 seconds
			
			Rule_RemoveMe()
			
		else
		
			--Util_AutoAmbient(t_carpiquet_dialogue.detection)
		
			Rule_RemoveMe()
		
		end
		
	elseif Prox_ArePlayersNearMarker(player1, mkr_secondary_activation2, false) then -- if player steps in zone 2
		
		Util_AutoAmbient(t_carpiquet_dialogue.warning)
		
		--Rule_AddOneShot(Capture_Carpiquet_Delay, 6) -- delays activation by 2 seconds
		
		Rule_RemoveMe()
	
	end
end



function Capture_Carpiquet_Delay() -- only activates after first objective gets destroyed
	
	--if g_first_objective_over == true and EGroup_IsEmpty(eg_factory_a) == false then
	
		Objective_Start(OBJ_Capture_Carpiquet) -- start objective
		
		Rule_RemoveMe()
		
	--end

end

-- start the related action
function Capture_Carpiquet_Kickoff()
	
	-- action that starts with the Obj being granted
	Rule_AddInterval(Capture_Carpiquet_Remove_Pings, 1)
	--Rule_AddInterval(Capture_Carpiquet_Troop_Exit, 10)
	--Rule_AddInterval(Capture_Carpiquet_Car1_Patrol, 1)
	
end


function Capture_Carpiquet_Patrol1()

--proposed patrol 1 to give life to Carpiquet
end


function Capture_Carpiquet_Patrol2()

-- proposed patrol 2 to give life to Carpiquet
end




-- example of how to finish an Obj
function Capture_Carpiquet_WinCheck()
	if Event_IsAnyRunning() == false then
		
		-- player wins by capturing the point before the garrison stuff finishes
		if EGroup_IsCapturedByPlayer(eg_carp_flag1, player1, true) then--and EGroup_IsEmpty(eg_factory_a) == false then
			-- the player has just won
			Objective_Complete(OBJ_Capture_Carpiquet)
			
			-- removes the pings if added, for this objective
			for i = 1, table.getn(t_carp_flag_checklist) do
				
				if t_carp_flag_checklist[i][2] ~= nil or t_carp_flag_checklist[i][2] ~= false then
					Objective_RemoveUIElements(OBJ_Capture_Carpiquet, t_carp_flag_checklist[i][2])
				end
				
			end
			
			b_Capture_CarpiquetOBJComplete = true
			
			Util_StartIntel(EVENTS.CAPTURE_CARPIQUET)
			
			Rule_AddInterval(Capture_Carpiquet_Delay_Reinforcements, 1)
			
			
			Rule_RemoveMe()
--~ 			
--~ 		elseif EGroup_IsCapturedByPlayer(eg_carp_flag1, player1, true) == false then --and t_commando.action.fg_commandos_all_objectives_ok == true then --Objective_IsComplete(OBJ_Commando_Action) == true
--~ 			
--~ 			
--~ 			-- the player has just failed
--~ 			Objective_Fail(OBJ_Capture_Carpiquet, false)
--~ 			
--~ 			Rule_RemoveMe()
--~ 			
		end
		
	end
	
end

function Capture_Carpiquet_Delay_Reinforcements()

	if Event_IsAnyRunning() == false then
		
		Rule_AddOneShot(Capture_Carpiquet_CW_Reinforcements, 1)
		
		Rule_RemoveMe()
		
	end
		
end


function Capture_Carpiquet_CW_Reinforcements()

	if Event_IsAnyRunning() == false then

	
		for k, v in pairs (t_carpiquet_reinforcements.vehicles) do
			
			Util_CreateSquads(player1, v.name, v.blueprint, v.loc,  nil, 1, v.number)
			SGroup_AddGroup(sg_carpiquet_reinforcements_group, v.name)
			Cmd_Move(v.name, v.destination)
			
		end

		
		EventCue_Create(CUE.NORMAL_REPEATING, nil, nil, sg_carpiquet_reinforcements_group)
		
		--Rule_AddOneShot(Capture_Carpiquet_Spawn_HQ, 3)
		
		Util_StartIntel(EVENTS.CAPTURE_POINTS_RCR_ARRIVES) -- random entrance speech
		
		
		Rule_AddOneShot(Capture_Carpiquet_CW_Reinforcements_Ping, 2)
	end
	
end



function Capture_Carpiquet_CW_Reinforcements_Ping() -- adds a tactical map ping on the tower for 10 seconds

	EventCue_Create(CUE.NORMAL_REPEATING, nil, nil, sg_carpiquet_reinforcements_group)
	
end





function Capture_Carpiquet_Remove_Pings() -- function for removing pings from the map once a strategic point is captured
	
	if b_Capture_CarpiquetOBJComplete == true then -- or g_stratpoint_countdown <= 0 
		
		-- if the objective is complete, then remove the rule
		Rule_RemoveMe()
		
	else
		
		for c = 1, table.getn(t_carp_flag_checklist) do -- leaving this in place in case we decide to make it so that multiple flags are captured instead of just 1
			
			-- if the flag egroup in question is captured by the player, and there is a ping, we need to remove it
			if EGroup_IsCapturedByPlayer(t_carp_flag_checklist[c][1], player1, false) and (t_carp_flag_checklist[c][2] ~= false) then
			
				-- remove ping
				Objective_RemoveUIElements(OBJ_Capture_Carpiquet, t_carp_flag_checklist[c][2])
				
				t_carp_flag_checklist[c][2] = false
				
				
			-- if the flag egroup in question is not captured by the player, and there is no ping, then we need to add it back
			elseif EGroup_IsCapturedByPlayer(t_carp_flag_checklist[c][1], player1, false) == false and (t_carp_flag_checklist[c][2] == false) then
				
				-- re-add ping
				--t_carp_flag_checklist[c][2] = Objective_AddUIElements(OBJ_Capture_Carpiquet, t_carp_flag_checklist[c][3], true, 1339157, false, true, true)--LOC("Capture this point to make the frontline!")
				t_carp_flag_checklist[c][2] = Objective_AddUIElements(OBJ_Capture_Carpiquet, t_carp_flag_checklist[c][3], true, 1339157, true, 2)--LOC("Capture this point to make the frontline!")
				
				t_carp_flag_checklist[c][2] = true
				
			end
		end
		
	end
	
end

-- function that governs what happens when a garrisoned squad in Carpiquet is attacked
function Capture_Carpiquet_Troop_Exit()
 
	if b_Capture_CarpiquetOBJComplete == true then -- or g_stratpoint_countdown <= 0 
		
		-- if the objective is complete, then remove the rule
		Rule_RemoveMe()
		
	else
		
		for i = 1, table.getn(t_carpiquet_town_spawn_table) do -- run this through the whole table of Carpiquet building units
		 
			if SGroup_IsEmpty(t_carpiquet_town_spawn_table[i][1]) == false then
			
			-- if building squad has people in it, and is garrisoned
				if SGroup_IsInHoldEntity(t_carpiquet_town_spawn_table[i][1], true) then
					
					if SGroup_IsUnderAttackByPlayer(t_carpiquet_town_spawn_table[i][1], player1, 5) then -- if sgroup was under attack by player for 5 seconds and is in building
					
						Cmd_UngarrisonSquad(t_carpiquet_town_spawn_table[i][1]) -- make the squad ungarrison
						
					end
					
					-- otherwise, if building squad has people in it, and is under attack by the player
				elseif SGroup_IsUnderAttackByPlayer(t_carpiquet_town_spawn_table[i][1], player1, 1) then
					
					--SGroup_GetLastAttacker(t_carpiquet_town_spawn_table[i][1], tsg_carpiquet_attacker[i]) -- gets the last sgroup that attacked the building squad
					
					--Cmd_AttackMove(t_carpiquet_town_spawn_table[i][1], t_carpiquet_town_spawn_table[i][6], nil, nil, 50) -- attacks the last sgroup that attacked the building squad (tsg_carpiquet_attacker[i])
					Cmd_Move(t_carpiquet_town_spawn_table[i][1], t_carpiquet_town_spawn_table[i][6], nil, nil, nil, nil, nil, 5)
					
				elseif SGroup_IsIdle(t_carpiquet_town_spawn_table[i][1], true) then
					-- gets own position so it spreads out
					Cmd_Move(t_carpiquet_town_spawn_table[i][1], SGroup_GetPosition(t_carpiquet_town_spawn_table[i][1]), nil, nil, nil, nil, nil, 5) --t_carpiquet_town_spawn_table[i][6]
					
					if i == 4 or i == 5 then -- 4 is exception to this rule
						
						Cmd_Move(t_carpiquet_town_spawn_table[i][1], mkr_fallback4, nil, nil, nil, nil, nil, 5) --t_carpiquet_town_spawn_table[i][6]
					
					end
					
					
				end
				
			end
			
		end
		
	end

end




function Capture_Carpiquet_Car1_Patrol() -- controls the patrol near the Factory

	
	
	
		local patrol_group = t_capture_carpiquet_car_patrol_data.car1
		
		if SGroup_IsEmpty(patrol_group.name) == true then
			
			Rule_RemoveMe()
			
		else
			
			if SGroup_IsUnderAttackByPlayer(patrol_group.name, player1, 1) == true then
				
				SGroup_GetLastAttacker(patrol_group.name, sg_car1_patrol_attacker) -- gets the last sgroup that attacked the building squad
				
				if SGroup_IsEmpty(sg_car1_patrol_attacker) == false then
					Cmd_AttackMove(patrol_group.name, sg_car1_patrol_attacker) -- attacks the last sgroup that attacked the building squad
				end	
				
				Rule_RemoveMe()
				
			elseif SGroup_IsUnderAttackByPlayer(sg_carpiquet_enemies, player1, 1) == false or SGroup_IsUnderAttackByPlayer(patrol_group.name, player1, 1) == false then
				
				if SGroup_IsMoving(patrol_group.name, false) == false then
					
					if patrol_group.g_car1_patrol_place >= patrol_group.g_car1_patrol_point_count then
						
						patrol_group.g_car1_patrol_place = 1
						
					elseif patrol_group.g_car1_patrol_place <= (patrol_group.g_car1_patrol_point_count - 1) then
						
						patrol_group.g_car1_patrol_place = patrol_group.g_car1_patrol_place + 1
						
					end
					
					Cmd_AttackMove(patrol_group.name, patrol_group.patrolpath[patrol_group.g_car1_patrol_place])
					
					
					
				end
				
			elseif SGroup_IsUnderAttackByPlayer(sg_carpiquet_enemies, player1, 1) == true then
				
				--local data  = t_capture_carpiquet_car_patrol_data
				
				--for i = 1, table.getn(t_capture_carpiquet_car_patrol_data) do
				
				for k, v in pairs(t_carpiquet_town_spawn_table) do
					
					if SGroup_IsEmpty(v[1]) == false and SGroup_IsUnderAttackByPlayer(v[1], player1, 1) then
						
						SGroup_GetLastAttacker(v[1], tsg_carpiquet_attacker[k]) -- gets the last sgroup that attacked the building squad
						
						if SGroup_IsEmpty(tsg_carpiquet_attacker[k]) == false then
							Cmd_AttackMove(patrol_group.name, tsg_carpiquet_attacker[k]) -- attacks the last sgroup that attacked the building squad
						end
						
						Rule_RemoveMe()
						
					end
					
				end
				
			end
			
		end
	
end

-----------------------------
-- Beginning Encounters -- 
-----------------------------




function Patrol1_Init() -- initialize stuff for the checkpoint near the landing zone
	eg_patrol1_munitions = EGroup_CreateIfNotFound("eg_patrol1_munitions")
	eg_patrol1_panzershreck = EGroup_CreateIfNotFound("eg_patrol1_panzershreck")
	
	sg_patrol1 = SGroup_CreateIfNotFound("sg_patrol1")
	
	sg_patrol_overgroup = SGroup_CreateIfNotFound("sg_patrol_overgroup")
	
	-- patrol data
	t_patrol1 = {
		
		spawn = {
			
			{name = sg_patrol1, blueprint = t_difficulty.g_soldier_type2, loc = mkr_patrol1},
			
		},
		
		pickups ={
			{name = eg_patrol1_munitions, blueprint = EBP.PICKUP.MUNITIONS, loc = mkr_patrol1_munitions, hintpoint_ID = false, hintpoint_text = 1339145 },
			{name = eg_patrol1_panzershreck, blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = mkr_patrol1_panzershreck, hintpoint_ID = false, hintpoint_text = 1339144},
		},
		
		--[[
		alert = {
			{ACTOR.GenericAlly, LOC("Quiet!  I think I hear some Jerries up ahead...")},
		},]]
		
	}
	--[[
	t_patrol1.alert = {
		{ACTOR.GenericAlly, LOC("Quiet!  I think I hear some Jerries up ahead...")},
	}]]
	
	
	Patrol1ThreatID = false
	--f_patrolthreat = false
	--f_patrol1_seen_once = false

	
	
end


function Patrol1_Preset()

	-- spawn squads
	
	for k, v in pairs(t_patrol1.spawn) do
		
		local patrol1_squad = v
		
		Util_CreateSquads(player2, patrol1_squad.name, patrol1_squad.blueprint, patrol1_squad.loc)
		SGroup_AddGroup(sg_patrol_overgroup, patrol1_squad.name)
		--Cmd_InstantUpgrade(patrol1_squad.name, UPG.AXIS.GREN_MG42, 1)
		
		Cmd_Move(patrol1_squad.name, mkr_patrol1_sandbags)
		
	end
	
	
	for k, v in pairs(t_patrol1.pickups) do
		local pickup = v
		Util_CreateEntities(nil, pickup.name, pickup.blueprint, pickup.loc, 1)
		
	end

	--t_patrol1.pickups[2].hintpoint_ID = HintPoint_Add(t_patrol1.pickups[2].name, true, t_patrol1.pickups[2].hintpoint_text)  
	
	-- do other cool things

end


function Patrol1_Activation()

	Rule_AddOneShot(Patrol1_Delay1, 0)
	
	--Rule_AddOneShot(Patrol1_Action, 5)

end


function Patrol1_Delay1()

	--local patrol1_pos = SGroup_GetPosition(sg_patrol1)
	
	--FOW_RevealSGroup(sg_patrol1, 6)
	
	--Camera_FocusOnPosition(patrol1_pos, true)
	
	if Patrol1ThreatID == false and SGroup_IsEmpty(sg_patrol1) == false then
		
		Patrol1ThreatID = ThreatArrow_CreateGroup()
		ThreatArrow_Add(Patrol1ThreatID, sg_patrol1)
		Rule_AddOneShot(Patrol1_Arrow_Manager, 10)
		
	end
	
	--Util_AutoIntel(t_patrol1.alert)
	Util_AutoIntel(t_first_encounter.move_out)
	
	Rule_AddInterval(Patrol1_Action, 2)
	

end


function Patrol1_Arrow_Manager()
	
	if SGroup_IsEmpty(sg_patrol1) then
		
		ThreatArrow_Remove(Patrol1ThreatID, sg_patrol1)
		ThreatArrow_DestroyGroup(Patrol1ThreatID)
		
		
		
		Rule_RemoveMe()
		
	end
	
end



function Patrol1_Action()

	if Event_IsAnyRunning() == false then
		
		Player_GetAll(player1)
		
		if SGroup_IsEmpty(sg_patrol_overgroup) == true or ((World_GetGameTime() > 120 or Prox_ArePlayerMembersNearMarker(player1, mkr_opening_FOW, true, 70) == false) and SGroup_Count(sg_allsquads) >= 1) then
			
			Util_AutoIntel(t_first_encounter.pre_sit_rep03_01)
			
			--Rule_AddOneShot(Patrol1_SitRep_03_01_Delay, 5)
			
			if EGroup_IsEmpty(t_patrol1.pickups[2].name) == false then
				t_patrol1.pickups[2].hintpoint_ID = HintPoint_Add(t_patrol1.pickups[2].name, true, t_patrol1.pickups[2].hintpoint_text)  -- hint to pick up panzershreck if the player hasn't done it yet
			end
			
			Objective_UpdateText(OBJ_Commando_Action, 1339100, 1339110, false)
			Sound_PlayMusic("Music/SP/Caen/Preparation/coh_they're_out_there.bsc",2,0)
			--Util_AutoNISlet( NISLET_GAME2GAME, t_carpiquet_sitrep.temp_01 )
			
			-- surreptitiously add in the sitrep and pretend it was always there
			OBJ_Commando_Action.OnStart = function() end
			OBJ_Commando_Action.SitRep = {
				Movie = "CXP1_SR_03-01",
				Force = true,
				SpeechTiming =
				{
					{ 1,	ACTOR.CXP1.Cutting, 1330550 },
					{ 3.4,	ACTOR.CXP1.Cutting, 1330551 },
					{ 7.5,	ACTOR.CXP1.Cutting, 1330552 },
					{ 16,	ACTOR.CXP1.Cutting, 1330553 },
					{ 21.5,	ACTOR.CXP1.Cutting, 1330558 },
					{ 27,	ACTOR.CXP1.Blackmore, 1330554 },
					{ 33,	ACTOR.CXP1.Blackmore, 1330555 },
					{ 39,	ACTOR.CXP1.Blackmore, 1330556 },
					{ 44.8,	ACTOR.CXP1.Blackmore, 1330557 },
				},
			}
			
			Objective_RemoveUIElements(OBJ_Commando_Action, OBJ_Commando_Action.mapElementID1)
			
			OBJ_Commando_Action.mapElementID1 = Objective_AddUIElements(OBJ_Commando_Action, eg_ammo_driver_spawn1, true, 1339100, true)


			Obj_SetObjectiveFunction(OBJ_Commando_Action.ID, FN_OnActivate, __ObjectiveOnActivateCallback)
			Objective_ForceSitRep(OBJ_Commando_Action)
			
			
			
			Rule_AddDelayedInterval(Commando_Reveal_Ammo_Dump_Objective_Start, 2, 2)

			
			--Rule_AddInterval(Initial_Music_Delay,1)
			
			Rule_RemoveMe()
			
		else 
		
		end
		
	end
end

function Initial_Music_Delay()

	if Event_IsAnyRunning() == false then
	
		Sound_PlayMusic("Music/SP/Caen/Preparation/coh_they're_out_there.bsc",2,0)
		
		Rule_RemoveMe()
		
	end
	
end


--------------------------------------------------------------------------



function Patrol2_Init() -- initialize stuff for the checkpoint near the landing zone
	
	sg_patrol2 = SGroup_CreateIfNotFound("sg_patrol2")
	sg_patrol_overgroup = SGroup_CreateIfNotFound("sg_patrol_overgroup")
	
	-- patrol 2 data
	t_patrol2 = {
		
		spawn = {
			
			{name = sg_patrol2, blueprint = t_difficulty.g_soldier_type1, loc = mkr_patrol2_spawn},
			
		},
		--[[
		alert = {
			{ACTOR.GenericAlly, LOC("Blast, more Jerries!")}
		},
		
		detection = {
			{ACTOR.GenericAlly, LOC("Halt!  Intruders!!")}
		},]]
		
		f_patrol2_seen_once = false,
		
		path = {mkr_patrol2_point1, mkr_patrol2_point2, mkr_patrol2_point3, mkr_patrol2_point4},
		
	}
	
	-- UNUSED?
	--[[
	t_patrol2.alert = {
		{ACTOR.GenericAlly, LOC("Blast, more Jerries!")}
	}
	
	t_patrol2.detection = {
		{ACTOR.GenericAlly, LOC("Halt!  Intruders!!")}
	}]]
	
	g_patrol2_count = table.getn(t_patrol2.path)	
	
	g_patrol2_point = 1

	f_patrol2_seen_once = false
	
	Patrol2ThreatID = false
	
	patrol2_attacker = SGroup_CreateIfNotFound("patrol2_attacker")
	patrol_overgroup_attacker = SGroup_CreateIfNotFound("patrol_overgroup_attacker")
end


function Patrol2_Preset()

	-- spawn squads
	
	for k, v in pairs(t_patrol2.spawn) do
		
		local patrol2_squad = v
		
		Util_CreateSquads(player2, patrol2_squad.name, patrol2_squad.blueprint, patrol2_squad.loc)
		SGroup_AddGroup(sg_patrol_overgroup, patrol2_squad.name)
		
		
	end
	
	-- start enemy behavior
	
	
	
	-- do other cool things

end


function Patrol2_Activation()

	Rule_AddInterval(Patrol2_Action, 2)

end


function Patrol2_Action()

	if SGroup_IsEmpty(sg_patrol2) == true then
		
		Rule_RemoveMe()
		
	else 
		
		if SGroup_IsEmpty(sg_patrol_overgroup) == false and SGroup_IsUnderAttack(sg_patrol_overgroup, false, 2) then

			if Event_IsAnyRunning() == false then

				SGroup_GetLastAttacker(sg_patrol_overgroup, patrol2_attacker)
				
				if SGroup_IsEmpty(patrol2_attacker) == false then
				
					Util_StartIntel (EVENTS.BATTLE_CHATTER2)
					
					local overgroup_attacker_pos = SGroup_GetOffsetPosition(patrol2_attacker, 2, 20)
					
					Cmd_Move(sg_patrol2, overgroup_attacker_pos, nil, nil, nil, nil, nil, 5)
					
					if Rule_Exists(Patrol2_Sandbag_Move) == false then
						
						Rule_AddInterval(Patrol2_Sandbag_Move, 5)
						
					end
					
					Rule_RemoveMe()
					
				end
		
			end
			
		elseif (SGroup_IsUnderAttack(sg_patrol2, false, 2) and f_patrol2_seen_once == true) then
			
			if Event_IsAnyRunning() == false then
			
				SGroup_GetLastAttacker(sg_patrol2, patrol2_attacker)
			
				--CALL AMBIENT SPEECH HERE
				--Util_AutoIntel(t_patrol2.detection)
				if SGroup_IsEmpty(patrol2_attacker) == false then
				
					Util_StartIntel (EVENTS.BATTLE_CHATTER2)
					
					local patrol2_attacker_pos = SGroup_GetOffsetPosition(patrol2_attacker, 2, 20)
					
					Cmd_Move(sg_patrol_overgroup, patrol2_attacker_pos, nil, nil, nil, nil, nil, 5)
					
					if Rule_Exists(Patrol2_Sandbag_Move) == false then
						Rule_AddInterval(Patrol2_Sandbag_Move, 5)
					end
					
					Rule_RemoveMe()
					
				end
			
			end
			
		elseif f_patrol2_seen_once == false and Player_CanSeeSGroup(player1, sg_patrol2, false)then
			
			if Event_IsAnyRunning() == false then
			
				local patrol2_pos = SGroup_GetPosition(sg_patrol2)
				
				--Camera_FocusOnPosition(patrol2_pos, true)
				
				--Util_AutoIntel(t_patrol2.alert)
				
				--CALL IN AMBIENT STUFF HERE
				
			
			
				Util_StartIntel (EVENTS.BATTLE_CHATTER1)
				
				
				
				f_patrol2_seen_once = true
				
				if Patrol2ThreatID == false and SGroup_IsEmpty(sg_patrol2) == false then
			
					Patrol2ThreatID = ThreatArrow_CreateGroup()
					ThreatArrow_Add(Patrol2ThreatID, sg_patrol2)
					Rule_AddOneShot(Patrol2_Arrow_Manager, 20)
			
				end
			

			end
		end
		
	end

end


function Patrol2_Sandbag_Move()

	if Prox_AreSquadsNearMarker(sg_patrol2, mkr_patrol1_reveal, false) == true then
		
		Rule_RemoveMe()
		
	else
		
		--if SGroup_IsUnderAttack(sg_patrol2, false, 1) == false then
		if SGroup_IsEmpty(sg_patrol1) then	
			
			Cmd_Move(sg_patrol2, mkr_patrol1, nil,nil,nil,nil,nil, 15)
		

		elseif SGroup_IsEmpty(sg_patrol_overgroup) == false and SGroup_IsUnderAttack(sg_patrol_overgroup, false, 5) then
		
			SGroup_GetLastAttacker(sg_patrol_overgroup, patrol2_attacker)
			
			if SGroup_IsEmpty(patrol2_attacker) == false then
				local overgroup_attacker_pos = SGroup_GetOffsetPosition(patrol2_attacker, 2, 15)
			
				Cmd_Move(sg_patrol2, overgroup_attacker_pos, nil, nil, nil, nil, nil, 5)
			end
			
		
		end
		
	end


end

function Patrol2_Arrow_Manager()
	
	if SGroup_IsEmpty(sg_patrol2) then
		
		ThreatArrow_Remove(Patrol2ThreatID, sg_patrol2)
		ThreatArrow_DestroyGroup(Patrol2ThreatID)
		Rule_RemoveMe()
		
	end
	
end

-------------------------------------------------------------------------

--The Ammo Dump Encounter

--Make officer run around to "talk" to people -- part of Commando portion of the level

-------------------------------------------------------------------------

-- 'Init()' is used to preset the Obj
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Ammo_Dump_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	
	-- general group for all combatants
	sg_ammo_dump_force = SGroup_CreateIfNotFound("sg_ammo_dump_force")
	
	-- group for SGroup inside the tower structure
	sg_ammo_garrisoned = SGroup_CreateIfNotFound("sg_ammo_garrisoned")
	
	-- officer
	sg_ammo_dump_officer = SGroup_CreateIfNotFound("sg_ammo_dump_officer")
	sg_ammo_command_section = SGroup_CreateIfNotFound("sg_ammo_command_section")
	
	-- "drivers" which are actually MG crew for the halftracks
	tmkr_driver = Marker_GetTable("mkr_driver%d")	
	tsg_ammo_dump_driver = SGroup_CreateTable("sg_ammo_dump_driver%d", table.getn(tmkr_driver))
	
	-- regular guards who will provide protection
	tmkr_guard = Marker_GetTable("mkr_ammo_dump_guard%d")	
	tsg_ammo_dump_guard = SGroup_CreateTable("sg_ammo_dump_guard%d", table.getn(tmkr_guard))
	
	sg_ammo_dump_guard1 = SGroup_CreateIfNotFound("sg_ammo_dump_guard1")	
	sg_ammo_dump_guard2 = SGroup_CreateIfNotFound("sg_ammo_dump_guard2")	
	sg_ammo_dump_guard3 = SGroup_CreateIfNotFound("sg_ammo_dump_guard3")	
	
	sg_ammo_dump_outside_guard1 =	SGroup_CreateIfNotFound("sg_ammo_dump_outside_guard1")	
	
	tmkr_mg_marker = Marker_GetTable("mkr_ammo_dump_mg%d")	
	tsg_ammo_dump_mg = SGroup_CreateTable("sg_ammo_dump_mg%d", table.getn(tmkr_mg_marker))
	
	-- halftracks
	tmkr_vehicle_marker = Marker_GetTable("mkr_vehicle%d")	
	tsg_vehicle = SGroup_CreateTable("sg_vehicle%d", table.getn(tmkr_vehicle_marker))
	
	-- reinforcement runner
	sg_ammo_dump_reinforcement_runners = SGroup_CreateIfNotFound("sg_ammo_dump_reinforcement_runners")
	
	-- reinforcements 
	sg_ammo_dump_reinforcements = SGroup_CreateIfNotFound("sg_ammo_dump_reinforcements")
	sg_ammo_dump_gunners = SGroup_CreateIfNotFound("sg_ammo_dump_gunners")
	sg_ammo_dump_reinforcement_overgroup = SGroup_CreateIfNotFound("sg_ammo_dump_reinforcement_overgroup")
	-- enemy aggressor (player's)
	sg_ammo_dump_aggressor = SGroup_CreateIfNotFound("sg_ammo_dump_aggressor")
	
	
	-- explodable ammo boxes
	teg_explodegroup = {eg_explodegroup1, eg_explodegroup2}
	tg_explodeobject_count = {EGroup_Count(teg_explodegroup[1]), EGroup_Count(teg_explodegroup[2])}
	sg_collateral1 = SGroup_CreateIfNotFound("sg_collateral1")
	sg_collateral2 = SGroup_CreateIfNotFound("sg_collateral2")
	tsg_collateral = {sg_collateral1, sg_collateral2}
	
	t_explode_data = {}
	t_explode_data[1] = {egroup = eg_explodegroup1}
	t_explode_data[2] = {egroup = eg_explodegroup2}
	
	for n = 1, table.getn(t_explode_data) do
		t_explode_data[n].count = EGroup_Count(t_explode_data[n].egroup)
	end
	
	
	
	-- defender and officer spawn table

	
	t_ammo_dump_enemy_spawn_table = {
		{sg_ammo_dump_officer, SBP.AXIS.OFFICER, mkr_ammo_dump_officer_spawn, 1, 1}, --mkr_ammo_dump_officer_spawn
		{tsg_ammo_dump_driver[1], t_difficulty.g_soldier_type1, eg_ammo_driver_spawn1, 1, 2}, --mkr_driver1
		{tsg_ammo_dump_driver[2], t_difficulty.g_soldier_type1, eg_ammo_driver_spawn2, 1, 3},
		{sg_ammo_command_section, t_difficulty.g_soldier_type3, eg_ammo_driver_spawn1, 1, 3},
	}
	
	-- regular guards and MG tower spawn table	
	t_ammo_dump_enemy_guard_table = {
		{tsg_ammo_dump_guard[1], t_difficulty.g_soldier_type2, mkr_ammo_dump_guard1, 1, 3},
		{tsg_ammo_dump_guard[2], t_difficulty.g_soldier_type1, eg_ammo_tower1, 1, 1},
		{tsg_ammo_dump_guard[3], t_difficulty.g_soldier_type1, mkr_ammo_dump_guard3, 1, 5},
	}

	
	t_ammo_dump_outside_guard = {
	
		{sg_ammo_dump_outside_guard1, t_difficulty.g_soldier_type2, mkr_ammo_dump_outside_guard1, 1, (3 + t_dif_numbers.g_dif_add_number)},
	
	}
	
	-- MG foot soldier spawn table 
	t_ammo_dump_enemy_mg_table = {
		{tsg_ammo_dump_mg[1], SBP.AXIS.HEAVYMG, eg_ammo_tower1, 1, 3},
	}
	
	
	-- halftrack spawn table
	t_ammo_dump_vehicle_table = {
		{tsg_vehicle[1], SBP.AXIS.HALFTRACK, tmkr_vehicle_marker[1], 1, 1, mkr_vehicle1_facing}, -- SBP.ELITE.HALFTRACK_251
		{tsg_vehicle[2], SBP.AXIS.HALFTRACK, tmkr_vehicle_marker[2], 1, 1, mkr_vehicle2_facing},
		--{tsg_vehicle[3], SBP.AXIS.HALFTRACK, tmkr_vehicle_marker[3], 1, 1, mkr_vehicle3_facing},
	}
	--[[
	t_ammo_dump = {
		
		event_discovery = {
			{ACTOR.GenericAlly, LOC("Zee Tommies are here! Quickly, get reinforcements!  Schnell! Schnell!!")}
		},
		event_at_tower = {
			{ACTOR.GenericAlly, LOC("The MG in that tower will rip us to shreds!")},
			{ACTOR.GenericAlly, LOC("We can use our smoke grenades, or we can try and find another way around.")},
			{ACTOR.GenericAlly, LOC("Whatever we do, decide quickly - we can't stick around for too long!")},
		}	
	}]]
	t_ammo_dump = {}
	--AMBIENT
	t_ammo_dump.event_discovery = {
		--{ACTOR.GenericAlly, LOC("Zee Tommies are here! Quickly, get reinforcements!  Schnell! Schnell!!")}
		{ACTOR.CXP1.GenericAxis, 1330610}, -- They must be British Commandos!  Quick, get reinforcements!  Schnell!  Schnell!!
		--{ACTOR.CXP1.GenericAxis, 1330611}, -- Where are they coming from?
		{ACTOR.CXP1.GenericAxis, 1330612}, -- Shit, they are everywhere!
		
	}
	
	t_ammo_dump.event_at_tower = {
		{ACTOR.CXP1.Hazard, 1330750}, -- MG42 to the front... Find cover 
		{ACTOR.CXP1.Hazard, 1330751}, -- Chambers, ready the SMOKE GRENADES and buy us some time.
		--{ACTOR.CXP1.Hazard, 1330752}, -- Bloody hell, get into cover or pop smoke grenades!
	}
	
	--[[
	t_ammo_dump.event_hq_eliminated = {
		{ACTOR.GenericAlly, 1330620}, -- Target 1 is down, I say again, Target 1 is down.
		{ACTOR.GenericAlly, 1330621}, -- You hear that lads?  That's the fuckin' sound of sweet victory!
		{ACTOR.GenericAlly, 1330622}, -- For King and country you fuckin' Hun bastards.
	}]]
	
	t_officer_patrol = {
		
		{destination = mkr_ammo_dump_officer_spawn},
		{destination = mkr_officer_point1},
		{destination = mkr_officer_point2},
		{destination = mkr_officer_point3},
		{destination = mkr_officer_point4},
		{destination = mkr_officer_point5},
		{destination = mkr_officer_point6},
		
	}
	
	t_squad_patrol = {
		{destination = mkr_ammo_dump_guard3},
		{destination = mkr_squad_point1},
		{destination = mkr_squad_point2},
	
	
	}
	
	g_ammo_dump_officer_patrol_point_count = table.getn(t_officer_patrol)
	g_patrol_place = 1 -- place in the patrol cycle for officer
	
	g_ammo_dump_squad_patrol_point_count = table.getn(t_squad_patrol)
	g_ammo_guard_patrol_place = 1 -- place in the guard patrol cycle
	
	g_ammo_dump_reinforcements_arrive = false -- reinforcements not arrived yet!
	
	f_officer_garrisoned = false
	g_officer_clock = 0
	g_officer_clock_base = 30
	
	-- for blowing up!!
	t_ammo_dump_explode = {
	
		
	
	}
	
	TowerThreatID = false
	f_threat = false
	
	f_ammo_dump_under_attack = false -- flag to see if ammo dump is under attack
	
	tf_explode_group_dead = {false, false}
	
	g_smoke_hint = 1339138 --LOC("Commandos can use concealing smoke!")
	
	
	EGroup_SetPlayerOwner(eg_ammo_driver_spawn1, player2) -- player2
	Cmd_InstantUpgrade(eg_ammo_driver_spawn1, UPG.AXIS.CONVERT_AMBIENT_BUILDING)
	
	g_ammo_nag_timer = 0
	
end




function Ammo_Dump_Preset()	
	
	-- spawn squads
 	
	-- drivers and officer
	for d = 1, table.getn(t_ammo_dump_enemy_spawn_table) do 
		
		local temp = t_ammo_dump_enemy_spawn_table[d]
 		
 		Util_CreateSquads(player2, temp[1], temp[2] , temp[3], nil, temp[4], temp[5]) --Util_GetPosition(temp[3])
		SGroup_AddGroup(sg_ammo_dump_force, temp[1]) 
		
 	end
	-- adds the command section to the group garrisoned inside the building
	--SGroup_AddGroup(sg_ammo_garrisoned, sg_ammo_command_section)
	SGroup_AddGroup(sg_ammo_command_section, sg_ammo_dump_officer)
	
	
	-- vehicles
	for d = 1, table.getn(t_ammo_dump_vehicle_table) do 
		
		local temp = t_ammo_dump_vehicle_table[d]
 		
 		Util_CreateSquads(player2, temp[1], temp[2] , Util_GetPosition(temp[3]), nil, temp[4], temp[5], false, temp[6]) -- facing appears to be broken
		
		Modify_SightRadius(temp[1], 0.8)
		Modify_WeaponRange(temp[1], "hardpoint_01", 0.8)
		Modify_WeaponAccuracy(temp[1], "hardpoint_01", 0.75)
		--Modify_UnitSpeed(temp[1], 0.75)
		Ceasefire_AddSGroup( temp[1] )
		SGroup_AddGroup(sg_ammo_dump_force, temp[1])
		 
 	end

	-- guards -- isolated because I might want to spawn these inside a bunker (can't do with Util_CreateSquads, may use Util_CreateSquadsAndGarrison)
	for d = 1, table.getn(t_ammo_dump_enemy_guard_table) do 
 		
		local temp = t_ammo_dump_enemy_guard_table[d]
 		
 		Util_CreateSquads(player2, temp[1], temp[2] , temp[3], nil, temp[4], temp[5])
 		SGroup_AddGroup(sg_ammo_dump_force, temp[1])
		
		--[[
		if (temp[1] ~= SGroup_FromName("sg_ammo_dump_guard1")) or (temp[1] ~= SGroup_FromName("sg_ammo_dump_guard2"))
			or  (temp[1] ~= SGroup_FromName("sg_ammo_dump_guard3")) then -- except for sg_ammo_dump_guard1, who guard the sandbags, everyone else gets thrown into the sg_ammo_dump_force
			
			SGroup_AddGroup(sg_ammo_dump_force, temp[1])
			
		end]]
		
 	end

	-- MGs
	for d = 1, table.getn(t_ammo_dump_enemy_mg_table) do 
		
		local temp = t_ammo_dump_enemy_mg_table[d]
 		
 		Util_CreateSquads(player2, temp[1], temp[2] , temp[3]) --, nil, temp[4], temp[5], false, temp[6]) -- facing appears to be broken
		Modify_SightRadius(temp[1], 0.8)
		Modify_WeaponRange(temp[1], "hardpoint_01", 0.8)
		Modify_WeaponAccuracy(temp[1], "hardpoint_01", 0.75)
		
		SGroup_AddGroup(sg_ammo_dump_force, temp[1])
		
		
 	end
	
	--outside guard
	for d = 1, table.getn(t_ammo_dump_outside_guard) do 
		
		local temp = t_ammo_dump_outside_guard[d]
 		Util_CreateSquads(player2, temp[1], temp[2] , temp[3], nil, temp[4], temp[5]) 
		
 	end
	
	
	-- reinforcement runner - motorcycle that runs into Carpiquet
	--Util_CreateSquads(player2, sg_ammo_dump_reinforcement_runners, SBP.AXIS.MOTORCYCLE, mkr_ammo_dump_reinforcement_runners) -- reinforcement runners
	--Modify_UnitSpeed(sg_ammo_dump_reinforcement_runners, 0.75)
	
	Rule_AddOneShot(Ammo_Dump_MG_Setup, 1)
	-- start enemy behavior
	
	
	-- do other cool things
	Ammo_Dump_ActionKickoff()
	
end


function Ammo_Dump_MG_Setup()
-- makes the MGs immediately set up
 	for d = 1, table.getn(t_ammo_dump_enemy_mg_table) do --t_ammo_dump_enemy_spawn_table[d][1]
 		
		local temp = t_ammo_dump_enemy_mg_table[d]
		
		Cmd_InstantSetupTeamWeapon(temp[1])
		
	end

end

function Ammo_Dump_LocationTrigger()

-- not used yet!
end



function Ammo_Dump_ActionKickoff()

	-- action that starts when this encounter is triggered
	--Rule_AddInterval(Ammo_Dump_Reinforcements_Runner_Control, 5)
	Rule_AddInterval(Ammo_Dump_Tower_Dialogue, 1)
	
	Rule_AddDelayedInterval(Garrison_Battle_Chatter_Control, 15, 1) -- ambient attacking chatter
	
	
	Rule_AddInterval(Ammo_Dump_Attacker_Tracker, 10)
	Rule_AddDelayedInterval(Ammo_Dump_Reaction, 1, 10)
	--Rule_AddDelayedInterval(Ammo_Dump_Officer_Control, 2, 5)
	Rule_AddDelayedInterval(Ammo_Dump_Officer_Patrol, 2, 10)
	Rule_AddDelayedInterval(Ammo_Dump_Squad_Patrol, 5, 10)
	Rule_AddDelayedInterval(Ammo_Dump_Gunner_Dash, 1, 5)
	--Rule_AddInterval(Ammo_Dump_Chain_Reaction, 1)
	--Rule_AddInterval(Commando_Ammo_Dump_Detonation_Detect, 1)
	
	Rule_AddInterval(Ammo_Dump_Occupation_Prevention, 1)
	
	Rule_AddInterval(Ammo_Dump_Last_Guy, 1)
	
	Rule_AddInterval(Commando_First_HQ_Flash_Start, 2)
	
end

-- prevents player from occupying the building if nobody is in it

function Ammo_Dump_Occupation_Prevention()

	if EGroup_IsEmpty(eg_ammo_driver_spawn1) == true then
		
		Rule_RemoveMe()
		
	else
		
		local loaded_squads = SGroup_CreateIfNotFound("loaded_squads")
		
		EGroup_GetSquadsHeld(eg_ammo_driver_spawn1, loaded_squads)
		
		if SGroup_IsEmpty(loaded_squads) == true then
			
			Modify_DisableHold(eg_ammo_driver_spawn1, true)
			
		end
		
	end

end



function Ammo_Dump_Tower_Dialogue()

	if SGroup_Exists(SGroup_GetName(tsg_ammo_dump_mg[1])) == false then -- checks to see if the mg sgroup exists
	
		Rule_RemoveMe()
	
	else	
		-- if the tower attacks the player 
		if SGroup_IsDoingAttack(tsg_ammo_dump_mg[1], false, 1) then --Player_CanSeeSGroup(player1, tsg_ammo_dump_mg[1], false) or
			
			Util_AutoIntel(t_ammo_dump.event_at_tower)
			
			flash_ID_suppression_button = UI_FlashAbilityButton( ABILITY.CW.SUPPRESSION_BREAK, true, BT_UI_Strong_AbilityBtn ) -- to highlight smoke grenade button
			hp_ID_suppression_button = HintPoint_AddToAbilityButton(ABILITY.CW.SUPPRESSION_BREAK, g_smoke_hint, true)
			
			
			g_smoke_on = true
			
			Rule_AddOneShot(Ammo_Dump_Tower_Suppression_HP_Stop, 15)
			
			Ammo_Dump_Tower_Threat_Arrow()
			
			Ammo_Dump_Tower_Ping()
			
			Rule_RemoveMe()
		
		end
	end
end


function Ammo_Dump_Tower_Suppression_HP_Stop()


	UI_StopFlashing(flash_ID_suppression_button)
	HintPoint_Remove(hp_ID_suppression_button)


end



function Ammo_Dump_Officer_Patrol()

	if SGroup_IsEmpty(sg_ammo_dump_officer) == true then
		
			Rule_RemoveMe()
			
	else
		
		if SGroup_IsUnderAttack(sg_ammo_dump_force, false, 1) == false and f_officer_garrisoned == true then
		
			
			if f_officer_garrisoned == true then
			
				Cmd_UngarrisonSquad(sg_ammo_dump_officer)
				
				f_officer_garrisoned = false
				
			end
				
				
			--for y = 1, table.getn(t_officer_patrol) do
				
				if SGroup_IsMoving(sg_ammo_dump_officer, false) == false then-- Prox_AreSquadsNearMarker(sg_ammo_dump_officer, t_officer_patrol[y].destination, false)
				
					if g_patrol_place >= g_ammo_dump_officer_patrol_point_count then
						
						g_patrol_place = 1
						
					elseif g_patrol_place <= (g_ammo_dump_officer_patrol_point_count - 1) then
						
						g_patrol_place = g_patrol_place + 1
						
					end
					
					Cmd_Move(sg_ammo_dump_officer, t_officer_patrol[g_patrol_place].destination)
	
				end
				
			--end
			
		elseif SGroup_IsUnderAttack(sg_ammo_dump_force, false, 1) == true and f_officer_garrisoned == false then
		
			if EGroup_IsEmpty(eg_ammo_driver_spawn1) == false then
				
				
				Cmd_Garrison(sg_ammo_dump_officer, eg_ammo_driver_spawn1)
				
				f_officer_garrisoned = true
				
				Rule_AddInterval(Ammo_Dump_Officer_Clock, 1)
				
				Rule_RemoveMe()
				
			end
			
		end
		
		
	end
end


function Ammo_Dump_Officer_Clock()

	if SGroup_IsEmpty(sg_ammo_dump_officer) == false and SGroup_IsEmpty(sg_ammo_dump_force) == false then
		
		if EGroup_IsEmpty(eg_ammo_driver_spawn1) == false then
		
			local sg_officer_temp = SGroup_CreateIfNotFound("sg_officer_temp")
			SGroup_Clear(sg_officer_temp)
			
			EGroup_GetSquadsHeld(eg_ammo_driver_spawn1, sg_officer_temp)
			
			if SGroup_ContainsSGroup(sg_officer_temp, sg_ammo_dump_officer, false) then
			
				if g_officer_clock < g_officer_clock_base then
					
					g_officer_clock = g_officer_clock + 1
					
				elseif (g_officer_clock >= g_officer_clock_base) and (SGroup_IsUnderAttack(sg_ammo_dump_officer, false, 1) or SGroup_IsUnderAttack(sg_ammo_dump_force, false, 1)) then
					
					g_officer_clock = 0
					
					Cmd_UngarrisonSquad(sg_ammo_dump_officer)
					
					Rule_AddInterval(Ammo_Dump_Officer_Running, 10)
					
					Rule_RemoveMe()
					
				end
				
			end
			
		else
			
			Rule_AddInterval(Ammo_Dump_Officer_Running, 10)
			
			Rule_RemoveMe()
			
		end
		
		
	end
	
end


function Ammo_Dump_Officer_Running()

	if SGroup_IsEmpty(sg_ammo_dump_officer) == false then
		
		Cmd_Move(sg_ammo_dump_officer, mkr_officer_run, nil,nil,nil,nil,nil, 7)
	
		Rule_RemoveMe()
		
	end

end


-- controls what happens to the last guy in the building
function Ammo_Dump_Last_Guy()

	-- is < 3 to account for Officer + 1 staff remaining
	if SGroup_TotalMembersCount(sg_ammo_command_section) < 3 and SGroup_IsInHoldEntity(sg_ammo_command_section, true) then
	
		Cmd_UngarrisonSquad(sg_ammo_command_section)
		
		Rule_AddInterval(Ammo_Dump_Staff_Running, 10)
		
		Rule_RemoveMe()
		
	end

end


function Ammo_Dump_Staff_Running()

	if SGroup_IsEmpty(sg_ammo_command_section) == false then
		
		Cmd_Move(sg_ammo_command_section, mkr_officer_run, nil,nil,nil,nil,nil, 7)
	
		Rule_RemoveMe()
		
	end

end


function Ammo_Dump_Squad_Patrol()

	if SGroup_IsEmpty(sg_ammo_dump_guard3) == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttack(sg_ammo_dump_force, false, 1) == false then
			
			if SGroup_IsMoving(sg_ammo_dump_guard3, false) == false then-- Prox_AreSquadsNearMarker(sg_ammo_dump_officer, t_officer_patrol[y].destination, false)
				
				if g_ammo_guard_patrol_place >= g_ammo_dump_squad_patrol_point_count then
					
					g_ammo_guard_patrol_place = 1
					
				elseif g_ammo_guard_patrol_place <= (g_ammo_dump_squad_patrol_point_count - 1) then
					
					g_ammo_guard_patrol_place = g_ammo_guard_patrol_place + 1
					
				end
				
				Cmd_Move(sg_ammo_dump_guard3, t_squad_patrol[g_ammo_guard_patrol_place].destination, nil, nil, nil, nil, nil, 30)
				
			end
			
		elseif SGroup_IsUnderAttack(sg_ammo_dump_force, false, 1) == true then
			
			local dump_aggressor = SGroup_CreateIfNotFound("dump_aggressor")
			SGroup_GetLastAttacker(sg_ammo_dump_force, dump_aggressor)
			if SGroup_IsEmpty(dump_aggressor) == false then
				Cmd_AttackMove(sg_ammo_dump_guard3, t_squad_patrol[g_ammo_guard_patrol_place].destination, nil, nil, 20)
			end
		end
		
	end
	
end


--[[
function Ammo_Dump_Officer_Control() 
-- controls the officer when the ammo dump force is under attack
-- note the officer is independent of the dump force


	if SGroup_IsEmpty(sg_ammo_dump_officer) or EGroup_IsEmpty(eg_ammo_tower1) then
		
		Rule_RemoveMe()
		
	else
		
		if f_ammo_dump_under_attack == true then
			
			Cmd_Garrison(sg_ammo_dump_officer, eg_ammo_tower1)
			
			
			Rule_RemoveMe()
			
		end
		
	end
	
end		]]

function Ammo_Dump_Tower_Threat_Arrow() -- creates a threat arrow for the machine gun watchtower

	if TowerThreatID == false then
		TowerThreatID = ThreatArrow_CreateGroup()
		ThreatArrow_Add(TowerThreatID, tsg_ammo_dump_mg[1])
		f_threat = true
		Rule_AddInterval(Ammo_Dump_Tower_Arrow_Manager, 1)
	end
	
end

function Ammo_Dump_Tower_Arrow_Manager()

	if SGroup_IsEmpty(tsg_ammo_dump_mg[1]) then -- if the tower is gone, remove it
		
		ThreatArrow_Remove(TowerThreatID, tsg_ammo_dump_mg[1])
		ThreatArrow_DestroyGroup(TowerThreatID)
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsDoingAttack(tsg_ammo_dump_mg[1], false, 1) and f_threat == false then -- add the arrow if the MG squad inside is attacking
			
			ThreatArrow_Add(TowerThreatID, tsg_ammo_dump_mg[1])
			
			f_threat = true
			
		elseif SGroup_IsDoingAttack(tsg_ammo_dump_mg[1], false, 1) == false and f_threat == true then  -- remove arrow if the MG squad inside is not attacking
			
			ThreatArrow_Remove(TowerThreatID, tsg_ammo_dump_mg[1])
			
			f_threat = false
			
		end
		
	end
	
end


function Ammo_Dump_Tower_Ping() -- adds a tactical map ping on the tower for 10 seconds

	--Tower_Ping_ID = Objective_AddPing(OBJ_Capture_Points, eg_ammo_tower1, 1)
	
	Tower_Ping_ID = UI_CreateMinimapBlip(eg_ammo_tower1, 10, BT_CombatPing)
	--Rule_AddOneShot(Ammo_Dump_Remove_Tower_Ping, 10)
	
end


function Ammo_Dump_Remove_Tower_Ping()
	
	--Objective_RemovePing(OBJ_Capture_Points, Tower_Ping_ID)
	
end


-- makes halftrack gunners run out of buildings
function Ammo_Dump_Gunner_Dash()

	if f_ammo_dump_under_attack == true then

		for p = 1, 1 do 
		
			if (SGroup_IsEmpty(tsg_ammo_dump_driver[p]) == false) and (SGroup_IsEmpty(tsg_vehicle[p]) == false) then
				
				Cmd_UngarrisonSquad(tsg_ammo_dump_driver[p], mkr_flanking_position, true)
				
			end
			
		end
		
		
		
		for p = 2, 2 do 
		
			if (SGroup_IsEmpty(tsg_ammo_dump_driver[p]) == false) and (SGroup_IsEmpty(tsg_vehicle[p]) == false) then
				
				Cmd_UngarrisonSquad(tsg_ammo_dump_driver[p], tsg_vehicle[p], true)
				
			end
			
		end
		
		
		Rule_AddOneShot(Ammo_Dump_Gunner_Garrison_Delay, 2)
		
		Rule_RemoveMe()
	
	end

end



-- makes half track runners go to the halftracks
function Ammo_Dump_Gunner_Garrison_Delay()

	for q = 2, 2 do -- only vehicle 2
		
		-- makes sure that the "drivers" and the halftracks exist
		if (SGroup_IsEmpty(tsg_ammo_dump_driver[q]) == false) and (SGroup_IsEmpty(tsg_vehicle[q]) == false) then
			Cmd_Garrison(tsg_ammo_dump_driver[q], tsg_vehicle[q])
		end
		
	end
	
	if (SGroup_IsEmpty(tsg_ammo_dump_driver[1]) == false) and (SGroup_IsEmpty(tsg_vehicle[1]) == false) then
		
		Cmd_Move(tsg_ammo_dump_driver[1], mkr_flanking_position, nil, nil, nil, nil, nil, 8)
		
	end
	
	
	for z = 1, table.getn(tsg_vehicle) do
		Ceasefire_RemoveSGroup(tsg_vehicle[z])
		--print("ceasefire removed!")
	end
	
	if SGroup_IsEmpty(tsg_vehicle[1]) == false then -- adds vehicle 1 to the reinforcement runner and starts the control function
		
		SGroup_AddGroup(sg_ammo_dump_reinforcement_runners, tsg_vehicle[1]) 
		--Modify_UnitSpeed(sg_ammo_dump_reinforcement_runners, 0.90)
		Modify_ReceivedDamage(sg_ammo_dump_reinforcement_runners, 2)
		
		Rule_AddDelayedInterval(Ammo_Dump_Reinforcements_Runner_Control, 11, 1)
		
	end
	
end

-- if the ammo dump is under attack, the enemy will send a vehicle into Carpiquet to get reinforcements
function Ammo_Dump_Reinforcements_Runner_Control()

	if SGroup_IsEmpty(sg_ammo_dump_reinforcement_runners) == true then -- are there units in the reinforcement runner sgroup?
		
		Rule_RemoveMe() -- nope? no more rule
		
	else
		
		if b_Capture_CarpiquetOBJComplete == false then -- is carpiquet still in Axis hands?
			
			if SGroup_IsUnderAttackByPlayer(sg_ammo_dump_force, player1, 1) then --or Prox_ArePlayersNearMarker(player1, mkr_ammo_dump_reinforcement_trigger, false) or SGroup_IsUnderAttackByPlayer(sg_ammo_dump_guard1, player1, 1)
				
				--Cmd_Retreat( sg_ammo_dump_reinforcement_runners, Util_GetPosition(eg_axis_hq) ) -- makes reinforcement runners go to building 4
				--Cmd_Move(sg_ammo_dump_reinforcement_runners, mkr_ammo_dump_runner_destination) -- makes reinforcement runners go to designated zone
				Cmd_SquadPath(sg_ammo_dump_reinforcement_runners, "AD_Reinforcement_Path", true, false, false, 0)
				
				SGroup_AddGroup(sg_ammo_dump_reinforcement_overgroup, sg_ammo_dump_reinforcement_runners)
				
				if SGroup_IsEmpty(tsg_vehicle[2]) == false then
					
					if SGroup_IsEmpty(sg_ammo_dump_aggressor) == false then
						
						local aggressor_offset = SGroup_GetOffsetPosition(sg_ammo_dump_aggressor, 0, 20)
						
						Cmd_AttackMove(tsg_vehicle[2], aggressor_offset)
						
					end
					
				end
				
				Util_AutoAmbient(t_ammo_dump.event_discovery)
				
				--Rule_AddInterval(Commando_First_HQ_Flash_Start, 2)
				
				Rule_AddInterval(Ammo_Dump_Reinforcements_Generation, 5)
				
				Rule_AddInterval(Ammo_Dump_Reinforcements_Runner_Control_Override, 5)
				
				Rule_RemoveMe()
				
				
			end
			
		elseif b_Capture_CarpiquetOBJComplete == true then -- carpiquet is in Allied hands
		
			Rule_RemoveMe()
		
		end
		
	end

end


function Ammo_Dump_Reinforcements_Runner_Control_Override() -- if reinforcement building is not owned or doesn't exist anymore

	if Objective_IsComplete(OBJ_Commando_Action)then
	
		Rule_RemoveMe()
	
	else
		if EGroup_IsEmpty(eg_axis_hq) == true or Player_OwnsEGroup(player2, eg_carpiquet_building9, false) == false or SGroup_IsEmpty(sg_enemy_reinforcement_minders) then
		
			if SGroup_IsEmpty(sg_ammo_dump_reinforcement_runners) == false then
				
				Cmd_Move(sg_ammo_dump_reinforcement_runners, mkr_fallback9)
				
				Rule_RemoveMe()
				
			end
			
		elseif Prox_AreSquadMembersNearMarker(sg_ammo_dump_reinforcement_runners, mkr_fallback9, false) then
		
			Rule_RemoveMe()
		
		end
		
	end
end


function Commando_First_HQ_Flash_Start()

	if EGroup_IsEmpty(eg_ammo_driver_spawn1) == true then
	
		Rule_RemoveMe()
		
	else
	
		if Prox_PlayerSquadsInProximityOfEntities(player1, eg_ammo_driver_spawn1, 30, false) then
		
			Util_AutoIntel(t_commando.action.event_garrison_objs)
			flash_ID_hq1_charge_button = UI_FlashCommandButton(SCMD_PlaceCharge, true, BT_UI_Strong_AbilityBtn)
			hp_ID_hq1_charge_button = HintPoint_AddToCommandButton(SCMD_PlaceCharge, g_demo_hint, true)
			Rule_AddOneShot(Commando_First_HQ_Flash_Stop, 15)
			
			Rule_RemoveMe()

		end
		
	end
	
end


function Commando_First_HQ_Flash_Stop()

	UI_StopFlashing(flash_ID_hq1_charge_button)
	HintPoint_Remove(hp_ID_hq1_charge_button)

end










--[[
function Ammo_Dump_Reinforcements_Explosion_Control()

	if SGroup_IsEmpty(sg_ammo_dump_reinforcement_runners) == true then -- are there units in the reinforcement runner sgroup?
	
		Rule_RemoveMe() -- nope? no more rule
		
	else
	
		if SGroup_GetAvgHealth(sg_ammo_dump_reinforcement_runners) <= 0.60 then
	
			SGroup_GetSpawnedSquadAt( sg_ammo_dump_reinforcement_runners, 1 )
			ModMisc_OOCAction( sg_ammo_dump_reinforcement_runners )

	
		end
	
	end


end]]




function Ammo_Dump_Reinforcements_Generation() -- generates reinforcements for the ammo dump

	if SGroup_IsEmpty(sg_ammo_dump_reinforcement_runners) == true then -- if runners are dead then no reinforcements
	
		Rule_RemoveMe()
		
	elseif Prox_AreSquadsNearMarker(sg_ammo_dump_reinforcement_runners, mkr_ammo_dump_runner_destination, false) then -- g_axis_hq_position
		
		Modify_UnitSpeed(sg_ammo_dump_reinforcement_runners, 0.60) -- these were called in sequential order, but across different functions
		
		Modify_UnitSpeed(sg_ammo_dump_reinforcement_runners, 0.75)
		
			
		if EGroup_IsEmpty(eg_carpiquet_building9) == false and Player_OwnsEGroup(player2, eg_carpiquet_building9, false) and SGroup_IsEmpty(sg_enemy_reinforcement_minders) == false then --EGroup_IsEmpty(eg_carpiquet_building9) == false then--Player_OwnsEGroup(player2, eg_axis_hq, false) then -- g_axis_position
			
		
			Util_CreateSquads(player2, sg_ammo_dump_reinforcements, t_difficulty.g_soldier_type1, g_axis_hq_position, SGroup_GetPosition(sg_ammo_dump_reinforcement_runners), 1, 4, nil, nil)
			
			SGroup_AddGroup(sg_ammo_dump_reinforcement_overgroup, sg_ammo_dump_reinforcements)
			
			Util_CreateSquads(player2, sg_ammo_dump_gunners, t_difficulty.g_soldier_type2, g_axis_hq_position, SGroup_GetPosition(sg_ammo_dump_reinforcement_runners), 1, 2, nil, nil)
			
			SGroup_AddGroup(sg_ammo_dump_reinforcement_overgroup, sg_ammo_dump_gunners)
			
			--Rule_AddOneShot(Ammo_Dump_Reinforcements_Move, 5)
			Rule_AddOneShot(Ammo_Dump_Gunners_Move, 1)
			Rule_AddDelayedInterval(Ammo_Dump_Reinforcements_Move, 2, 1)
			
		end

		
		-- add dudes from center areas here
		
		Rule_RemoveMe()
		
	end
end


function Ammo_Dump_Gunners_Move()
-- moves gunners to board the reinforcement halftrack
	if SGroup_IsEmpty(sg_ammo_dump_reinforcement_runners) == false and SGroup_IsEmpty(sg_ammo_dump_gunners) == false then
		
		Cmd_Garrison(sg_ammo_dump_gunners, sg_ammo_dump_reinforcement_runners)
		
		Rule_RemoveMe()
		
	elseif SGroup_IsEmpty(sg_ammo_dump_reinforcement_runners) == true or SGroup_IsEmpty(sg_ammo_dump_gunners) == true then

		Rule_RemoveMe()
	
	end

end

function Ammo_Dump_Reinforcements_Move() -- moves reinforcements for the ammo dump
	
	if SGroup_IsEmpty(sg_ammo_dump_reinforcements) == true then

		Rule_RemoveMe()
		
	
	else
		
		--Modify_UnitSpeed(sg_ammo_dump_reinforcement_runners, 0.75)
		
		--Util_CreateSquads(player2, sg_ammo_dump_reinforcements, t_difficulty.g_soldier_type1, g_axis_hq_position, nil, 2, 4, nil, nil)
		
		if EGroup_IsEmpty(eg_ammo_driver_spawn1) == true then
		
			if EGroup_IsCapturedByPlayer(eg_ammo_flag, player2, false) == false then -- checks to see if the AI player owns the ammo dump
				
				Cmd_AttackMoveThenCapture(sg_ammo_dump_reinforcements, eg_ammo_flag) -- if not then capture it
				
				if SGroup_IsEmpty(sg_ammo_dump_reinforcement_runners) == false then -- further, if the reinforcement runners are still alive, go back to the ammo dump
					
					
					if SGroup_IsEmpty(sg_ammo_dump_aggressor) == false then

						Cmd_Move(sg_ammo_dump_reinforcement_runners, EGroup_GetPosition(eg_ammo_flag), nil, nil, nil, nil, nil, 30) -- attack aggressor
					
					else
					

						Cmd_Move(sg_ammo_dump_reinforcement_runners, EGroup_GetPosition(eg_ammo_flag), nil, nil, nil, nil, nil, 30) -- attack aggressor
						
					end
					
				end
				
			else
				
				if SGroup_IsEmpty(sg_ammo_dump_reinforcements) == false then -- if reinforcements are still alive go to ammo dump
					
					if SGroup_IsEmpty(sg_ammo_dump_aggressor) == false then -- if aggressor still alive
						
					
						Cmd_Move(sg_ammo_dump_reinforcements, EGroup_GetPosition(eg_ammo_flag), nil, nil, nil, nil, nil, 30) -- attack aggressor
						
					else
						
						Cmd_Move(sg_ammo_dump_reinforcements, EGroup_GetPosition(eg_ammo_flag), nil, nil, nil, nil, nil, 30) -- head to flag
						
					end
					
				end
				
				
				if SGroup_IsEmpty(sg_ammo_dump_reinforcement_runners) == false then -- if the reinforcement runners are still alive, go back to the ammo dump
					
					if SGroup_IsEmpty(sg_ammo_dump_aggressor) == false then -- if aggressor still alive
					
						Cmd_Move(sg_ammo_dump_reinforcement_runners, EGroup_GetPosition(eg_ammo_flag), nil, nil, nil, nil, nil, 30) -- attack aggressor
						
					else
						
						Cmd_Move(sg_ammo_dump_reinforcement_runners, EGroup_GetPosition(eg_ammo_flag), nil, nil, nil, nil, nil, 30) -- head to flag
						
					end
					
				end
				
				
			end
			
			Rule_AddInterval(Ammo_Dump_Reinforcements_Control, 7)
			
			Rule_RemoveMe()
			
		end
		
	end
	
end


-- ammo dump reinforcement runner control here!!
-----
function Ammo_Dump_Reinforcements_Control()

	if SGroup_IsEmpty(sg_ammo_dump_reinforcements) == true then
	
		Rule_RemoveMe()
		
	else
			
		if g_ammo_dump_reinforcements_arrive == false then
		
			if Prox_AreSquadMembersNearMarker(sg_ammo_dump_reinforcements, mkr_ammo_reinforce_activate, false) then
		
				g_ammo_dump_reinforcements_arrive = true
				
				local random_movement = Util_GetRandomPosition(mkr_ammo_reinforce_activate)
				
				Cmd_AttackMove(sg_ammo_dump_reinforcements, random_movement, nil, nil, 20)
			
			end
			
		elseif g_ammo_dump_reinforcements_arrive == true then
		
			local random_movement = Util_GetRandomPosition(mkr_ammo_reinforce_activate)
			--print("random!")
			
			if SGroup_IsUnderAttack(sg_ammo_dump_reinforcements, false, 5) then
			
				Cmd_AttackMove(sg_ammo_dump_reinforcements, random_movement, nil, nil, 20)
				
			else
			
				Cmd_Move(sg_ammo_dump_reinforcements, random_movement)
				
			end
			
		end
		
	end

end








function Ammo_Dump_Attacker_Tracker() -- tracks to see if the ammo dump force is under attack.  if everyone is dead, then the rule is removed

	if SGroup_IsEmpty(sg_ammo_dump_force) then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttackByPlayer(sg_ammo_dump_force, player1, 20) then
			
			SGroup_GetLastAttacker(sg_ammo_dump_force, sg_ammo_dump_aggressor)
			
			f_ammo_dump_under_attack = true
			
		end
		
	end

end


function Ammo_Dump_Reaction() 
-- controls guard 3's reaction when the ammo dump force is under attack. if everyone is dead, then the rule is removed.  
-- Note guard 3 is independent of sg_ammo_dump_force

	if SGroup_IsEmpty(sg_ammo_dump_force) then
	
		Rule_RemoveMe()
		
	else

		if f_ammo_dump_under_attack == true then
			
			if SGroup_IsEmpty(tsg_ammo_dump_guard[3]) == false then
				
				Cmd_Attack(tsg_ammo_dump_guard[3], sg_ammo_dump_aggressor)
				
			end
			
		end
		
	end

end


-- nags the player into planting charges
function Ammo_Dump_Plant_Charge_Notify()

	if SGroup_IsEmpty(sg_ammo_dump_force) == true and EGroup_IsEmpty(eg_ammo_driver_spawn1) == true then -- eg_fuel_sheds
		
		Rule_RemoveMe()
		
	elseif SGroup_IsEmpty(sg_ammo_dump_force) == true and EGroup_IsEmpty(eg_ammo_driver_spawn1) == false then
		
		local hqid = EGroup_GetSpawnedEntityAt(eg_ammo_driver_spawn1, 1) -- grabs the hq entity id
		
		if Entity_IsDemolitionReady(hqid) then
		
			g_ammo_nag_timer = 0
		
		else
		
			if g_ammo_nag_timer < 120 then
		
				g_ammo_nag_timer = g_ammo_nag_timer + 1
			
			elseif  g_ammo_nag_timer >= 120 then
			
				--NAG SPEECH HERE
			
				
			
				g_ammo_nag_timer = 0
			
			
			end
		
		end
	
	end

end



-- helper function to destroy sgroups that are in the area as collateral damage
function Ammo_Dump_Collateral(collateral)

	SGroup_Kill(collateral)

end

-- gets all the sgroups inside the comm tower
function Ammo_Dump_Get_Garrisoned_SGroup()
	
	EGroup_GetSquadsHeld(eg_ammo_driver_spawn1, sg_ammo_garrisoned)
	
end




----------
-- Detonations! -- Ammo_Dump
------------


function Detonation_Grab()
	
	if EGroup_IsEmpty(eg_ammo_driver_spawn1) == true then
	
		Rule_RemoveMe()
	
	else
		
		Player_GetAllEntitiesNearMarker(player1, eg_detcharge, mkr_detonation_detect)
		
		EGroup_Filter(eg_detcharge, EBP.CW.DEMOLITION_CHARGE, FILTER_KEEP)
		
		if EGroup_IsEmpty(eg_detcharge) == false then
			
			Rule_AddInterval(Detonation_Detect, 1)
			
			Rule_RemoveMe()
			
		end
		
	end
	
end


function Detonation_Detect()

	if EGroup_IsEmpty(eg_ammo_driver_spawn1) == true then
		
		Rule_RemoveMe()
		
	else
		
		if EGroup_IsEmpty(eg_detcharge) == true then
			
			EGroup_Kill(eg_ammo_driver_spawn1) -- BOOM, factory is dead.
			
			Rule_RemoveMe()
			
		end
		
	end
	
end






-------------------------------------------------------------------------

-- Anti Air Encounter
--"Anti-Air" units set up.  Note, these units are tied in with the Clear Tetrarch LZ objective
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Anti_Air_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	
	tmkr_anti_air_guard = Marker_GetTable("mkr_anti_air_guard%d")	
	tsg_anti_air_guard = SGroup_CreateTable("sg_anti_air_guard%d", table.getn(tmkr_anti_air_guard))
	
	sg_anti_air_force = SGroup_CreateIfNotFound("sg_anti_air_force")
	
	tmkr_anti_air_mg = Marker_GetTable("mkr_anti_air_mg%d")	
	tsg_anti_air_mg = SGroup_CreateTable("sg_anti_air_mg%d", table.getn(tmkr_anti_air_mg))
	tsg_anti_air_vehicle = SGroup_CreateTable("sg_anti_air_vehicle", 2)
	
	tmkr_anti_air_aa = Marker_GetTable("mkr_anti_air_aa%d")	
	tsg_anti_air_aa = SGroup_CreateTable("sg_anti_air_aa%d", table.getn(tmkr_anti_air_aa))
	
	sg_aa_mg_attackers = SGroup_CreateIfNotFound("sg_aa_mg_attackers")
	
	g_aa_guard1_stop = false
	g_aa_guard2_stop = false
	g_aa_guard3_stop = false
	
	
	g_aa_stopped = 0
	
	t_aa_data = {
		
		retreat = {
			
			{name = tsg_anti_air_guard[1], stopped = false, runto = mkr_after_retreat1, runto_alt = mkr_aa_after_retreat1},
			{name = tsg_anti_air_guard[2], stopped = false, runto = mkr_after_retreat2, runto_alt = mkr_aa_after_retreat2},
			--{name = tsg_anti_air_guard[3], stopped = false, runto = mkr_after_retreat3, runto_alt = mkr_aa_after_retreat3},
			--{name = tsg_anti_air_vehicle[3], stopped = false, runto = mkr_after_retreat3, runto_alt = mkr_aa_after_retreat3},
		},
	}

	
	
	t_anti_air_enemy_spawn_table = {
		
		--{tsg_anti_air_guard[1], t_difficulty.g_soldier_type1, mkr_anti_air_guard1, 1, (3 + t_dif_numbers.g_dif_add_number)},
		{tsg_anti_air_guard[2], t_difficulty.g_soldier_type2, mkr_anti_air_guard2, 1, (3 + t_dif_numbers.g_dif_add_number)},
		{tsg_anti_air_vehicle[1], SBP.ELITE.ARMOURCAR_221, mkr_anti_air_guard3, 1, 1},
		--{tsg_anti_air_guard[3], t_difficulty.g_soldier_type2, mkr_anti_air_guard3, 1, (3 + t_dif_numbers.g_dif_add_number)},
		--{tsg_anti_air_guard[4], SBP.AXIS.GRENADIER, mkr_anti_air_guard4, 1, (3 + t_dif_numbers.g_dif_add_number)},
		--{tsg_anti_air_guard[5], SBP.AXIS.VOLKSGRENADIER, mkr_anti_air_guard5, 1, (3 + t_dif_numbers.g_dif_add_number)},
	}
	
	
	t_anti_air_enemy_mg_table = {
		{tsg_anti_air_mg[1], SBP.AXIS.HEAVYMG, mkr_anti_air_mg1, 1, 3, mkr_aa_mg_facing},
		
	}
	
	
	-- spawned behind sandbags
	t_anti_air_aa_table = {
		{tsg_anti_air_aa[1], t_difficulty.g_soldier_type1, mkr_anti_air_aa1, 1, (2 + t_dif_numbers.g_dif_add_number), nil},
		
	}
	
	--[[
	t_anti_air_bunker_load_event = {
		
		{ACTOR.GenericAlly, LOC("They're making a run for that bunker!")}
		
	}]]
	g_anti_air_init_count = 0 -- initializes variable that contains the count of total squads created
	
end

-- preset any units or events needed before the kickoff
function Anti_Air_Preset()

	-- spawn squads
	
	for d = 1, table.getn(t_anti_air_enemy_spawn_table) do 
		
		local temp = t_anti_air_enemy_spawn_table[d]
 		
 		Util_CreateSquads(player2, temp[1], temp[2] , Util_GetPosition(temp[3]), nil, temp[4], temp[5])
		
		SGroup_AddGroup(sg_anti_air_force, temp[1])
		
 	end
	
	Modify_WeaponAccuracy(tsg_anti_air_vehicle[1], "hardpoint_01", 0.5)
	Modify_WeaponDamage(tsg_anti_air_vehicle[1], "hardpoint_01", 0.5)
	Modify_Vulnerability(tsg_anti_air_vehicle[1], 2)
	
	-- MG Squad - have to do it this way because the game won't let me do it any other way without the game currently removing the HMG :/
 	for d = 1, table.getn(t_anti_air_enemy_mg_table) do --t_ammo_dump_enemy_spawn_table[d][1]
 		
		local temp = t_anti_air_enemy_mg_table[d]
		
		Util_CreateSquads(player2, temp[1], temp[2] , Util_GetPosition(temp[3]), nil, 1, nil, true, temp[6]) -- facing appears to be broken
		SGroup_AddGroup(sg_anti_air_force, temp[1])
		Cmd_InstantSetupTeamWeapon(temp[1])
		--Cmd_Move(temp[1], Util_GetPosition(temp[6])) -- force the unit to move in a certain direction so that it faces the right direction
		Modify_WeaponDamage(temp[1], "hardpoint_01", 0.75)
		Modify_WeaponAccuracy(temp[1], "hardpoint_01", 0.75)
	end	
	
	--AA
	for d = 1, table.getn(t_anti_air_aa_table) do 
		
		local temp = t_anti_air_aa_table[d]
 		
 		Util_CreateSquads(player2, temp[1], temp[2] , temp[3], nil, temp[4], temp[5])
		SGroup_AddGroup(sg_anti_air_force, temp[1])
		
 	end
	
	g_anti_air_init_count = SGroup_TotalMembersCount(sg_anti_air_force)
	
	-- start enemy behavior
	Rule_AddOneShot(Anti_Air_MG_Setup, 1)
	Rule_AddInterval(Anti_Air_MG_Control, 5)
	--Rule_AddInterval(Anti_Air_Kickoff, 3)
	
	-- do other cool things
	Rule_AddInterval(Anti_Air_Retreat, 2)
	Rule_AddInterval(Anti_Air_Response_Control, 1)

end


function Anti_Air_MG_Setup()
-- makes the MGs immediately set up
 	for d = 1, table.getn(t_anti_air_enemy_mg_table) do --t_ammo_dump_enemy_spawn_table[d][1]
 		
		local temp = t_anti_air_enemy_mg_table[d]
		
		Cmd_InstantSetupTeamWeapon(temp[1])
		
	end

end


function Anti_Air_MG_Control() -- grabs last attacker and tells the MG to attack move in that direction
	
	if SGroup_IsEmpty(tsg_anti_air_mg[1]) then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttack(tsg_anti_air_mg[1], false, 5) then
			
			SGroup_GetLastAttacker(tsg_anti_air_mg[1], sg_aa_mg_attackers)
			
			
			if SGroup_IsEmpty(sg_aa_mg_attackers) == false then
				
				Cmd_AttackMove(tsg_anti_air_mg[1], sg_aa_mg_attackers, nil, nil, 25)
				
			end
			
		end
		
		
		
	end

end




function Anti_Air_Retreat() -- governs when the anti-air guys run

	if SGroup_IsEmpty(sg_anti_air_force) == true or b_Capture_Points_OBJComplete == true then
		
		Rule_RemoveMe()
		
	else
		-- if their flag is captured, or their  is less than 60% of their start then some will retreat
		if EGroup_IsCapturedByPlayer(eg_flag6, player2, false) == false or (SGroup_TotalMembersCount(sg_anti_air_force) < (0.50 * g_anti_air_init_count)) then
			
			if f_middle_squad_first_retreat == false then
				
				-- retreat the whole gang!
				if EGroup_IsEmpty(eg_factory_a) == false then 
					
					Cmd_Retreat(sg_anti_air_force, mkr_fallback9)
					
					Rule_AddInterval(Anti_Air_Retreat_Control_1, 1)
					
				elseif EGroup_IsEmpty(eg_factory_a) and EGroup_IsCapturedByPlayer(eg_flag3, player2, false) == true then
					
					Cmd_Retreat(sg_anti_air_force, mkr_aa_retreat_point) --mkr_aa_retreat_point -- mkr_fallback_9 -- mkr_counterattack_spawn1
					
					Rule_AddInterval(Anti_Air_Retreat_Control_2, 1)
					
				elseif EGroup_IsEmpty(eg_factory_a) and EGroup_IsCapturedByPlayer(eg_flag3, player2, false) == false then
					
					Cmd_Retreat(sg_anti_air_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1) --mkr_aa_retreat_point -- mkr_fallback_9
					
					--Rule_AddInterval(Anti_Air_Retreat_Control_3, 1)
					
				end
				
				sg_middle_retreat_squad = SGroup_AddGroup(sg_middle_retreat_squad, sg_anti_air_force)
				
				f_middle_squad_first_retreat = true
				
				Rule_RemoveMe()
				
			elseif f_middle_squad_first_retreat == true then
				
				if EGroup_IsEmpty(eg_factory_a) == false then
				
					Cmd_Retreat(sg_anti_air_force, mkr_carpiquet_offmap_retreat, mkr_carpiquet_offmap_retreat)
				
				elseif EGroup_IsEmpty(eg_factory_a) == true then
				
					Cmd_Retreat(sg_anti_air_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1)
				
				end
				
				Rule_RemoveMe()
				
			end
			
		end
		
	end
		
end

function Anti_Air_Retreat_Control_1()

	if SGroup_IsEmpty(sg_anti_air_force) == true or b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
	
	else
	
		
		
		
		--if Prox_AreSquadsNearMarker(sg_at_gun_force, mkr_fallback10, true) then
		
			print("near marker")
			
			
			for k,v in pairs (t_aa_data.retreat) do
			
				if SGroup_IsEmpty(v.name) == false then
				
					if SGroup_IsRetreating(v.name, true) == false and v.stopped == false then
					
						v.stopped = true
						
						g_aa_stopped = g_aa_stopped + 1
				
						Cmd_Move(v.name, v.runto, nil, nil, nil, nil, nil, 5)
				
					end
					
				end
			
			end
			
			if g_aa_stopped >= 3 then
			
				Rule_RemoveMe()
			
			end
			
		--end
		
	end


end

function Anti_Air_Retreat_Control_2()

	if SGroup_IsEmpty(sg_anti_air_force) == true or b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
	
	else
	
		--if Prox_AreSquadsNearMarker(sg_at_gun_force, mkr_fallback10, true) then
		
			print("near marker")
			
			
			for k,v in pairs (t_aa_data.retreat) do
			
				if SGroup_IsEmpty(v.name) == false then
				
					if SGroup_IsRetreating(v.name, true) == false and v.stopped == false then
					
						v.stopped = true
						
						g_aa_stopped = g_aa_stopped + 1
				
						Cmd_Move(v.name, v.runto_alt, nil, nil, nil, nil, nil, 5)
				
					end
					
				end
			
			end
			
			if g_aa_stopped >= 3 then
			
				Rule_RemoveMe()
			
			end
			
		--end
		
	end

end



function Anti_Air_Response_Control()

	if b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
	
	else
		if SGroup_IsEmpty(sg_anti_air_force) == false and SGroup_IsUnderAttackByPlayer(sg_anti_air_force, player1, 5) then

			Rule_AddOneShot(Anti_Air_Response, 7)

			Rule_RemoveMe()
		end
		
	end

end

function Anti_Air_Response()

	if b_Capture_Points_OBJComplete == true then

		Rule_RemoveMe()
		
	else

		if SGroup_IsEmpty(sg_anti_air_force) == false then
		
			if SGroup_IsEmpty(tsg_anti_air_guard[2]) == false then
				Cmd_Move(tsg_anti_air_guard[2], mkr_anti_air_guard2_dest, nil, nil, nil, nil, nil, 10)
			end
			
			if SGroup_IsEmpty(tsg_anti_air_vehicle[1]) == false then
				Cmd_Move(tsg_anti_air_vehicle[1], mkr_anti_air_guard3_dest, nil, nil, nil, nil, nil, 10)
			end
		
		end
		
	end

end


-----------------------------------------------

------------------------------------

-- Airport Fence Bunker

-----------------------------------

function Airport_Fence_Init() -- initialize stuff for the airport fence bunker area.

	sw_fence_pak38 = SyncWeapon_GetFromEGroup(eg_airport_fence_pak38)
	eg_fence_manned_pak38 = EGroup_CreateIfNotFound("eg_fence_manned_pak38")
	sg_fence_gun = SGroup_CreateIfNotFound("sg_fence_gun")	

	
	
	tmkr_airport_fence_guard = Marker_GetTable("mkr_airport_fence_guard%d")	
	tsg_airport_fence_guard = SGroup_CreateTable("sg_airport_fence_guard%d", table.getn(tmkr_airport_fence_guard))
	sg_fence_force = SGroup_CreateIfNotFound("sg_fence_force")
	sg_fence_reinforcements = SGroup_CreateIfNotFound("sg_fence_reinforcements")
	sg_raider_target = SGroup_CreateIfNotFound("sg_raider_target")
	
	sg_airport_fence_mg_attackers = SGroup_CreateIfNotFound("sg_airport_fence_mg_attackers")
	
	
	sg_airport_fence_bunker_guard1 = SGroup_CreateIfNotFound("sg_airport_fence_bunker_guard1")
	sg_airport_fence_bunker_guard2 = SGroup_CreateIfNotFound("sg_airport_fence_bunker_guard2")
	sg_airport_fence_mg1 = SGroup_CreateIfNotFound("sg_airport_fence_mg1")
	sg_airport_fence_pak38_crew = SGroup_CreateIfNotFound("sg_airport_fence_pak38_crew")
	sg_airport_fence_pak38_guard = SGroup_CreateIfNotFound("sg_airport_fence_pak38_guard")
	
	sg_fence_aggressor = SGroup_CreateIfNotFound("sg_fence_aggressor") -- player's attacking units
	
	sg_airport_fence_raiders = SGroup_CreateIfNotFound("sg_airport_fence_raiders")
	
	t_airport_fence = {
		
		spawn = {
			
			{name = sg_airport_fence_bunker_guard1, blueprint = t_difficulty.g_soldier_type2, loc = eg_airport_fence_bunker1, number = 3},
			{name = sg_airport_fence_bunker_guard2, blueprint = t_difficulty.g_soldier_type2, loc = eg_airport_fence_bunker2, number = 3},
			--{name = sg_airport_fence_mg1, blueprint = SBP.AXIS.HEAVYMG, loc = mkr_airport_fence_mg1, number = 3},
			{name = sg_airport_fence_pak38_crew, blueprint = t_difficulty.g_soldier_type2, loc = mkr_airport_fence_pak38_crew, number = 3},
			{name = sg_airport_fence_pak38_guard, blueprint = SBP.AXIS.VOLKSGRENADIER, loc = mkr_airport_fence_pak38_guard, number = 3},
		},
		
		
		to_be_spawned = {
		
			{name = tsg_airport_fence_guard[1], blueprint = t_difficulty.g_soldier_type3, loc = mkr_airport_fence_guard1, number = 3, spawned = false},
			{name = tsg_airport_fence_guard[2], blueprint = t_difficulty.g_soldier_type2, loc = mkr_airport_fence_guard2, number = 3, spawned = false},
			{name = tsg_airport_fence_guard[3], blueprint = t_difficulty.g_soldier_type1, loc = mkr_airport_fence_guard3, number = 3, spawned = false},
			{name = tsg_airport_fence_guard[4], blueprint = t_difficulty.g_soldier_type1, loc = mkr_airport_fence_guard4, number = 3, spawned = false}, -- used to be an MG
			
		
		},
		
		raiders = {
			
			{name = sg_airport_fence_raiders, blueprint = t_difficulty.g_soldier_type2, loc = mkr_fence_door, number = 5},
			
		},
	}

	f_raider_sent = false

	g_airport_fence_raider_wave = 0
	
	g_airport_fence_spawn_counter = 1
	g_airport_fence_spawn_limit = table.getn(t_airport_fence.to_be_spawned)
	
end


function Airport_Fence_Preset()

	-- spawn squads
	
	for k, v in pairs(t_airport_fence.spawn) do
	
		local airportsquad = v
	
		Util_CreateSquads(player2, airportsquad.name, airportsquad.blueprint, airportsquad.loc, nil, 1, airportsquad.number)
		SGroup_AddGroup(sg_fence_force, airportsquad.name)
	
	end
	
	--Util_CreateSquads(player2, tsg_airport_fence_guard[4], SBP.AXIS.HEAVYMG, mkr_airport_fence_guard4, nil, 1)
	--SGroup_AddGroup(sg_fence_force, tsg_airport_fence_guard[4])
	Util_CreateSquads(player2, sg_airport_fence_mg1, SBP.AXIS.HEAVYMG, mkr_airport_fence_mg1, nil, 1)
	SGroup_AddGroup(sg_fence_force, sg_airport_fence_mg1)
	
	if SGroup_IsEmpty(sg_airport_fence_mg1) == false then
		
		Cmd_InstantSetupTeamWeapon(sg_airport_fence_mg1)
		--Modify_WeaponAccuracy(
		Modify_WeaponAccuracy(sg_airport_fence_mg1, "hardpoint_01", 0.25)
		Modify_WeaponDamage(sg_airport_fence_mg1, "hardpoint_01", 0.25)
		
	end
	--[[
	if SGroup_IsEmpty(tsg_airport_fence_guard[4]) == false then
		
		Cmd_InstantSetupTeamWeapon(tsg_airport_fence_guard[4])
		Modify_WeaponAccuracy(tsg_airport_fence_guard[4], "hardpoint_01", 0.25)
		Modify_WeaponDamage(tsg_airport_fence_guard[4], "hardpoint_01", 0.25)
	end]]
	
	Cmd_InstantUpgrade(eg_airport_fence_bunker1, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	Cmd_InstantUpgrade(eg_airport_fence_bunker2, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	
	-- start enemy behavior
	
	-- do other cool things

end



function Airport_Fence_Kickoff() -- kickoff function

	Rule_AddInterval(Airport_Fence_Gungrab, 5)
	Rule_AddInterval(Airport_Fence_Find_Attacker, 5)
	Rule_AddDelayedInterval(Airport_Fence_Movement, 7, 5)
	Rule_AddInterval(Airport_Fence_Raider_Control, 10)

	Rule_AddInterval(Airport_Fence_MG_Control, 5)
	Rule_AddInterval(Airport_Fence_Timed_Spawn_Trigger, 5)
end



function Airport_Fence_Find_Attacker() -- function to find the player units who are attacking the fence forces

	if SGroup_IsEmpty(sg_fence_force) == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttackByPlayer(sg_fence_force, player1, 1) then
			
			SGroup_GetLastAttacker(sg_fence_force, sg_fence_aggressor)
			
			
			
		end
		
	end

end


function Airport_Fence_Movement() -- controls what the initial guards are doing

	if SGroup_IsUnderAttackByPlayer(sg_fence_force, player1, 1) then
	
		if SGroup_IsEmpty(tsg_airport_fence_guard[1]) == false and EGroup_IsEmpty(eg_fence_building) == false then
		
			Cmd_Garrison(tsg_airport_fence_guard[1], eg_fence_building)
		
		end
		
		Rule_RemoveMe()
		
	end


end



function Airport_Fence_Gungrab() -- makes the crew grab the pak38

	if SGroup_IsEmpty(sg_airport_fence_pak38_crew) == false then
		
		if Player_CanSeeSGroup(player1,sg_airport_fence_pak38_crew, false) then
			
			Cmd_CaptureTeamWeapon(sg_airport_fence_pak38_crew, eg_airport_fence_pak38)
			
			Rule_AddInterval(Airport_Fence_Pak38_Grabber, 5)
			
			Rule_RemoveMe()
			
		end
		
	end

end


function Airport_Fence_Pak38_Grabber() -- takes the sgroup inside the pak38 and adds it to fence force, and then calls a control function to control its firing

	if SGroup_IsEmpty(sg_fence_gun) then
	
		Player_GetAllSquadsNearMarker(player2, sg_fence_gun, mkr_fence_pak38_grabber)
		
		if SGroup_IsEmpty(sg_fence_gun) == false then -- this function only ends when sg_fence_gun is no longer empty
			
			SGroup_AddGroup(sg_fence_force, sg_fence_gun)
			
			Modify_WeaponAccuracy(sg_fence_gun, "hardpoint_01", 0.50) -- lowers the accuracy of this gun to half (but only with this axis crew)
			Modify_WeaponDamage(sg_fence_gun, "hardpoint_01", 0.50) -- lowers the damage of this gun to half (but only with this axis crew)
			
			Rule_AddInterval(Airport_Fence_Pak38_Control, 5)
			
			Rule_RemoveMe()
			
		end
	end
	
end


function Airport_Fence_Pak38_Control() -- controls pak38 firing behaviour

	if SGroup_IsEmpty(sg_fence_gun) == true then
	
		Rule_RemoveMe()
		
	
	else
		
		if SGroup_IsUnderAttackByPlayer(sg_fence_force, player1, 1) then
	
			--SGroup_GetLastAttacker(sg_fence_force, sg_fence_aggressor)
			
			if SGroup_IsEmpty(sg_fence_aggressor) == false then -- checks to see if the aggressor sgroup exists
				
				Cmd_Move(sg_fence_gun, sg_fence_gun, false, nil, sg_fence_aggressor)
				Cmd_Attack(sg_fence_gun, sg_fence_aggressor, false, true)
				
			end
			
			
		end
	
	end


end


-- sends out dudes once in a while from the door, to fight the player.  turned off when eg_flag2 has been captured
function Airport_Fence_Raider_Control()

	
	if EGroup_IsEmpty(eg_flag2) or EGroup_IsCapturedByPlayer(eg_flag2, player1, false) or SGroup_IsEmpty(sg_fence_force) or g_airport_fence_raider_wave >= 2 or b_Capture_Points_OBJComplete == true then
		
		Rule_RemoveMe()
		
		
		
	else
	
		if SGroup_IsUnderAttackByPlayer(sg_fence_force, player1, 2) and SGroup_IsEmpty(t_airport_fence.raiders[1].name) then
			
			SGroup_GetLastAttacker(sg_fence_force, sg_raider_target)  -- raider get last attacker is different than that of the guards in general
			
			if f_raider_sent == false then
				
				f_raider_sent = true -- flag to make sure that the delay isn't called while an instance of it is in queue
				
				Rule_AddOneShot(Airport_Fence_Raider_Delay, 10) -- sets a hard 10 second delay so stuff doesn't just pop in all of a sudden
				
			end
			
			
		elseif SGroup_IsUnderAttackByPlayer(sg_fence_force, player1, 2) and SGroup_IsEmpty(t_airport_fence.raiders[1].name) == false then
			
			if SGroup_IsEmpty(sg_raider_target) == false then -- if the player's squads are still alive
				
				Cmd_Attack(t_airport_fence.raiders[1].name, sg_raider_target)
				
			end
			
			
		end
		
	end


end

function Airport_Fence_Raider_Delay() -- after delay, kicks off the helper function 

	if SGroup_IsEmpty(sg_raider_target) == false then
		Airport_Fence_Raider_Spawn(t_airport_fence.raiders, sg_raider_target)
	
		
	end

	f_raider_sent = false
end



function Airport_Fence_Raider_Spawn(raiders,target) -- helper function that creates a squad of raiders from the fence door

	for k, raidersquad in pairs(raiders) do
		
		Util_CreateSquads(player2, raidersquad.name, raidersquad.blueprint, raidersquad.loc, nil, 1, raidersquad.number)
		SGroup_AddGroup(sg_fence_force, raidersquad.name)
		
		g_airport_fence_raider_wave = g_airport_fence_raider_wave + 1
		
		if SGroup_IsEmpty(target) == false then
			
			Cmd_Attack(raidersquad.name, target)
			
		end
		
	end
end



function Airport_Fence_MG_Control()

	if SGroup_IsEmpty(sg_airport_fence_mg1) then
	
		Rule_RemoveMe()
		
	else
	
		if SGroup_IsUnderAttack(sg_airport_fence_mg1, false, 5) then
				
			SGroup_GetLastAttacker(sg_airport_fence_mg1, sg_airport_fence_mg_attackers)
			
			if SGroup_IsEmpty(sg_airport_fence_mg1) == false then
				
				if SGroup_IsEmpty(sg_airport_fence_mg_attackers) == false then
					
					Cmd_AttackMove(sg_airport_fence_mg1, sg_airport_fence_mg_attackers, nil, nil, 25)

				end
				
			end
			
		end
		
	end

end



function Airport_Fence_Timed_Spawn_Trigger()

	if SGroup_IsEmpty(sg_fence_force) == false and SGroup_IsEmpty(sg_fence_aggressor) == false then
	
		if SGroup_IsUnderAttack(sg_fence_force, false, 5) or SGroup_IsDoingAttack(sg_fence_Force, false, 5) then
		
			Rule_AddDelayedInterval(Airport_Fence_Timed_Spawn, 5, 1)
			
			Rule_RemoveMe()
			
		end
		
	elseif SGroup_IsEmpty(sg_fence_force) == true and SGroup_IsEmpty(sg_fence_aggressor) == true then
	
		Rule_RemoveMe()
	
	end


end


function Airport_Fence_Timed_Spawn()

	local this = t_airport_fence.to_be_spawned[g_airport_fence_spawn_counter]

	if SGroup_IsEmpty(this.name) then
	
		Util_CreateSquads(player2, this.name, this.blueprint, mkr_fence_door, this.loc, 1, this.number)
		
		SGroup_AddGroup(sg_fence_force, this.name)
		
		Cmd_Move(this.name, this.loc, nil, nil, nil, nil, nil, 4 )
		
		if Rule_Exists(Airport_Fence_Time_Spawn_Reset) == false then
			
			Rule_AddInterval(Airport_Fence_Time_Spawn_Reset, 1)
			
			Rule_RemoveMe()
			
		end
		
	else

		

	end	
	
	

end


function Airport_Fence_Time_Spawn_Reset()

	local this = t_airport_fence.to_be_spawned[g_airport_fence_spawn_counter]
	
	if SGroup_IsEmpty(this.name) then
	
		if g_airport_fence_spawn_counter < g_airport_fence_spawn_limit then
		
			g_airport_fence_spawn_counter = g_airport_fence_spawn_counter + 1
			
			
	
			if Rule_Exists(Airport_Fence_Timed_Spawn) == false then
				
				local delaytime = World_GetRand(10, 15)
				
				Rule_AddDelayedInterval(Airport_Fence_Timed_Spawn, delaytime, 1)
				
				Rule_RemoveMe()
				
			end
			
			
			
		elseif g_airport_fence_spawn_counter >= g_airport_fence_spawn_limit then
		
			Rule_RemoveMe()
		
		end
		
	end


end


------------------------------------

-- Mortar Troops

-----------------------------------

function Mortar_Init() -- initialize stuff for the mortar area.

	tmkr_mortar_squad = Marker_GetTable("mkr_mortar_squad%d")
	
	tmkr_mortar_guard = Marker_GetTable("mkr_mortar_guard%d")	
	tsg_mortar_guard = SGroup_CreateTable("sg_mortar_guard%d", table.getn(tmkr_mortar_guard))
	
	sg_mortar1		 = SGroup_CreateIfNotFound("sg_mortar1")
	sg_mortar_guard1 = SGroup_CreateIfNotFound("sg_mortar_guard1")
	sg_mortar_guard2 = SGroup_CreateIfNotFound("sg_mortar_guard2")
	
	t_mortar = {
		
		spawn = {
			
			{name = tsg_mortar_guard[1], blueprint = t_difficulty.g_soldier_type1, loc = mkr_mortar_guard1},
			--{name = tsg_mortar_guard[2], blueprint = SBP.AXIS.GRENADIER, loc = mkr_mortar_guard2},
			{name = sg_mortar1, blueprint = t_difficulty.g_soldier_type2, loc = mkr_mortar_squad1},
			--{name = tsg_mortar_guard[4], blueprint = SBP.AXIS.AA_20MM, loc = mkr_mortar_guard4},
			--{name = sg_mortar1, blueprint = SBP.AXIS.PAK_38, loc = mkr_mortar1},
			--{name = sg_mortar2, blueprint = SBP.AXIS.PAK_38, loc = mkr_mortar2},
		},
	}

	eg_panzershreck1 = EGroup_CreateIfNotFound("eg_panzershreck1")
	eg_mortar1 = EGroup_CreateIfNotFound("eg_mortar1")
	--eg_mortar_drop = EGroup_CreateIfNotFound("eg_mortar_drop")
	
	f_mortar_grabbed = false
	
end


function Mortar_Preset()

	-- spawn squads
	
	for k, v in pairs(t_mortar.spawn) do
	
		local mortar_squad = v
	
		Util_CreateSquads(player2, mortar_squad.name, mortar_squad.blueprint, mortar_squad.loc, nil, 1, 3)
		
		
	end
	
	Util_CreateEntities(nil, eg_panzershreck1, EBP.PICKUP.AXIS.PANZERSCHRECK, mkr_panzerschreck1, 1)
	Util_CreateEntities(nil, eg_mortar1, EBP.PICKUP.AXIS.MORTAR, mkr_mortar1, 1) -- EBP.PICKUP.AXIS.MORTAR
	
	Rule_AddInterval(Mortar_Grab1, 2)
	Rule_AddDelayedInterval(Mortar_Grab2, 1, 2)
	-- start enemy behavior
	
	-- do other cool things

end

function Mortar_Grab1()


	if f_mortar_grabbed == true or SGroup_IsEmpty(sg_mortar1) then
		
		Rule_RemoveMe()
		
	else
--Prox_ArePlayersNearMarker(player1, mkr_mortar_spawn_detection, false)
		if (SGroup_IsUnderAttackByPlayer(sg_mortar1, player1, 4) or Player_CanSeeSGroup(player1, sg_mortar1, false)) and EGroup_IsEmpty(eg_ammo_driver_spawn1) then
			
			f_mortar_grabbed = true
			
			Cmd_CaptureTeamWeapon(sg_mortar1, eg_mortar1)
			
			if SGroup_IsEmpty(tsg_mortar_guard[1]) == false then
				
				Cmd_Move(tsg_mortar_guard[1], mkr_mortar_guard_destination, nil, nil, nil, nil, nil, 10 )
				
			end
			
			SGroup_AddSlotItemToDropOnDeath( sg_mortar1, SLOT_ITEM.AXIS_MORTAR, 1.0, true )
			
			Rule_RemoveMe()
			
		end
	
	end

end


function Mortar_Grab2()

	if f_mortar_grabbed == true or SGroup_IsEmpty(sg_mortar1) then
		
		Rule_RemoveMe()
		
	else
		
		if EGroup_IsEmpty(eg_ammo_driver_spawn1)then
			
			f_mortar_grabbed = true
			
			Rule_AddOneShot(Mortar_Grab2_Delay, 15) -- 15 seconds after the fall of the garrison hq, the mortar team will run out to grab the mortar anyway
			
			
			Rule_RemoveMe()
			
		end
		
	end

end


function Mortar_Grab2_Delay()

	if SGroup_IsEmpty(sg_mortar1) == false then
		
		Cmd_CaptureTeamWeapon(sg_mortar1, eg_mortar1)
		
		if SGroup_IsEmpty(tsg_mortar_guard[1]) == false then
			
			Cmd_Move(tsg_mortar_guard[1], mkr_mortar_guard_destination, nil, nil, nil, nil, nil, 10 )
			
		end	
		
		SGroup_AddSlotItemToDropOnDeath( sg_mortar1, SLOT_ITEM.AXIS_MORTAR, 1.0, true )
		
	end
	
end


-------------------------

-- Flak88 Encounter

-----------------------

function Flak88_Init() -- initialize stuff for the Flak88 area

	
	
	sw_flak88_gun01 = SyncWeapon_GetFromEGroup(eg_flak88_gun01)
	
	sg_flak88_soldiers = SGroup_CreateIfNotFound("sg_flak88_soldiers")
	
	sg_flak88_delayers = SGroup_CreateIfNotFound("sg_flak88_delayers")
	
	sg_flak88_gun = SGroup_CreateIfNotFound("sg_flak88_gun") -- sgroup for the manned version
	
	sg_flak88_runners = SGroup_CreateIfNotFound("sg_flak88_runners")
	SGroup_AddGroup(sg_flak88_soldiers, sg_flak88_runners)
	
	tsg_flak88_soldiers = {sg_flak88_delayers, sg_flak88_runners}
	
	t_flak88 = {
		
		spawn = {
			
			{name = tsg_flak88_soldiers[1], blueprint = t_difficulty.g_soldier_type2, loc = mkr_flak88_delayers, number = 3},
			{name = tsg_flak88_soldiers[2], blueprint = t_difficulty.g_soldier_type2, loc = mkr_flak88_runners, number = 3},
			--{name = sg_flak881, blueprint = SBP.AXIS.PAK_38, loc = mkr_flak881},
			--{name = sg_flak882, blueprint = SBP.AXIS.PAK_38, loc = mkr_flak882},
		},
		--[[
		event_triggered = {
			{ACTOR.GenericAlly, LOC("The cowards are running away! After them!!")}
		},]]
	}

	-- AMBIENT EVENT
	t_flak88.event_triggered = {
		--{ACTOR.GenericAlly, LOC("The cowards are running away! After them!!")}
		{ACTOR.CXP1.GenericAxis, 1330760}, -- Canadians!  Head for the 88!
		{ACTOR.CXP1.Chubb, 1330761}, -- Quickly lads! Those cowards are getting away!  After them!
	}
	
	--eg_mortar2 = EGroup_CreateIfNotFound("eg_mortar2")
	f_flak88_runners_triggered = false
	
end


function Flak88_Preset()

	-- spawn squads
	
	for k, v in pairs(t_flak88.spawn) do
	
		local flak88_squad = v
	
		Util_CreateSquads(player2, flak88_squad.name, flak88_squad.blueprint, flak88_squad.loc, nil, 1, flak88_squad.number, true)
		SGroup_AddGroup(sg_flak88_soldiers, flak88_squad.name)
	
	end
	
	--Util_CreateEntities(nil, eg_mortar2, EBP.PICKUP.ALLIES.MORTAR, mkr_mortar2, 1)
	
	
	-- start enemy behavior
	Rule_AddInterval(Flak88_Runner_Control1, 5)
	Rule_AddDelayedInterval(Flak88_Runner_Control2, 1, 5)
	-- do other cool things

end



-- check if runners exist, then if flak88 group exists, then fence force
-- then, checks to see if these groups are under attack then if so, if runners exist, then they will run to the 88 and man it.  
function Flak88_Runner_Control1() 

	if SGroup_IsEmpty(sg_flak88_runners) == true or f_flak88_runners_triggered == true then
	
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsEmpty(sg_flak88_soldiers) == false then -- do the soldiers exist for the flak88?
		
			if SGroup_IsUnderAttack(sg_flak88_soldiers, false, 1) then -- are these soldiers under attack?
				
				if SGroup_IsEmpty(sg_flak88_runners) == false then -- do the runners exist?
					
					if SyncWeapon_Exists(sw_flak88_gun01) then -- does the flak88 in question exist?
						
						Cmd_CaptureTeamWeapon(sg_flak88_runners, eg_flak88_gun01, false) -- capture the flak88
						
						Util_AutoAmbient(t_flak88.event_triggered)
						
						Rule_AddInterval(Flak88_Grabber, 5)
						
						f_flak88_runners_triggered = true
						
						Rule_RemoveMe()
						
					end
					
				end
				
				
				
			end
		
		end
		
	end

end



function Flak88_Runner_Control2()

	if SGroup_IsEmpty(sg_flak88_runners) == true or f_flak88_runners_triggered == true then
	
		Rule_RemoveMe()
		
	else
		if SGroup_IsEmpty(sg_fence_force) == false then
	
			if SGroup_IsUnderAttack(sg_fence_force, false, 1) then -- are these soldiers under attack?
					
				if SGroup_IsEmpty(sg_flak88_runners) == false then -- do the runners exist?
					
					if SyncWeapon_Exists(sw_flak88_gun01) then -- does the flak88 in question exist?
						
						Cmd_CaptureTeamWeapon(sg_flak88_runners, eg_flak88_gun01, false) -- capture the flak88
						
						Util_AutoAmbient(t_flak88.event_triggered)
						
						Rule_AddInterval(Flak88_Grabber, 5)
						
						f_flak88_runners_triggered = true
						
						Rule_RemoveMe()
					
					end
				end
				
			end
		end
	end

end


function Flak88_Grabber() -- grabs the squad on the 88, changes accuracy

	if SGroup_IsEmpty(sg_flak88_gun) then
		
		Player_GetAllSquadsNearMarker(player2, sg_flak88_gun, mkr_fence_88)
		
		
		if SGroup_IsEmpty(sg_flak88_gun) == false then -- only turns off if the gun really is occupied
		
			Modify_WeaponAccuracy(sg_flak88_gun, "hardpoint_01", 0.50) -- lowers the accuracy of this gun to half		
			
			SGroup_AddGroup(sg_fence_force, sg_flak88_gun)
			
		end
		
		
	elseif SGroup_IsEmpty(sg_flak88_gun) == false then -- only turns off if the gun really is occupied
		
		Rule_RemoveMe()
		
	end


end



------------------------------------

-- Airport Gate Bunkers

-----------------------------------
function Airport_Gate_Init() -- initialize stuff for the airport gate bunker area.

	tmkr_airport_gate_guard = Marker_GetTable("mkr_airport_gate_guard%d")	
	tsg_airport_gate_guard = SGroup_CreateTable("sg_airport_gate_guard%d", table.getn(tmkr_airport_gate_guard))
	
	sg_airport_gate_bunker_guard1 = SGroup_CreateIfNotFound("sg_airport_gate_bunker_guard1")
	sg_airport_gate_bunker_guard2 = SGroup_CreateIfNotFound("sg_airport_gate_bunker_guard2")
	sg_airport_gate_88_crew = SGroup_CreateIfNotFound("sg_airport_gate_88_crew")
	sg_airport_gate_88 = SGroup_CreateIfNotFound("sg_airport_gate_88")
	
	sg_gate_force = SGroup_CreateIfNotFound("sg_gate_force")
	sg_gate_aggressor = SGroup_CreateIfNotFound("sg_gate_aggressor")
	
	sg_airport_gate_raiders = SGroup_CreateIfNotFound("sg_airport_gate_raiders")
	sg_gate_raider_target = SGroup_CreateIfNotFound("sg_gate_raider_target")
	
	t_airport_gate = {
		
		spawn = {
			
			--{name = tsg_airport_gate_guard[1], blueprint = t_difficulty.g_soldier_type3, loc = mkr_airport_gate_guard1},
			--{name = tsg_airport_gate_guard[2], blueprint = t_difficulty.g_soldier_type1, loc = mkr_airport_gate_guard2},
			--{name = tsg_airport_gate_guard[3], blueprint = SBP.AXIS.GRENADIER, loc = mkr_airport_gate_guard3},
			--{name = tsg_airport_gate_guard[4], blueprint = SBP.AXIS.GRENADIER, loc = mkr_airport_gate_guard4},
			{name = sg_airport_gate_bunker_guard1, blueprint = t_difficulty.g_soldier_type2, loc = eg_airport_gate_bunker1},
			--{name = sg_airport_gate_bunker_guard2, blueprint = t_difficulty.g_soldier_type2, loc = eg_airport_gate_bunker2},
		},
		
		crew = {
		
			{name = sg_airport_gate_88_crew, blueprint = t_difficulty.g_soldier_type2, loc = mkr_gate_bunker_door2, number = 3},
		
		},
		
		raiders = {
			
			{name = sg_airport_gate_raiders, blueprint = t_difficulty.g_soldier_type2, loc = mkr_gate_door2, number = 3},
			
		},
		
	}
	
	g_gate_raider_wave = 0
	
	fg_bunker_runners_deployed = false
	
end


function Airport_Gate_Preset()

	-- spawn squads
	
	for k, v in pairs(t_airport_gate.spawn) do
	
		local airport_gate = v
	
		Util_CreateSquads(player2, airport_gate.name, airport_gate.blueprint, airport_gate.loc, nil, 1, 3)
		SGroup_AddGroup(sg_gate_force, airport_gate.name)
	
	end
	
	
	Cmd_InstantUpgrade(eg_airport_gate_bunker1, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	
	Modify_WeaponRange(eg_airport_gate_bunker1, "hardpoint_01", 0.8)
	
	--Cmd_InstantUpgrade(eg_airport_gate_bunker2, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	
	-- start enemy behavior
	
	-- do other cool things

end


function Airport_Gate_Kickoff() -- kickoff function

	Rule_AddInterval(Airport_Gate_Find_Attacker, 5)
	Rule_AddInterval(Airport_Gate_Raider_Control, 10)
	Rule_AddDelayedInterval(Airport_Gate_88_Crew_Spawn, 45, 1)

end



function Airport_Gate_Find_Attacker() -- function to find the player units who are attacking the gate forces

	if SGroup_IsEmpty(sg_gate_force) == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsUnderAttackByPlayer(sg_gate_force, player1, 5)and SGroup_IsDoingAttack(sg_gate_force, false, 5) then
			
			SGroup_GetLastAttacker(sg_gate_force, sg_gate_aggressor)
			
			Rule_AddOneShot(Airport_Gate_Extra_Dudes1, 20)
			Rule_AddOneShot(Airport_Gate_Extra_Dudes2, 35)
			
			if Rule_Exists(Airport_Gate_88_Bunker_Runners) == false and fg_bunker_runners_deployed == false then
				
				Rule_AddOneShot(Airport_Gate_88_Bunker_Runners, 7)
				
			end
			
			Rule_RemoveMe()
			
		end
		
	end

end


function Airport_Gate_Extra_Dudes1()

	if SGroup_IsEmpty(sg_gate_force) == true then
	
		Rule_RemoveMe()
		
	else
	
		if SGroup_IsEmpty(sg_gate_aggressor) == false then
		
			if SGroup_IsEmpty(tsg_airport_gate_guard[1]) == true then
			
				Util_CreateSquads(player2, tsg_airport_gate_guard[1], t_difficulty.g_soldier_type3, mkr_gate_bunker_door1, nil, 1, 3)
				SGroup_AddGroup(sg_gate_force, tsg_airport_gate_guard[1])
				
				Cmd_Move(tsg_airport_gate_guard[1],  mkr_at_after_retreat1)
				
				Rule_RemoveMe()
			
			end
			
		end
		
	end
		

end

function Airport_Gate_Extra_Dudes2()

	if SGroup_IsEmpty(sg_gate_force) == true then
	
		Rule_RemoveMe()
		
	else
	
		if SGroup_IsEmpty(sg_gate_aggressor) == false then
		
			if SGroup_IsEmpty(tsg_airport_gate_guard[2]) == true then
			
				Util_CreateSquads(player2, tsg_airport_gate_guard[2], t_difficulty.g_soldier_type1, mkr_gate_bunker_door2, nil, 1, 3)
				SGroup_AddGroup(sg_gate_force, tsg_airport_gate_guard[2])
				Cmd_Move(tsg_airport_gate_guard[2],  mkr_airport_gate_guard1)
				
				Rule_RemoveMe()
			
			end
			
		end
		
	end
		

end

-- sends out dudes once in a while from the door, to fight the player.  turned off when eg_flag2 has been captured
function Airport_Gate_Raider_Control()

	
	if EGroup_IsEmpty(eg_flag4) or EGroup_IsCapturedByPlayer(eg_flag4, player1, false) or SGroup_IsEmpty(sg_gate_force) or g_gate_raider_wave >= 3 or b_Capture_Points_OBJComplete == true then
		
		Rule_RemoveMe()
		
		
		
	else
	
		if SGroup_IsUnderAttackByPlayer(sg_gate_force, player1, 2) and SGroup_IsEmpty(t_airport_gate.raiders[1].name) then
			
			SGroup_GetLastAttacker(sg_gate_force, sg_gate_raider_target)  -- raider get last attacker is different than that of the guards in general
			
			if f_raider_sent == false then
				
				f_raider_sent = true -- flag to make sure that the delay isn't called while an instance of it is in queue
				
				Rule_AddOneShot(Airport_Gate_Raider_Delay, 15) -- sets a hard 15 second delay so stuff doesn't just pop in all of a sudden
				
			end
			
			
		elseif SGroup_IsUnderAttackByPlayer(sg_gate_force, player1, 2) and SGroup_IsEmpty(t_airport_gate.raiders[1].name) == false then
			
			if SGroup_IsEmpty(sg_gate_raider_target) == false then -- if the player's squads are still alive
				
				Cmd_Attack(t_airport_gate.raiders[1].name, sg_gate_raider_target)
				
			end
			
			
		end
		
	end


end

function Airport_Gate_Raider_Delay() -- after delay, kicks off the helper function 

	if SGroup_IsEmpty(sg_gate_raider_target) == false then
		Airport_Gate_Raider_Spawn(t_airport_gate.raiders, sg_gate_raider_target)
	end
	
	f_raider_sent = false

end



function Airport_Gate_Raider_Spawn(raiders,target) -- helper function that creates a squad of raiders from the gate door

	for k, raidersquad in pairs(raiders) do
		
		Util_CreateSquads(player2, raidersquad.name, raidersquad.blueprint, raidersquad.loc, nil, 1, raidersquad.number)
		SGroup_AddGroup(sg_gate_force, raidersquad.name)
		
		g_gate_raider_wave = g_gate_raider_wave + 1
		--Modify_WeaponAccuracy(raidersquad.name, "hardpoint_01", 0.85)
		
		if SGroup_IsEmpty(target) == false then
			
			Cmd_Attack(raidersquad.name, target)
			
		end
		
	end
end



function Airport_Gate_88_Crew_Spawn() -- spawns the 88 crew

	if SGroup_IsEmpty(sg_gate_force) == false then
	
		if SGroup_IsUnderAttackByPlayer(sg_gate_force, player1, 1) then
		
			Util_CreateSquads(player2, t_airport_gate.crew[1].name, t_airport_gate.crew[1].blueprint, t_airport_gate.crew[1].loc, nil, 1, t_airport_gate.crew[1].number)
			SGroup_AddGroup(sg_gate_force, t_airport_gate.crew[1].name)
			
			Rule_AddOneShot(Airport_Gate_88_Capture_Delay, 3) -- needed otherwise the crew will just warp to the 88 for some reason?
			
			Rule_RemoveMe()
		
		end
		
	else
		
		Rule_RemoveMe()
		
	end

end


-- delayed capture called, also this function calls Airport_Gate_88_Get_Squads after 10 seconds so that the squad has time to reach the weapon
function Airport_Gate_88_Capture_Delay() 

	if SGroup_IsEmpty(t_airport_gate.crew[1].name) == false then
		Cmd_CaptureTeamWeapon(t_airport_gate.crew[1].name, eg_flak88_gun03)
	end

	Rule_AddInterval(Airport_Gate_88_Get_Squads, 5)
	
end



-- grabs the crew of the gun and puts it into a usable SGroup.
function Airport_Gate_88_Get_Squads() 

	if SGroup_IsEmpty(sg_airport_gate_88) then
		
		Player_GetAllSquadsNearMarker(player2, sg_airport_gate_88, mkr_gate_88_detect) 
		
		if SGroup_IsEmpty(sg_airport_gate_88) == false then
		
			Modify_WeaponAccuracy(sg_airport_gate_88, "hardpoint_01", 0.25) -- makes the axis squad have low accuracy with the gun
			
			SGroup_AddGroup(sg_gate_force, sg_airport_gate_88)
		
		end
		
	elseif SGroup_IsEmpty(sg_airport_gate_88) == false then
		
		Rule_RemoveMe()
		
	end
	

end

function Airport_Gate_88_Bunker_Runners()

	Util_CreateSquads(player2, sg_airport_gate_bunker_guard2, t_difficulty.g_soldier_type2, mkr_gate_bunker_door1, nil, 1, 3)
	SGroup_AddGroup(sg_gate_force, sg_airport_gate_bunker_guard2)
	fg_bunker_runners_deployed = true
	
	if EGroup_IsEmpty(eg_bunker6) == false then
		
		Cmd_Move(sg_airport_gate_bunker_guard2, eg_bunker6)
		Rule_AddInterval(Airport_Gate_88_Bunker_Entry, 1)
		
	else
		
		Cmd_Move(sg_airport_gate_bunker_guard2, mkr_preset_vehicle8)
		
	end

	
	
end

function Airport_Gate_88_Bunker_Entry()

	if EGroup_IsEmpty(eg_bunker6) == true or SGroup_IsEmpty(sg_airport_gate_bunker_guard2) == true then
	
		Rule_RemoveMe()
	
	elseif EGroup_IsEmpty(eg_bunker6) == false and SGroup_IsEmpty(sg_airport_gate_bunker_guard2) == false then	
	
		if Prox_SquadsInProximityOfEntities(sg_airport_gate_bunker_guard2, eg_bunker6, 5, true) then

			Modify_DisableHold(eg_bunker6, false)
			
			Cmd_Garrison(sg_airport_gate_bunker_guard2, eg_bunker6)
			--Cmd_InstantGarrison(sg_airport_gate_bunker_guard2, eg_bunker6)
			
			
			--Cmd_InstantUpgrade(eg_bunker6, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
			
			--Rule_AddInterval(Airport_Gate_88_Bunker_Instant, 1)
			
			Rule_AddInterval(Airport_Gate_88_Bunker_Revert, 1)
			
			
			
			Rule_RemoveMe()
			
		end
		
		
	end
		

end

--[[
function Airport_Gate_88_Bunker_Instant()
	
	if EGroup_IsEmpty(eg_bunker6) == true or SGroup_IsEmpty(sg_airport_gate_bunker_guard2) then
	
		Rule_RemoveMe()
		
	else
	
	
		if EGroup_IsEmpty(eg_bunker6) == false and Player_OwnsEGroup(player2, eg_bunker6, false) then
		
			Cmd_InstantUpgrade(eg_bunker6, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
			
			Rule_RemoveMe()
		
		end

	end

end]]

function Airport_Gate_88_Bunker_Revert()

	if EGroup_IsEmpty(eg_bunker6) == true then
	
		Rule_RemoveMe()
		
	elseif EGroup_IsEmpty(eg_bunker6) == false and SGroup_IsEmpty(sg_airport_gate_bunker_guard2) == true then	
	
		Modify_DisableHold(eg_bunker6, true)
		
		--EGroup_SetPlayerOwner(eg_bunker6, player3)

		Rule_RemoveMe()

	end
	
end

------------------------------------

-- Field Troops

-- NOTE TO SELF: ADD OFFICER IN THIS AREA, directing troops, etc.  Make him do a patrol, etc.

-----------------------------------



function Field_Init() -- initialize stuff for the mid-field area.

	-- defining the aggressor group - the group of player soldiers that are attacking this position
	sg_field_aggressor = SGroup_CreateIfNotFound("sg_field_aggressor")
	sg_field_flak88_crew = SGroup_CreateIfNotFound("sg_field_flak88_crew")
	sg_field_88 = SGroup_CreateIfNotFound("sg_field_88")
	sg_field_pak38_crew = SGroup_CreateIfNotFound("sg_field_pak38_crew")
	sg_field_pak38 = SGroup_CreateIfNotFound("sg_field_pak38")
	sg_field_alert = SGroup_CreateIfNotFound("sg_field_alert")
	sg_field_extra = SGroup_CreateIfNotFound("sg_field_extra")
	sg_field_door_force = SGroup_CreateIfNotFound("sg_field_door_force")
	
	tmkr_field_guard = Marker_GetTable("mkr_field_guard%d")	
	tsg_field_guard = SGroup_CreateTable("sg_field_guard%d", table.getn(tmkr_field_guard))
	sg_field_force = SGroup_CreateIfNotFound("sg_field_force")
	--sg_field1 = SGroup_CreateIfNotFound("sg_field1")
	--sg_field2 = SGroup_CreateIfNotFound("sg_field2")
	
	sg_field_bunker1 = SGroup_CreateIfNotFound("sg_field_bunker1")
	sg_field_bunker2 = SGroup_CreateIfNotFound("sg_field_bunker2")
	
	t_field = {
		
		alert = {
			{name = sg_field_alert, blueprint = t_difficulty.g_soldier_type2, loc = mkr_alert_guards, number = 5},
			
		},
		
		spawn = {
			
			{name = tsg_field_guard[1], blueprint = t_difficulty.g_soldier_type3, loc = mkr_field_door, number = 3, dest = mkr_field_guard1}, -- mkr_field_guard1
			{name = tsg_field_guard[2], blueprint = t_difficulty.g_soldier_type1, loc = mkr_gate_door1, number = 3, dest = mkr_field_guard2},
			{name = tsg_field_guard[3], blueprint = SBP.AXIS.OFFICER, loc = mkr_field_door, number = 1, dest = mkr_field_guard3},
			--{name = tsg_field_guard[4], blueprint = t_difficulty.g_soldier_type2, loc = mkr_gate_door1, number = 3, dest = mkr_field_guard4},
			
			--{name = sg_field1, blueprint = SBP.AXIS.PAK_38, loc = mkr_field1},
			--{name = sg_field2, blueprint = SBP.AXIS.PAK_38, loc = mkr_field2},
			
		},
		
		gun_crews = {
			{name = sg_field_flak88_crew, blueprint = t_difficulty.g_soldier_type2, loc = mkr_field_door, number = 3},
			{name = sg_field_pak38_crew, blueprint = t_difficulty.g_soldier_type2, loc = mkr_field_door, number = 3},
			
		},
		
		bunker_spawn = {
			
			{name = sg_field_bunker1, blueprint = t_difficulty.g_soldier_type2, loc = eg_field_bunker1, number = 3},
			{name = sg_field_bunker2, blueprint = t_difficulty.g_soldier_type2, loc = eg_field_bunker2, number = 3},
			
		},
		
		
		extra_enemy_info = {
		
			name = sg_field_extra, 
			blueprint = {t_difficulty.g_soldier_type3, t_difficulty.g_soldier_type2, t_difficulty.g_soldier_type2},
			loc = mkr_gate_door1,
			number = 3,
		},
		
		
	}

	g_field_spawn_base_count = table.getn(t_field.spawn)
	g_field_spawn_count = 1
	g_field_88_crew = nil
	
	g_field_extra_wave = 0
	
end


function Field_Preset()

	-- spawn "alert" squad
	
	for k, v in pairs(t_field.alert) do
	
		local field_squad = v
	
		Util_CreateSquads(player2, field_squad.name, field_squad.blueprint, field_squad.loc, nil, nil, field_squad.number)
		SGroup_AddGroup(sg_field_force, field_squad.name)
	
	end
	
	-- spawn bunker squads
	for k, v in pairs(t_field.bunker_spawn) do
	
		local field_squad = v
	
		Util_CreateSquads(player2, field_squad.name, field_squad.blueprint, field_squad.loc, nil, nil, field_squad.number)
		SGroup_AddGroup(sg_field_force, field_squad.name)
	
	end
	
	Cmd_InstantUpgrade(eg_field_bunker1, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	Cmd_InstantUpgrade(eg_field_bunker2, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	Modify_WeaponRange(eg_field_bunker1, "hardpoint_01", 0.6)
	Modify_WeaponRange(eg_field_bunker2, "hardpoint_01", 0.8)
	-- start enemy behavior
	
	-- do other cool things

end



-- kicks off action, gun crews run out, other dudes run out
function Field_Kickoff()

	Rule_AddDelayedInterval(Field_88_Crew_Spawn, 5, 1)
	Rule_AddInterval(Field_Door_Spawner, 10)

end

-- 88 crew spawning function for middle area. 
function Field_88_Crew_Spawn()
	
	if SGroup_IsUnderAttackByPlayer(sg_field_force, player1, 1) and Player_CanSeeSGroup(player1, sg_field_alert, false)  then
		
		local field_squad = t_field.gun_crews[1]
		
		Util_CreateSquads(player2, field_squad.name, field_squad.blueprint, field_squad.loc, nil, nil, field_squad.number)
		SGroup_AddGroup(sg_field_force, field_squad.name)
		
		g_field_88_crew = field_squad.name
		
		Rule_AddOneShot(Field_88_Grabber, 3)
		
		Rule_AddOneShot(Field_Pak38_Crew_Spawn, 2)
		
		Rule_RemoveMe()
		
	end
	
	

end

-- makes the gun crew run to the gun
function Field_88_Grabber()
	
	Cmd_CaptureTeamWeapon(g_field_88_crew, eg_flak88_gun02 )
	
	Rule_AddInterval(Field_88_Getter, 5)

	
end

-- grabs the squad at the 88
function Field_88_Getter()

	if SGroup_IsEmpty(sg_field_88) then -- assumes that the crew got to the gun already, and lost its sgroup as a result
	
		Player_GetAllSquadsNearMarker(player2, sg_field_88, mkr_field_88)
		
		if SGroup_IsEmpty(sg_field_88) == false then -- ends rule when there really is someone occupying the gun
		
			SGroup_AddGroup(sg_field_force, sg_field_88)
		
		end
		
		--Modify_WeaponAccuracy(sg_field_88, "hardpoint_01", 0.50) -- lowers the accuracy of this gun to half (but only with this axis crew)
		--Modify_WeaponDamage(sg_field_88, "hardpoint_01", 0.50) -- lowers the damage of this gun to half (but only with this axis crew)
		
	elseif SGroup_IsEmpty(sg_field_88) == false then -- ends rule when there really is someone occupying the gun
		
		Modify_WeaponAccuracy(sg_field_88, "hardpoint_01", 0.60) -- lowers the accuracy of this gun to half (but only with this axis crew)
		Modify_WeaponDamage(sg_field_88, "hardpoint_01", 0.60) -- lowers the damage of this gun to half (but only with this axis crew)
		
		
		Rule_RemoveMe()
		
	end
	
end


-- spawns the crew for the pak38
function Field_Pak38_Crew_Spawn()

	if SGroup_IsUnderAttackByPlayer(sg_field_force, player1, 1) then
	
		local field_squad = t_field.gun_crews[2]
		
		Util_CreateSquads(player2, field_squad.name, field_squad.blueprint, field_squad.loc, nil, nil, field_squad.number)
		SGroup_AddGroup(sg_field_force, field_squad.name)
		g_field_pak38_crew = field_squad.name
		
		Cmd_CaptureTeamWeapon(field_squad.name, eg_field_pak38 )
		
		Rule_AddOneShot(Field_Pak38_Move, 1)
		
	end

end

-- makes the pak38 crew run to their gun
function Field_Pak38_Move()

	Cmd_CaptureTeamWeapon(g_field_pak38_crew, eg_field_pak38 )
	Rule_AddInterval(Field_Pak38_Grabber, 7)
	
end

--grabs the squad inside the gun, and assigns it to an SGroup so that we can use it to attack things
function Field_Pak38_Grabber()

	if SGroup_IsEmpty(sg_field_pak38) then
		
		Player_GetAllSquadsNearMarker(player2, sg_field_pak38, mkr_field_pak38_grabber)
		
		if SGroup_IsEmpty(sg_field_pak38) == false then
			
			SGroup_AddGroup(sg_field_force, sg_field_pak38)
		
			Modify_WeaponAccuracy(sg_field_pak38, "hardpoint_01", 0.25) -- lowers the accuracy of this gun
			
		end
	
	elseif SGroup_IsEmpty(sg_field_pak38) == false then
		
		Rule_AddInterval(Field_Pak38_Control, 5)
		
		Rule_RemoveMe()
		
	end
	
end

-- controller for the pak38
function Field_Pak38_Control()

	if SGroup_IsEmpty(sg_field_pak38) == true then
		
		Rule_RemoveMe()
		
		
	else
		
		if SGroup_IsUnderAttackByPlayer(sg_field_force, player1, 1) then
			
			SGroup_GetLastAttacker(sg_field_force, sg_field_aggressor)
			
			--Player_GetAllSquadsNearMarker(player2, sg_field_gun, mkr_field_pak38_grabber)
			if SGroup_IsEmpty(sg_field_aggressor) == false then
			
				Cmd_Move(sg_field_pak38, sg_field_pak38, false, nil, sg_field_aggressor)
				Cmd_Attack(sg_field_pak38, sg_field_aggressor, false, true)
				
			end
			
		end
		
	end

end


-- makes sure the extra soldiers spawn out of the doors nearby
function Field_Door_Spawner()
	-- if spawned field guys is less than the base number
	if g_field_spawn_count <= g_field_spawn_base_count then
		
		local field_squad = t_field.spawn[g_field_spawn_count]
	
		Util_CreateSquads(player2, field_squad.name, field_squad.blueprint, field_squad.loc, field_squad.dest, nil, field_squad.number)
		
		SGroup_AddGroup(sg_field_force, field_squad.name)
		SGroup_AddGroup(sg_field_door_force, field_squad.name)
		if SGroup_IsEmpty(sg_field_aggressor) == false then
		
			Cmd_Move(field_squad.name, sg_field_aggressor, nil, nil, nil, nil, nil, 20)
		
		end
		
		g_field_spawn_count = g_field_spawn_count + 1
		
	else
		
		Rule_AddInterval(Field_Extra_Enemy_Control, 10)
		
		Rule_RemoveMe()
		
		
		
	end
	
end


function Field_Extra_Enemy_Control() -- controls the spawning of the extra dudes that pop out

	if SGroup_IsEmpty(sg_field_extra) == true and SGroup_IsEmpty(sg_field_force) == false and g_field_extra_wave <= 2 and SGroup_IsEmpty(sg_field_door_force) then -- limits extra wave to 2
		
		local rand_spawn_time = World_GetRand(10, 15)
		
		Rule_AddOneShot(Field_Extra_Enemy_Spawn, rand_spawn_time)
		
		Rule_RemoveMe()
		
	elseif EGroup_IsCapturedByPlayer(eg_flag3, player1, false) or g_field_extra_wave >= 2 or EGroup_IsEmpty(eg_flag3) or SGroup_IsEmpty(sg_field_force) == true then
		
		Rule_RemoveMe()
		
	end
	

end


function Field_Extra_Enemy_Spawn() -- spawn extra dudes
	
	local random_bp = World_GetRand(1, table.getn(t_field.extra_enemy_info.blueprint))
	
	Util_CreateSquads(player2, t_field.extra_enemy_info.name, t_field.extra_enemy_info.blueprint[random_bp], t_field.extra_enemy_info.loc, nil, 1, t_field.extra_enemy_info.number)
	
	--Modify_WeaponAccuracy(t_field.extra_enemy_info.name, "hardpoint_01", 0.50)
	g_field_extra_wave = g_field_extra_wave + 1
	
	if SGroup_IsEmpty(sg_field_aggressor) == false then
		
		Cmd_Attack(t_field.extra_enemy_info.name, sg_field_aggressor)
			
	else
	
		Cmd_Move(t_field.extra_enemy_info.name, mkr_door_move, nil, nil, nil, nil, nil, 20)
	
	end
	
	Rule_AddInterval(Field_Extra_Enemy_Control, 10)
	
end

-------------------------------------

------------------------------------

-- AT Gun Emplacements
-- Actually, now just a bunch of defenders
-----------------------------------


function AT_Gun_Init() -- initialize stuff for the AT gun area

	tmkr_at_gun_guard = Marker_GetTable("mkr_at_gun_guard%d")	
	tsg_at_gun_guard = SGroup_CreateTable("sg_at_gun_guard%d", table.getn(tmkr_at_gun_guard))
	sg_at_gun_force = SGroup_CreateIfNotFound("sg_at_gun_force")
	tsg_at_gun_vehicle = SGroup_CreateTable("sg_at_gun_vehicle", 2)
	eg_checkpoint_mortar = EGroup_CreateIfNotFound("eg_checkpoint_mortar")
	
	--sg_at_gun1 = SGroup_CreateIfNotFound("sg_at_gun1")
	--sg_at_gun2 = SGroup_CreateIfNotFound("sg_at_gun2")
	
	t_at_gun = {
		
		spawn = {
			
			{name = tsg_at_gun_guard[1], blueprint = t_difficulty.g_soldier_type2, loc = mkr_at_gun_guard1, stopped = false, runto = mkr_after_retreat1, runto_alt = mkr_at_after_retreat1},
			{name = tsg_at_gun_guard[2], blueprint = t_difficulty.g_soldier_type1, loc = mkr_at_gun_guard2, stopped = false, runto = mkr_after_retreat2, runto_alt = mkr_at_after_retreat2},
			--{name = tsg_at_gun_guard[3], blueprint = t_difficulty.g_soldier_type3, loc = mkr_at_gun_guard3, stopped = false, runto = mkr_after_retreat3, runto_alt = mkr_at_after_retreat3},
			{name = tsg_at_gun_vehicle[1], blueprint = SBP.ELITE.ARMOURCAR_221, loc = mkr_at_gun_guard3, stopped = false, runto = mkr_after_retreat3, runto_alt = mkr_at_after_retreat3},
			--{name = sg_at_gun1, blueprint = SBP.AXIS.PAK_38, loc = mkr_at_gun1},
			--{name = sg_at_gun2, blueprint = SBP.AXIS.PAK_38, loc = mkr_at_gun2},
		},
		
		
		pickups ={
			{name = eg_checkpoint_mortar, blueprint = EBP.PICKUP.AXIS.MORTAR, loc = mkr_checkpoint_mortar, hintpoint_ID = false, hintpoint_text = 1339144 },
			
		},
	}

	g_at_gun_init_count = 0
	
	
	g_at_guard1_stop = false
	g_at_guard2_stop = false
	g_at_guard3_stop = false
	
	--g_aa_stopped = 0
	g_at_stopped = 0
	
	
		
	
	
end


function AT_Gun_Preset()

	-- spawn squads
	
	for k, v in pairs(t_at_gun.spawn) do
	
		local at_squad = v
	
		Util_CreateSquads(player2, at_squad.name, at_squad.blueprint, at_squad.loc, nil, 1, 4)
		SGroup_AddGroup(sg_at_gun_force, at_squad.name)
	
	end
	Modify_WeaponAccuracy(tsg_at_gun_vehicle[1], "hardpoint_01", 0.5)
	Modify_WeaponDamage(tsg_at_gun_vehicle[1], "hardpoint_01", 0.5)
	Modify_Vulnerability(tsg_at_gun_vehicle[1], 2)
	
	g_at_gun_init_count = SGroup_TotalMembersCount(sg_at_gun_force)
	
	
		
	for k, v in pairs(t_at_gun.pickups) do -- spawning goodies for the player
		
		Util_CreateEntities(nil, v.name, v.blueprint, v.loc, 1)
	end
	
	
	-- start enemy behavior
	Rule_AddInterval(AT_Gun_Retreat, 2)
	Rule_AddInterval(AT_Gun_221_Control, 2)
	
	-- do other cool things

end


function AT_Gun_Retreat()

	if SGroup_IsEmpty(sg_at_gun_force) == true or b_Capture_Points_OBJComplete == true then
		
		Rule_RemoveMe()
		
	else
		
		-- if their flag is captured, or their  is less than 60% of their start then some will retreat
		if EGroup_IsCapturedByPlayer(eg_flag5, player2, false) == false or (SGroup_TotalMembersCount(sg_at_gun_force) < (0.50 * g_at_gun_init_count))	then
		
			if f_middle_squad_first_retreat == false then
			
			-- retreat the whole gang!
				if EGroup_IsEmpty(eg_factory_a) == false then 
				
					Cmd_Retreat(sg_at_gun_force, mkr_fallback10)
				
					Rule_AddInterval(AT_Gun_Retreat_Control_1, 1)
				
				elseif EGroup_IsEmpty(eg_factory_a) and EGroup_IsCapturedByPlayer(eg_flag4, player2, false) == true then
				
					Cmd_Retreat(sg_at_gun_force, mkr_at_retreat_point) --mkr_aa_retreat_point -- mkr_fallback_9 -- mkr_counterattack_spawn1
				
					Rule_AddInterval(AT_Gun_Retreat_Control_2, 1)
				
				elseif EGroup_IsEmpty(eg_factory_a) and EGroup_IsCapturedByPlayer(eg_flag4, player2, false) == false then
				
					Cmd_Retreat(sg_at_gun_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1) --mkr_aa_retreat_point -- mkr_fallback_9
					
					--Rule_AddInterval(AT_Gun_Retreat_Control_3, 1)
					
				end
				
				sg_middle_retreat_squad = SGroup_AddGroup(sg_middle_retreat_squad, sg_at_gun_force)
				
				f_middle_squad_first_retreat = true
				
				Rule_RemoveMe()
				
			elseif f_middle_squad_first_retreat == true then
				
				if EGroup_IsEmpty(eg_factory_a) == false then
				
					Cmd_Retreat(sg_at_gun_force, mkr_carpiquet_offmap_retreat, mkr_carpiquet_offmap_retreat)
					
				elseif EGroup_IsEmpty(eg_factory_a) == true then
				
					Cmd_Retreat(sg_at_gun_force, mkr_counterattack_spawn1, mkr_counterattack_spawn1)
				
				end
				
				Rule_RemoveMe()
				
			end
			
		end
		
	end

end


function AT_Gun_Retreat_Control_1()

	if SGroup_IsEmpty(sg_at_gun_force) == true or b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
	
	else
	
		
		
		
		--if Prox_AreSquadsNearMarker(sg_at_gun_force, mkr_fallback10, true) then
		
			print("near marker")
			
			
			for k,v in pairs (t_at_gun.spawn) do
			
				if SGroup_IsEmpty(v.name) == false then
				
					if SGroup_IsRetreating(v.name, true) == false and v.stopped == false then
					
						v.stopped = true
						
						g_at_stopped = g_at_stopped + 1
				
						Cmd_Move(v.name, v.runto, nil, nil, nil, nil, nil, 5)
				
					end
					
				end
			
			end
			
			if g_at_stopped >= 3 then
			
				Rule_RemoveMe()
			
			end
			
		--end
		
	end


end

function AT_Gun_Retreat_Control_2()

	if SGroup_IsEmpty(sg_at_gun_force) == true or b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
	
	else
	
		--if Prox_AreSquadsNearMarker(sg_at_gun_force, mkr_fallback10, true) then
		
			print("near marker")
			
			
			for k,v in pairs (t_at_gun.spawn) do
			
				if SGroup_IsEmpty(v.name) == false then
				
					if SGroup_IsRetreating(v.name, true) == false and v.stopped == false then
					
						v.stopped = true
						
						g_at_stopped = g_at_stopped + 1
				
						Cmd_Move(v.name, v.runto_alt, nil, nil, nil, nil, nil, 5)
				
					end
					
				end
			
			end
			
			if g_at_stopped >= 3 then
			
				Rule_RemoveMe()
			
			end
			
		--end
		
	end

end

function AT_Gun_221_Control()

	if SGroup_IsEmpty(tsg_at_gun_vehicle[1]) == true or b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
		
	else 
	
		if SGroup_IsEmpty(sg_at_gun_force) == false then
		
			if SGroup_IsUnderAttack(sg_at_gun_force, false, 2) then
			
				if SGroup_IsEmpty(tsg_at_gun_vehicle[1]) == false then
					
					local sg_221_target = SGroup_CreateIfNotFound("sg_221_target")
					
					SGroup_GetLastAttacker(sg_at_gun_force, sg_221_target) 
					
					if SGroup_IsEmpty(sg_221_target) == false then 
						
						Cmd_Move(tsg_at_gun_vehicle[1], mkr_mortar_guard2)
						
					end

					Rule_RemoveMe()
					
				end
			
			end
			
		end
	
	end



end

--[[
function AT_Gun_Retreat_Control_3()

	if SGroup_IsEmpty(sg_at_gun_force) == true then
	
		Rule_RemoveMe()
	
	else
	
		if Prox_AreSquadsNearMarker(sg_at_gun_force, mkr_counterattack_spawn1, true) and SGroup_IsRetreating(sg_at_gun_force, true) == false then
		
			Cmd_Move(sg_at_gun_force, mkr_counterattack_spawn1, nil, mkr_counterattack_spawn1, nil, nil, nil, 30)
			
			Rule_RemoveMe()
			
		end
		
	end


end]]

---------------------------------------
-- Ambient Artillery
---------------------------------------

function Ambient_Artillery_Init()
	-- table of ambient barrage markers
	tmkr_ambient_barrage = {mkr_ambient_barrage1, mkr_ambient_barrage2, mkr_ambient_barrage3, mkr_ambient_barrage4}
							

	tmkr_ambient_barrage_b = {mkr_ambient_barrage1b, mkr_ambient_barrage2b, mkr_ambient_barrage3b}
							
							
	g_artillery_marker_number = table.getn(tmkr_ambient_barrage) -- number of markers
	g_artillery_marker_number_b = table.getn(tmkr_ambient_barrage_b)
	--AMBIENT -- NOT USED ANYMORE BECAUSE EQUIVALENT IS IN EVENTS FILE
	t_artillery_warning = {
		-- equivalent in events file
		{ACTOR.CXP1.Hazard, 1330860}, -- Turn the fuck back 'round INCOMING!
	
	}
	
end


function Ambient_Artillery_Kickoff()

	--Rule_AddInterval(Ambient_Artillery_Manager, 5)


	Rule_AddOneShot(Ambient_Artillery_Randomizer, 5)
	Rule_AddInterval(Ambient_Artillery_Quick_Attack, 7)
end



function Ambient_Artillery_Randomizer()

	local random_time = World_GetRand(5, 10) -- random time of 2-10 seconds

	Rule_AddOneShot(Ambient_Artillery_Manager, random_time)

end


function Ambient_Artillery_Manager()

	if b_Capture_Points_OBJComplete == true then -- or g_stratpoint_countdown <= 0
		
		Rule_RemoveMe()
		
	elseif b_Capture_Points_OBJComplete == false then
		
		local rand_marker = nil
		local rand_pos = nil
		
		if t_commando.action.fg_commandos_all_objectives_ok == false then
			
			-- when commando raid is going on use these values
			rand_marker = World_GetRand(1, g_artillery_marker_number) -- random marker selected
			rand_pos = Util_GetRandomPosition(tmkr_ambient_barrage[rand_marker]) -- random position within the radius
			
		elseif t_commando.action.fg_commandos_all_objectives_ok == true then
			
			-- when capture points is going on use these values
			rand_marker = World_GetRand(1, g_artillery_marker_number_b) -- random marker selected
			rand_pos = Util_GetRandomPosition(tmkr_ambient_barrage_b[rand_marker]) -- random position within the radius
			
		end
		
		Cmd_Ability(player1, ABILITY.SP.SINGLE_HOWITZER_ALTSOUND , rand_pos, nil, true)
		
		Rule_AddOneShot(Ambient_Artillery_Randomizer, 1)
		
	end
	


end


function Ambient_Artillery_Quick_Attack()

	
	if b_Capture_Points_OBJComplete == true or t_commando.action.fg_commandos_all_objectives_ok == true then -- when commandos stuff finished?
	
		Rule_RemoveMe()
		
	else
	
		local target_group = SGroup_CreateIfNotFound("target_group")
		
		local marker_area = nil
		
			
		if t_commando.action.fg_commandos_all_objectives_ok == false then
			
			-- when commando raid is going on use these values
			marker_area = tmkr_ambient_barrage
			
		elseif t_commando.action.fg_commandos_all_objectives_ok == true then
			
			-- when capture points is going on use these values
			marker_area = tmkr_ambient_barrage_b
			
		end
		
		for f = 1, table.getn(marker_area) do
		
			Player_GetAllSquadsNearMarker(player1, target_group, marker_area[f])
			
			
			
			if SGroup_IsEmpty(target_group) == false then
			
				local target_offset = World_GetRand(0, 6)
				local target_offset_distance = World_GetRand(5, 15)
				local target_offset_pos = SGroup_GetOffsetPosition(target_group, target_offset, target_offset_distance)
			
				Cmd_Ability(player1, ABILITY.SP.SINGLE_HOWITZER_ALTSOUND , target_offset_pos, nil, true) --ABILITY.SP.SINGLE_HOWITZER_ALTSOUND --ABILITY.SP.SP_ARTILLERY_M01_SINGLE
			
			end
				
			
			
			
		end
		
	end

end

--------------------------------------

--------------------------------------------------------
-- FF Artillery mechanic
--------------------------
function Carpiquet_Airport_FF_Artillery_Trigger()

	for k,v in pairs(t_carp.artillery) do 

		local sgroup1 = SGroup_CreateIfNotFound("sgroup1")
		local pos1 = false
		
		if Prox_ArePlayersNearMarker(player1, v.marker1, false) then

			Player_GetAllSquadsNearMarker(player1, sgroup1, v.marker1)

			if SGroup_IsEmpty(sgroup1) == false then
				
				--if Squad_GetActiveCommand(SGroup_GetSpawnedSquadAt(sgroup1, 1 ) ) == SQUADSTATEID_Idle then
				if SGroup_IsIdle(sgroup1, false) then
					-- randomize here
					local offset_random = World_GetRand(0, 7)
					local offset_random_distance = World_GetRand(0, 10)
					
					pos1 = SGroup_GetOffsetPosition(sgroup1, offset_random, offset_random_distance )
				elseif SGroup_IsDoingAttack(sgroup1, false, 2) or SGroup_IsUnderAttack(sgroup1, false, 2) then
				--elseif Squad_GetActiveCommand(SGroup_GetSpawnedSquadAt(sgroup1, 1 ) ) == SQUADSTATEID_Combat then
					
					
					pos1 = SGroup_GetPosition(sgroup1)
				elseif SGroup_IsMoving(sgroup1, false) then	
				--elseif Squad_GetActiveCommand(SGroup_GetSpawnedSquadAt(sgroup1, 1 ) ) == SQUADSTATEID_Move then
					
					pos1 = SGroup_GetOffsetPosition(sgroup1, OFFSET_FRONT, 10 )
					
				else
					
					pos1 = SGroup_GetPosition(sgroup1)
					
				end
				
				if pos1 ~= false then
					
					Cmd_Ability(player1, ABILITY.SP.SINGLE_HOWITZER_ALTSOUND, pos1, nil, true)
					
				end
				
				
				-- say dialogue here about getting the hell out of there -- use boolean to make it say once
				if v.dialogueflag1 == false then
					
					--Util_AutoIntel(t_artillery_warning)
					
					Util_StartIntel(EVENTS.FF_ARTILLERY_WARNING)
					
					v.dialogueflag1 = true
					
				end
			
			end
			
			if SGroup_IsEmpty(sgroup1) == false then
			
				Cmd_Retreat(sgroup1, v.retreatlocation1)
				
				local vehicle_sgroup = SGroup_CreateIfNotFound("vehicle_sgroup")
				
				Player_GetAllSquadsNearMarker(player1, vehicle_sgroup, v.marker1)
				
				if SGroup_IsEmpty(vehicle_sgroup) == false then
				
					SGroup_Filter(vehicle_sgroup, {SBP.CW.BREN_CARRIER, SBP.CW.CROMWELL, SBP.CW.STUART, SBP.CW.TETRARCH, SBP.CW.COMMANDOS_JEEP, SBP.CW.INFANTRY_HQ, SBP.CW.HQ}, FILTER_KEEP)
					
					SGroup_SetSelectable(vehicle_sgroup, false)	
					
					if SGroup_ContainsSGroup(sg_vehicle_retreat_group, vehicle_sgroup, false) == false then
						
						SGroup_AddGroup(sg_vehicle_retreat_group, vehicle_sgroup)
						
						SGroup_RemoveGroup(sgroup1, vehicle_sgroup)
						
					end
					
					Cmd_Move(vehicle_sgroup, v.retreatlocation1)
					
					SGroup_Clear(sgroup1)
				
				end
				
			end
			
		end
	end
	
end


function Carpiquet_Airport_FF_Artillery_Vehicle_Check() -- thank you Neil for your help with this!

	if SGroup_IsEmpty(sg_vehicle_retreat_group) == false then
	
		local _CheckSquad = function (gid, idx, sid)
			
			-- creates local sgroup
			local check_temp = SGroup_CreateIfNotFound("check_temp")
			
			-- makes an sgroup out of the squad entered
			SGroup_Single(check_temp, sid)
			
			local squad_pos = Squad_GetPosition(sid)
			SGroup_SetSelectable(check_temp, true)
			for k,v in pairs(t_carp.artillery) do 
			
			-- use X axis detection here?
				
				--print(squad_pos.y)
				--local v = t_carp.artillery
				
				if Prox_AreSquadsNearMarker(check_temp, v.marker1, false) == false and squad_pos.y > 10 then
				
					-- add back selectable
					--SGroup_SetSelectable(check_temp, true)
					
					-- remove from sg_vehicle_retreat_group
					if SGroup_ContainsSGroup(sg_vehicle_retreat_group, check_temp, false) then
						SGroup_RemoveGroup(sg_vehicle_retreat_group, check_temp)
					end
					
				end
				
			end
			
		end
		-- applies above to members of the vehicle retreat group
		SGroup_ForEach(sg_vehicle_retreat_group, _CheckSquad)
		
	end


end






function Carpiquet_Airport_FF_Artillery_Retreat()

	for k,v in pairs(t_carp.artillery) do 
	
		local this = v
		
		if SGroup_IsEmpty(this.sgroup1) == false then
			
			Cmd_Retreat(this.sgroup1, this.retreatlocation1)
			
		end
		
	end


end


function Carpiquet_Airport_FF_Artillery_Dialogue_Reset()

-- when the player's group makes it to the retreat rally point
-- reset dialogue flag here, and clear the sgroup1
	
	if g_ff_arty_dialogue_reset >= g_ff_arty_dialogue_limit then
	
		for k,v in pairs(t_carp.artillery) do 
			
			local this = v
			
			
			
				if this.dialogueflag1 == true then -- if the dialogue has been spoken
					
					-- these were in place before ff dialogue reset changes and the timer was added
					--[[
					if SGroup_IsEmpty(this.sgroup1) or Prox_AreSquadsNearMarker(this.sgroup1, this.retreatlocation1, false) then
						
						this.dialogueflag1 = false -- set dialogue to not spoken yet
						--print("dialogue flag now false")
						print("clearing")
						g_retreat_in_progress = false
						
						SGroup_Clear(this.sgroup1) -- clear the sgroup... 
						
					end]]
					
					this.dialogueflag1 = false -- set dialogue to not spoken yet
					
					g_retreat_in_progress = false
					
					g_ff_arty_dialogue_reset = 0
					
				end
				
			
			
		end
	
	elseif g_ff_arty_dialogue_reset < g_ff_arty_dialogue_limit then
		
		print("reset")
	
		g_ff_arty_dialogue_reset = g_ff_arty_dialogue_reset + 1
	
	end
	


end


--------------------------------------------------------------------------------

-- END MISSION

--------------------------------------------------------------------------------



function Rule_EndMission()

            

            if Event_IsAnyRunning() == false then

                        

                        Rule_RemoveMe()

                        

                        Rule_AddDelayedInterval(Rule_EndMissionB, 1, 1)

                        

            end

            

end

function Rule_EndMissionB()

            if Event_IsAnyRunning() == false then

                        Game_EndSP(true)

            end

end


-------------------------
-- Alarm Klaxon Function
-------------------------
function Alarm_Sound(sound_emitter)
	
	if EGroup_Count (sound_emitter) >=1 then
		
		local eid = EGroup_GetSpawnedEntityAt (sound_emitter, 1)
		Sound_Play3D (g_alarm_soundpath, eid) --Current sound file is not 3d? NRiley (03/27/07)
		
	end
end




-------------------------
--Control Tower Fuel Sheds Chain Reaction
------------------------
function Shed_Chain_Reaction_Init()

	eg_control_tower_sheds_blowup = EGroup_CreateIfNotFound("eg_control_tower_sheds_blowup")
	
	tmkr_sheds_blast = Marker_GetTable("mkr_shed_blast_radius%d")
	tsg_sheds_collateral = SGroup_CreateTable("sg_sheds_collateral%d", 3)
	
	eg_control_tower_sheds_blowup1 = EGroup_CreateIfNotFound("eg_control_tower_sheds_blowup1")
	eg_control_tower_sheds_blowup2 = EGroup_CreateIfNotFound("eg_control_tower_sheds_blowup2")
	
	
	t_sheds_explodegroup = {
	
		{egroup = eg_control_tower_sheds_blowup1, count = EGroup_Count(eg_control_tower_sheds_blowup1), collateral = tsg_sheds_collateral[1], blast = tmkr_sheds_blast[1], destroyed = false},
		{egroup = eg_control_tower_sheds_blowup2, count = EGroup_Count(eg_control_tower_sheds_blowup2), collateral = tsg_sheds_collateral[2], blast = tmkr_sheds_blast[2], destroyed = false},
		
	}
	
	g_sheds_destroyed_count = 0
	g_sheds_group_number = table.getn(t_sheds_explodegroup)
	
	f_sheds_chain_reaction = false
	
	

end



function Shed_Chain_Reaction()

	if EGroup_IsEmpty(eg_control_tower_sheds_blowup) == true then
	
		Rule_RemoveMe()
		
	else
	
	
		for k, v in pairs (t_sheds_explodegroup) do
		
			
			if f_sheds_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
				
				if EGroup_Count(v.egroup) < v.count then
					
					
					EGroup_SetDemolitions(player1, v.egroup, 5)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					
					--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
					--Commando_Sheds_Collateral(v.collateral)
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					
					if SGroup_IsEmpty(v.collateral) == false then
						
						Commando_Sheds_Collateral(v.collateral)
						
					end
					
					f_sheds_chain_reaction = true
					
					g_sheds_destroyed_count = g_sheds_destroyed_count + 1
					
					break
				
				end
				
			elseif f_sheds_chain_reaction == true then -- the rest goes boom
				
				if EGroup_IsEmpty(v.egroup) == false then
				
					EGroup_SetDemolitions(player1, v.egroup, 5)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
					--Commando_Sheds_Collateral(v.collateral)
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					
					if SGroup_IsEmpty(v.collateral) == false then
						
						Commando_Sheds_Collateral(v.collateral)
						
					end
					
					g_sheds_destroyed_count = g_sheds_destroyed_count + 1
					
					break
					
				end
				
			end	
		
		end
		
		if g_sheds_destroyed_count == g_sheds_group_number then
		
			EGroup_Kill(eg_control_tower_sheds_blowup)
				
			Rule_RemoveMe()
		
		end
	
	end
	
end


-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Sheds_Collateral(collateral)

	SGroup_Kill(collateral)

end



-------------------------
--Forward Chain Reaction
------------------------
function Forward_Chain_Reaction_Init()

	eg_forward_fuel_blowup = EGroup_CreateIfNotFound("eg_forward_fuel_blowup")

	tmkr_forward_blast = {mkr_forward_fuel_blast_radius}
	tsg_forward_collateral = SGroup_CreateTable("sg_forward_collateral%d", 3)
	
	eg_forward_fuel_blowup1 = EGroup_CreateIfNotFound("eg_forward_fuel_blowup1")
	eg_forward_fuel_blowup2 = EGroup_CreateIfNotFound("eg_forward_fuel_blowup2")
	eg_forward_fuel_blowup3 = EGroup_CreateIfNotFound("eg_forward_fuel_blowup3")
	
	t_forward_explodegroup = {
	
		{egroup = eg_forward_fuel_blowup1, count = EGroup_Count(eg_forward_fuel_blowup1), collateral = tsg_forward_collateral[1], blast = tmkr_forward_blast[1], destroyed = false},
		{egroup = eg_forward_fuel_blowup2, count = EGroup_Count(eg_forward_fuel_blowup2), collateral = tsg_forward_collateral[2], blast = tmkr_forward_blast[1], destroyed = false},
		{egroup = eg_forward_fuel_blowup3, count = EGroup_Count(eg_forward_fuel_blowup3), collateral = tsg_forward_collateral[3], blast = tmkr_forward_blast[1], destroyed = false},
		
	}
	
	g_forward_destroyed_count = 0
	g_forward_group_number = table.getn(t_forward_explodegroup)
	
	f_forward_chain_reaction = false

end



function Forward_Chain_Reaction()

	if EGroup_IsEmpty(eg_forward_fuel_blowup) == true then
	
		Rule_RemoveMe()
		
	else
	
	
		for k, v in pairs (t_forward_explodegroup) do
		
			
			if f_forward_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
				
				if EGroup_Count(v.egroup) < v.count then
					
					
					EGroup_SetDemolitions(player1, v.egroup, 5)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					
					--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
					--Commando_Forward_Collateral(v.collateral)
					--Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					--Commando_Forward_Collateral(v.collateral)
					
					f_forward_chain_reaction = true
					
					g_forward_destroyed_count = g_forward_destroyed_count + 1
					
					break
				
				end
				
			elseif f_forward_chain_reaction == true then -- the rest goes boom
				
				if EGroup_IsEmpty(v.egroup) == false then
				
					EGroup_SetDemolitions(player1, v.egroup, 5)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
					--Commando_Forward_Collateral(v.collateral)
					--Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					--Commando_Forward_Collateral(v.collateral)
					
					g_forward_destroyed_count = g_forward_destroyed_count + 1
					
					break
					
				end
				
			end	
		
		end
		
		if g_forward_destroyed_count == g_forward_group_number then
		
			Player_GetAllSquadsNearMarker(player1, tsg_forward_collateral[1], mkr_forward_fuel_blast_radius)
			
			if SGroup_IsEmpty(tsg_forward_collateral[1]) == false then
			Commando_Forward_Collateral(tsg_forward_collateral[1])
			end
			
			Player_GetAllSquadsNearMarker(player2, tsg_forward_collateral[1], mkr_forward_fuel_blast_radius)
			
			if SGroup_IsEmpty(tsg_forward_collateral[1]) == false then
				Commando_Forward_Collateral(tsg_forward_collateral[1])
			end
			
			EGroup_Kill(eg_forward_fuel_blowup)
				
			Rule_RemoveMe()
		
		end
	
	end
	
end


-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Forward_Collateral(collateral)

	SGroup_Kill(collateral)

end


-------------------------
--Hangar2 Chain Reaction
------------------------
function Hangar2_Chain_Reaction_Init()

	eg_hangar2_blowup = EGroup_CreateIfNotFound("eg_hangar2_blowup")

	tmkr_hangar2_blast = {mkr_hangar2_blast_radius}
	tsg_hangar2_collateral = SGroup_CreateTable("sg_hangar2_collateral%d", 3)
	
	eg_hangar2_blowup1 = EGroup_CreateIfNotFound("eg_hangar2_blowup1")

	
	t_hangar2_explodegroup = {
	
		{egroup = eg_hangar2_blowup1, count = EGroup_Count(eg_hangar2_blowup1), collateral = tsg_hangar2_collateral[1], blast = tmkr_hangar2_blast[1], destroyed = false},
		
	}
	
	g_hangar2_destroyed_count = 0
	g_hangar2_group_number = table.getn(t_hangar2_explodegroup)
	
	f_hangar2_chain_reaction = false

end



function Hangar2_Chain_Reaction()

	if EGroup_IsEmpty(eg_hangar2_blowup) == true then
	
		Rule_RemoveMe()
		
	else
	
	
		for k, v in pairs (t_hangar2_explodegroup) do
		
			
			if f_hangar2_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
				
				if EGroup_Count(v.egroup) < v.count then
					
					
					EGroup_SetDemolitions(player1, v.egroup, 1)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					
					--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
					--Commando_Hangar2_Collateral(v.collateral)
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					
					if SGroup_IsEmpty(v.collateral) == false then
						Commando_Hangar2_Collateral(v.collateral)
					end
					
					f_hangar2_chain_reaction = true
					
					g_hangar2_destroyed_count = g_hangar2_destroyed_count + 1
					
					break
				
				end
				
			elseif f_hangar2_chain_reaction == true then -- the rest goes boom
				
				if EGroup_IsEmpty(v.egroup) == false then
				
					EGroup_SetDemolitions(player1, v.egroup, 1)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
					--Commando_Hangar2_Collateral(v.collateral)
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					
					if SGroup_IsEmpty(v.collateral) == false then
						Commando_Hangar2_Collateral(v.collateral)
					end
					
					g_hangar2_destroyed_count = g_hangar2_destroyed_count + 1
					
					break
					
				end
				
			end	
		
		end
		
		if g_hangar2_destroyed_count == g_hangar2_group_number then
		
			local neutral_egroup = EGroup_CreateIfNotFound("neutral_egroup")
			
			World_GetNeutralEntitiesNearMarker(neutral_egroup, mkr_hangar2_blast_radius)
		
			EGroup_SetDemolitions(player1, neutral_egroup, 1)
			Cmd_DetonateDemolitions(player1, neutral_egroup)
				
			if EGroup_IsEmpty(neutral_egroup) == false then
				
				EGroup_Kill(neutral_egroup)
			
			end
			
			EGroup_Kill(eg_hangar2_blowup)
				
			Rule_RemoveMe()
		
		end
	
	end
	
end


-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Hangar2_Collateral(collateral)

	SGroup_Kill(collateral)

end



-------------------------
--Hangar3 Chain Reaction
------------------------
function Hangar3_Chain_Reaction_Init()

	eg_hangar3_blowup = EGroup_CreateIfNotFound("eg_hangar3_blowup")

	tmkr_hangar3_blast = {mkr_hangar3_blast_radius}
	tsg_hangar3_collateral = SGroup_CreateTable("sg_hangar3_collateral%d", 3)
	
	eg_hangar3_blowup1 = EGroup_CreateIfNotFound("eg_hangar3_blowup1")

	
	t_hangar3_explodegroup = {
	
		{egroup = eg_hangar3_blowup1, count = EGroup_Count(eg_hangar3_blowup1), collateral = tsg_hangar3_collateral[1], blast = tmkr_hangar3_blast[1], destroyed = false},
		
	}
	
	g_hangar3_destroyed_count = 0
	g_hangar3_group_number = table.getn(t_hangar3_explodegroup)
	
	f_hangar3_chain_reaction = false

end



function Hangar3_Chain_Reaction()

	if EGroup_IsEmpty(eg_hangar3_blowup) == true then
	
		Rule_RemoveMe()
		
	else
	
	
		for k, v in pairs (t_hangar3_explodegroup) do
		
			
			if f_hangar3_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
				
				if EGroup_Count(v.egroup) < v.count then
					
					
					EGroup_SetDemolitions(player1, v.egroup, 1)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					
					--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
					--Commando_Hangar3_Collateral(v.collateral)
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					
					--if SGroup_IsEmpty(v.collateral) == false then
						Commando_Hangar3_Collateral(v.collateral)
					--end
					
					f_hangar3_chain_reaction = true
					
					g_hangar3_destroyed_count = g_hangar3_destroyed_count + 1
					
					break
				
				end
				
			elseif f_hangar3_chain_reaction == true then -- the rest goes boom
				
				if EGroup_IsEmpty(v.egroup) == false then
				
					EGroup_SetDemolitions(player1, v.egroup, 1)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					--Player_GetAllSquadsNearMarker(player1, v.collateral, v.blast)
					--Commando_Hangar3_Collateral(v.collateral)
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					
					--if SGroup_IsEmpty(v.collateral) == false then
						Commando_Hangar3_Collateral(v.collateral)
					--end
					
					g_hangar3_destroyed_count = g_hangar3_destroyed_count + 1
					
					break
					
				end
				
			end	
		
		end
		
		if g_hangar3_destroyed_count == g_hangar3_group_number then
		
			local neutral_egroup = EGroup_CreateIfNotFound("neutral_egroup")
			
			World_GetNeutralEntitiesNearMarker(neutral_egroup, mkr_hangar3_blast_radius)
		
			EGroup_SetDemolitions(player1, neutral_egroup, 1)
			Cmd_DetonateDemolitions(player1, neutral_egroup)
				
			if EGroup_IsEmpty(neutral_egroup) == false then
				
				EGroup_Kill(neutral_egroup)
			
			end
			
			
			EGroup_Kill(eg_hangar3_blowup)
				
			Rule_RemoveMe()
		
		end
	
	end
	
end


-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Hangar3_Collateral(collateral)

	SGroup_Kill(collateral)

end





-------------------------------

--AXIS TAUNTS
-------------------------------

function Axis_Taunt_Speech_Control() -- random Axis speech called when attacking front lines

	if b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
		
	else
	
		if Rule_Exists(Axis_Taunt_Speech) == false then
			
			
			if SGroup_IsEmpty(sg_all_units) == false and SGroup_IsUnderAttackByPlayer(sg_all_units, player2, 5) then
			
				Rule_AddDelayedInterval(Axis_Taunt_Speech, 5, 1)
				
				Rule_RemoveMe()
			
			end
			
		end
		
	end

end



function Axis_Taunt_Speech() -- NPC Speech_SetGlobalStealthRead

	if b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
		
	else
	
	
		if Rule_Exists(Axis_Taunt_Speech_Control) == false then
		
			local random_speech_table = World_GetRand(1, 2)

			if random_speech_table == 1 then
				
				Util_StartIntel(EVENTS.AXIS_TAUNTS1)
				
			elseif random_speech_table == 2 then
				
				Util_StartIntel(EVENTS.AXIS_TAUNTS2)
				
			end
			
			local random_time = World_GetRand(60, 120) -- 1 to 2 mins between taunts
			
			
			Rule_AddDelayedInterval(Axis_Taunt_Speech_Control, random_time, 1)
			Rule_RemoveMe()
			
		end
	end
	
end

-------------------
-- Capture Points Nag
-------------------

function Capture_Points_Nag_Control() -- random nag speech when capturing lines

	if b_Capture_Points_OBJComplete == true then

		Rule_RemoveMe()
	
	else
	
		if Rule_Exists(Capture_Points_Nag_Speech) == false then
		
			Rule_AddDelayedInterval(Capture_Points_Nag_Speech, 5, 1)
			
			Rule_RemoveMe()
			
		end
	
	end
	
	
end


function Capture_Points_Nag_Speech() -- NPC Speech_SetGlobalStealthRead

	if b_Capture_Points_OBJComplete == true then
	
		Rule_RemoveMe()
		
	else
	
	
		if Rule_Exists(Capture_Points_Nag_Control) == false then
			
			Util_StartIntel(EVENTS.CAPTURE_POINTS_NAG)
			
			local random_time = World_GetRand(120, 180) -- 2 to 3 mins between taunts
			
			Rule_AddDelayedInterval(Capture_Points_Nag_Control, random_time, 1)
			Rule_RemoveMe()
			
		end
	end
	
end


-------------------
-- Capture Points Movement
-------------------

function Capture_Points_Movement_Control() -- random allied speech called when attacking front lines

	if b_Capture_Points_OBJComplete == true then

		Rule_RemoveMe()
	
	else
	
		if Rule_Exists(Capture_Points_Movement_Speech) == false then
		
			if SGroup_IsEmpty(sg_all_units) == false and SGroup_IsDoingAttack(sg_all_units, false, 2) then
			
				Rule_AddDelayedInterval(Capture_Points_Movement_Speech, 5, 1)
				
				Rule_RemoveMe()
				
			end
			
		end
	
	end
	
	
end


function Capture_Points_Movement_Speech() 

	if b_Capture_Points_OBJComplete == true then
		
		Rule_RemoveMe()
		
	else
		
		if Rule_Exists(Capture_Points_Movement_Control) == false then
			
			Util_StartIntel(EVENTS.CAPTURE_POINTS_CANADIAN_MOVEMENT)
			
			local random_time = World_GetRand(60, 120) -- 1 to 2 mins between taunts
			
			Rule_AddDelayedInterval(Capture_Points_Movement_Control, random_time, 1)
			Rule_RemoveMe()
			
		end
	end
	
end

-----------------------------
--Capture Points Under Attack
-----------------------------


-------------------
-- Capture Points Movement
-------------------

function Capture_Points_Under_Attack_Control() -- random allied speech called when attacking front lines

	if b_Capture_Points_OBJComplete == true then

		Rule_RemoveMe()
	
	else
	
		if Rule_Exists(Capture_Points_Under_Attack_Speech) == false then
		
			if SGroup_IsEmpty(sg_all_units) == false and SGroup_IsUnderAttackByPlayer(sg_all_units, player2, 2) then
			
				Rule_AddDelayedInterval(Capture_Points_Under_Attack_Speech, 5, 1)
				
				Rule_RemoveMe()
				
			end
			
		end
	
	end
	
	
end


function Capture_Points_Under_Attack_Speech() 

	if b_Capture_Points_OBJComplete == true then
		
		Rule_RemoveMe()
		
	else
		
		if Rule_Exists(Capture_Points_Under_Attack_Control) == false then
			
			local test_sgroup = SGroup_CreateIfNotFound("test_group")
			local test_egroup = EGroup_CreateIfNotFound("test_egroup")
			--Player_GetAll(test_sgroup, test_egroup)
			
			SGroup_AddGroup(test_sgroup, sg_all_units)
			
			SGroup_Filter(test_sgroup, SBP.CW.COMMANDOS, FILTER_KEEP)
			
			if SGroup_IsEmpty(test_sgroup) == false then
			
			
				Util_StartIntel(EVENTS.MEDAL_OBJECTIVE_NPC_AMBIENT3)
				
				local random_time = World_GetRand(60, 120) -- 1 to 2 mins between taunts
				
				Rule_AddDelayedInterval(Capture_Points_Under_Attack_Control, random_time, 1)
				Rule_RemoveMe()
			
			end
			
			SGroup_Clear(test_sgroup)
			
			--Rule_AddInterval(Capture_Points_Under_Attack_Control, 1)
			
			--Rule_RemoveMe()
			
		end
	end
	
end

----------------------------------------------
--Commando Raid First Objective Battle Chatter
----------------------------------------------



function Garrison_Battle_Chatter_Control() -- random allied speech called when attacking first garrison

	if SGroup_IsEmpty(sg_ammo_dump_force) == true and EGroup_IsEmpty(eg_ammo_driver_spawn1) == true then

		Rule_RemoveMe()
	
	else
	
		if Rule_Exists(Garrison_Battle_Chatter_Speech) == false then
		
			if SGroup_IsEmpty(sg_all_units) == false and SGroup_IsDoingAttack(sg_all_units, false, 2) then
			
				if SGroup_IsUnderAttackByPlayer(sg_ammo_dump_force, player1, 2) then
				
					Rule_AddDelayedInterval(Garrison_Battle_Chatter_Speech, 5, 1)
					
					Rule_RemoveMe()
					
				end
				
			end
			
		end
	
	end
	
	
end


function Garrison_Battle_Chatter_Speech() 

	if SGroup_IsEmpty(sg_ammo_dump_force) == true and EGroup_IsEmpty(eg_ammo_driver_spawn1) == true then
		
		Rule_RemoveMe()
		
	else
		
		if Rule_Exists(Garrison_Battle_Chatter_Control) == false then
			
			Util_StartIntel(EVENTS.GARRISON_BATTLE_CHATTER1)
			
			local random_time = World_GetRand(60, 90) -- 1 to 1.5 mins between taunts
			
			Rule_AddDelayedInterval(Garrison_Battle_Chatter_Control, random_time, 1)
			Rule_RemoveMe()
			
		end
	end
	
end

function Carp_Flag_Tracker()

	if g_carp_flag1_captured == true and g_carp_fuel_captured == true then
	
		Rule_RemoveMe()
		
	else
	
	
		if EGroup_IsCapturedByPlayer(eg_carp_flag1, player1, false) and g_carp_flag1_captured == false then 
		
			g_carp_flag1_captured = true
			
		end
		
		if EGroup_IsCapturedByPlayer(eg_carpiquet_fuel, player1, false) and g_carp_fuel_captured == false then 

			g_carp_fuel_captured = true
		
		end
		
	end
	
end


function Final_Flag_Init()

	sg_fence_force = SGroup_CreateIfNotFound("sg_fence_force")
	sg_gate_force = SGroup_CreateIfNotFound("sg_gate_force")
	sg_field_force = SGroup_CreateIfNotFound("sg_field_force")
	
	t_flag_checklist_b = {
		sg_fence_force, sg_fence_force, sg_field_force, sg_gate_force, -- set up in order of flags
	}

	g_final_flag_counter = 0

end

function Final_Flag_Giveaway_Delay()

	Rule_AddInterval(Final_Flag_Giveaway, 1)

end


function Final_Flag_Giveaway()

	if g_number_of_points_captured >= 4 then
	
		Rule_RemoveMe()
	
	elseif g_number_of_points_captured == 3 then
	
		for i = 1, table.getn(t_flag_checklist) do
	
			if EGroup_IsCapturedByPlayer(t_flag_checklist[i][1], player1, false) == false then
			
			--[[
				if i == 1 then
					
					if SGroup_IsEmpty(t_flag_checklist_b[i]) == true and SGroup_IsEmpty(sg_flak88_gun) == false then
					
						EGroup_InstantCaptureStrategicPoint(t_flag_checklist[i][1], player1)
						
						g_number_of_points_captured = g_number_of_points_captured + 1
					
					end
				
				
				else
				]]
					if SGroup_IsEmpty(t_flag_checklist_b[i]) == true and g_final_flag_counter >= 60 then
					
						EGroup_InstantCaptureStrategicPoint(t_flag_checklist[i][1], player1)
						
						g_number_of_points_captured = g_number_of_points_captured + 1
					
					elseif SGroup_IsEmpty(t_flag_checklist_b[i]) == true and g_final_flag_counter < 60 then
					
						g_final_flag_counter = g_final_flag_counter + 1
					
					
					end
				
				--end
			
			end

		end

	end

end
