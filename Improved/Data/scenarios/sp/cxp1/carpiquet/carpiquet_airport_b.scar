-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Mission Name

-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")



-------------------------------------------------------------------------

-- [[ SETUP ]]

-------------------------------------------------------------------------

function OnGameSetup()
	-- string numbers should reference dat files
	-- "allies_commonwealth" "allies" "axis" "axis_panzer_elite"
	player1 = Setup_Player(1, 1309060, "allies_commonwealth", 1)
	player2 = Setup_Player(2, 1309061, "axis", 2)
	player3 = Setup_Player(3, 1309060, "allies_commonwealth", 1) -- NPCs
	player4 = Setup_Player(4, 1309051, "axis", 2) -- "counterattack" AI axis player
	--Setup_SetPlayerTeam(player3, 0)		
	-- AI slot (ensure that the AI is on the same team as the other Axis player by setting the second parameter
--~  	player3 = Setup_Player(3, "$000000", "Axis Infantry Company", 2)
end

function OnGameRestore()
	player1 = World_GetPlayerAt(1)
	player2 = World_GetPlayerAt(2)
	player3 = World_GetPlayerAt(3)
	player4 = World_GetPlayerAt(4)
	-- function takes care of restoring all global mission parameters after a save/load
	Game_DefaultGameRestore()
end




-------------------------------------------------------------------------

-- [[ ONINIT ]]

-------------------------------------------------------------------------

function OnInit()
	g_MissionSpeechPath="Caen\\sp2\\Mission4"
	
	g_AIControl_Enable = false
	g_AIControl_Pause = true
	
	-- a constant that stores the mission number for use with
	-- setting the global speech paths, tech tree setup, and 
	-- the player's starting resources
	MISSION_NUMBER = 0104
	
	--[[ PRESET GAME STATE ]]
	Setup_MissionPreset(MISSION_NUMBER)
	
	--[[ PRESET DEBUG CONDITIONS ]]
	--Carpiquet_B_Debug()
	
	--[[ REGISTER OBJECTIVES ]]
	Carpiquet_B_ObjectiveRegister()
	
	--[[ MOD INITIAL STATS ]]
	Carpiquet_B_ModifyStats()
	
	--[[ SET RESTRICTIONS ]]
	Carpiquet_B_Restrictions()
	
	--[[ SET AI ]]
	Carpiquet_B_CpuInit()
	
	--[[ SET DIFFICULTY ]]
	Carpiquet_B_Difficulty()
	
	--[[ MISSION PRESETS ]]
	Carpiquet_B_MissionPreset()
	
	--[[ DEBUG KEYS]]
	Carpiquet_B_Debug()
	
	--[[ GAME START CHECK ]]
	Rule_Add(Carpiquet_B_MissionStart)

end

Scar_AddInit(OnInit)

function Carpiquet_B_Debug()
	--[[
	-- looks for the command line option [-debug]
	if Misc_IsCommandLineOptionSet("debug") then
		
		g_debug = true
		
		-- reveal FOW
		
	end
	
	if Misc_IsCommandLineOptionSet("nis") then]]
	
		
		-- set up bindings for NISes
--~ 		Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS01)')]])")
--~ 		Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS02)')]])")
--~ 		Scar_DebugConsoleExecute("bind([[ALT+3]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS03)')]])")
		
	--end
	
	
	--Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS01)')]])")
	Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS02)')]])")
	
	
end

function Carpiquet_B_ObjectiveRegister()

	--[[ *** MUST INITIALIZE THE OBJ TABLE BEFORE REGISTERING *** ]]
	Initialize_OBJ_Build_Defenses()
	Initialize_OBJ_Secure_Airfield()
	Initialize_OBJ_Neutralize_88s()
	Initialize_OBJ_Shoot_Down_Planes()
	Initialize_OBJ_Medal_Objective()
end

function Carpiquet_B_ModifyStats()
	
	
end

function Carpiquet_B_Restrictions()

	--[[ UN/RESTRICT UPGRADES ]]
	
	--RESOURCES 
	Player_SetResource(player1, RT_Manpower, 1000)
	Player_SetResource(player1, RT_Munition, 300)
	Player_SetResource(player1, RT_Fuel, 150)
	
	--[[ UN/RESTRICT ABILITIES ]]
	-- brw, why is this set to player1?
	Player_SetUpgradeAvailability(player1, UPG.SP.HENSCHEL_ALL_UNLOCK, ITEM_UNLOCKED)
	Player_SetAbilityAvailability(player1, ABILITY.CW.HQ_REINFORCE, ITEM_DEFAULT) -- allows HQ to be rebuilt if destroyed?
	Cmd_InstantUpgrade(player1, UPG.SP.UNLOCK_CANADIAN, 1)
	
	-- UN/RESTRICT POP CAP
	Player_SetPopCapOverride(player1, 90)

	if mod_actionpoints ~= nil then
		--mod_actionpoints = Modify_PlayerResourceRate(player1, RT_Action, 1.0)
		Modifier_Remove(mod_actionpoints)
		UI_EnableResourceTypeKicker(RT_Action, true)            
	end
	
	--[[ UN/RESTRICT UI ]]
	
	
	--[[ UN/RESTRICT SBPS ]]
	
end



function Carpiquet_B_CpuInit()

	--[[ left as an example
	
	-- set up Player3 AI  
	Util_AI_Setup(player3, {Util_DifVar({10, 15, 20, 30}), 5}, player3, Game_GetSPDifficulty(), 7, Util_DifVar({1, 2, 3, 5}), 2, 3)
	
	-- Set up AI's resources
	Player_SetResource(player3, RT_Manpower, 1000)
	Player_SetResource(player3, RT_Munition, 100)
	Player_SetResource(player3, RT_Fuel, 100)
	
	-- tell AI to go after strongest threat instead of the weakest
	AI_DoString( player3, "s_personality.attack_prefer_threat = true" )
	AI_DoString( player3, "s_personality.defend_prefer_threat = true" )

	-- tell AI not to "defend" territories outside of the ring around its base
	AI_EnableComponent(player3, false, COMPONENT_ForwardDefending)
	
	-- disable use of comapny commander menu and abilities
	AI_DoString( player3, "s_commandtree_enabled = false" )
	AI_DoString( player3, "s_playerabilities_enabled = false" )
	
	AI_EnableComponent(player3, false, COMPONENT_Attacking)
	
	]]

end

function Carpiquet_B_Difficulty()
	
	-- get the difficulty
	g_difficulty = Game_GetSPDifficulty()  -- set a global difficulty variable
	print("************************************************************** DIFFICULTY: "..g_difficulty)

	Setup_Difficulty(player1, g_difficulty) -- pass the player and difficulty global variable into the Set Health function
	Setup_Difficulty(player2, g_difficulty) -- do it for each player that you have defined
	Setup_Difficulty(player3, g_difficulty)
	Setup_Difficulty(player4, g_difficulty)
	
	t_dif = {
		
		g_soldier_type1 = Util_DifVar({SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.GRENADIER, SBP.AXIS.GRENADIER, SBP.ELITE.PANZERGRENADIER}),
		g_soldier_type2 = Util_DifVar({SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.VOLKSGRENADIER}),
		g_soldier_type3 = Util_DifVar({SBP.AXIS.GRENADIER, SBP.ELITE.PANZERGRENADIER, SBP.ELITE.PANZERGRENADIER, SBP.ELITE.PANZERGRENADIER}),
		AT1 = Util_DifVar({SBP.ELITE.ARMOURCAR_222, SBP.ELITE.HALFTRACK_SNIPER, SBP.ELITE.MARDER}),
		AT2 = Util_DifVar({SBP.ELITE.ARMOURCAR_222, SBP.ELITE.HALFTRACK_SNIPER, SBP.AXIS.PANZER}),
		
	}
	

	--[[ left as an example 
	
	-- get the difficulty
	g_difficulty = Game_GetSPDifficulty()  -- set a global difficulty variable
	print("********* DIFFICULTY: "..g_difficulty)
	
	-- set health bonus for player 1
	Setup_Difficulty(player1, g_difficulty) -- pass the player and difficulty global variable into the Set Health function
	Setup_Difficulty(player2, g_difficulty) -- do it for each player that you have defined
	
	t_dif = {
		base_def_spawn 			= Util_DifVar( {2*60, 1.5*60, 1*60, 0.75*60} ),			-- amount of time required before spawning base defense soldiers
		base_def_squad_num		= Util_DifVar( {1, 1, 2, 3} ),							-- number of squads to spawn for the base defense
		sniper_vulnerability 	= Util_DifVar( {2.5, 2, 1.5, 1} ),						-- the vulnerability factor on the snipers
		sniper_number			= Util_DifVar( {1, 2, 2, 3} ),							-- number of snipers to spawn
		sniper_wpn_cooldown		= Util_DifVar( {2, 1.5, 1, 1} ),						-- weapon cooldown time for the snipers
		stronghold_attack_num	= Util_DifVar( {1, 1, 2, 2} ),							-- number of squads to spawn from the guard tower to spawn and attack the player on alert
		aa_def_sbps				= Util_DifVar( {SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.GRENADIER, SBP.AXIS.STORMTROOPER, SBP.AXIS.KNIGHTSCROSS} ), -- types of squads to defend the AA Guns
	}
	
	]]
	
end


-------------------------------------------------------------------------

-- MISSION Preset 

-------------------------------------------------------------------------

function Carpiquet_B_MissionPreset()
	
	-- loads lighting template
	Game_LoadAtmosphere("data:art/scenarios/presets/atmosphere/CXP1_Carpiquet_Dawn_00.aps", 0)
	
	-- focus camera on start position
	Camera_FocusOnPosition(EGroup_GetPosition(eg_flag3), true)

	-- to account for henschels in A
	eg_henschel_group = EGroup_CreateIfNotFound("eg_henschel_group")
	eg_stationary_planes = EGroup_CreateIfNotFound("eg_stationary_planes")
	-- to account for possible CW reinforcements that come with carpiquet's capture in A
	sg_carpiquet_reinforcements_group = SGroup_CreateIfNotFound("sg_carpiquet_reinforcements_group")
	
	if EGroup_IsEmpty(eg_stationary_planes) == false then
		--stationary_plane_mod1 = Modify_Vulnerability(eg_stationary_planes, 8)
	end

	sg_all_units = SGroup_CreateIfNotFound("sg_all_units")
	eg_all_buildings = EGroup_CreateIfNotFound("eg_all_buildings")
	eg_carp_a_gliders = EGroup_CreateIfNotFound("eg_carp_a_gliders")
	
	if EGroup_IsEmpty(eg_carp_a_gliders) == false then
		EGroup_DestroyAllEntities(eg_carp_a_gliders)
	end
	
	sg_preset_cw_hq = SGroup_CreateIfNotFound("sg_preset_cw_hq")
	sg_preset_infantry_hq = SGroup_CreateIfNotFound("sg_preset_infantry_hq")
	sg_preset_sappers = SGroup_CreateIfNotFound("sg_preset_sappers")
	sg_preset_infantry = SGroup_CreateIfNotFound("sg_preset_infantry")
	
	sg_henschel_squad_target_no_mans = SGroup_CreateIfNotFound("sg_henschel_squad_target_no_mans")
	eg_henschel_entity_target_no_mans = EGroup_CreateIfNotFound("eg_henschel_entity_target_no_mans")
	
	sg_hummel_squad_target_no_mans = SGroup_CreateIfNotFound("sg_hummel_squad_target_no_mans")
	eg_hummel_entity_target_no_mans = EGroup_CreateIfNotFound("eg_hummel_entity_target_no_mans")
	sg_hummel_squad_target_barrage = SGroup_CreateIfNotFound("sg_hummel_squad_target_barrage")
	eg_hummel_entity_target_barrage =EGroup_CreateIfNotFound("eg_hummel_entity_target_barrage")
	sg_no_mans_hummel = SGroup_CreateIfNotFound("sg_no_mans_hummel")

	--modifications to the hummel ability
	Modify_AbilityMaxCastRange (player2, ABILITY.ELITE.HUMMEL_BARRAGE, 5.0)
	
	
	if EGroup_CountDeSpawned(eg_carpiquet_b_victory_flags) >= 1 then
		
		EGroup_ReSpawn(eg_carpiquet_b_victory_flags)
		
	end
	
	eg_factory_a			= EGroup_CreateIfNotFound("eg_factory_a")
	eg_fuel_tanks_blowup	= EGroup_CreateIfNotFound("eg_fuel_tanks_blowup")
	eg_fuel_sheds_blowup	= EGroup_CreateIfNotFound("eg_fuel_sheds_blowup")
	eg_ammo_driver_spawn1	= EGroup_CreateIfNotFound("eg_ammo_driver_spawn1")
	eg_ammo_driver_spawn2	= EGroup_CreateIfNotFound("eg_ammo_driver_spawn2")
	eg_ammo_tower1			= EGroup_CreateIfNotFound("eg_ammo_tower1")
	eg_axis_hq				= EGroup_CreateIfNotFound("eg_axis_hq")
	
	t_previous_axis_buildings = {eg_factory_a, eg_fuel_tanks_blowup, eg_fuel_sheds_blowup, eg_ammo_driver_spawn1}
	
	
	for u = 1, table.getn(t_previous_axis_buildings) do
		
		if EGroup_IsEmpty(t_previous_axis_buildings[u]) == false then
			
			EGroup_DestroyAllEntities(t_previous_axis_buildings[u])
			
		end
		
	end
	
	if EGroup_IsEmpty(eg_axis_hq) then
		--EGroup_InstantRevertOccupiedBuilding(eg_axis_hq)
		EGroup_DestroyAllEntities(eg_axis_hq)
	end
	
	

	
	tmkr_mortar_guard = Marker_GetTable("mkr_mortar_guard%d")	
	sg_field_extra 				= SGroup_CreateIfNotFound("sg_field_extra")
	sg_anti_air_force 			= SGroup_CreateIfNotFound("sg_anti_air_force")
	sg_at_gun_force 			= SGroup_CreateIfNotFound("sg_at_gun_force")
	sg_flak88_soldiers 			= SGroup_CreateIfNotFound("sg_flak88_soldiers")
	sg_flak88_delayers 			= SGroup_CreateIfNotFound("sg_flak88_delayers")
	sg_gate_force 				= SGroup_CreateIfNotFound("sg_gate_force")
	sg_mortar1		 			= SGroup_CreateIfNotFound("sg_mortar1")
	sg_mortar_guard1		 	= SGroup_CreateIfNotFound("sg_mortar_guard1")
	sg_patrol1		 			= SGroup_CreateIfNotFound("sg_patrol1")
	sg_patrol2		 			= SGroup_CreateIfNotFound("sg_patrol2")
	sg_ammo_dump_outside_guard1	= SGroup_CreateIfNotFound("sg_ammo_dump_outside_guard1")
	sg_ammo_dump_force			= SGroup_CreateIfNotFound("sg_ammo_dump_force")
	sg_fence_force				= SGroup_CreateIfNotFound("sg_fence_force")
	sg_field_force				= SGroup_CreateIfNotFound("sg_field_force")
	sg_carpiquet_enemies 		= SGroup_CreateIfNotFound("sg_carpiquet_enemies")
	sg_factory_force			= SGroup_CreateIfNotFound("sg_factory_force")
	sg_carpiquet_car1_patrol	= SGroup_CreateIfNotFound("sg_carpiquet_car1_patrol")
	sg_alerted_tanks_force			= SGroup_CreateIfNotFound("sg_alerted_tanks_force")
	sg_gunner_force				= SGroup_CreateIfNotFound("sg_gunner_force")
	sg_commando_hangar_reinforcement_group = SGroup_CreateIfNotFound("sg_commando_hangar_reinforcement_group")
	
	tsg_mortar_guard 			= SGroup_CreateTable("sg_mortar_guard%d", table.getn(tmkr_mortar_guard))
	
	t_previous_axis = {sg_field_extra, sg_anti_air_force, sg_at_gun_force, sg_flak88_soldiers, sg_flak88_delayers, sg_gate_force,sg_mortar1, 
		sg_patrol1, sg_patrol2, sg_ammo_dump_outside_guard1, sg_fence_force, sg_field_force, sg_ammo_dump_force, sg_carpiquet_enemies, sg_factory_force,
		sg_carpiquet_car1_patrol, sg_gunner_force, sg_mortar_guard1, sg_commando_hangar_reinforcement_group, sg_alerted_tanks_force} --sg_mortar_guard1 --sg_alerted_tanks
		
	
	for u = 1, table.getn(t_previous_axis) do
		
		if SGroup_IsEmpty(t_previous_axis[u]) == false then
			
			--SGroup_DeSpawn(t_previous_axis[u])
			SGroup_DestroyAllSquads(t_previous_axis[u])
			
		end
		
	end
	
	for u = 1, table.getn(tsg_mortar_guard) do
		
		if SGroup_IsEmpty(tsg_mortar_guard[u]) == false then
			
			SGroup_DeSpawn(tsg_mortar_guard[u])
			SGroup_DestroyAllSquads(tsg_mortar_guard[u])
			
		end
		
	end
	
	t_ct_buildings = {eg_control_tower, eg_control_tower_b, eg_control_tower_complex1, eg_control_tower_complex2, eg_control_tower_complex3, eg_control_tower_complex4, eg_control_tower_complex5, eg_control_tower_complex6}
	
	local ct_squads = SGroup_CreateIfNotFound("ct_squads")
	
	for i = 1, table.getn(t_ct_buildings) do
		
		if EGroup_IsEmpty(t_ct_buildings[i]) == false then
			
			EGroup_GetSquadsHeld(t_ct_buildings[i], ct_squads)
			SGroup_DestroyAllSquads(ct_squads)
			
		end
		
	end
	
	--
	--for k, v in pairs(t_landing_data) do
		--if SGroup_IsEmpty(v.aggressor) == false then
	sg_holding1 = SGroup_CreateIfNotFound("sg_holding1")
	sg_holding2 = SGroup_CreateIfNotFound("sg_holding2")	
	
	

	sg_fuel_tanks_aggressor = SGroup_CreateIfNotFound("sg_fuel_tanks_aggressor")
	sg_hangar_aggressor = SGroup_CreateIfNotFound("sg_hangar_aggressor")
			if SGroup_IsEmpty(sg_fuel_tanks_aggressor) == false then
				--SGroup_SetInvulnerable(sg_fuel_tanks_aggressor, false)
			end
			if SGroup_IsEmpty(sg_hangar_aggressor) == false then
				--SGroup_SetInvulnerable(sg_hangar_aggressor, false)
			end
		--end
		
	--end
	
	--halfbuilt_entity = {}
	
	
	-- medal objective presets, just in case
	eg_hideout1 = EGroup_CreateIfNotFound("eg_hideout1")
	eg_hideout2 = EGroup_CreateIfNotFound("eg_hideout2")
	
	sg_hiding_commandos = SGroup_CreateIfNotFound("sg_hiding_commandos")

	
	
	if SGroup_IsEmpty(sg_holding1) == false then
		Modify_WeaponDamage(sg_holding1, "hardpoint_01", 0.10)
	end
		
	
	
	if SGroup_IsEmpty(sg_holding2) == false then
		Modify_WeaponDamage(sg_holding2, "hardpoint_01", 0.10)
	end
	
	fg_hangar_kicked_off = false
	
	--victory point stuff
	
	t_victory_points = {
		-- removed the other two - deg
		{flag_name = eg_control_tower_flag, control_struct = eg_control_tower_control, owned_by_player = false, neutral = false },
	}
	
	
	g_counterattack_countdown = 300
	g_counterattack_base = 300
	g_medal_started = false
	
	-- TEMPORARY stuff is called here.  This is so to provide the player with units if they go into the mission with nothing.
	Carpiquet_B_Temp()
	
	
	--------------------------------
	-- Mission Sitreps
	--------------------------------
	
	f_sitrep_over = false
	
	-- AMBIENT
	t_carpiquet_b_propaganda = {}
	t_carpiquet_b_propaganda.exchange1 = {
		
		{ACTOR.CXP1.GenericPanzerElite, 1340740}, -- Men of Canada, this is not your war! 
		{ACTOR.CXP1.GenericPanzerElite, 1340750}, -- Give up now and we will spare you.
		{ACTOR.CXP1.GenericPanzerElite, 1340760}, -- Do not fight for your masters. Be free men of Canada.
		{ACTOR.CXP1.GenericPanzerElite, 1340770}, -- Why fight for your Imperial Masters. They do not remember your sacrifices at Vimy.
		{ACTOR.CXP1.GenericPanzerElite, 1340800}, -- You call yourselves common and your British masters treat you just as that, like common mutts inbred in the Americas.
		{ACTOR.CXP1.GenericCommonwealth, 1340840}, -- That's the one the Major spoke of, he's a brat, but now he's working for Jerry! 
		{ACTOR.CXP1.GenericCommonwealth, 1340850}, -- Come on men, let's show them what Commonwealth means!	
		
	}
	
	
	t_carpiquet_b_propaganda.exchange2 = {
		
		{ACTOR.CXP1.GenericPanzerElite, 1340780}, -- Remember your homes. Your families.
		{ACTOR.CXP1.GenericPanzerElite, 1340790}, -- Who is your sweet heart with now?
		{ACTOR.CXP1.GenericPanzerElite, 1340810}, -- Canadian Rifles, I give you one last offer, surrender and your lives will be spared. No blood need be shed this day.
		{ACTOR.CXP1.GenericCommonwealth, 1340880}, -- Never, you fucking ass-backward bastards!
		{ACTOR.CXP1.GenericCommonwealth, 1340890}, -- My guns getting cold listening to your going on you damn Jerry!
		
	}
	
	
	t_carpiquet_b_propaganda.exchange3 = {
		
		{ACTOR.CXP1.GenericPanzerElite, 1340820}, -- Fools! Tremble in your petty defiance! The 12th SS has offered you life!
		{ACTOR.CXP1.GenericPanzerElite, 1340830}, -- Today you will come to know the storm of the 3rd Empire!
		{ACTOR.CXP1.GenericCommonwealth, 1340870}, -- McMahon do you hear this shit!	
		{ACTOR.CXP1.GenericCommonwealth, 1340860}, -- Can't wait to get one of these rifles up poor Jerry's trap door! 
		
	}
	
	
	-- if areas of your script need to be kicked off early
	
	-- inits here too!
	Build_Defenses_Init()
	Secure_Airfield_Init()
	Clear_Hangars_Init()
	Neutralize_88s_Init()
	Clear_Control_Tower_Init()
	Axis_Counterattack_Init()
	Runway_Bunkers_Init()
	Barracks_Init()
	Shed_Chain_Reaction_Init()
	Forward_Chain_Reaction_Init()
	Hangar2_Chain_Reaction_Init()
	Hangar3_Chain_Reaction_Init()
	Shoot_Down_Planes_Init()
	Medal_Objective_Init()
	Build_Defenses_Preset()
	Clear_Hangars_Preset()
	Neutralize_88s_Preset()
	Clear_Control_Tower_Preset()
	Axis_Counterattack_Preset()
	Runway_Bunkers_Preset()
	Barracks_Preset()
	Medal_Objective_Preset()
	Shoot_Down_Planes_Preset()

end

-- TEMPORARY stuff is called here.  This is so to provide the player with units if they go into the mission with nothing.
function Carpiquet_B_Temp()
	
	sg_player_init_group_a = SGroup_CreateTable("sg_player_init_group_a%d", 3) 
	sg_player_init_group_b = SGroup_CreateTable("sg_player_init_group_b%d", 3) 
	sg_player_init_group_c = SGroup_CreateTable("sg_player_init_group_c%d", 3) 
	sg_player_ally_group = SGroup_CreateTable("sg_player_ally_group%d", 3) 
	
	eg_emplacement = EGroup_CreateTable("eg_emplacement%d", 3) 
	tmkr_emplacement = Marker_GetTable("mkr_emplacement%d")
	
	
	-- TEMPORARY Player Spawn!
	t_carpiquet_player_info = {
	
		initial_p1_spawn = {
			
			--area 1
			{
			{name = sg_player_init_group_a[1], blueprint = SBP.CW.TOMMIES_CANADIAN_SP, loc = mkr_preset_placement7, number = 1},
			{name = sg_player_init_group_a[2], blueprint = SBP.CW.COMMANDOS, loc = mkr_preset_placement4, number =1},
			{name = sg_player_init_group_a[3], blueprint = SBP.CW.LIEUTENANT, loc = mkr_preset_placement7, number = 1},
			},
			
			--area 2
		{
			{name = sg_player_init_group_b[1], blueprint = SBP.CW.TOMMIES_CANADIAN_SP, loc = mkr_preset_placement2, number = 1},
			{name = sg_player_init_group_b[2], blueprint = SBP.CW.COMMANDOS, loc = mkr_preset_placement5, number = 1},
			{name = sg_player_init_group_b[3], blueprint = SBP.CW.LIEUTENANT, loc = mkr_preset_placement8, number = 1},
			},
			
			--area 3
		{
			{name = sg_player_init_group_c[1], blueprint = SBP.CW.TOMMIES_CANADIAN_SP, loc = mkr_preset_placement3, number = 1},
			{name = sg_player_init_group_c[2], blueprint = SBP.CW.COMMANDOS, loc = mkr_preset_placement9, number = 1},
			--{name = sg_player_init_group_c[3], blueprint = SBP.CW.LIEUTENANT, loc = mkr_alert_guards, number = 1},
			},
			
			
			--HQ?
			
			
		},
		
		
		ally_spawn = {
	
			{name = sg_player_ally_group[1], blueprint = SBP.CW.COMMANDOS, loc = mkr_preset_placement1, number = 1},
			{name = sg_player_ally_group[2], blueprint = SBP.CW.TOMMIES_CANADIAN_SP, loc = mkr_alert_guards, number = 1},
			{name = sg_player_ally_group[3], blueprint = SBP.CW.STUART, loc = mkr_extra_tank1, number = 1},
			{name = sg_player_ally_group[4], blueprint = SBP.CW.STUART, loc = mkr_extra_tank2, number = 1},
			--{name = sg_player_ally_group[5], blueprint = SBP.CW.LIEUTENANT, loc = mkr_carp_flag1_pointer, number = 1},
			
		},
		
		--temporary emplacements
		
		emplacements = {
		
			{name = eg_emplacement[1], blueprint = EBP.CW.MG_NEST, loc = tmkr_emplacement[1], number = 1},
			{name = eg_emplacement[2], blueprint = EBP.CW.MG_NEST, loc = tmkr_emplacement[2], number = 1},
			{name = eg_emplacement[3], blueprint = EBP.CW.MG_NEST, loc = tmkr_emplacement[3], number = 1},
		
		},
		
		
	}
	
	
	-- TEMPORARY, giving player stuff to simulate a good end from the last map, an to give enemy stuff assuming a typical ending 
	t_carpiquet_player_info.flag_ownership = {
		
		mandatory = {
		--friendly
			{name = eg_flag1, owner = player1},
			{name = eg_flag2, owner = player1},
			{name = eg_flag3, owner = player1},
			{name = eg_flag4, owner = player1},
			{name = eg_flag5, owner = player1},
			{name = eg_flag6, owner = player1},
			{name = eg_ammo_flag, owner = player1},
			--{name = eg_carp_flag1, owner = player1},
			
			--enemy
			{name = eg_control_tower_flag, owner = player2},
			{name = eg_88s_flag, owner = player2},
			{name = eg_hangar_flag, owner = player2},
			{name = eg_barracks_control, owner = player2},
		},
		
		optional = {
			{name = eg_carp_flag1, owner = player1},
			{name = eg_carpiquet_fuel, owner = player1},
		},
		
	}
	
	sg_carpiquet_enemies = SGroup_CreateIfNotFound("sg_carpiquet_enemies")
	
	
	

	
	-- flag ownership
	
	for k, v in pairs(t_carpiquet_player_info.flag_ownership.mandatory) do
		
		local flag = v
	 
		--if EGroup_IsCapturedByPlayer(eg_carp_flag1, player1, false) == false then
			
			EGroup_InstantCaptureStrategicPoint(flag.name, flag.owner)
			
		--end
		
	end

	for k, v in pairs(t_carpiquet_player_info.flag_ownership.optional) do
		
		local flag = v
	 
		EGroup_InstantCaptureStrategicPoint(flag.name, flag.owner)
		
	end
	
	sg_leftover_squads = SGroup_CreateIfNotFound("sg_leftover_squads")
	eg_leftover_buildings = EGroup_CreateIfNotFound("eg_leftover_buildings")
	
	Player_GetAll(player1, sg_leftover_squads, eg_leftover_buildings)
	g_player_sgroup_count = SGroup_Count(sg_leftover_squads)
	
	g_originally_no_starting_units = false
	
	
	if g_player_sgroup_count <= 0 then
	
		for i = 1, table.getn(t_carpiquet_player_info.initial_p1_spawn) do
		
			for k, v in pairs(t_carpiquet_player_info.initial_p1_spawn[i]) do
				
				local squads = v
				 
				Util_CreateSquads(player1, squads.name, squads.blueprint, squads.loc, nil, squads.number)
				
			end
			
		end
		
		--fg_ally_spawn = true
		
		--if fg_ally_spawn == true then
		
		
		
		if EGroup_IsCapturedByPlayer(eg_carp_flag1, player1, false) and SGroup_IsEmpty(sg_carpiquet_reinforcements_group) then
		
			for k, v in pairs(t_carpiquet_player_info.ally_spawn) do
				
				local squads = v
				 
				Util_CreateSquads(player1, squads.name, squads.blueprint, squads.loc, nil, squads.number)
				
			end
		
		
		end
		
		g_originally_no_starting_units = true
	
	end
	
	
	-- Give player HQs if they don't have any	
	temp_sgroups = SGroup_CreateIfNotFound("temp_sgroups")
	Player_GetAll(player1, temp_sgroups)
	
	if SGroup_ContainsBlueprints(temp_sgroups, SBP.CW.INFANTRY_HQ, false) == false then
		
			Util_CreateSquads(player1, sg_preset_infantry_hq, SBP.CW.INFANTRY_HQ, mkr_temp_hq1_alt)
			
		-- the following lines help set up new rally points for the player that are close by the new location of the hq in question
		Command_SquadPos(player1, sg_preset_infantry_hq, SCMD_RallyPoint, Marker_GetPosition(mkr_hq1_alt_rally), false)
		
		
	else
		
		SGroup_Filter(temp_sgroups, SBP.CW.INFANTRY_HQ, FILTER_KEEP)
		
		SGroup_FilterCount(temp_sgroups, 1)
		SGroup_WarpToMarker(temp_sgroups, mkr_temp_hq1_alt)
		
		-- the following lines help set up new rally points for the player that are close by the new location of the hq in question
		Command_SquadPos(player1, temp_sgroups, SCMD_RallyPoint, Marker_GetPosition(mkr_hq1_alt_rally), false)
		
	end
	
	SGroup_Clear(temp_sgroups)
	
	
	Player_GetAll(player1, temp_sgroups)
	
	if SGroup_ContainsBlueprints(temp_sgroups, SBP.CW.HQ, false) == false then
		
		Util_CreateSquads(player1, sg_preset_cw_hq, SBP.CW.HQ, mkr_temp_hq2_alt)
		
		-- the following lines help set up new rally points for the player that are close by the new location of the hq in question
		Command_SquadPos(player1, sg_preset_cw_hq, SCMD_RallyPoint, Marker_GetPosition(mkr_hq2_alt_rally), false)
		
		
	else
		
		SGroup_Filter(temp_sgroups, SBP.CW.HQ, FILTER_KEEP)
		
		SGroup_FilterCount(temp_sgroups, 1)
		SGroup_WarpToMarker(temp_sgroups, mkr_temp_hq2_alt)
		
		-- the following lines help set up new rally points for the player that are close by the new location of the hq in question
		Command_SquadPos(player1, temp_sgroups, SCMD_RallyPoint, Marker_GetPosition(mkr_hq2_alt_rally), false)
		
	end
	SGroup_Clear(temp_sgroups)
	
	tsg_infantry_placement = SGroup_CreateTable("sg_infantry_placement%d", 100)
	tsg_lt_placement = SGroup_CreateTable("sg_lt_placement%d", 100)
	tsg_com_placement = SGroup_CreateTable("sg_com_placement%d", 100)
	tsg_stu_placement = SGroup_CreateTable("sg_stu_placement%d", 100)
	tsg_tet_placement = SGroup_CreateTable("sg_tet_placement%d", 100)
	tsg_bren_placement = SGroup_CreateTable("sg_bren_placement%d", 100)
	tmkr_placement_markers = {mkr_preset_placement1, mkr_preset_placement2, mkr_preset_placement3, mkr_preset_placement4, mkr_preset_placement5, 
							mkr_preset_placement6, mkr_preset_placement7, mkr_preset_placement8, mkr_preset_placement9}
	
		
	tmkr_vehicle_placement_markers = {mkr_preset_vehicle1, mkr_preset_vehicle2, mkr_preset_vehicle3, 
										mkr_preset_vehicle4, mkr_preset_vehicle5, mkr_preset_vehicle6}
	
	t_friendly_type = {
		{blueprint = SBP.CW.TOMMIES_CANADIAN_SP, friendly_sgroup_table = tsg_infantry_placement, placement = tmkr_placement_markers, vehicle = false},
		{blueprint = SBP.CW.LIEUTENANT, friendly_sgroup_table = tsg_lt_placement, placement = tmkr_placement_markers, vehicle = false},
		{blueprint = SBP.CW.COMMANDOS, friendly_sgroup_table = tsg_com_placement, placement = tmkr_placement_markers, vehicle = false},
		{blueprint = SBP.CW.STUART, friendly_sgroup_table = tsg_stu_placement, placement = tmkr_vehicle_placement_markers, vehicle = true},
		{blueprint = SBP.CW.TETRARCH, friendly_sgroup_table = tsg_tet_placement, placement = tmkr_vehicle_placement_markers, vehicle = true},
		{blueprint = SBP.CW.BREN_CARRIER, friendly_sgroup_table = tsg_bren_placement, placement = tmkr_vehicle_placement_markers, vehicle = true},
	}
	
	if g_originally_no_starting_units == false then
		
		for k, v in pairs(t_friendly_type) do
			
			-- track the placing of units
			local place_count = 1
			
			local placement_limit = 0
			
			if v.vehicle == true then
				
				placement_limit = table.getn(tmkr_vehicle_placement_markers)
				
			else
				
				placement_limit = table.getn(tmkr_placement_markers)
				
			end
			
			-- filter the desired sbp
			SGroup_Clear(temp_sgroups)
			Player_GetAll(player1, temp_sgroups)
			SGroup_Filter(temp_sgroups, v.blueprint, FILTER_KEEP)
			
			if SGroup_IsEmpty(temp_sgroups) == false then
				
				local temp_placement_count = SGroup_CountSpawned(temp_sgroups)
				-- only proceed if its not empty
				if temp_placement_count > 0 then
					-- print the count and the iteration
					print("For the "..k.." sbp the count is "..temp_placement_count)
					
					for f = 1, temp_placement_count do
						
						SGroup_Add(v.friendly_sgroup_table[f], SGroup_GetSpawnedSquadAt(temp_sgroups, 1)) 
						SGroup_RemoveGroup(temp_sgroups, v.friendly_sgroup_table[f])
						
						print(place_count)
						
						if v.vehicle == true then
							
							SGroup_WarpToMarker(v.friendly_sgroup_table[f], tmkr_vehicle_placement_markers[place_count]) 
							
						elseif SGroup_IsInHoldSquad(v.friendly_sgroup_table[f], false) == false and SGroup_IsInHoldEntity(v.friendly_sgroup_table[f], false) == false then
							
							SGroup_WarpToMarker(v.friendly_sgroup_table[f], tmkr_placement_markers[place_count]) 
							
						end
						
						
						--If we want to move these units, the call has to be done after a cycle after the warp
						
						-- use this count to loop back the placement if all nine are used
						
						if placement_limit > 0 then
							
							if place_count < placement_limit then
								place_count = place_count + 1
							else
								place_count = 1
							end
							
						end
						
					end
				end
				
			end
		end
		
	end
	
	for k, v in pairs(t_friendly_type) do
	
			local place_count = 1
			
			local placement_limit = 0
			
			if v.vehicle == true then
				
				placement_limit = table.getn(tmkr_vehicle_placement_markers)
				
			else
				
				placement_limit = table.getn(tmkr_placement_markers)
				
			end
			
				
			local temp_placement_count = table.getn(v.friendly_sgroup_table)
			
			if temp_placement_count > 0 then
			
				for f = 1, temp_placement_count do
				
					if SGroup_IsEmpty(v.friendly_sgroup_table[f]) == false then
					
						if v.vehicle == true then
						
							--Cmd_Move(v.friendly_sgroup_table[f], tmkr_vehicle_placement_markers[place_count], nil, nil, nil, nil, nil, 10)
						
						else
						
							Cmd_Move(v.friendly_sgroup_table[f], tmkr_placement_markers[place_count], nil, nil, nil, nil, nil, 10)
							
						end
						
					
						if placement_limit > 0 then
						
							if place_count < placement_limit then
								place_count = place_count + 1
							else
								place_count = 1
							end
						end
					
					end
					
				end
				
			end
		
		
	end
	
	-- specific infantry placement here, so that they aren't automatically allocated
	-- sappers given here, since the player won't have any	
	Util_CreateSquads(player1, sg_preset_sappers, SBP.CW.SAPPER, mkr_hq1_alt_rally)
	
	-- if the player has no Canadian Tommies, we can spare them one squad
	Player_GetAll(player1, temp_sgroups)
	if SGroup_ContainsBlueprints(temp_sgroups, SBP.CW.TOMMIES_CANADIAN_SP, false) == false then
	
		Util_CreateSquads(player1, sg_preset_infantry, SBP.CW.TOMMIES_CANADIAN_SP, mkr_hq2_alt_rally)
		
	end
	
	-- TEMPORARY DESTROYING BUNKERS, assuming player did last time
	
	EGroup_DestroyAllEntities(eg_bunker_group)
end


-------------------------------------------------------------------------

-- MISSION START 

-------------------------------------------------------------------------

function Carpiquet_B_MissionStart()

	if Event_IsAnyRunning() == false then
		
		FOW_UnRevealAll()
		
		-- delay objectives
		Rule_AddDelayedInterval(Carpiquet_B_Delay_Secure_Airfield, 4, 1)
		
		-- had to do it this way because calling the delay with an AddDelayedInterval 
		--calls the function immediately but applies the immediate result after the indicated delay
		Rule_AddOneShot(Carpiquet_88_Delay, 5) 
		
		Rule_AddDelayedInterval(Carpiquet_B_Shoot_Down_Planes_Activation, 2, 1)
		
		Rule_AddOneShot(Carpiquet_B_Delay_Build_Defenses, 0)
		
		Rule_AddInterval(Carpiquet_Airport_B_General_Lose_Condition, 5)
		
		Rule_AddInterval(Carpiquet_B_Victory_Point_Control, 1)
		Rule_AddOneShot(Barracks_Kickoff, 1)
		
		if g_hidden ~= nil and g_hidden > 0 then
			Rule_AddInterval(Carpiquet_B_Delay_Medal_Objective_Detect, 5)
			Rule_AddInterval(Carpiquet_B_Delay_Medal_Objective_Start, 1)
		end
		
		Rule_AddOneShot(Carpiquet_B_No_Mans_Land_Mechanics, 1)
		
		Rule_AddOneShot(Axis_Counterattack_Spawn_Hummel, 2)
		
		Rule_AddInterval(Shed_Chain_Reaction, 1)
		Rule_AddInterval(Forward_Chain_Reaction, 1)
		Rule_AddInterval(Hangar2_Chain_Reaction, 1)
		Rule_AddInterval(Hangar3_Chain_Reaction, 1)
		
		
		Rule_AddDelayedInterval(Hangar1_Troop_Control, 1,15)
		Rule_AddDelayedInterval(Hangar2_Troop_Control, 2,15)
		Rule_AddDelayedInterval(Hangar3_Troop_Control, 3,15)
		
		Rule_RemoveMe()
	end
end


function Carpiquet_B_Delay_Secure_Airfield()
	
	if fg_axis_secure_airfield_start == true then--or Player_CanSeeSGroup(player1, sg_hangar_forces, false) --or Player_CanSeeSGroup(player1, sg_runway_88_crew_members_combined, false)
	--or Player_CanSeeSGroup(player1, sg_control_tower_forces, false) then -- gunguard 1 is temporary! -- SGroup_IsUnderAttackByPlayer(sg_gun_guard1, player1, 1)
		
		Objective_Start(OBJ_Secure_Airfield)
		
		Player_SetPopCapOverride(player1, 100) -- ? put here because it was the only way I could affect the pop cap
		
		--Player_SetMaxPopulation(player1, CT_Personnel, 100 ) -- originally 30
		
		--[[
		if Rule_Exists(Carpiquet_B_Delay_Medal_Objective_Start) == false then
			Rule_AddInterval(Carpiquet_B_Delay_Medal_Objective_Start, 1)
		end]]
		
		Rule_RemoveMe()
		
	end
	
end


function Carpiquet_88_Delay()

	Rule_AddInterval(Carpiquet_B_Delay_88s, 1, 1)

end


function Carpiquet_B_Delay_88s()

	if SGroup_IsEmpty(sg_runway_88_crew_members_combined) == false then
	
		if f_sitrep_over == true and Player_CanSeeSGroup(player1, sg_runway_88_crew_members_combined, false) and SGroup_IsUnderAttack(sg_runway_88_crew_members_combined, false, 2) then
			
			Objective_Start(OBJ_Neutralize_88s)
			
			Rule_RemoveMe()
			
		end
		
	end

end


function Carpiquet_B_Delay_Build_Defenses()

	if Event_IsAnyRunning() == false then
		
		-- start the objective 
		Objective_Start(OBJ_Build_Defenses)
		-- start the checker for spawning the counter attack
		Rule_AddInterval(CarpB_CounterAttack_Begin, 1)
		
		f_sitrep_over = true
		
		
		flash_ID_tommy_build = UI_FlashConstructionMenu(TYPE.CONSTRUCT.CW.TOMMIES, true, BT_UI_Strong_AbilityBtn)
		flash_ID_commando_build = UI_FlashConstructionMenu(TYPE.CONSTRUCT.CW.COMMANDO, true, BT_UI_Strong_AbilityBtn)
		flash_ID_HQ_build = UI_FlashConstructionMenu(TYPE.CONSTRUCT.CW.HQ, true, BT_UI_Strong_AbilityBtn)
		flash_ID_sapper_build = UI_FlashConstructionMenu(TYPE.CONSTRUCT.CW.SAPPER, true, BT_UI_Strong_AbilityBtn)
		flash_ID_armor_HQ_build = UI_FlashProductionButton(PITEM_Spawn, SBP.CW.ARMOUR_HQ, true, BT_UI_Strong_AbilityBtn)
		
		Rule_RemoveMe()
		
	end	

end

-- when 30% of the defense building time has elapsed
-- start the counter attack troops spawning
function CarpB_CounterAttack_Begin()
	-- using variables set in other places to track time 
	if g_counterattack_countdown <= g_counterattack_base*.6 then
		-- start related action
		Rule_AddOneShot(Axis_Counterattack_Kickoff,0)
		
		Rule_RemoveMe()
	end
end


-- called at end of build defenses objective
function Carpiquet_B_Delay_Axis_Counterattack() 
	
	if Event_IsAnyRunning() == false then
	
		--Objective_Start(OBJ_Axis_Counterattack)
		Objective_UpdateText(OBJ_Build_Defenses, 1349101, 1349111, true)
		
		Rule_AddInterval(Axis_Counterattack_WinCheck, 5)
		
		-- flag for letting the counter attack loose
		t_counterAttack_go[1] = true
		-- set up the AI for player 4
		CarpB_Player4_Setup()
		-- intel tracker
		Rule_AddInterval(Axis_Counterattack_First_Contact, 1)
		
		Rule_RemoveMe()
		
	end
	
end

-- Player 4 is the AI player used to attack the player 
function CarpB_Player4_Setup()

	AI_Enable(player4, true)
	AI_ForceAttack(player4, player1)
	
	AI_EnableComponent(player4, true, COMPONENT_Attacking)
	AI_EnableComponent(player4, true, COMPONENT_Defending)
	AI_EnableComponent(player4, true, COMPONENT_Resourcing)
	AI_EnableComponent(player4, true, COMPONENT_Securing)
	AI_EnableComponent(player4, true, COMPONENT_Tactics)
	AI_EnableComponent(player4, false, COMPONENT_ForwardDefending)
	AI_EnableComponent(player4, false, COMPONENT_BuildUnits)
	AI_EnableComponent(player4, false, COMPONENT_BuildStructures)
	AI_EnableComponent(player4, false, COMPONENT_BuildResearch)
	AI_EnableComponent(player4, false, COMPONENT_BuildAddOns)

end

-- watching what the player has
function Carpiquet_Airport_B_General_Lose_Condition()

	Player_GetAll(player1, sg_all_units, eg_all_buildings)

	if SGroup_CountSpawned(sg_all_units) == 0 then
		
		Game_EndSP(false, nil, true)
		
		Rule_RemoveMe()
		
	end
	
end


function Carpiquet_B_Shoot_Down_Planes_Activation()
	
	if fg_hangar_kicked_off == true then  
		
		Rule_AddOneShot(Carpiquet_B_Shoot_Down_Planes_Delay, 25) 
		
		Rule_RemoveMe()
		
	end

end


function Carpiquet_B_Delay_Medal_Objective_Detect()

	if Objective_IsStarted(OBJ_Medal_Objective) or Objective_IsStarted(OBJ_Secure_Airfield) then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_medal_info.data) do
			
			if Prox_ArePlayersNearMarker(player1, v.rescue_marker, false, 60) and v.group_active == true then
				
				g_player_medal_activation = true
				
				Rule_RemoveMe()
			end
			
		end
		
	end
end



function Carpiquet_B_Delay_Medal_Objective_Start()
	
	-- or player is near rescue marker activation
	if (Objective_IsStarted(OBJ_Secure_Airfield) and Objective_IsStarted(OBJ_Medal_Objective) == false) or g_player_medal_activation == true then --fg_axis_secure_airfield_start == true
		
		if Event_IsAnyRunning() == false then
			
			--if SGroup_IsEmpty(sg_hiding_commandos) == false then
			if fg_group1_active == true or fg_group2_active == true then

				if g_player_medal_activation == true then
					
					Rule_AddInterval(Delay_Medal, 1)
					
				else
					
					Rule_AddDelayedInterval(Delay_Medal, 20, 1)
					
				end
				
				Rule_RemoveMe()
				
			--elseif SGroup_IsEmpty(sg_hiding_commandos) == true then
			elseif fg_group1_active == false and fg_group2_active == false then	
				
				Rule_RemoveMe()
				
			end
			
		end
		
	end

end

function Carpiquet_B_Shoot_Down_Planes_Delay()
	
	Objective_Start(OBJ_Shoot_Down_Planes)
	
end

function Delay_Medal()

	if Event_IsAnyRunning() == false then
	
		Objective_Start(OBJ_Medal_Objective)
	
		g_medal_started = true
		
		Rule_RemoveMe()
	
	end


end

-- manages the owner of the invisible control structure associated with the point
function Carpiquet_B_Victory_Point_Control()

	for k, v in pairs(t_victory_points) do
		
		if EGroup_IsCapturedByPlayer(v.flag_name, player1, false) and v.owned_by_player == false then
			
			EGroup_InstantCaptureStrategicPoint(v.control_struct, player1)
			
			v.owned_by_player = true
			
		end
		
	end
	
end

function Carpiquet_B_No_Mans_Land_Mechanics()

	Axis_Counterattack_Response_Init()
	Rule_AddInterval(Axis_Counterattack_Henschel_Control_No_Mans, 1)
	
	Rule_AddDelayedInterval(Axis_Counterattack_Left_Response_Activator, 1, 5)
	Rule_AddDelayedInterval(Axis_Counterattack_Right_Response_Activator, 2, 5)
	
	Rule_AddInterval(Axis_Response_Monitor, 1)
	
end

-------------------------------------------------------------------------
-- Build Defenses
-- Main objective, build defenses
-- Player must build defenses in preparation of an imminent Axis counterattack
-------------------------------------------------------------------------
function Initialize_OBJ_Build_Defenses()

	OBJ_Build_Defenses = {
		
		SetupUI = function() 
			
			
			
		end,
		
		OnStart = function()
			Sound_PlayMusic("Music/SP/Caen/preparation/coh_waiting_game.bsc",0,0)
			-- announce the goal
			-- Util_AutoIntel(t_capture_hangars.EventStart)
			
			-- win/lose check
			
			Rule_AddInterval(Build_Defenses_WinCheck, 1)
			
			-- start related action
			Build_Defenses_Kickoff()
			
		end,
		
		OnComplete = function()
			Sound_PlayMusic("Music/SP/Caen/trepidation/coh_force_beyond.bsc",0,0)
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1349100,
		Description = 1349110,
		Type = OT_Primary,
		
		SitRep = {
			Movie = "CXP1_SR_04-01",
			Force = true,
			SpeechTiming =
			{
				{ 1,	ACTOR.CXP1.Cutting, 1340500 },
				{ 2,	ACTOR.CXP1.Cutting, 1340510 },
				{ 7.4,	ACTOR.CXP1.Blackmore, 1340520 },
				{ 8.8,	ACTOR.CXP1.Cutting, 1340530 },
				{ 13,	ACTOR.CXP1.Cutting, 1340540 },
				{ 19,	ACTOR.CXP1.Cutting, 1340590 },
			--	{ 21,	ACTOR.CXP1.Blackmore, 1332060 }, -- Not sure what this is - didn't want to delete it, just in case :)
				{ 21.4,	ACTOR.CXP1.Blackmore, 1340650 },
				{ 27,	ACTOR.CXP1.Blackmore, 1340660 },
				{ 29.9,	ACTOR.CXP1.Blackmore, 1340670 },
				
			},
		},
		
	}
	
	-- Register Objective
	Objective_Register(OBJ_Build_Defenses)
	
	-- Initialize Data
	

end



function Build_Defenses_Init()

	tmkr_emplacements = Marker_GetTable("mkr_emplacement%d")
	teg_built_emplacement = EGroup_CreateTable("eg_built_emplacement%d", table.getn(tmkr_emplacements))
	
	t_build_defences_data = {
		build_defences_spawn = {
			
			{name = sg_sappers, blueprint = SBP.CW.SAPPER, loc = mkr_player_start4, numberofsquads = 2},
			
		},
		
		emplacement_data = {
			--[[
			-- emplacement 1
			{name = tmkr_emplacement[1],text = LOC("INTEL: Build a machine gun nest here!"),  indicatorID = nil},
			-- emplacement 2
			{name = tmkr_emplacement[2],text = LOC("INTEL: Build a machine gun nest here!"),  indicatorID = nil},
			-- emplacement 3
			{name = tmkr_emplacement[3],text = LOC("INTEL: Build a machine gun nest here!"),  indicatorID = nil},
			]]
		},
		
	}
--	Objective_AddUIElements(OBJ_Build_Defenses, eg_flag1, true, LOC("Build Defenses"), true)
	
	OBJ_Build_Defenses.EmplacementElementID = {}
	
	for i = 1, table.getn(tmkr_emplacements) do
		table.insert(t_build_defences_data.emplacement_data, {name = teg_built_emplacement[i], loc = tmkr_emplacements[i], built = false,
						indicatorID = nil, text = 1349150, 
						emplacement_type = {EBP.CW.MG_NEST, EBP.CW.ANTITANK_NEST, EBP.CW.HOWITZER_NEST, EBP.CW.MORTAR_NEST, EBP.CW.SLITTRENCH_NEST}})
	end
	
	for i = 1, table.getn(t_build_defences_data.emplacement_data) do
		--print("test")
		table.insert(OBJ_Build_Defenses.EmplacementElementID, Objective_AddUIElements(OBJ_Build_Defenses, t_build_defences_data.emplacement_data[i].loc, true, t_build_defences_data.emplacement_data[i].text, true) )
		
	end
	
	for k,v in pairs(t_build_defences_data.emplacement_data) do 
		v.indicatorID = OBJ_Build_Defenses.EmplacementElementID[k]
	end
	
	g_emplacements_built = 0
	
	t_build_defenses_dialogue ={
		
		--post SitRep_PlaySpeech
		post_sitrep = {
		
			{ACTOR.CXP1.Cutting, 1340680}, --12th SS Panzer Division is mobilizing a counter-attack, prepare defenses!
			{ACTOR.CXP1.Cutting, 1340690}, --I say again, 12th SS Panzer Division is mobilizing a counter-attack, prepare defenses!
			{ACTOR.CXP1.Cutting, 1340700}, --That's coming from the top gents.
			{ACTOR.CXP1.Chubb, 1340710}, --You heard him men, move into defensive positions. 
			{ACTOR.CXP1.Chubb, 1340720}, --I want A-T and M-G emplacements deployed in a jiffy. 
			{ACTOR.CXP1.Chubb, 1340730}, --Get moving ladies! We need defensive positions A-SAP!
			
		},
		
		post_sitrep2 = {
			
			{ACTOR.CXP1.Chubb, 1340900}, --Alright boys, listen up, I want M-Gs to cover the frontline!
			{ACTOR.CXP1.Chubb, 1340910}, --Sort out the A-T Gun emplacements, I want a maximum field of fire lads!
			{ACTOR.CXP1.Chubb, 1340920}, --Corporal Macdonald, get to building me some Mortars and stop your waddling about!
			
		},
		
		
		defenses_built = {
			--{ACTOR.GenericAlly, LOC("Excellent work.  Hopefully this will hold the Jerries at bay.  Now, prepare for enemy attack!")} --Excellent work.  Hopefully this will hold the Jerries at bay.  Now, prepare for enemy attack!
		},
		
		incoming_counterattack = {
			{ACTOR.CXP1.Seville, 1340930} --Alright troops, look sharp, Jerry's coming for us!
		},
		
		first_contact = {
		
			{ACTOR.CXP1.Seville, 1340990}, -- Contact!  Hold the line!!
			{ACTOR.CXP1.Seville, 1341000}, -- Make every shot count troops!
			{ACTOR.CXP1.Seville, 1341010}, -- Rapid rate! Go on!
			{ACTOR.CXP1.Seville, 1341020}, -- Targets to your front! Go on!
		},
		
		
		countdown_5_mins = {
			
			{ACTOR.CXP1.Seville, 1340940}, -- Counter Attack in 5 minutes.
			
		},
		
		countdown_3_mins = {
			
			{ACTOR.CXP1.Seville, 1340950}, -- Counter Attack in 3 minutes.
			
		},
		
		countdown_2_mins = {
			
			{ACTOR.CXP1.Seville, 1340960}, -- Counter Attack in 2 minutes.
			
		},
		
		countdown_1_mins = {
			
			{ACTOR.CXP1.Seville, 1340970}, -- Counter Attack in 60 seconds.
			
		},
		
	}
	
	g_build_defenses_over = false
	
	fg_5_mins = false
	fg_4_mins = false
	fg_3_mins = false
	fg_2_mins = false
	fg_1_mins = false
	
	tmkr_counterattack_reveal_area = Marker_GetTable("mkr_counterattack_reveal_area%d")
	
end


function Build_Defenses_Preset()

	Rule_AddInterval(Build_Defenses_Remove_Ping, 3)

end


function Build_Defenses_Kickoff()
	
	Util_AutoIntel(t_build_defenses_dialogue.post_sitrep)
	--Util_AutoIntel(t_build_defenses_dialogue.post_sitrep2)
	
	Rule_AddInterval(Build_Defenses_Kickoff2, 1)

end


function Build_Defenses_Kickoff2()

	if Event_IsAnyRunning() == false then
		
		Rule_AddOneShot(Build_Defenses_Timer, 1)
		Rule_AddInterval(Build_Defenses_Countdown, 1)
		Rule_AddInterval(Build_Defenses_Countdown_Speech, 1)
		Rule_RemoveMe()
		
	end

end

function Build_Defenses_Remove_Ping()
--print("remove ping!")
	
	if g_build_defenses_over == true then
		
		for i = 1, table.getn(t_build_defences_data.emplacement_data) do
			
			local e_data = t_build_defences_data.emplacement_data
			
			Objective_RemoveUIElements(OBJ_Build_Defenses, e_data[i].indicatorID)
			
		end
		
		Rule_RemoveMe()
		
	else
		
		for i = 1, table.getn(t_build_defences_data.emplacement_data) do
			
			local e_data = t_build_defences_data.emplacement_data
			
			if e_data[i].built == false then 
				
				Player_GetAllEntitiesNearMarker(player1, e_data[i].name, e_data[i].loc)
				
				if EGroup_ContainsBlueprints(e_data[i].name, e_data[i].emplacement_type, false) then
					
					e_data[i].built = true
					--print("removed")
					Objective_RemoveUIElements(OBJ_Build_Defenses, e_data[i].indicatorID)
					
					g_emplacements_built = g_emplacements_built + 1
					
				end
				
			end
			
			
		end
		
		if g_emplacements_built >= 3 then
			
			--Util_AutoIntel(t_build_defenses_dialogue.defenses_built)
			
			Rule_RemoveMe()
			
		end
	end
end


function Build_Defenses_Timer()

	Objective_StartTimer(OBJ_Build_Defenses, COUNT_DOWN, g_counterattack_base, -1)
	
end



function Build_Defenses_Countdown() 
-- counts down from whatever g_stratpoint_countdown is, until 0, then removes itself

	if g_counterattack_countdown > 0 then
		
		g_counterattack_countdown = g_counterattack_countdown - 1
		
	elseif g_counterattack_countdown <= 0 then
		
		
		Rule_RemoveMe()
		
	end


end



function Build_Defenses_Countdown_Speech()

	if g_counterattack_countdown >= 241 and fg_5_mins == false then
		
		if Event_IsAnyRunning() == false then
			
			Util_AutoIntel(t_build_defenses_dialogue.countdown_5_mins)
			Util_AutoIntel(t_build_defenses_dialogue.post_sitrep2)
			
			fg_5_mins = true
			
		end
		
	elseif g_counterattack_countdown <= 240 and g_counterattack_countdown >= 181 and fg_4_mins == false then
		
		if Event_IsAnyRunning() == false then
			
			--Util_AutoIntel(t_build_defenses_dialogue.countdown_4_mins)
			Util_AutoAmbient(t_carpiquet_b_propaganda.exchange1)
			
			fg_4_mins = true
			
		end
		
	elseif g_counterattack_countdown <= 180 and g_counterattack_countdown >= 121 and fg_3_mins == false then
		
		if Event_IsAnyRunning() == false then
			
			Util_AutoIntel(t_build_defenses_dialogue.countdown_3_mins)
			fg_3_mins = true
			
		end
		
	elseif g_counterattack_countdown <= 120 and g_counterattack_countdown >= 61 and fg_2_mins == false then
		
		if Event_IsAnyRunning() == false then
			
			Util_AutoIntel(t_build_defenses_dialogue.countdown_2_mins)
			Util_AutoAmbient(t_carpiquet_b_propaganda.exchange2)
			fg_2_mins = true
			
		end
		
	elseif g_counterattack_countdown <= 60 and g_counterattack_countdown > 0 and fg_1_mins == false then	
		
		if Event_IsAnyRunning() == false then
			
			Util_AutoIntel(t_build_defenses_dialogue.countdown_1_mins)
			Util_AutoAmbient(t_carpiquet_b_propaganda.exchange3)
			-- FIX ARTILLERY HIT
			Rule_AddOneShot(Axis_Counterattack_Hummel_Barrage_Control, 0)
			
			fg_1_mins = true
			
		end
		
	end
end


function Build_Defenses_WinCheck()

	if (g_counterattack_countdown <= 0) or (g_counterattack_countdown <= 0) then -- g_emplacements_built <= 3 and
		
		if Event_IsAnyRunning() == false then
			
			Util_AutoIntel(t_build_defenses_dialogue.incoming_counterattack)
			--now kick off counterattack!
			
			g_build_defenses_over = true
			
			Objective_StopTimer(OBJ_Build_Defenses)
			Rule_AddInterval(Carpiquet_B_Delay_Axis_Counterattack, 1)
			
			-- turns on hummel barrage control on trenches
			Rule_AddDelayedInterval(Axis_Counterattack_Hummel_Barrage_Control, 1, 1)
			
			for j = 1, table.getn(tmkr_counterattack_reveal_area) do
				
				FOW_RevealMarker(tmkr_counterattack_reveal_area[j], -1)
				
			end
			
			
			Rule_RemoveMe()
		end
		
	end

end

-------------------------------------------------------------------------
-- Secure Airfield
-- Main objective, containing subobjectives defined like encounters
-- Player must neutralize the 88s, clear the hangars, and clear the control tower.  this may happen concurrently with the defend against axis counterattack objective
-------------------------------------------------------------------------
function Initialize_OBJ_Secure_Airfield()

	OBJ_Secure_Airfield = {
		
		SetupUI = function() 
			
			OBJ_Secure_Airfield.mapElementID1 = Objective_AddUIElements(OBJ_Secure_Airfield, mkr_hangar1_pointer, true, 1349154, true)
			OBJ_Secure_Airfield.mapElementID2 = Objective_AddUIElements(OBJ_Secure_Airfield, mkr_hangar2_pointer, true, 1349154, true)
			OBJ_Secure_Airfield.mapElementID3 = Objective_AddUIElements(OBJ_Secure_Airfield, mkr_hangar3_pointer, true, 1349154, true)
			OBJ_Secure_Airfield.tower_pingID1 = Objective_AddUIElements(OBJ_Secure_Airfield, mkr_control_tower_pointer, true, 1349155, true)
			
		end,
		
		OnStart = function()
			
			-- announce the goal
			
			-- win/lose check
			Rule_AddInterval(Secure_Airfield_WinCheck, 5)
			
			-- start related action
			--Secure_Airfield_Kickoff()
			Rule_AddOneShot(Secure_Airfield_Kickoff, 0)
			
			-- ui check here
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1349102,
		Description = 1349112,
		Type = OT_Primary,
		
		SitRep = {
			Movie = "CXP1_SR_04-02",
			Force = true,
			SpeechTiming =
			{
				{ 1,	ACTOR.CXP1.Cutting, 1341100 },
				{ 5.8,	ACTOR.CXP1.Cutting, 1341110 },
				{ 7,	ACTOR.CXP1.Cutting, 1341120 },
				{ 11.8,	ACTOR.CXP1.Blackmore, 1341130 },
				
			},
		},
	}
	
	-- Register Objective
	Objective_Register(OBJ_Secure_Airfield)
	
end

---------------------
-- initializes the airfield variables
function Secure_Airfield_Init()

	
	t_secureAirfield = {
		--neutralize_88s_activated set to true to kick things off!
		activated = {clear_hangars = false, clear_control_tower = false}, -- neutralize_88s_activated = false,
		completed = {clear_hangars = false, clear_control_tower = false}, -- neutralize_88s_completed = false, 
		
	}
	
	t_secure_airfield_dialogue = { -- duplicate of .repulsed2
		-- for use when the secure airfield gets called sequentially after the counterattack.  Otherwise it just jumps straight to the objective's dialogue
		
		airfield_secured = {
			
			{ACTOR.CXP1.Cutting, 1341530}, --Excellent work, men.
			{ACTOR.CXP1.Cutting, 1341550}, --With Carpiquet Airport under our control, Caen is as good as ours!
			
			{ACTOR.CXP1.Blackmore, 1341560}, --Bloody good job men, bloody good.
			{ACTOR.CXP1.Blackmore, 1341580}, --Get The Royal Scots on the radio. Tell them to stand by for orders...
			
		},
		
	}
	
	fg_all_objectives_completed = false
	
	fg_first_objective_active = false -- flag to activate 88 objective after axis counterattack
	
	-- init times (in seconds) between text warnings for each objective
	g_neutralize_88s_warning_time = 0
	g_clear_hangars_warning_time = 0
	g_clear_control_tower_warning_time = 0
	
end

----------------

function Secure_Airfield_Kickoff()

	--Testing revealed that this may be due to some initialization quirks
	
	--Neutralize_88s_Kickoff()
	Rule_AddInterval(Secure_Airfield_Objective_Tracker, 5) -- 1 second previously
	--Rule_AddInterval(Secure_Airfield_WinCheck, 1)
	Rule_AddInterval(Secure_Airfield_Intel_Tracker, 1)
	Rule_AddInterval(Secure_Airfield_Dialogue_Delay1, 1)

end

function Secure_Airfield_Dialogue_Delay1()

	if Event_IsAnyRunning() == false then
		
		Util_AutoIntel(t_counterattack_dialogue.repulsed2)
		
		Rule_AddInterval(Secure_Airfield_Dialogue_Delay2, 1)	
		
		Rule_RemoveMe()
		
	end
	
end


function Secure_Airfield_Dialogue_Delay2()

	if Event_IsAnyRunning() == false then
		
		Util_StartIntel(EVENTS.MOVEOUT)
		
		Rule_RemoveMe()
		
	end
	
end









-- tracker function that keeps track of the objectives on the airfield
function Secure_Airfield_Objective_Tracker()

	local status_activated = t_secureAirfield.activated
	local status_completed = t_secureAirfield.completed
	
	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else	
		-- hangars
		if  (fg_first_objective_active == true and status_activated.clear_hangars == false) or --(status_completed.neutralize_88s_completed == true
			
			(status_activated.clear_hangars == false and SGroup_IsUnderAttackByPlayer(sg_hangar_forces, player1, 1)) or 
			(status_completed.clear_control_tower == true and status_activated.clear_hangars == false) 
			
			then
			
			-- kickoff for hangars here
			local delay = 0
			if fg_first_objective_active == true then
				-- a bit more of a delay so that the success message of counterattack appears first, and this later
				delay = 5
			end
			Rule_AddInterval(Clear_Hangars_Kickoff, delay) 
			Rule_AddDelayedInterval(Clear_Hangars_Nag_Control, 300, 1)
			
			-- status change
			status_activated.clear_hangars = true
			
			-- added here 
			-- kickoff for control tower here
			-- delayed and then an interval so I can make sure all intel events are done by the time this starts
			Rule_AddDelayedInterval(Clear_Control_Tower_Kickoff, 30, 1) 
			
		-- control tower
		elseif (status_completed.clear_hangars == true and status_activated.clear_control_tower == false) or
			(status_activated.clear_control_tower == false and SGroup_IsUnderAttackByPlayer(sg_control_tower_forces, player1, 1))	then
			
			-- removed so that the objectives can be ordered in any direction
			
		elseif status_activated.clear_control_tower == true then
			
			--nothing!
			
		end
		
		if status_completed.clear_hangars == true and status_completed.clear_control_tower == true then --status_completed.neutralize_88s_completed == true and
			
			fg_all_objectives_completed = true
			
		end
		
	end

end


--will be changed to secure airfield general check
function Secure_Airfield_WinCheck()
	
	-- if all hangars neutralized then complete the objective
	if fg_all_objectives_completed == true then
		
		-- the player has just won
		Objective_Complete(OBJ_Secure_Airfield)
		Rule_AddInterval(Secure_Airfield_Win, 1)
		
		-- final over talk
		Util_AutoIntel(t_secure_airfield_dialogue.airfield_secured)		
		-- bring in letterbox
		Game_Letterbox(true, 2)
		
		Rule_RemoveMe()
		
	end
	
end


function Secure_Airfield_Intel_Tracker()
-- used to nag players when they're idling too long for an objective

	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	end

end

function Secure_Airfield_Win()

	if Event_IsAnyRunning() == false then
		
		Rule_AddInterval(Secure_Airfield_Win_Delay, 1)
		
		Rule_RemoveMe()
		
	end
	
end


function Secure_Airfield_Win_Delay()

	if Event_IsAnyRunning() == false then
		
		if g_medal_started == true and Objective_IsComplete(OBJ_Medal_Objective) == false then
			
			Objective_Fail(OBJ_Medal_Objective)
			
		end
		
		Rule_AddInterval(Secure_Airfield_Win_Delay2, 1)
		
		Rule_RemoveMe()
		
	end

end



function Secure_Airfield_Win_Delay2()

	if Event_IsAnyRunning() == false then
		
		if SGroup_IsEmpty(sg_hangar_forces) == false then
			
			SGroup_DestroyAllSquads(sg_hangar_forces)
			
		end
		
		if SGroup_IsEmpty(sg_control_tower_forces) == false then
			
			SGroup_DestroyAllSquads(sg_control_tower_forces)
			
		end
		
		Util_StartNIS(EVENTS.NIS02)
		
		Rule_AddInterval(Secure_Airfield_Win_Delay3, 1)
		
		Rule_RemoveMe()
		
	end
	
end


function Secure_Airfield_Win_Delay3()

	if Event_IsAnyRunning() == false then
		
		Game_EndSP(true, 1349161)
		
		Rule_RemoveMe()
		
	end

end

























-------------------------------------------------------------------------
-- Axis Counterattack
-- Opening counterattack.  Axis gets sent into the player's pre-set guns from last map.  Success is when the player fights off the enemies
-------------------------------------------------------------------------

-- Initialize variables needed for the counterattacks
function Axis_Counterattack_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	
	-- infantry
	sg_counterattack_wave_infantry = SGroup_CreateTable("sg_counterattack_wave_infantry%d",5)
	
	
	sg_counterattack_subwave1_infantry = SGroup_CreateTable("sg_counterattack_subwave1_infantry%d",5)
	sg_counterattack_subwave2_infantry = SGroup_CreateTable("sg_counterattack_subwave2_infantry%d",5)
	sg_counterattack_subwave3_infantry = SGroup_CreateTable("sg_counterattack_subwave3_infantry%d",5)
	
	sg_counterattack_subwave1_retreat_infantry = SGroup_CreateTable("sg_counterattack_subwave1_retreat_infantry%d",5)
	sg_counterattack_subwave2_retreat_infantry = SGroup_CreateTable("sg_counterattack_subwave2_retreat_infantry%d",5)
	sg_counterattack_subwave3_retreat_infantry = SGroup_CreateTable("sg_counterattack_subwave3_retreat_infantry%d",5)
	
	sg_counterattack_subwave1_retreat_vehicles = SGroup_CreateTable("sg_counterattack_subwave1_retreat_vehicles%d",5)
	sg_counterattack_subwave2_retreat_vehicles = SGroup_CreateTable("sg_counterattack_subwave2_retreat_vehicles%d",5)
	sg_counterattack_subwave3_retreat_vehicles = SGroup_CreateTable("sg_counterattack_subwave3_retreat_vehicles%d",5)

	sg_counterattack_wave_vehicles = SGroup_CreateTable("sg_counterattack_wave_vehicles%d",3)
	sg_counterattack_subwave1_vehicles = SGroup_CreateTable("sg_counterattack_subwave1_vehicles%d",5)
	sg_counterattack_subwave2_vehicles = SGroup_CreateTable("sg_counterattack_subwave2_vehicles%d",5)
	sg_counterattack_subwave3_vehicles = SGroup_CreateTable("sg_counterattack_subwave3_vehicles%d",5)
	
	
	
	-- "over group" for all waves for purposes of combining enemies into a single wave, survivors and reinforcements alike
	sg_counterattack_force = SGroup_CreateIfNotFound("sg_counterattack_force")
	sg_counterattack_infantry = SGroup_CreateIfNotFound("sg_counterattack_infantry")
	sg_counterattack_vehicles = SGroup_CreateIfNotFound("sg_counterattack_vehicles")
	
	sg_retreated_force = SGroup_CreateIfNotFound("sg_retreated_force")
	
	sg_retreated_subforce = SGroup_CreateTable("sg_retreated_subforce%d", 3)
	
	sg_subwave_inf_overgroup = SGroup_CreateTable("sg_subwave_inf_overgroup%d",3)
	sg_subwave_veh_overgroup = SGroup_CreateTable("sg_subwave_veh_overgroup%d",3)
	
	sg_wave1 = SGroup_CreateTable("sg_wave1%d",3)
	sg_wave2 = SGroup_CreateTable("sg_wave2%d",3)
	sg_wave3 = SGroup_CreateTable("sg_wave3%d",3)
	
	sg_subwave_target_concentration = SGroup_CreateTable("sg_subwave_target_concentration%d",3)
	eg_subwave_target_concentration = EGroup_CreateTable("eg_subwave_target_concentration%d",3)
	
	tmkr_counterattack_barrage_locations = {mkr_counterattack1_search_radius, mkr_counterattack2_search_radius, mkr_counterattack3_search_radius}
	
	
	
	-- contains spawn info and destinations
	t_counterattack_time_between_waves = {60, 40, 30}
	t_counterAttack_go = {false, false, false}
	t_counterattack_spawn = {
	
		{ -- wave 1
			
			wave_data ={
				--sub wave 1
				{
					spawn = {
						{name = sg_counterattack_subwave1_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_infantry[1]},
						{name = sg_counterattack_subwave1_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 5, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_infantry[2]},
						{name = sg_counterattack_subwave1_infantry[3], blueprint = t_dif.g_soldier_type3, loc = mkr_counterattack_spawn1, number = 1, offset = 2, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_infantry[3]},
						
						{name = sg_counterattack_subwave1_vehicles[1], blueprint = SBP.AXIS.PUMA, loc = mkr_counterattack_spawn2, number = 1, offset = 0, distance = 0, vehicle = true,
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_vehicles[1]},
						},
					destination = mkr_wave1_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[1],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point2,
					gun = eg_flak88_gun03,
					reached_destination = false,
					rallypoint = mkr_counterattack1_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack1_search_radius,
					infantry_leader = sg_counterattack_subwave1_infantry[1],
					vehicle_leader = sg_counterattack_subwave1_vehicles[1],
					--vehicle_leader = false,
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave1_vehicles[1],
					subwave_overgroup = sg_wave1[1],
					inf_overgroup = sg_subwave_inf_overgroup[1],
					veh_overgroup = sg_subwave_veh_overgroup[1],
					sgroup_target = sg_subwave_target_concentration[1],
					egroup_target = eg_subwave_target_concentration[1],
					capture_point = eg_flag4,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					WaveThreatID = false,
					given_to_AI = false,
				},
				
				
				--sub wave 2
				{
					spawn = {
						{name = sg_counterattack_subwave2_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_west_alternate_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[1]},
						{name = sg_counterattack_subwave2_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_west_alternate_spawn1, number = 1, offset = 5, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[2]},
						{name = sg_counterattack_subwave2_infantry[3], blueprint = t_dif.g_soldier_type3, loc = mkr_west_alternate_spawn1, number = 1, offset = 2, distance = 10, vehicle = false,
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[3]},
						--{name = sg_counterattack_subwave2_infantry[4], blueprint = t_dif.g_soldier_type2, loc = mkr_west_alternate_spawn2, number = 1, offset = 7, distance = 10, vehicle = false},
						
						{name = sg_counterattack_subwave2_vehicles[1], blueprint = SBP.AXIS.PUMA, loc = mkr_west_alternate_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_vehicles[1]},
						},
					destination = mkr_wave2_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[2],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point1,
					gun = eg_flak88_gun01,
					reached_destination = false,
					rallypoint = mkr_counterattack2_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack2_search_radius,
					infantry_leader = sg_counterattack_subwave2_infantry[1],
					vehicle_leader = sg_counterattack_subwave2_vehicles[1],
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave2_vehicles[1],
					subwave_overgroup = sg_wave1[2],
					inf_overgroup = sg_subwave_inf_overgroup[2],
					veh_overgroup = sg_subwave_veh_overgroup[2],
					sgroup_target = sg_subwave_target_concentration[2],
					egroup_target = eg_subwave_target_concentration[2],
					capture_point = eg_flag2,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					WaveThreatID = false,
					given_to_AI = false,
				},
				
				
				--sub wave 3
				{
					spawn = {
						{name = sg_counterattack_subwave3_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[1]},
						{name = sg_counterattack_subwave3_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 5, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[2]},
						{name = sg_counterattack_subwave3_infantry[3], blueprint = t_dif.g_soldier_type3, loc = mkr_counterattack_spawn1, number = 1, offset = 2, distance = 10, vehicle = false,
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[3]},
						{name = sg_counterattack_subwave3_infantry[4], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn2, number = 1, offset = 7, distance = 10, vehicle = false,
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[4]},
						
						{name = sg_counterattack_subwave3_vehicles[1], blueprint = SBP.AXIS.HALFTRACK_FLAME, loc = mkr_counterattack_spawn2, number = 1, offset = 0, distance = 0, vehicle = true,
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_vehicles[1]},
						--{name = sg_counterattack_subwave3_vehicles[2], blueprint = SBP.ELITE.HALFTRACK_SNIPER, loc = mkr_west_alternate_spawn2, number = 1, offset = 0, distance = 0, vehicle = true},
							},
					destination = mkr_wave3_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[3],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point2,
					--gun = eg_flak88_gun02,
					reached_destination = false,
					rallypoint = mkr_counterattack3_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack3_search_radius,
					infantry_leader = sg_counterattack_subwave3_infantry[1],
					vehicle_leader = sg_counterattack_subwave3_vehicles[1],
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave3_vehicles[1],
					subwave_overgroup = sg_wave1[3],
					inf_overgroup = sg_subwave_inf_overgroup[3],
					veh_overgroup = sg_subwave_veh_overgroup[3],
					sgroup_target = sg_subwave_target_concentration[3],
					egroup_target = eg_subwave_target_concentration[3],
					capture_point = eg_flag3,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					WaveThreatID = false,
					given_to_AI = false,
					
				},
			},
			
			wave_order = {1, 2, 3},
			wave_times = {10, 20, 0}, -- 20, 20, 0
			wave_force_time = 240,
			
		},
		
		
		{-- wave 2
			
			wave_data ={
				
				{-- sub wave 1
					spawn = {
						{name = sg_counterattack_subwave1_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_infantry[1]},
						{name = sg_counterattack_subwave1_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 5, distance = 5, vehicle = false,
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_infantry[2]},
						{name = sg_counterattack_subwave1_infantry[3], blueprint = t_dif.g_soldier_type3, loc = mkr_counterattack_spawn1, number = 1, offset = 2, distance = 10, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_infantry[3]},
						
						{name = sg_counterattack_subwave1_vehicles[1], blueprint = SBP.AXIS.PUMA, loc = mkr_counterattack_spawn3, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_vehicles[1]},
						{name = sg_counterattack_subwave1_vehicles[2], blueprint = SBP.ELITE.ARMOURCAR_222, loc = mkr_counterattack_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_vehicles[2]},
						--{name = sg_counterattack_subwave1_vehicles[3], blueprint = SBP.ELITE.HALFTRACK_251, loc = mkr_counterattack_spawn3, number = 1, offset = 0, distance = 0, vehicle = true},
							},
					destination = mkr_wave1_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[1],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point2,
					--gun = eg_flak88_gun02,
					reached_destination = false,
					rallypoint = mkr_counterattack1_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack1_search_radius,
					infantry_leader = sg_counterattack_subwave1_infantry[1],
					vehicle_leader = sg_counterattack_subwave1_vehicles[1],
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave1_vehicles[1],
					subwave_overgroup = sg_wave2[1],
					inf_overgroup = sg_subwave_inf_overgroup[1],
					veh_overgroup = sg_subwave_veh_overgroup[1],
					sgroup_target = sg_subwave_target_concentration[1],
					egroup_target = eg_subwave_target_concentration[1],
					capture_point = eg_flag4,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					given_to_AI = false,
				},
				
				{-- sub wave 2
					spawn = {
						{name = sg_counterattack_subwave2_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_west_alternate_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[1]},
						{name = sg_counterattack_subwave2_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_west_alternate_spawn1, number = 1, offset = 5, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[2]},
						{name = sg_counterattack_subwave2_infantry[3], blueprint = t_dif.g_soldier_type3, loc = mkr_west_alternate_spawn1, number = 1, offset = 2, distance = 10, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[3]},
						
						{name = sg_counterattack_subwave2_vehicles[1], blueprint = SBP.AXIS.PUMA, loc = mkr_west_alternate_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_vehicles[1]},
						{name = sg_counterattack_subwave2_vehicles[2], blueprint = SBP.ELITE.HALFTRACK_SNIPER, loc = mkr_west_alternate_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_vehicles[2]},
						--{name = sg_counterattack_subwave2_vehicles[3], blueprint = SBP.ELITE.HALFTRACK_251, loc = mkr_west_alternate_spawn2, number = 1, offset = 0, distance = 0, vehicle = true},
							},
					destination = mkr_wave2_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[2],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point1,
					--gun = eg_flak88_gun02,
					reached_destination = false,
					rallypoint = mkr_counterattack2_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack2_search_radius,
					infantry_leader = sg_counterattack_subwave2_infantry[1],
					vehicle_leader = sg_counterattack_subwave2_vehicles[1],
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave2_vehicles[1],
					subwave_overgroup = sg_wave2[2],
					inf_overgroup = sg_subwave_inf_overgroup[2],
					veh_overgroup = sg_subwave_veh_overgroup[2],
					sgroup_target = sg_subwave_target_concentration[2],
					egroup_target = eg_subwave_target_concentration[2],
					capture_point = eg_flag2,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					given_to_AI = false,
				},
			
				{ -- sub wave 3
					spawn = {
						{name = sg_counterattack_subwave3_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[1]},
						{name = sg_counterattack_subwave3_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 5, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[2]},
						{name = sg_counterattack_subwave3_infantry[3], blueprint = t_dif.g_soldier_type3, loc = mkr_counterattack_spawn1, number = 1, offset = 2, distance = 10, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[3]},
						
						{name = sg_counterattack_subwave3_vehicles[1], blueprint = SBP.AXIS.PUMA, loc = mkr_counterattack_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_vehicles[1]},
						{name = sg_counterattack_subwave3_vehicles[2], blueprint = SBP.AXIS.HALFTRACK_FLAME, loc = mkr_counterattack_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_vehicles[2]},
						--{name = sg_counterattack_subwave3_vehicles[3], blueprint = SBP.AXIS.PUMA, loc = mkr_counterattack_spawn3, number = 1, offset = 0, distance = 0, vehicle = true},
							},
					destination = mkr_wave3_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[3],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point2,
					--gun = eg_flak88_gun02,
					reached_destination = false,
					rallypoint = mkr_counterattack3_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack3_search_radius,
					infantry_leader = sg_counterattack_subwave3_infantry[1],
					vehicle_leader = sg_counterattack_subwave3_vehicles[1],
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave3_vehicles[1],
					subwave_overgroup = sg_wave2[3],
					inf_overgroup = sg_subwave_inf_overgroup[3],
					veh_overgroup = sg_subwave_veh_overgroup[3],
					sgroup_target = sg_subwave_target_concentration[3],
					egroup_target = eg_subwave_target_concentration[3],
					capture_point = eg_flag3,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					given_to_AI = false,
				},
			},
			
			wave_order = {1, 2, 3},
			wave_times = {10, 20, 0}, -- 10, 10, 0
			wave_force_time = 240,
		},
		
		
		{-- wave 3
			wave_data ={
				{-- sub wave 1
					spawn = {
						{name = sg_counterattack_subwave1_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_infantry[1]},
						{name = sg_counterattack_subwave1_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 5, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_infantry[2]},
						
						{name = sg_counterattack_subwave1_vehicles[1], blueprint = t_dif.AT2, loc = mkr_counterattack_spawn3, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_vehicles[1]},
						{name = sg_counterattack_subwave1_vehicles[2], blueprint = SBP.AXIS.PUMA, loc = mkr_counterattack_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_vehicles[2]},
						{name = sg_counterattack_subwave1_vehicles[3], blueprint = SBP.ELITE.PANZER_SUPPORT, loc = mkr_counterattack_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave1_retreat_vehicles[3]},
						--{name = sg_counterattack_subwave1_vehicles[3], blueprint = SBP.AXIS.PUMA, loc = mkr_counterattack_spawn3, number = 1, offset = 0, distance = 0, vehicle = true},
							},
					destination = mkr_wave1_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[1],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point2,
					--gun = eg_flak88_gun02,
					reached_destination = false,
					rallypoint = mkr_counterattack1_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack1_search_radius,
					infantry_leader = sg_counterattack_subwave1_infantry[1],
					vehicle_leader = sg_counterattack_subwave1_vehicles[1],
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave1_vehicles[1],
					subwave_overgroup = sg_wave3[1],
					inf_overgroup = sg_subwave_inf_overgroup[1],
					veh_overgroup = sg_subwave_veh_overgroup[1],
					sgroup_target = sg_subwave_target_concentration[1],
					egroup_target = eg_subwave_target_concentration[1],	
					capture_point = eg_flag4,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					given_to_AI = false,

				},
				
				
				{-- sub wave 2
					spawn = {
						{name = sg_counterattack_subwave2_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_west_alternate_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[1]},
						{name = sg_counterattack_subwave2_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_west_alternate_spawn1, number = 1, offset = 5, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[2]},
						{name = sg_counterattack_subwave2_infantry[3], blueprint = t_dif.g_soldier_type3, loc = mkr_west_alternate_spawn1, number = 1, offset = 2, distance = 10, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_infantry[3]},
						
						{name = sg_counterattack_subwave2_vehicles[1], blueprint = SBP.ELITE.PANZER_SUPPORT, loc = mkr_west_alternate_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_vehicles[1]},
						{name = sg_counterattack_subwave2_vehicles[2], blueprint = SBP.ELITE.HALFTRACK_SNIPER, loc = mkr_west_alternate_spawn2, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave2_retreat_vehicles[2]},
						--{name = sg_counterattack_subwave2_vehicles[3], blueprint = SBP.AXIS.PUMA, loc = mkr_west_alternate_spawn3, number = 1, offset = 0, distance = 0, vehicle = true},
							},
					destination = mkr_wave2_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[2],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point1,
					--gun = eg_flak88_gun02,
					reached_destination = false,
					rallypoint = mkr_counterattack2_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack2_search_radius,
					infantry_leader = sg_counterattack_subwave2_infantry[1],
					vehicle_leader = sg_counterattack_subwave2_vehicles[1],
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave2_vehicles[1],
					subwave_overgroup = sg_wave3[2],
					inf_overgroup = sg_subwave_inf_overgroup[2],
					veh_overgroup = sg_subwave_veh_overgroup[2],
					sgroup_target = sg_subwave_target_concentration[2],
					egroup_target = eg_subwave_target_concentration[2],
					capture_point = eg_flag2,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					given_to_AI = false,
				},
				
				
				
				
				{ -- sub wave 3
					spawn = {
						{name = sg_counterattack_subwave3_infantry[1], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 0, distance = 0, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[1]},
						{name = sg_counterattack_subwave3_infantry[2], blueprint = t_dif.g_soldier_type2, loc = mkr_counterattack_spawn1, number = 1, offset = 5, distance = 5, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[2]},
						{name = sg_counterattack_subwave3_infantry[3], blueprint = t_dif.g_soldier_type3, loc = mkr_counterattack_spawn1, number = 1, offset = 2, distance = 10, vehicle = false, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_infantry[3]},
						
						{name = sg_counterattack_subwave3_vehicles[1], blueprint = SBP.ELITE.PANZER_SUPPORT, loc = mkr_counterattack_spawn3, number = 1, offset = 0, distance = 0, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_vehicles[1]},
						{name = sg_counterattack_subwave3_vehicles[2], blueprint = t_dif.AT1, loc = mkr_counterattack_spawn2, number = 1, offset = 5, distance = 10, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_vehicles[2]},
						{name = sg_counterattack_subwave3_vehicles[3], blueprint = t_dif.AT1, loc = mkr_counterattack_spawn2, number = 1, offset = 3, distance = 10, vehicle = true, 
						retreated_squad = false, retreated_group = sg_counterattack_subwave3_retreat_vehicles[3]},
						--{name = sg_counterattack_subwave3_vehicles[3], blueprint = SBP.ELITE.HALFTRACK_251, loc = mkr_west_alternate_spawn21, number = 1, offset = 0, distance = 0, vehicle = true},
							},
					destination = mkr_wave3_destination,
					retreat = false,
					retreated_force = sg_retreated_subforce[3],
					retreat_count = 0,
					retreat_slowdown = false,
					retreat_area = mkr_axis_retreat_point2,
					--gun = eg_flak88_gun02,
					reached_destination = false,
					rallypoint = mkr_counterattack3_rally,
					squad_rallied = false,
					area_concentration = mkr_counterattack3_search_radius,
					infantry_leader = sg_counterattack_subwave3_infantry[1],
					vehicle_leader = sg_counterattack_subwave3_vehicles[1],
					vehicle_retreated = false,
					counterattack_keystone = sg_counterattack_subwave3_vehicles[1],
					subwave_overgroup = sg_wave3[3],
					inf_overgroup = sg_subwave_inf_overgroup[3],
					veh_overgroup = sg_subwave_veh_overgroup[3],
					sgroup_target = sg_subwave_target_concentration[3],
					egroup_target = eg_subwave_target_concentration[3],
					capture_point = eg_flag3,
					flag_captured = false,
					population = 0,
					retreat_percentage = 0.20,
					given_to_AI = false,
				},
			},
			
			wave_order = {1, 2, 3},
			wave_times = {1, 1, 0},
			wave_force_time = 240,
		},
		
		
	}
	
	-- sets the "keystone" vehicle.  If this takes a critical hit, or destroyed, all enemy forces associated with it's attack group fold like a deck of cards
	--g_counterattack_keystone = sg_counterattack_wave3_vehicles[1]
	
	-- dialogue for counterattack
	t_counterattack_dialogue = {
		
		wave1 = {
			--{ACTOR.GenericAlly, LOC("INTEL: Get ready! They should be here very shortly!")},
			{ACTOR.CXP1.Seville, 1340980}, --Alright boys, hold your ground. Give it to them.
			
			
		},
		
		wave2 = {
			{ACTOR.CXP1.Chubb, 1341030}, -- We've fought off their first wave!
			{ACTOR.CXP1.Chubb, 1341040}, --Don't let your guard down though, more of those wankers are coming!
		},
		
		wave3 = {
			--{ACTOR.GenericAlly, LOC("INTEL: Bloody hell!  That was a second wave... When are they going to stop coming?")},
			{ACTOR.CXP1.Chubb, 1341050}, --Jesus Christ!  That was a second wave... They're just throwing themselves at us!
			{ACTOR.CXP1.Chubb, 1341060}, --Prepare for their next assault!
		},
		
		wavering = {
			
			{ACTOR.CXP1.Seville, 1341070}, --Their morale's wavering!  Just hang tight
			
		},
		
		-- pre sit-rep
		repulsed = {
			
			{ACTOR.CXP1.Seville, 1341080}, -- Excellent job troops!  Stand Down.
			{ACTOR.CXP1.Seville, 1341090}, -- Major Blackmore, RCR waiting out on further orders.
		},

		-- post sit-rep duplicate of 
		repulsed2 = {
			
			{ACTOR.CXP1.Cutting, 1341140}, --Alright RCR it's your turn, assemble sections with medium armor support and take that bloody Airfield!
			{ACTOR.CXP1.Cutting, 1341150}, --Refer to your maps, at the specified grid locations, we have four primary targets.
			{ACTOR.CXP1.Cutting, 1341160}, --Grab 'em quick and send 'em home lads!
			{ACTOR.CXP1.Chubb, 1341170}, --Ready yourselves! We are moving in. 
			{ACTOR.CXP1.Chubb, 1341180}, --In formation!!
			
		},
		
	}

	
	--weapon pickups
	tmkr_carp_b_counterattack_pickups = Marker_GetTable("mkr_carp_b_counterattack_pickup%d")
	g_counterattack_pickup_count = table.getn(tmkr_carp_b_counterattack_pickups)
	teg_counterattack_pickups = EGroup_CreateTable("eg_counterattack_pickups%d", g_counterattack_pickup_count)	
	
	t_counterattack_pickups = {
		
		{name = teg_counterattack_pickups[1], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_carp_b_counterattack_pickups[1]},
		{name = teg_counterattack_pickups[2], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_carp_b_counterattack_pickups[2]},
		
	}

	
	
	g_retreat_location = mkr_axis_retreat_point1 -- temporary, move to neutralize 88s for the retreat point, to lure player there
	
	-- flags for if waves are sent
	fg_wave1_sent = false
	fg_wave2_sent = false
	fg_wave3_sent = false
	
	g_wave_timer = 0 -- timer variable
	g_wave_time_limit = 15 -- number that we can use to determine the time limit needed... we can change this easily for difficulty tuning via script
	
	
	fg_wave_active = false
	f_vehicle_retreated = false
	fg_axis_retreat = false 
	fg_last_wave = false
	fg_axis_secure_airfield_start = false
	
	g_retreat_count = 0
	
	fg_attacks_repulsed = false
	
	sg_counterAt_player = SGroup_CreateIfNotFound("sg_counterAt_player")
	
	sg_henschel_squad_target = SGroup_CreateIfNotFound("sg_henschel_squad_target")
	eg_henschel_squad_target = EGroup_CreateIfNotFound("eg_henschel_entity_target")
	
	--player_concentration = Player_GetSquadConcentration(player1)
	f_smoke_mortars = false
	g_smoke_launched = 0
	
	g_retreat_slowdown = false
	f_waver_talk = false
	
	g_sub_wave_number = 1
	g_sub_wave_timer = 1
	g_wave_number = 1
	g_sub_wave_time_limit = 1
	
	g_stop_retreat = false
	g_reached_destination_count = 0
	
	g_not_visible_counter = 0
	f_counterattack_not_visible = false
	
	f_counterattack_start = false
	g_counterattack_end_timer = 0
	
	g_response_respawn_timer = 0
	
	g_force_timer = 0
	g_force_counterattack = false
	
end	


-- Preset for counterattack squads etc.
function Axis_Counterattack_Preset()

	-- spawns pickups
	for k, v in pairs(t_counterattack_pickups) do
		
		local pickup = v
		
		Util_CreateEntities(nil, pickup.name, pickup.blueprint, pickup.loc, 1)
		
	end
	
end


function Axis_Counterattack_Kickoff()
	
	Rule_AddInterval(Axis_Counterattack_Spawner, 4)
	
	f_counterattack_start = true
	
end









-------------------------------------------------------------------------
-- COUNTERATTACK ACTION
-------------------------------------------------------------------------

-- serves as a timer for counterattacks.  
-- called in Axis_Counterattack_Manager
function Axis_Counterattack_Timer()
	
	if fg_axis_retreat == true then
		
		Rule_RemoveMe() -- turns off timer function
		
	elseif g_wave_timer <= g_wave_time_limit and fg_wave_active == false then
		
		g_wave_timer = g_wave_timer + 1 -- increments timer by 1
		
	elseif g_wave_timer >= (g_wave_time_limit + 1) and fg_wave_active == true then
		
		g_wave_timer = 0 -- resets timer when done
		
		Rule_RemoveMe() -- turns off timer function
		
	end

end

-- wave number changes when they're all dead
 -- switch up spawn order!
function Axis_Counterattack_Spawner()

	if g_wave_number > 3 then
		Rule_RemoveMe()
		return
	else
		--UIWarning_Show( LOC("Wave "..g_wave_number ))
	end
	
	local done = true
	for k, v in pairs(t_counterattack_spawn[g_wave_number].wave_data[g_sub_wave_number].spawn) do
		
		if SGroup_IsEmpty(v.name) then
			
			Util_CreateSquads(player2, v.name, v.blueprint, v.loc)-- , nil, wave.number
			
			if v.vehicle == false then
				SGroup_AddGroup(t_counterattack_spawn[g_wave_number].wave_data[g_sub_wave_number].inf_overgroup, v.name)
				SGroup_AddGroup(sg_counterattack_infantry, v.name)
				
			elseif v.vehicle == true then
				SGroup_AddGroup(t_counterattack_spawn[g_wave_number].wave_data[g_sub_wave_number].veh_overgroup, v.name)
				SGroup_AddGroup(sg_counterattack_vehicles, v.name)
				
			end
			SGroup_AddGroup(t_counterattack_spawn[g_wave_number].wave_data[g_sub_wave_number].subwave_overgroup, v.name)
			SGroup_AddGroup(sg_counterattack_force, v.name)
			
			local rallypoint = t_counterattack_spawn[g_wave_number].wave_data[g_sub_wave_number].rallypoint
			
			-- initial movement here!
			Cmd_Move(v.name, rallypoint, NO_QUEUE, NIL_DELETE, NIL_FACE, k, k*7, 10)
			-- FIX
			done = false
			break
			
		end
		
	end
	
	-- finished spawning the wave, iterate to the next!
	if g_sub_wave_number < 3 then 
		g_sub_wave_number = g_sub_wave_number + 1 
	else
		g_sub_wave_number = 1
	end
	
	if done == true and t_counterAttack_go[1] == true then 
		
		for i = 1, 3 do 
			if t_counterattack_spawn[g_wave_number].wave_data[i].WaveThreatID == false 
			and SGroup_IsEmpty(t_counterattack_spawn[g_wave_number].wave_data[i].subwave_overgroup) == false then
				
				t_counterattack_spawn[g_wave_number].wave_data[i].WaveThreatID = ThreatArrow_CreateGroup()
				ThreatArrow_Add(t_counterattack_spawn[g_wave_number].wave_data[i].WaveThreatID, t_counterattack_spawn[g_wave_number].wave_data[i].subwave_overgroup)
				
				if Rule_Exists(Axis_Counterattack_Threat_Arrow_Manager) == false then
					
					Rule_AddInterval(Axis_Counterattack_Threat_Arrow_Manager, 1)
					
				end
				
			end
			
			t_counterattack_spawn[g_wave_number].wave_data[i].population = SGroup_TotalMembersCount(t_counterattack_spawn[g_wave_number].wave_data[i].subwave_overgroup)
		end
		
		-- FIX
		if Rule_Exists(Axis_Counterattack_Spawn_Timer) == false then
			Rule_AddInterval(Axis_Counterattack_Spawn_Timer, 1)
		end
		
		Rule_RemoveMe()
	end
	
end


function Axis_Counterattack_Threat_Arrow_Manager()

	if fg_axis_retreat == true then
		
		Rule_RemoveMe()
		
	else
		
		for m = 1, 3 do
			
			if (SGroup_IsEmpty(t_counterattack_spawn[g_wave_number].wave_data[m].subwave_overgroup) == true or SGroup_IsRetreating(t_counterattack_spawn[g_wave_number].wave_data[m].subwave_overgroup, false)
			or g_force_counterattack == true) and t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID ~= false 
			and t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID ~= nil then
				
				print(t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID)
				ThreatArrow_Remove(t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID, t_counterattack_spawn[g_wave_number].wave_data[m].subwave_overgroup)
				ThreatArrow_DestroyGroup(t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID)
				t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID = false
				print(t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID)
				
			elseif t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID == nil then
				
				t_counterattack_spawn[g_wave_number].wave_data[m].WaveThreatID = false
				
			end
			
		end
		
	end

end




function Axis_Counterattack_Spawn_Timer()

	-- if sub wave number is 3 or less then grab the time limit stored in t_counterattack_spawn
	if g_sub_wave_time_limit == 0 and g_wave_number <= 3 then 
		
		g_sub_wave_time_limit = t_counterattack_spawn[g_wave_number].wave_times[g_sub_wave_number]
		
	end
	
	if fg_axis_retreat == true then
		
		Rule_RemoveMe() -- turns off timer function
		
	else
		
			-- returns the subwave value to 0 in preparation for the next wave
			g_sub_wave_number = 1 
			--print("change ?")
			g_stop_retreat = false
			g_force_counterattack = false
			
			if Rule_Exists(Axis_Counterattack_Movement_Manager) == false then
				Rule_AddInterval(Axis_Counterattack_Movement_Manager, 5)
			end
			
			-- to kick off the check to see if the counterattack force gets destroyed. 
			if Rule_Exists(Axis_Counterattack_Iterator) == false then
				Rule_AddInterval(Axis_Counterattack_Iterator, 5)  
			end
			
			--Put here to ensure that it's called after all the needed units are spawned.
			Rule_AddOneShot(Axis_Counterattack_Hummel_Barrage_Control, 0) -- random hummel barrage
			Rule_AddOneShot(Axis_Counterattack_Henschel_Control, 1) -- to start a random Henschel attack
			
			if Rule_Exists(Axis_Counterattack_Retreater) == false then
				Rule_AddDelayedInterval(Axis_Counterattack_Retreater, 1, 5)
			end
			
			if Rule_Exists(Force_Counterattack_Timer) == false then
				Rule_AddInterval(Force_Counterattack_Timer, 1)
			end
			
			if g_wave_number == 1 and t_counterattack_dialogue.wave1 ~= false then
				Util_AutoIntel(t_counterattack_dialogue.wave1)
				t_counterattack_dialogue.wave1 = false
			end
			
			f_counterattack_start = true
			
			Rule_RemoveMe()
			
	end
end


function Axis_Counterattack_Movement_Manager()

	if SGroup_IsEmpty(sg_counterattack_force) == true then
		
		Rule_RemoveMe()
		
	else
		-- not in combat, and haven't reached destination yet?
		for k, v in pairs(t_counterattack_spawn[g_wave_number].wave_data) do
			
			local destination = t_counterattack_spawn[g_wave_number].wave_data[k].destination
			local rallypoint = t_counterattack_spawn[g_wave_number].wave_data[k].rallypoint
			local area_concentration = t_counterattack_spawn[g_wave_number].wave_data[k].area_concentration
			
			if SGroup_IsEmpty(v.subwave_overgroup) == false then
				
				-- PLAYER HAS ATTACKED 
				-- skip rallying/advancing and go straight to attacking
				if fg_left_activated == true or fg_right_activated == true then
					-- these get set to true because the player has jumped the gun
					v.squad_rallied = true
					t_counterAttack_go[g_wave_number] = true
					
					-- jump straight to attacking the player
					Player_GetAll(player1, sg_counterAt_player)
					if SGroup_IsEmpty(sg_counterAt_player) == false then
						Cmd_AttackMove(v.subwave_overgroup, sg_counterAt_player)
					end
				
				-- TRYING TO RALLY UP
				-- checking to see if they are rallied
				elseif v.squad_rallied == false then
					if Prox_AreSquadsNearMarker(v.subwave_overgroup, rallypoint, true) == false 
					and SGroup_IsMoving(v.subwave_overgroup, false) == false then 
						Cmd_AttackMove(v.subwave_overgroup, rallypoint)
					elseif SGroup_IsEmpty(v.vehicle_leader) == false then
						v.squad_rallied = true
						t_counterAttack_go[g_wave_number] = true
					end
				
				-- checking to see if they are at the location
				elseif v.reached_destination == false then
					if Prox_AreSquadsNearMarker(v.subwave_overgroup, destination, false) and SGroup_IsIdle(v.subwave_overgroup, false) then
						
						v.reached_destination = true
						g_reached_destination_count = g_reached_destination_count + 1
						
					elseif SGroup_IsDoingAttack(v.subwave_overgroup, false, 5) == false 
					and t_counterAttack_go[g_wave_number] == true then
						-- CHARGING TO THE ATTACK POINTS
						for s, t in pairs(t_counterattack_spawn[g_wave_number].wave_data[k].spawn) do
							
							if t.retreated_squad == false then
								
								local leader = t_counterattack_spawn[g_wave_number].wave_data[k].infantry_leader
								if t.vehicle == true then
									leader = t_counterattack_spawn[g_wave_number].wave_data[k].vehicle_leader
								end
								
								if SGroup_IsEmpty(t.name) == false then
									
									if leader ~= false then
										
										if SGroup_GetName(t.name) == SGroup_GetName(leader) then 
											
											local force_offset = Util_GetRandomPosition(destination)
											Cmd_Move(t.name, force_offset, nil, nil, nil, nil, nil, 3) 
											
										else
											
											--local force_offset = Util_GetOffsetPosition(destination, t.offset, t.distance)
											local force_offset = Util_GetRandomPosition(destination)
											Cmd_Move(t.name, force_offset, nil, nil, nil, nil, nil, 3) 
											
										end
									end
								end
							end	
						end
					end
					
				-- FIX
				-- NOT ATTACKING BUT FINALLY REACHED THE ATTACK POINT
				elseif SGroup_IsDoingAttack(v.subwave_overgroup, false, 5 ) == false and v.reached_destination == true then
					
					if EGroup_IsCapturedByPlayer(v.capture_point, player2, false) == false and v.flag_captured == false then
						-- to keep them from quitting if they are already trying to capture
						
						if SGroup_IsCapturing(v.inf_overgroup, false) == false then
							Cmd_MoveToThenCapture(v.inf_overgroup, v.capture_point)
						end
						
					elseif EGroup_IsCapturedByPlayer(v.capture_point, player2, false) == true then
						
						if v.flag_captured == false then
							
							v.flag_captured = true
							
						else
							-- no longer added to the AI cause of unit count issues and
							-- in favour of keeping them part of the 'wave' system
							Player_GetAll(player1, sg_counterAt_player)
							if SGroup_IsEmpty(sg_counterAt_player) == false then
								Cmd_AttackMove(v.subwave_overgroup, sg_counterAt_player)
							end
							
						end
						
					end
				end
			end
		end
	end
end



function Axis_Counterattack_Retreater()

	if SGroup_IsEmpty(sg_counterattack_force) then
		
		Rule_RemoveMe()
		
	else
		
		for l, m in pairs(t_counterattack_spawn[g_wave_number].wave_data) do
			
			if SGroup_IsEmpty(m.subwave_overgroup) == false then
				
				if m.squad_rallied and m.counterattack_keystone ~= false and m.retreat == false then
					print("the "..g_wave_number.." attack wave is capable of retreating now")
					
					print(SGroup_TotalMembersCount(m.subwave_overgroup))
					print(m.population * m.retreat_percentage)
					print("base pop: "..m.population)
					-- check for people running away
					if SGroup_TotalMembersCount(m.subwave_overgroup) <= (m.population * m.retreat_percentage) then
						
						for k, v in pairs(m.spawn) do
							
							if SGroup_IsEmpty(v.name) == false then
								
								if v.vehicle == false and SGroup_IsRetreating(v.name, false) == false
								and SGroup_TotalMembersCount(v.name) <= 2 then
								-- infantry retreat -- randomly choose 2 squads, if they exist
									-- FIX
									--Cmd_Retreat(v.name, g_retreat_location, g_retreat_location)	
									
									local rand_retreat_chance = World_GetRand(1, 2)
									print("rand chance = "..rand_retreat_chance)
									if rand_retreat_chance == 1 then
										
										Cmd_Retreat(v.name, m.retreat_area, m.retreat_area)	
										
									end
									
									
									v.retreated_squad = true
									break
									
								elseif v.vehicle == true and SGroup_GetAvgHealth(v.name) < .08 then
									
									--Cmd_Move(v.name, g_retreat_location, nil, g_retreat_location) -- tells keystone vehicle to move back
									SGroup_Kill(v.name)
									m.vehicle_retreated = true
									break
									
								end
								
							end
						end
					end
				end
			end
		end
		
		-- check to see how long the wave has lasted
		-- I'm co-oping this variable to set a time limit on the waves
		local forceRetreat = false
		if g_force_timer > 200 then
			forceRetreat = true
		end
		
		-- check when everyone is retreating or dead
		local retreating = true
		for l, m in pairs(t_counterattack_spawn[g_wave_number].wave_data) do
			if SGroup_IsEmpty(m.subwave_overgroup) == false then
				if forceRetreat == true then
					-- for infantry
					Cmd_Retreat(m.subwave_overgroup, m.retreat_area, m.retreat_area)
					-- for tanks
					Cmd_Move(m.subwave_overgroup, m.retreat_area, NO_QUEUE, m.retreat_area)
				elseif SGroup_IsRetreating(m.subwave_overgroup, true) == false then
					retreating = false
				end
			end
		end
		
		if retreating == true then 
			g_retreating = true 
			print("g_retreating should be true")
			print(g_retreating)
			
			-- reset this variable
			g_force_timer = 0
			
		else
			g_retreating = false 
		end
	end
end


function Axis_Counterattack_Iterator() -- or two minutes elapsed
	
--	if g_wave_number >= 3 and t_counterAttack_go[g_wave_number] == true 
--		and ( SGroup_IsEmpty(sg_counterattack_force) or (g_retreating == true and fg_last_wave == true)) then 
	
	if fg_last_wave == true then --or (g_wave_number == 3 and (SGroup_IsEmpty(sg_counterattack_force) == false and	SGroup_IsIdle(sg_counterattack_force, ALL))) then 	
		fg_axis_retreat = true
		
		Rule_RemoveMe()
		
	else
		
		if t_counterAttack_go[g_wave_number] == true -- and (( SGroup_IsEmpty(sg_counterattack_force) or g_retreating == true ) or
		and ( SGroup_IsEmpty(sg_counterattack_force) or (SGroup_Count(sg_counterattack_force) <= 3 and SGroup_IsIdle(sg_counterattack_force, ALL))) then
		print("g_retreating should be ???")
		print(g_retreating)
			if g_wave_number < 3  and g_stop_retreat == false then
				
				g_wave_number = g_wave_number + 1 -- iterate to next wave!
				--UIWarning_Show( LOC("Wave incremented "..g_wave_number ))
				-- reset retreat flag
				g_retreating = false
				
				if Rule_Exists(Axis_Counterattack_Spawner) == false then
					Rule_AddInterval(Axis_Counterattack_Spawner, 4)
				end
				
				if g_wave_number == 2 then
					
					Util_AutoIntel(t_counterattack_dialogue.wave2)
					
				elseif g_wave_number == 3 then
					
					Util_AutoIntel(t_counterattack_dialogue.wave3)
					
					-- retreat remaining units if counterattack force has remainders and g_force_counterattack == true
					if SGroup_IsEmpty(sg_counterattack_force) == false then
						
						--Cmd_Move(sg_counterattack_force, g_retreat_location, nil, g_retreat_location)
						Cmd_Move(sg_counterattack_force, mkr_axis_retreat_point2, nil, mkr_axis_retreat_point2)
						
						
						Modify_Vulnerability(sg_counterattack_force, 10)
						
					end
					
				end
				
				if Rule_Exists(Axis_Counterattack_Spawn_Timer) == false then
					
					Rule_AddInterval(Axis_Counterattack_Spawn_Timer, 1) -- calls timer
					
				end
				
			elseif g_wave_number == 3  and g_stop_retreat == false then
				
				fg_last_wave = true
				
			end
			
			f_counterattack_start = false
			g_force_counterattack = false
			
			g_stop_retreat = true
			
		elseif SGroup_Count(sg_counterattack_force) <= 2 and g_force_counterattack == true then 
			
			--UIWarning_Show( LOC("Wave Iterator Alternate kick "..g_wave_number ))
			
		end
		
	end

end


function Force_Counterattack_Timer()

	if fg_axis_retreat == true or SGroup_IsEmpty(sg_counterattack_force) then
		
		Rule_RemoveMe()
		
	else
		
		if g_force_counterattack == false then
			
			if g_force_timer < t_counterattack_spawn[g_wave_number].wave_force_time then
				
				g_force_timer = g_force_timer + 1
				
			elseif g_force_timer >= t_counterattack_spawn[g_wave_number].wave_force_time then 
				
				g_force_counterattack = true
				
				g_force_timer = 0
				
				Rule_RemoveMe()
				
			end
			
		end
		
	end
	
end


function Axis_Response_Monitor() -- respawns responders on a timer


	if fg_axis_retreat == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsEmpty(sg_counterattack_responders_left_total) == true and SGroup_IsEmpty(sg_counterattack_responders_right_total) == true and g_response_respawn_timer < 30 then
			
			g_response_respawn_timer = g_response_respawn_timer + 1
			
		elseif SGroup_IsEmpty(sg_counterattack_responders_left_total) == true and SGroup_IsEmpty(sg_counterattack_responders_right_total) == true and g_response_respawn_timer >= 30 then
			
			if Rule_Exists(Axis_Counterattack_Left_Response_Activator) == false then
				
				Rule_AddDelayedInterval(Axis_Counterattack_Left_Response_Activator, 1, 5)
				
			end
			
			if Rule_Exists(Axis_Counterattack_Right_Response_Activator) == false then
				
				Rule_AddDelayedInterval(Axis_Counterattack_Right_Response_Activator, 2, 5)
				
			end
			
			g_response_respawn_timer = 0 		
			
		end
	end
end


function Axis_Counterattack_Smoke_Monitor()

	if Prox_AreSquadMembersNearMarker(sg_counterattack_force, mkr_smoke_mortar_detect, false) then
		
		Rule_AddInterval(Axis_Counterattack_Drop_Smoke, 1)
		
		Rule_RemoveMe()
		
	end


end


function Axis_Counterattack_Drop_Smoke()

	if g_smoke_launched <= 2 then
			
		local random_position = Util_GetRandomPosition(mkr_counterattack3_smoke_mortar)
		
		Cmd_Ability(player2, ABILITY.SP.SINGLE_MORTAR_SMOKE , random_position, nil, true)
		
		g_smoke_launched = g_smoke_launched + 1
		
	elseif g_smoke_launched >=3 then
		
		Rule_RemoveMe()
		
	end


end

	
	
	
	
	
	
	
	
-------------------------------------------------------------------------
-- HENSCHEL ACTION
-------------------------------------------------------------------------


function Axis_Counterattack_Henschel_Control()

	if fg_axis_retreat ~= true and Rule_Exists(Axis_Counterattack_Henschel_Attack_Timer) == false then
		Rule_AddInterval(Axis_Counterattack_Henschel_Attack_Timer, 1)
	end

end


function Axis_Counterattack_Henschel_Attack_Timer()

	if fg_axis_retreat == true then
		
		Rule_RemoveMe()
		
	elseif Rule_Exists(Axis_Counterattack_Henschel_Attack) == false and fg_axis_retreat == false then
		
		local random_attack_time = World_GetRand(45, 45) -- 60, 90
		
		Rule_AddDelayedInterval(Axis_Counterattack_Henschel_Attack, random_attack_time, 1)
		Rule_RemoveMe()
		
	end

end




function Axis_Counterattack_Henschel_Attack()
	
	if fg_axis_retreat == true then
		
		Rule_RemoveMe()
		
	else
		
		local target = sg_henschel_squad_target
		-- if the concentration is empty, then check again
		if SGroup_IsEmpty(target) then
			
			target = Player_GetSquadConcentration(player1)
			
			-- if the concentration is still empty, then check to see if the entity concentration is empty
			if SGroup_IsEmpty(target) then  
				
				-- if entity concentration is empty then grab more entities
				if EGroup_IsEmpty(eg_henschel_entity_target) == true then
					
					target = Player_GetEntityConcentration(player1)
					
					-- if entity group is still empty then
					if EGroup_IsEmpty(target) then
						
						-- do nothing
						Rule_RemoveMe()
						return
						
					end
				end
			end
		end
		
		-- the full attack, several planes per strafing run
		local ability = ABILITY.COMMANDER_TREE.ELITE.HENSCHEL
		-- on easy and normal, only 1 attack
		if g_difficulty < 2 then ability = ABILITY.SP.HENSCHEL_ALL end
		Cmd_Ability(player2, ability, target, nil, true)
		
		Rule_RemoveMe()
		
	end

end



-- if the player decides to run into No Man's Land before he's supposed to...
function Axis_Counterattack_Henschel_Control_No_Mans()

	if fg_axis_retreat == true then
		
		Rule_RemoveMe()
		
	else
		
		Rule_AddInterval(Axis_Counterattack_Henschel_Attack_Timer_No_Mans, 5)
		Rule_RemoveMe()
		
	end
	


end

-- detector
function Axis_Counterattack_Henschel_Attack_Timer_No_Mans() 

	if fg_axis_retreat == true then
	
		Rule_RemoveMe()
		
	else
		
		if Prox_ArePlayersNearMarker(player1, mkr_no_mans_land, false) then
		
			local random_attack_time = World_GetRand(1, 2)
			print(random_attack_time)
			
			if Rule_Exists(Axis_Counterattack_Henschel_Attack_No_Mans) == false and fg_axis_retreat == false then
				
				Rule_AddDelayedInterval(Axis_Counterattack_Henschel_Attack_No_Mans, random_attack_time, 1)
				Rule_RemoveMe()
				
			end
			
			
		end
		
	end

end



-- if the player decides to run into No Man's Land before he's supposed to...
function Axis_Counterattack_Henschel_Attack_No_Mans()

	if fg_axis_retreat == true then
		
		Rule_RemoveMe()
		
	else
		
		local target = sg_henschel_squad_target_no_mans
		
		if SGroup_IsEmpty(target) then  
			
			Player_GetAllSquadsNearMarker(player1, sg_henschel_squad_target_no_mans, mkr_no_mans_land)
			
			target = sg_henschel_squad_target_no_mans
			
			-- if the sgroup is still empty, then check to see if the egroup is empty
			if SGroup_IsEmpty(target) then  
				
				if EGroup_IsEmpty(eg_henschel_entity_target_no_mans) == true then
					
					Player_GetAllEntitiesNearMarker(player1, eg_henschel_entity_target_no_mans, mkr_no_mans_land)
					
					target = eg_henschel_entity_target_no_mans
					
					-- if entity group is still empty then
					if EGroup_IsEmpty(target) == true then
						
						-- do nothing
						Rule_RemoveMe()
						return
						
					end
				end
			end
		end
		
		-- will not occur unless the enemy units can 'see' the target
		Cmd_Ability(player2, ABILITY.COMMANDER_TREE.ELITE.HENSCHEL, target, nil, true)
		Rule_AddDelayedInterval(Axis_Counterattack_Henschel_Control_No_Mans, 15, 1)
		Rule_RemoveMe()
		
	end	

end



-------------------------------------------------------------------------
-- HUMMEL ACTION
-------------------------------------------------------------------------

-- FIX -- have this roll into position instead of blinking in?
function Axis_Counterattack_Spawn_Hummel()

	Util_CreateSquads(player2, sg_no_mans_hummel, SBP.ELITE.HUMMEL, mkr_hummel_spawn)
	
end

-- called in after the 1st objective is complete AND during the counterattacks
function Axis_Counterattack_Hummel_Barrage_Control()
	
	if SGroup_IsEmpty(sg_no_mans_hummel) then
		
		Rule_RemoveMe()
		
	elseif Rule_Exists(Axis_Counterattack_Hummel_Barrage) == false then
	
		local random_attack_time = World_GetRand(1, 1)
		Rule_AddDelayedInterval(Axis_Counterattack_Hummel_Barrage, random_attack_time, 1)
		Rule_RemoveMe()
		
	end

end


-- uses the Hummel No Man's land detection
function Axis_Counterattack_Hummel_Barrage() 

	if SGroup_IsEmpty(sg_no_mans_hummel) == false then
		
		local random_emplacement_area = World_GetRand(1, table.getn(tmkr_counterattack_barrage_locations))
		local pos = Util_GetPosition(tmkr_counterattack_barrage_locations[random_emplacement_area])
		Cmd_Ability(sg_no_mans_hummel, ABILITY.ELITE.HUMMEL_BARRAGE, pos, nil, true) 
		
		Rule_RemoveMe()
	end

end


-- first contact with counterattack!
function Axis_Counterattack_First_Contact() 

	if Player_CanSeeSGroup(player1, sg_counterattack_force, false) then
		
		Util_AutoIntel(t_build_defenses_dialogue.first_contact)
		
		Rule_RemoveMe()
		
	end
	
end



-------------------------------------------------------------------------
-- COUNTERATTACK - PLAYER ADVANCES
-------------------------------------------------------------------------

-- created to counter the player intruding when they aren't supposed to.
function Axis_Counterattack_Response_Init()

	sg_counterattack_responders_left = SGroup_CreateTable("sg_counterattack_responders_left%d", 4)
	sg_counterattack_responders_left_total = SGroup_CreateIfNotFound("sg_counterattack_responders_left_total")
	sg_counterattack_responders_right = SGroup_CreateTable("sg_counterattack_responders_right%d", 4)
	sg_counterattack_responders_right_total = SGroup_CreateIfNotFound("sg_counterattack_responders_right_total")
	sg_left_leader = SGroup_CreateIfNotFound("sg_left_leader")
	sg_right_leader = SGroup_CreateIfNotFound("sg_right_leader")
	
	sg_left_targets = SGroup_CreateIfNotFound("sg_left_targets")
	sg_right_targets = SGroup_CreateIfNotFound("sg_right_targets")
	
	g_left_leader = sg_counterattack_responders_left[1]
	g_right_leader =  sg_counterattack_responders_right[1]

end


function Axis_Counterattack_Left_Response_Activator()

	if fg_axis_retreat == true or fg_right_activated then
		
		Rule_RemoveMe()
		
	else
		-- if players are in left detection area then...
		if Prox_ArePlayerMembersNearMarker(player1, mkr_counterattack_response_left_detect, false) then 
			
			fg_left_activated = true -- activate flag to stop the right side detection since a response force will be created
			
			Rule_RemoveMe()
			
		end
		
	end
end



function Axis_Counterattack_Right_Response_Activator()

	if fg_axis_retreat == true or fg_left_activated then
		Rule_RemoveMe()
		
	else
		-- if players are in right detection area then...
		if Prox_ArePlayerMembersNearMarker(player1, mkr_counterattack_response_right_detect, false) then 
			
			fg_right_activated = true -- activate flag to stop the right side detection since a response force will be created
			
			Rule_RemoveMe()
			
		end
		
	end
end








------------------------------------

-- checks to see if the objective is complete

function Axis_Counterattack_WinCheck()

	if fg_axis_retreat == true then
		
		--Objective_Complete(OBJ_Axis_Counterattack)
		Objective_Complete(OBJ_Build_Defenses)
		
		Util_AutoIntel(t_counterattack_dialogue.repulsed)	-- DON'T FORGET repulsed2  sitrep first though
		
		for j = 1, table.getn(tmkr_counterattack_reveal_area) do
			
			FOW_UnRevealMarker(tmkr_counterattack_reveal_area[j])
		
		end
		
		
		fg_first_objective_active = true
		
		Rule_AddInterval(Axis_Counterattack_Secure_Airfield_Delay, 1)
		
		Rule_RemoveMe()
		
	end

end


function Axis_Counterattack_Secure_Airfield_Delay()

	if Event_IsAnyRunning() == false then
		
		Rule_AddInterval(Axis_Counterattack_Secure_Airfield_Real_Delay, 1)
		
		Rule_RemoveMe()
		
	end

end

function Axis_Counterattack_Secure_Airfield_Real_Delay()

	if Event_IsAnyRunning() == false then
		
		fg_axis_secure_airfield_start = true
		
		Rule_AddDelayedInterval(Axis_Objective_Delay, 5, 1)
		
		Rule_RemoveMe()
		
	end
	
end


function Axis_Objective_Delay()

	if Event_IsAnyRunning() == false then
		
		fg_first_objective_active = true
		
		Rule_RemoveMe()
		
	end
	
end




-------------------------------------------------------------------------

-- Neutralize 88s
-- Neutralize the 88s by taking out the spawn building, the guns, themselves, or capture them
-- Kind of messy due to retrofitting from old style encounter I made
-- THE PING CHECK IN THIS HAS BEEN INCORPORATED INTO VARIOUS FUNCTIONS DUE TO ITS CONSTRUCTION

-------------------------------------------------------------------------


-------------------------------------------------------------------------
-- Build Defenses
-- Main objective, build defenses
-- Player must build defenses in preparation of an imminent Axis counterattack
-------------------------------------------------------------------------
function Initialize_OBJ_Neutralize_88s()

	OBJ_Neutralize_88s = {
		
		SetupUI = function() 
			
			
			
		end,
		
		OnStart = function()
			
			-- announce the goal
		
			
			-- win/lose check
			
			Rule_AddInterval(Neutralize_88s_WinCheck, 5)
			
			-- start related action
			Rule_AddOneShot(Neutralize_88s_Kickoff, 0)
				
			
			
			-- ui check here
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1349103,
		Description = 1349113,
		Type = OT_Secondary,
		
	}
	
	-- Register Objective
	Objective_Register(OBJ_Neutralize_88s)
	
	-- Initialize Data
	

end



----------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Neutralize_88s_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_gun_guard1 = SGroup_CreateIfNotFound("sg_gun_guard1") -- occupies spawn building so player 2 doesn't lose ownership
	sg_runway_88_crew1 = SGroup_CreateIfNotFound("sg_runway_88_crew1")
	sg_runway_88_crew2 = SGroup_CreateIfNotFound("sg_runway_88_crew2")
	--sg_runway_88_crew_members = --SGroup_CreateTable("sg_runway_88_crew0%d", 2)
	
	sg_runway_88_crew_members = {sg_runway_88_crew1, sg_runway_88_crew2}
	
	sg_runway_88_crew_members_combined = SGroup_CreateIfNotFound("sg_runway_88_crew_members_combined")
	
	t_kill88 ={
		
		spawn ={
			
			{name =  sg_runway_88_crew1, blueprint = SBP.ELITE.LUFTWAFFE, loc = mkr_runway_88_crew1_spawn, 1}, --SBP.AXIS.VOLKSGRENADIER
			{name =  sg_runway_88_crew2, blueprint = SBP.ELITE.LUFTWAFFE, loc = mkr_runway_88_crew2_spawn, 1}, --SBP.AXIS.VOLKSGRENADIER
			
		},
	}
	
	tmkr_runway_88_crew_exit = {mkr_runway_88_crew1_spawn, mkr_runway_88_crew2_spawn}
	
	--tmkr_runway_88_crew_exit = {mkr_88_crew_respawn1, mkr_88_crew_respawn2}	
	
	if EGroup_IsEmpty(eg_runway_building_guard) == false then -- sets crew spawn building to enemy and upgrades it
		EGroup_SetPlayerOwner(eg_runway_building_guard, player2)
		Cmd_InstantUpgrade(eg_runway_building_guard, UPG.AXIS.CONVERT_AMBIENT_BUILDING, 1)
    end
	
	g_crew1_timer = 0
	b_crew1_ready = true
	g_crew2_timer = 0
	b_crew2_ready = true
	
	tb_crew_readiness = {true, true}
	tg_crew_timer = {0, 0}
	
	--sw_runway_88_gun1 = SyncWeapon_GetFromEGroup(eg_runway_88_gun1)
	--sw_runway_88_gun2 = SyncWeapon_GetFromEGroup(eg_runway_88_gun2)
	--tsw_runway_88_guns = {sw_runway_88_gun1, sw_runway_88_gun2}
	--teg_runway_88_guns = {eg_runway_88_gun1, eg_runway_88_gun2}
	
	teg_runway_88_guns = {eg_bodenturm1, eg_bodenturm2}
	
	--eg_runway_88_guns = EGroup_CreateIfNotFound("eg_runway_88_guns")
	eg_bodenturms = EGroup_CreateIfNotFound("eg_bodenturms")
	
	
	tb_syncweapon_captured = {false, false} -- boolean for if the player has captured the guns
	g_syncweapon_base_count = 0
	g_syncweapon_captured_count = 0
	
	t_guns = {
		
		checklist = {
			{name = eg_bodemturm1, destroyed = false, visible = false, ping_id = false},
			{name = eg_bodemturm2, destroyed = false, visible = false, ping_id = false},
			
			--{name = eg_runway_88_gun1, destroyed = false, visible = false, ping_id = false},
			--{name = eg_runway_88_gun2, destroyed = false, visible = false, ping_id = false},
			
		},
		
	}
	
	--g_destroyed_flak88s = 0
	
	--tmkr_flak88_crew_exit = {mkr_flak88_crew_exit1 ,mkr_flak88_crew_exit2}
	
	t_kill88.status = {
		
		fg_all_destroyed	= false,			-- flag to indicate that all the flaks are dead
		fg_all_captured 	= false,			-- flag to check whether all the flaks are captured
		fg_bunker_clear = false,	-- flag to check whether the flak crew spawn has been neutralized (exists or is captured)
		fg_guns_unmanned = true,	-- flag to check whether all the flaks are unmanned by player 2
		fg_runway_88_ended = false
		
	}
	
	p1_gun1_captured = false
	p1_gun2_captured = false
	tg_gun_capture_state = {false, false}
	
	t_88s_dialogue = {
		
		manning_88s = {
			{ACTOR.CXP1.GenericPanzerElite, 1341230}, -- Tommies sighted!  Don't let those turrets fall into their hands!
			{ACTOR.CXP1.Degnan, 1341240}, -- Turrets to the front.  Knock them out!
		},
		
		-- NEEDS TO BE ADDED?  AMBIENT?
		nag_88s = {
			
			{ACTOR.CXP1.Chubb, 1341250}, -- Goddamn I want those turrets out of commission. NOW!
			{ACTOR.CXP1.Chubb, 1341260}, -- Listen up, neutralize those turrets now.
		},
		
		
		neutralized_88s = {
			
			{ACTOR.CXP1.Seville, 1341270}, -- Good work! We've neutralized those turrets.
			
		},
	}
	
	
	--weapon pickups
	tmkr_neutralize_88s_pickups = Marker_GetTable("mkr_neutralize_88s_pickup%d")
	g_88s_pickup_count = table.getn(tmkr_neutralize_88s_pickups)
	teg_88s_pickups = EGroup_CreateTable("eg_88s_pickups%d", g_88s_pickup_count)	
	
	t_88s_pickups =	{
		
		{name = teg_88s_pickups[1], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_neutralize_88s_pickups[1]},
		{name = teg_88s_pickups[2], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_neutralize_88s_pickups[2]},
		{name = teg_88s_pickups[3], blueprint = EBP.PICKUP.AXIS.LMG_42, loc = tmkr_neutralize_88s_pickups[3]},
		
	}
	
end


-- preset any units or events needed before the kickoff
function Neutralize_88s_Preset()

	-- spawn 88 crew squads
	for k, v in pairs(t_kill88.spawn) do
		
		local runway_88s = v
		
		Util_CreateSquads(player2, runway_88s.name, runway_88s.blueprint, runway_88s.loc)

		SGroup_AddGroup(sg_runway_88_crew_members_combined, runway_88s.name)
		
	end
	
	
	if EGroup_IsEmpty(eg_runway_building_guard) == false then 
		Util_CreateSquads(player2, sg_gun_guard1, t_dif.g_soldier_type2, eg_runway_building_guard, nil, 1, 1)
	end
	
	if EGroup_IsEmpty(eg_runway_building_guard) == false then -- sets crew spawn building to enemy and upgrades it
		EGroup_SetPlayerOwner(eg_runway_building_guard, player2)
		Cmd_InstantUpgrade(eg_runway_building_guard, UPG.AXIS.CONVERT_AMBIENT_BUILDING, 1)
    end
	
	
		-- spawns pickups
	for k, v in pairs(t_88s_pickups) do
	
		local pickup = v
		
		Util_CreateEntities(nil, pickup.name, pickup.blueprint, pickup.loc, 1)
	
	end
	-- start enemy behavior

	-- do other cool things

end


-- start the related action
function Neutralize_88s_Kickoff()
	-- action that starts when this encounter is triggered

	Util_AutoIntel(t_88s_dialogue.manning_88s)
	
	-- adds pings
	OBJ_Neutralize_88s.gunpingID = {}
	-- these will be filled in when the guns are actually manned
	OBJ_Neutralize_88s.gunpingID[1] = false --Gun1
	OBJ_Neutralize_88s.gunpingID[2] = false --Gun2
	OBJ_Neutralize_88s.spawnID = Objective_AddUIElements(OBJ_Neutralize_88s, eg_gun_crew_spawn, true, 1349152, true, 1.5)
	
	--TEMP DISABLE, SO THAT IAN CAN ADD THE NEW GUNS
	Rule_AddOneShot(Neutralize_88s_First_Capture_Command, 1)
	
	-- start nag speech
	Rule_AddDelayedInterval(Turret_Nag_Control, 60, 1)
	
end


-- tells initial crew 1 to capture the gun
function Neutralize_88s_First_Capture_Command()
	
	if EGroup_IsEmpty(teg_runway_88_guns[1]) == false then
		
		if SGroup_IsEmpty(t_kill88.spawn[1].name) == false then
			Cmd_Garrison(t_kill88.spawn[1].name, teg_runway_88_guns[1])
		end
		
	end
	Rule_AddOneShot(Neutralize_88s_Second_Capture_Command, 5)
	
end

-- tells initial crew 2 to capture the gun
function Neutralize_88s_Second_Capture_Command()
	
	if EGroup_IsEmpty(teg_runway_88_guns[2]) == false then
		
		if SGroup_IsEmpty(t_kill88.spawn[2].name) == false then
			Cmd_Garrison(t_kill88.spawn[2].name, teg_runway_88_guns[2])
		end
		
	end
	
	Rule_AddOneShot(Neutralize_88s_Behaviour_Delay, 2)
	
end

-- kicks off gun grew behaviour
function Neutralize_88s_Behaviour_Delay()
	
	Rule_AddInterval(Neutralize_88s_Gunstates_Checker, 1)
	Rule_AddInterval(Neutralize_88s_Gunstates_Captured_Checker, 1)
	Rule_AddInterval(Neutralize_88s_Crew_Spawn_Site_Checker, 1)
	Rule_AddInterval(Neutralize_88s_Unmanned_Check, 1)
	Rule_AddInterval(Neutralize_88s_Crew_Idle_Fixer, 5)
	Rule_AddInterval(Neutralize_88s_Crew_Checker, 5)
	
	Rule_AddInterval(Neutralize_88s_Cleanup_Check, 1) -- calls the cleanup function
	
end

-- checks to see if the crew is not there, and other behaviour
function Neutralize_88s_Crew_Checker()

	local status = t_kill88.status

	--print("check enabled")
	if status.fg_runway_88_ended == true then 
		--if either all the guns are captured or destroyed by player 1, then remove this rule
		Rule_RemoveMe()
		
	else
		
		for a = 1, table.getn(sg_runway_88_crew_members)do
			
			if SGroup_IsEmpty(sg_runway_88_crew_members[a]) then
				
				if EGroup_IsEmpty(teg_runway_88_guns[a]) == true then
					
					-- do nothing
					
				else
					
					-- does the weapon exist and is owned by player 2?
					
					if Player_OwnsEGroup(player2, teg_runway_88_guns[a]) then
					
					-- above check failed, the gun is not owned by player 2
					
					elseif (tg_crew_timer[a] < 9) then
						
						--print("timer < 9!")
						tg_crew_timer[a] = tg_crew_timer[a] + 1
						--print(tg_crew_timer[a])
						
					-- if the counter is over 45, we're ready to spawn another squad
					elseif (tg_crew_timer[a] >= 9) then
						--print("timer >= 9!")
						
						-- check to see if the spawn building exists (i.e. not destroyed) or is owned by another player.  Will only spawn if building exists
						-- and is owned by player2
						if EGroup_IsEmpty(eg_gun_crew_spawn) == false and Player_OwnsEGroup(player2, eg_gun_crew_spawn) then
							
							Util_CreateSquads(player2, sg_runway_88_crew_members[a], SBP.ELITE.LUFTWAFFE, tmkr_runway_88_crew_exit[a], nil, 1, 3 )
							
							SGroup_AddGroup(sg_runway_88_crew_members_combined, sg_runway_88_crew_members[a])
							
							tg_crew_timer[a] = 0
							
							break
						end
						
					end
					
				end
				
				-- the sgroup is NOT empty	
			elseif EGroup_IsEmpty(teg_runway_88_guns[a]) == false 
			and Player_OwnsEGroup(player2, teg_runway_88_guns[a])== false 
			and Player_OwnsEGroup(player1, teg_runway_88_guns[a]) == false then
				
				-- is the Sgroup >= 3?  If so, then send them to the gun
				if SGroup_TotalMembersCount(sg_runway_88_crew_members[a]) >= 3 then
					
					Cmd_Garrison(sg_runway_88_crew_members[a], teg_runway_88_guns[a])
					
				-- is the Sgroup <= 2?  If not, then send them back to their spawn building to get reinforcements
				elseif SGroup_TotalMembersCount(sg_runway_88_crew_members[a]) <= 2 then
					
					-- makes sure the spawning building exists!
					if EGroup_IsEmpty(eg_gun_crew_spawn) == false and Player_OwnsEGroup(player2, eg_gun_crew_spawn) then
					
						Cmd_Retreat(sg_runway_88_crew_members[a], tmkr_runway_88_crew_exit[a]) -- EGroup_GetPosition(eg_gun_crew_spawn)
						Cmd_ReinforceUnit(sg_runway_88_crew_members[a], 1)
						break
						
					end
					
				end 
				
			end
			
		end
		
	end
	
end


function Neutralize_88s_SyncWeaponCheck(syncID, playerID)
	-- function that checks to see if a syncweapon exists, and is owned by a player.  If so, this function returns a true, and if not, it returns a false.
	if SyncWeapon_Exists(syncID) and SyncWeapon_IsOwnedByPlayer(syncID, playerID) then
		return true
	else
		return false
	end
end


function Neutralize_88s_Crew_Idle_Fixer()
-- checks to see if the gun crews are idle.  If they are idle and not in combat then they are sent towards their respective guns.
	-- cycles through the sgroup table that contains all the crew members
	
	local status = t_kill88.status
	
	if status.fg_runway_88_ended ==  true then
	
		Rule_RemoveMe()
	
	else
	
		for c = 1, table.getn(sg_runway_88_crew_members) do
			
			-- is the sgroup in question empty? if not then continue
			if SGroup_IsEmpty(sg_runway_88_crew_members[c]) == false then
				
				if Squad_GetActiveCommand(SGroup_GetSpawnedSquadAt(sg_runway_88_crew_members[c], 1 ) ) == SQUADSTATEID_Idle then
					
					
					if EGroup_IsEmpty(teg_runway_88_guns[c]) == false and Player_OwnsEGroup(player2, teg_runway_88_guns[c])== false and Player_OwnsEGroup(player1, teg_runway_88_guns[c]) == false  then --Neutralize_88s_SyncWeaponCheck(tsw_runway_88_guns[c], nil)
						
						Cmd_Garrison(sg_runway_88_crew_members[c], teg_runway_88_guns[c])
						
						break
						
					end
					
				end
				
			end
		end
	end
	
end

-- checks to see if a gun is destroyed
function Neutralize_88s_Gunstates_Checker()
	
	--print(EGroup_IsEmpty(eg_runway_88_guns))
	
	local status = t_kill88.status
	
	if status.fg_runway_88_ended == true then
		
		Rule_RemoveMe()
		
	else
		
		-- checks to see if guns are destroyed...
		if EGroup_IsEmpty(eg_bodenturms) == true then
			
			--print("guns destroyed")
			
			status.fg_all_destroyed = true
			
			Rule_RemoveMe()
			
		else
			for b = 1, table.getn(teg_runway_88_guns)do	
				
				if EGroup_IsEmpty(teg_runway_88_guns[b]) == false then
					
				elseif EGroup_IsEmpty(teg_runway_88_guns[b]) == true then
					
					Objective_RemoveUIElements(OBJ_Secure_Airfield, OBJ_Neutralize_88s.gunpingID[b])
					
				end
				
			end
		end
	end
end

-- checks to see if a gun is captured
function Neutralize_88s_Gunstates_Captured_Checker()
	
	local status = t_kill88.status
	
	-- checks the status of the flak 88s
	if status.fg_runway_88_ended == true then  --use Objective_IsComplete(OBJ_Neutralize_88s) instead of g_Neutralize_88s_OBJComplete == true?
		
		Rule_RemoveMe()
		
	else
		
		for v = 1, table.getn(teg_runway_88_guns) do
			
			local guns = teg_runway_88_guns
			
			if EGroup_IsEmpty(guns[v]) == false and Player_OwnsEGroup(player1, guns[v]) == true and tg_gun_capture_state[v] == false then
				
				tg_gun_capture_state[v] = true
				
			end
			
		end
		
		if tg_gun_capture_state[1]== true and tg_gun_capture_state[2]== true then
			
			t_kill88.status.fg_all_captured = true
			
		else
			
			t_kill88.status.fg_all_captured = false
			
		end
		
	end	
end
	
-- checks to see if the spawn point for the men are neutralized
function Neutralize_88s_Crew_Spawn_Site_Checker()

	local status = t_kill88.status
	
	if status.fg_runway_88_ended == true then 
		
		Rule_RemoveMe()
		
	else
		
		--checks to see if the flak crew spawn building is empty, or is owned by the computer player
		if EGroup_IsEmpty(eg_gun_crew_spawn) == false and Player_OwnsEGroup(player2, eg_gun_crew_spawn) then
			
			t_kill88.status.fg_bunker_clear = false
			
		elseif EGroup_IsEmpty(eg_gun_crew_spawn) == true or Player_OwnsEGroup(player2, eg_gun_crew_spawn) == false then
			
			t_kill88.status.fg_bunker_clear = true
			
			if SGroup_IsEmpty(sg_runway_88_crew_members_combined) == false 
			and (status.fg_all_captured == true or status.fg_all_destroyed == true) then
				
				Cmd_Retreat(sg_runway_88_crew_members_combined, mkr_gun_crew_retreat)
				
			end	
			
			
			
		end
		
	end

end

-- checks to see if a gun has nobody on it
function Neutralize_88s_Unmanned_Check()
	
	local status = t_kill88.status
	
	-- function checks to see if the flak88s are unmanned

	--if objective is complete then remove
	if status.fg_runway_88_ended == true then 
		
		Rule_RemoveMe()
		
	else
		
		local UnmannedbyP2 = true -- meaning either unmanned or otherwise not owned by player 2
		
		for k,egroup in pairs(teg_runway_88_guns) do  --tsw_runway_88_guns
			
			-- if any one of the weapons exists and is owned by player 2 then we can assumed that at least one of them are manned
			if EGroup_IsEmpty(egroup) == false then
				
				if Player_OwnsEGroup(player2, egroup) then	
					-- add ping
					if OBJ_Neutralize_88s.gunpingID[k] == false then
						OBJ_Neutralize_88s.gunpingID[k] = Objective_AddUIElements(OBJ_Neutralize_88s, egroup, true, 1349151, true)
					end
					
					UnmannedbyP2 = false
				else
					-- remove ping
					if OBJ_Neutralize_88s.gunpingID[k] ~= false then
						Objective_RemoveUIElements(OBJ_Neutralize_88s, OBJ_Neutralize_88s.gunpingID[k])
						OBJ_Neutralize_88s.gunpingID[k] = false
					end
					
				end
				
			end
			
		end
		
		-- checks to see if unmanned by P2
		if UnmannedbyP2 == true then
			
			--print("unmanned!")
			
			t_kill88.status.fg_guns_unmanned = true
			
		else
			
			t_kill88.status.fg_guns_unmanned = false
			
		end
		
	end
		
end


-- cleanup function for 88s. if everything for this objective has been completed, 
-- then remove pings (if they haven't been removed yet) and set overall completion flags
function Neutralize_88s_Cleanup_Check()
	
	local status = t_kill88.status
	
	if (status.fg_bunker_clear == true and status.fg_guns_unmanned == true) 
	or (status.fg_all_captured == true or status.fg_all_destroyed == true) then
		
		Objective_RemoveUIElements(OBJ_Neutralize_88s, OBJ_Neutralize_88s.gunpingID[1])
		Objective_RemoveUIElements(OBJ_Neutralize_88s, OBJ_Neutralize_88s.gunpingID[2])
		Objective_RemoveUIElements(OBJ_Neutralize_88s, OBJ_Neutralize_88s.spawnID)
		
		status.fg_runway_88_ended = true -- sets the flag that indicates this section of the mission is complete to true
		
		-- for the objective controller function
		t_secureAirfield.completed.neutralize_88s_completed = true 
		
		if SGroup_IsEmpty(sg_runway_88_crew_members_combined) == false then
			
			Cmd_Retreat(sg_runway_88_crew_members_combined, mkr_gun_crew_retreat)
			
		end
		
		Rule_RemoveMe()
		
	end

end

function Neutralize_88s_WinCheck()
	
	if t_kill88.status.fg_runway_88_ended == true then
		
		Objective_Complete(OBJ_Neutralize_88s, true)
		
		Util_AutoIntel(t_88s_dialogue.neutralized_88s)
		
		Rule_RemoveMe()
		
	end

end
-------------------------------------------------------------------------
-- Clear Hangars - Clear Hangars Sub Objective - Functions 
-- Player has to kill all enemies in the area
-- Every time a hangar area is cleared, a hangar ping disappears
-- treat like encounter!
-------------------------------------------------------------------------

function Clear_Hangars_Init()

	-- define sgroups, egroups, etc associated with this obj
	sg_hangar1_guard1 = SGroup_CreateIfNotFound("sg_hangar1_guard1")
	sg_hangar1_guard2 = SGroup_CreateIfNotFound("sg_hangar1_guard2")
	sg_hangar1_guards = SGroup_CreateIfNotFound("sg_hangar1_guards")
	
	sg_hangar2_guard1 = SGroup_CreateIfNotFound("sg_hangar2_guard1")
	sg_hangar2_guard2 = SGroup_CreateIfNotFound("sg_hangar2_guard2")
	sg_hangar2_guard3 = SGroup_CreateIfNotFound("sg_hangar2_guard3")
	sg_hangar2_guards = SGroup_CreateIfNotFound("sg_hangar2_guards")
	
	sg_hangar3_guard1 = SGroup_CreateIfNotFound("sg_hangar3_guard1")
	sg_hangar3_guard2 = SGroup_CreateIfNotFound("sg_hangar3_guard2")
	sg_hangar3_guard3 = SGroup_CreateIfNotFound("sg_hangar3_guard3")
	sg_hangar3_guard4 = SGroup_CreateIfNotFound("sg_hangar3_guard4")
	sg_hangar3_guards = SGroup_CreateIfNotFound("sg_hangar3_guards")
	
	--sg_hangar_tank1 = SGroup_CreateIfNotFound("sg_hangar_tank1")
	--sg_hangar_tank2 = SGroup_CreateIfNotFound("sg_hangar_tank2")
	
	tmkr_hangar_tanks = Marker_GetTable("mkr_hangar_tank%d")
	
	tsg_hangar_tanks = SGroup_CreateTable("sg_hangar_tank%d", table.getn(tmkr_hangar_tanks))
	tsg_hangar_tanks_attacker = SGroup_CreateTable("sg_hangar_tanks_attacker%d", table.getn(tmkr_hangar_tanks))
	sg_hangar_tank_force = SGroup_CreateIfNotFound("sg_hangar_tank_force")
	
	sg_hangar_forces = SGroup_CreateIfNotFound("sg_hangar_forces")
	
	sg_hangar_spawn_guard = SGroup_CreateIfNotFound("sg_hangar_spawn_guard")
	
	tmkr_hangar_pickups = Marker_GetTable("mkr_hangar_pickups%d")
	g_hangar_pickup_count = table.getn(tmkr_hangar_pickups)
	teg_hangar_pickups = EGroup_CreateTable("eg_hangar_pickups%d", g_hangar_pickup_count)
	
	tmkr_hangar_mortars = Marker_GetTable("mkr_hangar_mortar_squad%d")
	g_hangar_mortar_count = table.getn(tmkr_hangar_mortars)
	tsg_hangar_mortars = SGroup_CreateTable("sg_hangar_mortar%d", g_hangar_mortar_count)
	
	tmkr_runway_defenders = Marker_GetTable("mkr_runway_defenders%d")
	g_runway_defender_count = table.getn(tmkr_runway_defenders)
	tsg_runway_defenders = SGroup_CreateTable("sg_runway_defenders%d", g_runway_defender_count)
	
	
	
	if EGroup_IsEmpty(eg_runway_defender_spawn) == false then
		EGroup_SetPlayerOwner(eg_runway_defender_spawn, player2)
		Cmd_InstantUpgrade(eg_runway_defender_spawn, UPG.AXIS.CONVERT_AMBIENT_BUILDING, 1)
		g_west_defense_spawn = eg_runway_defender_spawn
	else
		
		g_west_defense_spawn = mkr_west_alternate_spawn1
		
	end
	
	-- hangar spawn table info
	t_hangar_spawn_table ={
		
		hangar1_guards ={
			
			{name =  sg_hangar1_guard1, blueprint = t_dif.g_soldier_type2, loc = mkr_hangar1_guard1, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 5, dest = mkr_hangar1_fallback1, active = false},
			{name =  sg_hangar1_guard2, blueprint = t_dif.g_soldier_type3, loc = mkr_hangar1_guard2, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 5, dest = mkr_hangar1_fallback2, active = false},
		},
		
		hangar2_guards = {
			
			{name =  sg_hangar2_guard1, blueprint = t_dif.g_soldier_type2, loc = mkr_hangar2_guard1, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 5, dest = mkr_hangar2_fallback1, active = false},
			{name =  sg_hangar2_guard2, blueprint = t_dif.g_soldier_type3, loc = mkr_hangar2_guard2, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 5, dest = mkr_hangar2_fallback2, active = false},
			{name =  sg_hangar2_guard3, blueprint = t_dif.g_soldier_type1, loc = mkr_hangar2_guard3, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 3, dest = mkr_hangar2_fallback3, active = false},
		},
		
		hangar3_guards = {
			
			{name =  sg_hangar3_guard1, blueprint = t_dif.g_soldier_type2, loc = mkr_hangar3_guard1, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 5, dest = mkr_hangar3_fallback1, active = false},
			{name =  sg_hangar3_guard2, blueprint = t_dif.g_soldier_type2, loc = mkr_hangar3_guard2, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 5, dest = mkr_hangar3_fallback2, active = false},
			{name =  sg_hangar3_guard3, blueprint = t_dif.g_soldier_type3, loc = mkr_hangar3_guard3, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 5, dest = mkr_hangar3_fallback3, active = false},
			{name =  sg_hangar3_guard4, blueprint = t_dif.g_soldier_type1, loc = mkr_hangar3_guard4, number = 1, alternatespawn = mkr_hangar_spawn_backup, size = 2, dest = mkr_hangar3_fallback4, active = false},
		},
		
		tanks ={
			{name = tsg_hangar_tanks[1], blueprint = SBP.AXIS.PANZER, loc = mkr_hangar_tank1, number = 1, attacker = tsg_hangar_tanks_attacker[1]},
			{name = tsg_hangar_tanks[2], blueprint = SBP.AXIS.PANZER, loc = mkr_hangar_tank2, number = 1, attacker = tsg_hangar_tanks_attacker[2]},
		},
		
		hangar_spawn_guard= {
			
			{name = sg_hangar_spawn_guard, blueprint = SBP.AXIS.HEAVYMG, loc = mkr_control_tower_hmg_guardian, alternatespawn = mkr_control_tower_hmg_guardian},
			
		},
		
		pickups = {
		
			{name = teg_hangar_pickups[1], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_hangar_pickups[1]},
			{name = teg_hangar_pickups[2], blueprint = EBP.PICKUP.AXIS.LMG_42, loc = tmkr_hangar_pickups[2]},
			{name = teg_hangar_pickups[3], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_hangar_pickups[3]},
			{name = teg_hangar_pickups[4], blueprint = EBP.PICKUP.AXIS.LMG_42, loc = tmkr_hangar_pickups[4]},
			{name = teg_hangar_pickups[5], blueprint = EBP.PICKUP.AXIS.MORTAR, loc = tmkr_hangar_pickups[5]},
			
		},
		
		mortars = {
		},
		
		runway_defenders = {
		},
		
	}
	
	
	for i = 1, g_hangar_mortar_count do -- populates stationary planes and pilots, depends on number of markers
		
		t_hangar_spawn_table.mortars[i] = {name = tsg_hangar_mortars[i], blueprint = SBP.AXIS.VOLKSGRENADIER, loc = mkr_west_alternate_spawn1, deployment = mkr_west_alternate_deployment, 
		deployed = false, destination = tmkr_hangar_mortars[i]}
		
	end
	
	for i = 1, g_runway_defender_count do -- populates stationary planes and pilots, depends on number of markers
		
		t_hangar_spawn_table.runway_defenders[i] = {name = tsg_runway_defenders[i], blueprint = SBP.AXIS.GRENADIER, loc = g_west_defense_spawn, 
		deployment = mkr_runway_defense_deployment, deployed = false, destination = tmkr_runway_defenders[i], size = 3 }
		
	end
	
	g_mortar_deploy_number = 0
	g_hangar_defender_deploy_number = 0
	
	-- objective flags
    t_clear_hangars = {
		fg_hangar1_neutralized	= false,			-- flag to indicate that hangar1 is neutralized
		fg_hangar2_neutralized	= false,			-- flag to indicate that hangar2 is neutralized
		fg_hangar3_neutralized	= false,			-- flag to indicate that hangar2 is neutralized
		fg_all_hangars_neutralized = false,			-- flag to indicate all hangars neutralized
	}
	
	
	g_hangar1_timer = 0
	g_hangar2_timer = 0
	g_hangar3_timer = 0
	
	g_hangar1_wave = 0
	g_hangar2_wave = 0
	g_hangar3_wave = 0
	
	g_hangar_respawn_max_wave = 1 -- controls the number of reinforcement waves that are sent back to the hangars
	
	g_hangar_respawn = 15
	g_hangar_max_respawn = 40 --(maximum time it takes to respawn, in seconds)
	g_hangar_respawn_loc = EGroup_GetPosition(eg_hangar_spawn)
	
	-- set up intel event tables
	t_hangar_dialogue = {
	
		begin_hangar = {
			
			{ACTOR.CXP1.Seville, 1341280}, -- Those Jerries are holed up in those hangars.  Time to flush them out!
			{ACTOR.CXP1.Seville, 1341330}, -- RCR your orders are to clear the hanger.
			{ACTOR.CXP1.Seville, 1341340}, -- You lot keep your eyes peeled for pockets of Jerries.
		},
		
		-- USED IN t_hangar_random_respawn_speech
		first_respawn = {
			
			{ACTOR.CXP1.GenericPanzerElite, 1341290}, -- Fuck, we're fucked!  The Allies are here!
			{ACTOR.CXP1.Degnan, 1341300}, -- More Jerries!  Send them back to the holes they came from!
		},
		
		-- NOT AMBIENT -- NOW IN EVENTS FILE
		hangar_nag = {
		
			{ACTOR.CXP1.Seville, 1341310}, -- Come on, step it up lads! There are still Axis soldiers in those hangars and we'd better take them out if we're to control this airfield.
			{ACTOR.CXP1.Seville, 1341320}, -- Get to it men?! Clear those hangars, now!
		
		},
		
		cleared_hangar = {
			
			-- first 2 lines are unused
			--{ACTOR.GenericAlly, 1341330}, --RCR your orders are to clear the hanger.
			--{ACTOR.GenericAlly, 1341340}, --You lot keep your eyes peeled for pockets of Jerries.
			
			{ACTOR.CXP1.Seville, 1341350}, --Excellent, the hangars are cleared.
		},
	}
	
	
	t_hangar_random_respawn_speech = {t_hangar_dialogue.first_respawn} 
	
	g_hangar_reinforced_speech = false
	g_hangar_initialSpawn = false
	
end

-- Presets Hangar dudes
function Clear_Hangars_Preset()
	
	-- spawns pickups
	for k, v in pairs(t_hangar_spawn_table.pickups) do
		
		Util_CreateEntities(nil, v.name, v.blueprint, v.loc, 1)
		
	end

	Rule_AddInterval(Clear_Hangars_PreSpawnCheck, 1)
end

-- Presets Hangar dudes
function Clear_Hangars_PreSpawnCheck()
	if t_counterAttack_go[3] == true then
		-- start spawning the hanger units
		Rule_AddInterval(Clear_Hangars_SpawnHangars, 1)
		
		Rule_RemoveMe()
	end
end

-- Presets Hangar dudes
function Clear_Hangars_SpawnHangars()
	local done = true
	if Util_EntityLimit(280) then
		-- spawn squads hangar1
		for k, guards in pairs(t_hangar_spawn_table.hangar1_guards) do
			if SGroup_IsEmpty(guards.name) then
				Util_CreateSquads(player2, guards.name, guards.blueprint, guards.loc, nil, 1, guards.size)
				
				SGroup_AddGroup(sg_hangar1_guards, guards.name)
				SGroup_AddGroup(sg_hangar_forces, guards.name)
				done = false
				break
			end
		end
		
		-- spawn squads hangar2
		for k, guards in pairs(t_hangar_spawn_table.hangar2_guards) do
			if SGroup_IsEmpty(guards.name) then
				Util_CreateSquads(player2, guards.name, guards.blueprint, guards.loc, nil, 1, guards.size)
				
				SGroup_AddGroup(sg_hangar2_guards, guards.name)
				SGroup_AddGroup(sg_hangar_forces, guards.name)
				done = false
				break
			end
		end
		
		-- spawn squads hangar3
		for k, guards in pairs(t_hangar_spawn_table.hangar3_guards) do
			if SGroup_IsEmpty(guards.name) then
				Util_CreateSquads(player2, guards.name, guards.blueprint, guards.loc, nil, 1, guards.size)
				
				SGroup_AddGroup(sg_hangar3_guards, guards.name)
				SGroup_AddGroup(sg_hangar_forces, guards.name)
				done = false
				break
			end
		end
	else
		--UIWarning_Show(LOC("Over entity count"))
		done = false
	end
	if done == true then 
		Rule_AddInterval(Clear_Hangars_SpawnTanks, 3) 
		Rule_RemoveMe()
	end
end

-- Spawns tanks
function Clear_Hangars_SpawnTanks()
	local done = true
	--spawn hangar tanks
	for k, hangar_tanks in pairs(t_hangar_spawn_table.tanks) do
		if SGroup_IsEmpty(hangar_tanks.name) then
			Util_CreateSquads(player2, hangar_tanks.name, hangar_tanks.blueprint, hangar_tanks.loc)
			
			print("added to sg_hangar_tank_force")
			
			SGroup_AddGroup(sg_hangar_forces, hangar_tanks.name)
			SGroup_AddGroup(sg_hangar_tank_force, hangar_tanks.name)
			done = false
			break
		end
	end
	
	-- spawn the spawn guardians
	for k, v in pairs(t_hangar_spawn_table.hangar_spawn_guard) do
		if SGroup_IsEmpty(v.name) then
			if EGroup_IsEmpty(eg_hangar_spawn) == false then
				Util_CreateSquads(player2, v.name, v.blueprint, v.loc)	
			else
				Util_CreateSquads(player2, v.name, v.blueprint, v.alternatespawn)	
			end
			done = false
			break
		end
	end
	
	sg_hangar_spawn_occupiers = SGroup_CreateIfNotFound("sg_hangar_spawn_occupiers")
	
	if SGroup_IsEmpty(sg_hangar_spawn_occupiers) and EGroup_IsEmpty(eg_hangar_spawn) == false then -- sets crew spawn building to enemy and upgrades it
		Util_CreateSquads(player2, sg_hangar_spawn_occupiers, SBP.ELITE.LUFTWAFFE, eg_hangar_spawn)
		SGroup_AddGroup(sg_hangar_forces, sg_hangar_spawn_occupiers)
		EGroup_SetPlayerOwner(eg_hangar_spawn, player2)
    end
	
	if done == true then 
		g_hangar_initialSpawn = true
 		Rule_RemoveMe()
	end
	
end

-- kicked off by objective tracker, sets pings, and calls ping remover and cleanup check
function Clear_Hangars_Kickoff() 

	if t_hangar_dialogue.begin_hangar ~= false then
		Util_AutoIntel(t_hangar_dialogue.begin_hangar)
		t_hangar_dialogue.begin_hangar = false
	end
	
	if g_hangar_initialSpawn then
		Rule_AddInterval(Clear_Hangars_Ping_Remove, 1)
		Rule_AddDelayedInterval(Clear_Hangars_Cleanup_Check, 1, 1)
		
		--Rule_AddInterval(Clear_Hangars_Randomize_Timer, 1)
		--Rule_AddInterval(Clear_Hangars_Enemy_Respawn, 1) -- turned off because it didn't make much of a difference, and was confusing for the player
		
		Rule_AddInterval(Clear_Hangars_Sally_Forth, 5)
		
		Rule_AddInterval(Clear_Hangars_Under_Attack, 1)
		
		Rule_AddInterval(Hangar_Tank_Control, 5)
		Rule_AddInterval(Clear_Hangars_Enemy_Control, 5)
		
		Rule_RemoveMe()
	end
end


function Clear_Hangars_Under_Attack()

	if SGroup_IsEmpty(sg_hangar_forces) == false then
		
		if SGroup_IsUnderAttackByPlayer(sg_hangar_forces, player1, 2) then
		
			fg_hangar_kicked_off = true
			
			Rule_RemoveMe()
			
		end
		
	end


end



function Clear_Hangars_Sally_Forth() -- responding mortars spawned first
	
	-- spawns mortars
	for k, v in pairs(t_hangar_spawn_table.mortars) do
		
		if v.deployed == false then
			
			Util_CreateSquads(player2, v.name, v.blueprint, v.loc, v.destination)
			SGroup_AddGroup(sg_hangar_forces, v.name)
			
			--Modify accuracy and damage
			Modify_WeaponAccuracy(v.name, "hardpoint_01", 0.50)
			Modify_WeaponDamage(v.name, "hardpoint_01", 0.25)
			
			v.deployed = true
			
			g_mortar_deploy_number = g_mortar_deploy_number + 1
			
			break
			
		else
			
			Cmd_Move(v.name, v.destination)
			
		end
		
	end
	
	if g_mortar_deploy_number >= g_hangar_mortar_count then
		
		Rule_AddInterval(Clear_Hangars_Sally_Forth2, 5)
		
		Rule_RemoveMe()
		
	end
	
end


function Clear_Hangars_Sally_Forth2() -- responding infantry spawned next

-- if thing is destroyed they shouldn't appear
	if EGroup_IsEmpty(eg_runway_defender_spawn) == false then
		
		if SGroup_IsUnderAttackByPlayer(sg_hangar_forces, player1, 1) then
		-- spawns defenders
		
			for k, v in pairs(t_hangar_spawn_table.runway_defenders) do
				
				if v.deployed == false then
					
					Util_CreateSquads(player2, v.name, v.blueprint, v.loc, v.destination, 1, v.size)
					
					Modify_WeaponAccuracy(v.name, "hardpoint_01", 0.50)
					Modify_WeaponDamage(v.name, "hardpoint_01", 0.50)
					v.deployed = true
					
					g_hangar_defender_deploy_number = g_hangar_defender_deploy_number + 1
					
					break
					
				else
					
					Cmd_Move(v.name, v.destination)
					
				end
				
			end
			
			if g_hangar_defender_deploy_number >= g_runway_defender_count then
				
				Rule_RemoveMe()
				
			end
		end
	else
		-- if spawn building doesn't exist
		Rule_RemoveMe()
		
	end
end


-- temp function for controlling the hangar pings
function Clear_Hangars_Ping_Remove()
	
	-- if all hangars neutralized then remove this function
	if t_clear_hangars.fg_all_hangars_neutralized == true then
		
		Rule_RemoveMe()
		
	else
		
	-- checks to see if a hangar has no more guards, and has no more spawner.  If so, then the flag will be set to true (for purposes of win conditions) and ping is removed
		
		if (SGroup_IsEmpty(sg_hangar1_guards) and SGroup_IsEmpty(tsg_hangar_tanks[1]) and t_clear_hangars.fg_hangar1_neutralized == false) then -- also add when the spawning device (eg_hangar_spawn1) is broken too!
			
			t_clear_hangars.fg_hangar1_neutralized = true
			
			-- TURN OFF HANGAR 1 PING HERE!
			Objective_RemoveUIElements(OBJ_Secure_Airfield, OBJ_Secure_Airfield.mapElementID1)
			
			Clear_Hangars_Leftovers(sg_hangar1_guards, mkr_hangar1_retreat)
			
			-- Give ownership of the sector under the hangar here
			
		elseif (SGroup_IsEmpty(sg_hangar2_guards) and SGroup_IsEmpty(tsg_hangar_tanks[2]) and t_clear_hangars.fg_hangar2_neutralized == false) then -- also add when the spawning device (eg_hangar_spawn2) is broken too!
			
			t_clear_hangars.fg_hangar2_neutralized = true
			
			-- TURN OFF HANGAR 2 PING HERE!
			Objective_RemoveUIElements(OBJ_Secure_Airfield, OBJ_Secure_Airfield.mapElementID2)
			
			Clear_Hangars_Leftovers(sg_hangar2_guards, mkr_hangar2_retreat)
			
			-- Give ownership of the sector under the hangar here
			
		elseif (SGroup_IsEmpty(sg_hangar3_guards) and t_clear_hangars.fg_hangar3_neutralized == false) then --also add when the spawning device (eg_hangar_spawn2) is broken too!
			
			t_clear_hangars.fg_hangar3_neutralized = true
			
			-- TURN OFF HANGAR 3 PING HERE!	
			Objective_RemoveUIElements(OBJ_Secure_Airfield, OBJ_Secure_Airfield.mapElementID3)
			
			Clear_Hangars_Leftovers(sg_hangar3_guards, mkr_hangar3_retreat) 
			
			-- Give ownership of the sector under the hangar here
			
		end
		
	end
	
end



function Clear_Hangars_Leftovers(defenders, destination)

-- move any leftover forces over to control tower
	
	if SGroup_IsEmpty(defenders) == false then
		
		Cmd_Retreat(defenders, destination)
		
	end
	
end


function Clear_Hangars_Enemy_Control()

	if t_secureAirfield.completed.clear_hangars == true then
		
		Rule_RemoveMe()
		
	else
		-- hangar1 guards - had to do it this way
		for k, v in pairs(t_hangar_spawn_table.hangar1_guards) do
			
			if SGroup_IsEmpty(v.name) == false and v.active == false then
				
				if SGroup_IsUnderAttack(v.name, false, 5) == true then
					
					Cmd_Move(v.name, v.dest, nil, nil, nil, nil, nil, 4)
					v.active = true
					
				end
				
			end
			
		end
		
		-- hangar2 guards - had to do it this way
		for k, v in pairs(t_hangar_spawn_table.hangar2_guards) do
			
			if SGroup_IsEmpty(v.name) == false and v.active == false then
				
				if SGroup_IsUnderAttack(v.name, false, 5) == true then
					
					Cmd_Move(v.name, v.dest, nil, nil, nil, nil, nil, 4)
					v.active = true
					
				end
				
			end
			
		end
		
		-- hangar3 guards - had to do it this way
		for k, v in pairs(t_hangar_spawn_table.hangar3_guards) do
			
			if SGroup_IsEmpty(v.name) == false and v.active == false then
				
				if SGroup_IsUnderAttack(v.name, false, 5) == true then
					
					Cmd_Move(v.name, v.dest, nil, nil, nil, nil, nil, 4)
					v.active = true
					
				end
				
			end
			
		end
		
	end
	
end



function Clear_Hangars_Cleanup_Check()

	-- if all hangars neutralized then remove this function
	if t_clear_hangars.fg_hangar1_neutralized and t_clear_hangars.fg_hangar2_neutralized and t_clear_hangars.fg_hangar3_neutralized then
		
		-- clear hangars specific variable to indicate all hangars neutralized -- cleans up associated functions
		t_clear_hangars.fg_all_hangars_neutralized = true
		
		-- for the secure airfield general tracker
		t_secureAirfield.completed.clear_hangars = true
		
		Util_AutoIntel(t_hangar_dialogue.cleared_hangar)
		
		Rule_RemoveMe()
		
	end


end

-----------------------------------------------------------
-- Hangar Enemy Troop Controls - To make them less static
-----------------------------------------------------------

--t_hangar_spawn_table.hangar1_guards
function Hangar1_Troop_Control()

	if SGroup_IsEmpty(sg_hangar1_guards) == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_hangar_spawn_table.hangar1_guards) do
			
			if SGroup_IsUnderAttack(v.name, false, 1) then
				
				local attacking_group = SGroup_CreateIfNotFound("attacking_group")
				
				SGroup_GetLastAttacker(v.name, attacking_group)
				
				if SGroup_IsEmpty(attacking_group) == false then
					
					local attacking_position = SGroup_GetOffsetPosition(attacking_group, 0, 10)
					
					Cmd_AttackMove(v.name, attacking_position, nil, nil, 10)
					
				end
				
			elseif SGroup_IsUnderAttack(v.name, true, 1) == false then
				
				local random_position = Util_GetRandomPosition(mkr_hangar1_patrol_area)
				
				Cmd_Move(v.name, random_position, nil, nil, nil, nil, nil, 10)
				
			end
			
		end
		
	end

end




--t_hangar_spawn_table.hangar2_guards
function Hangar2_Troop_Control()

	if SGroup_IsEmpty(sg_hangar2_guards) == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_hangar_spawn_table.hangar2_guards) do
			
			if SGroup_IsUnderAttack(v.name, false, 1) then
				
				local attacking_group = SGroup_CreateIfNotFound("attacking_group")
				
				SGroup_GetLastAttacker(v.name, attacking_group)
				
				if SGroup_IsEmpty(attacking_group) == false then
					
					local attacking_position = SGroup_GetOffsetPosition(attacking_group, 0, 10)
					
					Cmd_AttackMove(v.name, attacking_position, nil, nil, 10)
					
				end
				
			elseif SGroup_IsUnderAttack(v.name, true, 1) == false then
				
				local random_position = Util_GetRandomPosition(mkr_hangar2_patrol_area)
				
				Cmd_Move(v.name, random_position, nil, nil, nil, nil, nil, 10)
				
			end
			
		end
		
	end

end



--t_hangar_spawn_table.hangar3_guards
function Hangar3_Troop_Control()

	if SGroup_IsEmpty(sg_hangar3_guards) == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_hangar_spawn_table.hangar3_guards) do
			
			if SGroup_IsUnderAttack(v.name, false, 1) then
				
				local attacking_group = SGroup_CreateIfNotFound("attacking_group")
				
				SGroup_GetLastAttacker(v.name, attacking_group)
				
				if SGroup_IsEmpty(attacking_group) == false then
					
					local attacking_position = SGroup_GetOffsetPosition(attacking_group, 0, 10)
					
					Cmd_AttackMove(v.name, attacking_position, nil, nil, 10)
					
				end
				
			elseif SGroup_IsUnderAttack(v.name, true, 1) == false then
				
				local random_position = Util_GetRandomPosition(mkr_hangar3_patrol_area)
				
				Cmd_Move(v.name, random_position, nil, nil, nil, nil, nil, 10)
				
			end
			
		end
		
	end

end


function Hangar_Tank_Control()

	if SGroup_IsEmpty(sg_hangar_tank_force) then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_hangar_spawn_table.tanks) do
			
			if SGroup_IsEmpty(v.name) == false then
				
				if SGroup_IsUnderAttack(v.name, false, 5) then
					
					SGroup_GetLastAttacker(v.name, v.attacker)
					
					if SGroup_IsEmpty(v.attacker) == false then
						
						--Cmd_AttackMove(v.name, v.attacker, nil, nil, nil)
						Cmd_Move(v.name, v.attacker, nil, nil, SGroup_GetPosition(v.attacker), 0, 25, nil)
					end
					
				end
				
			end
			
		end
		
	end

end

-------------------------------------------------------------------------

-- Clear Control Tower Objective
-- This is when the Allies attack the Control Tower
-- Player is victorious here when the units around the Control Tower area have been eliminated

-------------------------------------------------------------------------

function Clear_Control_Tower_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	
	sg_control_tower_guard = SGroup_CreateTable("sg_control_tower_guard%d", 6)
	
	sg_control_tower_tank1 = SGroup_CreateIfNotFound("sg_control_tower_tank1")
	
	sg_control_tower_forces = SGroup_CreateIfNotFound("sg_control_tower_forces")
	
	sg_hangar_spawn_occupiers = SGroup_CreateIfNotFound("sg_hangar_spawn_occupiers")
	sg_runway_bunker7_occupiers = SGroup_CreateIfNotFound("sg_runway_bunker7_occupiers")
	
	sg_end_occupiers = SGroup_CreateIfNotFound("sg_end_occupiers")
	
	t_tower_spawn ={
		
		guards ={
			
			{name = sg_control_tower_guard[1], blueprint = t_dif.g_soldier_type2, loc = mkr_control_tower_guard1, number = 1, dest = mkr_ct_fallback1, active = false},
			{name = sg_control_tower_guard[2], blueprint = t_dif.g_soldier_type2, loc = mkr_control_tower_guard2, number = 1, dest = mkr_ct_fallback2, active = false},
			{name = sg_control_tower_guard[3], blueprint = t_dif.g_soldier_type2, loc = eg_control_tower_complex2, number = 1, dest = mkr_ct_fallback3, active = false}, -- eg_control_tower_complex2
			{name = sg_control_tower_guard[4], blueprint = t_dif.g_soldier_type1, loc = eg_control_tower_complex3, number = 1, dest = mkr_ct_fallback4, active = false}, -- eg_control_tower_complex3
			{name = sg_control_tower_guard[5], blueprint = t_dif.g_soldier_type3, loc = mkr_control_tower_guard5, number = 1, dest = mkr_ct_fallback5, active = false}, 
			{name = sg_control_tower_guard[6], blueprint = t_dif.g_soldier_type3, loc = mkr_control_tower_guard6, number = 1, dest = mkr_ct_fallback6, active = false}, -- eg_control_tower_complex5
			
		},
		
		
		tanks ={
			{name = sg_control_tower_tank1, blueprint = SBP.AXIS.PANZER, loc = mkr_control_tower_tank1, 1},
			
		},
		
	}
	
	fg_clear_control_tower_finished = false
	
	t_control_tower_dialogue = {
		begin_tower = {
			{ACTOR.CXP1.Seville, 1341360}, --That Control Tower is going to be a tough battle, I want fire superiority.
			--{ACTOR.CXP1.Seville, 1341370}, --Clear out those Jerries and I'll give you all a round of drinks!
			{ACTOR.CXP1.Seville, 1341380}, --Remember, form up in short quick bursts and watch your spacing. This is going to be a tight one!
		},
		
		-- NOT AMBIENT -- IN EVENTS FILE NOW
		nag_tower = {
		
			{ACTOR.CXP1.Degnan, 1341390}, --The Control Tower is still occupied by the bloody Huns!
			{ACTOR.CXP1.Degnan, 1341400}, --We should flush 'ol Jerry out as soon as fucking possible!
		
		},
		
		clear_tower = {
			{ACTOR.CXP1.Chubb, 1341420}, --Lord love a duck! The control tower is ours!
		},
		
	}
	
	
end

-- preset any units or events needed before the kickoff
function Clear_Control_Tower_Preset()

	-- spawn squads
	
	for k,tower_guards in pairs(t_tower_spawn.guards) do
		
		Util_CreateSquads(player2, tower_guards.name, tower_guards.blueprint, tower_guards.loc)
		
		SGroup_AddGroup(sg_control_tower_forces, tower_guards.name)
		
	end
	
	-- spawn tanks
	
	for k,tower_tanks in pairs(t_tower_spawn.tanks) do
		
		Util_CreateSquads(player2, tower_tanks.name, tower_tanks.blueprint, tower_tanks.loc)
		
		SGroup_AddGroup(sg_control_tower_forces, tower_tanks.name)
		
	end
	
	g_control_tower_forces_base = SGroup_TotalMembersCount(sg_control_tower_forces)
	
	-- start enemy behavior
	Rule_AddInterval(Clear_Control_Tower_Control, 5)
	
	-- do other cool things

end

-- start the related action
function Clear_Control_Tower_Kickoff()
	if Event_IsAnyRunning() == false then
		-- action that starts when this encounter is triggered
		Rule_AddDelayedInterval(Clear_Tower_Nag_Control, 300, 1)
		
		-- status change
		t_secureAirfield.activated.clear_control_tower = true
		
		Util_AutoIntel(t_control_tower_dialogue.begin_tower)
		
		Rule_AddInterval(Clear_Control_Tower_Enemy_Retreat, 1)
		Rule_AddInterval(Clear_Control_Tower_Cleanup_Check, 1)
		
		Rule_RemoveMe()
	end
end


function Clear_Control_Tower_Control() -- makes the people standing around do stuff

	if fg_clear_control_tower_finished == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_tower_spawn.guards) do
			
			if SGroup_IsEmpty(v.name) == false and v.active == false then
				
				if SGroup_IsUnderAttack(v.name, false, 5) == true then
					
					if SGroup_IsInHoldEntity(v.name, false) then
						
						Cmd_UngarrisonSquad(v.name, v.dest, false)
						Cmd_Move(v.name, v.dest, true, nil, nil, nil, nil, 4)
						v.active = true
						
					else
						
						Cmd_Move(v.name, v.dest, nil, nil, nil, nil, nil, 4)
						v.active = true
						
					end
					
				end
				
			end
			
		end
		
	end
	
end



function Clear_Control_Tower_Enemy_Retreat()
	
	if SGroup_TotalMembersCount(sg_control_tower_forces) <= (0.33 * g_control_tower_forces_base) then
		
		-- clear the control towers
		if SGroup_IsEmpty(sg_control_tower_forces) == false then
			FOW_RevealSGroup(sg_control_tower_forces, 10)
			Cmd_Retreat(sg_control_tower_forces, mkr_counterattack_spawn1, mkr_counterattack_spawn1)
		end
		
		-- clear out the spawn building at the far end of the runway
		if EGroup_IsEmpty(eg_hangar_spawn) == false then
			
			EGroup_GetSquadsHeld(eg_hangar_spawn, sg_hangar_spawn_occupiers)
			
			if SGroup_IsEmpty(sg_hangar_spawn_occupiers) == false and Player_OwnsSGroup(player2, sg_hangar_spawn_occupiers, false) then
				Cmd_Ungarrison(eg_hangar_spawn, mkr_counterattack_spawn1)
				SGroup_AddGroup(sg_hangar_forces, sg_hangar_spawn_occupiers)
				SGroup_AddGroup(sg_end_occupiers, sg_hangar_spawn_occupiers)
			end
			
		end
		
		if EGroup_IsEmpty(eg_control_tower_complex2) == false then
			local complex2 = SGroup_CreateIfNotFound("complex2")
			EGroup_GetSquadsHeld(eg_control_tower_complex2, complex2)
			
			if SGroup_IsEmpty(complex2) == false and Player_OwnsSGroup(player2, complex2, false) then
				Cmd_Ungarrison(eg_control_tower_complex2, mkr_counterattack_spawn1)
				SGroup_AddGroup(sg_control_tower_forces, complex2)
				SGroup_AddGroup(sg_end_occupiers, complex2)
			end
			
		end
		
		if EGroup_IsEmpty(eg_control_tower_complex3) == false then
			local complex3 = SGroup_CreateIfNotFound("complex3")
			EGroup_GetSquadsHeld(eg_control_tower_complex3, complex3)
			
			if SGroup_IsEmpty(complex3) == false and Player_OwnsSGroup(player2, complex3, false) then
				Cmd_Ungarrison(eg_control_tower_complex3, mkr_counterattack_spawn1)
				SGroup_AddGroup(sg_control_tower_forces, complex3)
				SGroup_AddGroup(sg_end_occupiers, complex3)
			end
			
		end
		
		
		-- destroy the bunker at the near end of the runway
		if EGroup_IsEmpty(eg_runway_bunker7) == false then
			EGroup_GetSquadsHeld(eg_hangar_spawn, sg_runway_bunker7_occupiers)
			SGroup_AddGroup(sg_control_tower_forces, sg_runway_bunker7_occupiers)
			Cmd_Ungarrison(eg_runway_bunker7, mkr_counterattack_spawn1)
			Rule_AddOneShot(Clear_Control_Tower_Bunker_Destroy, 5)
		end
		
		
		
		Rule_AddOneShot(Clear_Control_Tower_Occupier_Retreat, 5) -- makes all occupiers run
		
		-- removes pings for the tower.  If all enemies dead, then remove it
		Objective_RemoveUIElements(OBJ_Secure_Airfield, OBJ_Secure_Airfield.tower_pingID1)
		fg_clear_control_tower_finished = true
		
		Rule_RemoveMe()
		
	end
end


function Clear_Control_Tower_Occupier_Retreat()

	if SGroup_IsEmpty(sg_end_occupiers) == false then
	
		Cmd_Retreat(sg_end_occupiers, mkr_counterattack_spawn1, mkr_counterattack_spawn1)
	
	end



end


function Clear_Control_Tower_Bunker_Destroy()

	if EGroup_IsEmpty(eg_runway_bunker7) == false then
		EGroup_Kill(eg_runway_bunker7)
	end

	if SGroup_IsEmpty(sg_runway_bunker7_occupiers) == false then
	
		Cmd_Retreat(sg_runway_bunker7_occupiers, mkr_counterattack_spawn1, mkr_counterattack_spawn1)
	
	end
	

end

--COUNTDOWN FUNCTION
function Clear_Control_Tower_Countdown()

end




-- cleanup check.  if the overeall objective finished flag is set to true then this subobjective is completed and the variable is passed to the main secure airfield tracker.
function Clear_Control_Tower_Cleanup_Check()

	if fg_clear_control_tower_finished == true then
	
		t_secureAirfield.completed.clear_control_tower = true

		Util_AutoIntel(t_control_tower_dialogue.clear_tower)
		
		Rule_RemoveMe()
		
	end

end
-----------------------------------------------------------------

-- Rescue Commandos - Secondary Objective
-----------------------------------------------------------------


-------------------------------------------------------------------------
function Initialize_OBJ_Medal_Objective()

	OBJ_Medal_Objective = {
		
		SetupUI = function() 
			
		end,
		
		OnStart = function()
			
			-- announce the goal
			
			-- win/lose check
			
			-- start related action
			Rule_AddOneShot(Medal_Objective_Kickoff, 0)
			
			-- ui check here
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1349104,
		Description = 1349114,
		Type = OT_Medal,
		MedalID			= MEDALS.CXP1.CARPIQUET_B,
		
	}
	
	-- Register Objective
	
	Objective_Register(OBJ_Medal_Objective)
	
	-- Initialize Data
	

	
end


function Medal_Objective_Init()
	
	
	if g_group1_population == nil then
		
		g_group1_population = 0
		
	end
	
	if g_group2_population == nil then
		
		g_group2_population = 0
		
	end
	
	if fg_group1_active == nil then
	
		fg_group1_active = false
	
	end
	
	if fg_group2_active == nil then
	
		fg_group2_active = false
	
	end
	sg_gen_subforce1 = SGroup_CreateIfNotFound("sg_gen_subforce1")
	sg_gen_subforce2 = SGroup_CreateIfNotFound("sg_gen_subforce2")
	sg_gen_forces = SGroup_CreateIfNotFound("sg_gen_forces")
	--sg_barracks_group = SGroup_CreateIfNotFound("sg_barracks_group")
	
	teg_hideouts = {eg_hideout1, eg_hideout2}
	
	t_medal_info = {
	
		data = {
			{hideout = eg_hideout1, hiding_squad = sg_holding1, pingUI = nil, rescue_marker = mkr_rescue1, active = false, group_active = fg_group1_active, 
				population = g_group1_population, rescue_switch = mkr_rescue_switch1, mod_recieved = false, mod_damage = false, rescued = false, guards = sg_gen_forces, dest = mkr_sheds_patrol7},
			{hideout = eg_hideout2, hiding_squad = sg_holding2, pingUI = nil, rescue_marker = mkr_rescue2, active = false, group_active = fg_group2_active, 
				population = g_group2_population, rescue_switch = mkr_rescue_switch2, mod_recieved = false, mod_damage = false, rescued = false, guards = sg_barracks_group, dest = mkr_barracks_guard1},
				},
	
		medal_objective = {
		
			--start = {{ACTOR.GenericAlly, LOC("Those commandos need our help!")}},
			--finish = {{ACTOR.GenericAlly, LOC("Excellent work!  You've rescued the commandos!")}}
			
		},
	}
	
	sg_hidden = SGroup_CreateIfNotFound("sg_hidden")
	fg_medal_complete = false
	g_rescued_commandos_count = 0
	g_failed_rescue = 0
	g_hidden_commandos_count = SGroup_Count(sg_hiding_commandos) -- this is for the counting of commandos passed in from Carp A
	
	if g_hidden == nil then
		g_hidden = 0
	end


end

function Medal_Objective_Preset()
-- stuff should be in place 
	
	-- barracks group is already covered by the barracks stuff
	-- generator group is covered here
	
	
	
	Player_GetAllSquadsNearMarker(player2, sg_gen_forces, mkr_fuel_sheds_reveal)
	Cmd_Move(sg_gen_forces, mkr_commando_sheds_patrol, nil, nil, nil, nil, nil, 10)
	
	if SGroup_TotalMembersCount(sg_gen_forces) <= 10 then
		--add a guard squad or two here
		Util_CreateSquads(player2, sg_gen_subforce1, SBP.AXIS.GRENADIER, mkr_generator_blast_radius2, nil, 1)
		Cmd_Move(sg_gen_subforce1, mkr_generator_blast_radius2, nil, nil, nil, nil, nil, 5)
		SGroup_AddGroup(sg_gen_forces, sg_gen_subforce1)
		
		Util_CreateSquads(player2, sg_gen_subforce2, SBP.AXIS.VOLKSGRENADIER, mkr_sheds_patrol7, nil, 1)
		Cmd_Move(sg_gen_subforce2, mkr_sheds_patrol7, nil, nil, nil, nil, nil, 5)
		SGroup_AddGroup(sg_gen_forces, sg_gen_subforce2)
	end
	
	-- update squad into table...
	t_medal_info.data[1].guards = sg_gen_forces


end



function Medal_Objective_Kickoff()

	Setup_SetPlayerTeam(player3, 0)	
	
	for k, v in pairs (t_medal_info.data) do
		
		if EGroup_IsEmpty(v.hideout) == false and v.group_active == true and v.population > 0 then

			print("REVEALING UNIT")
			v.pingUI = Objective_AddUIElements(OBJ_Medal_Objective, v.hideout, true, 1349156, true)
			v.active = true
			
			Util_CreateSquads(player3, v.hiding_squad, SBP.CW.COMMANDOS, v.hideout, nil, 1, v.population)
			SGroup_AddGroup(sg_hidden, v.hiding_squad)
			Cmd_InstantGarrison(v.hiding_squad, v.hideout)
			Util_SetPlayerOwner(v.hideout, player3, true)
			
			v.mod_recieved = Modify_ReceivedDamage(v.hiding_squad, 0.05)
			v.mod_damage = Modify_WeaponDamage(v.hiding_squad, "hardpoint_01", 0.1)
			--v.mod_vulnerability = Modify_Vulnerability(v.hiding_squad, 0.1)
		
		end
		
	end
	
	Rule_AddInterval(Medal_Objective_Check, 5)
	
	FOW_RevealMarker(mkr_rescue1, -1)
	FOW_RevealMarker(mkr_rescue2, -1)
	
end

function Medal_Objective_Force_Player3()

	Setup_SetPlayerTeam(player3, 0)	

	for k, v in pairs (t_medal_info.data) do

		if EGroup_IsEmpty(v.hideout) == false and SGroup_IsEmpty(v.hiding_squad) == false then
		
			SGroup_SetPlayerOwner(v.hiding_squad, player3)
		
			--SGroup_DestroyAllSquads(v.hiding_squad)
			
			--Util_CreateSquads(player3, v.hiding_squad, SBP.CW.COMMANDOS, v.hideout)
		
			Cmd_InstantGarrison(v.hiding_squad, v.hideout)
			
			Util_SetPlayerOwner(v.hideout, player3, true)
			
			
		end

	end
	
end


function Medal_Objective_Check()
	
	-- if we want to make the objective win or lose depending on the total amount of hidden commando squads ever generated, then we'll use g_hidden_commandos_count
	-- player still wins if they rescue at least 1
	if (g_rescued_commandos_count >= 1) and (SGroup_Count(sg_hidden) == 0)then -- g_hidden_commandos_count
		
		fg_medal_complete = 1
		
		Rule_AddInterval(Medal_Objective_Completion_Delay, 1)
		
		Rule_RemoveMe()
		
	-- else if there are no more commandos left, and rescued commandos were 0
	elseif (SGroup_Count(sg_hidden) == 0) and  g_rescued_commandos_count <= 0 then
		
		fg_medal_complete = 0
		
		Rule_AddInterval(Medal_Objective_Completion_Delay, 1)
		
		Rule_RemoveMe()
		
	else
	
		
		for a, b in pairs (t_medal_info.data) do
			
			if b.active == true then

				if b.rescued == false and SGroup_IsEmpty(b.hiding_squad) == false and EGroup_IsEmpty(b.hideout) == false then
					
					if SGroup_IsEmpty(b.guards) then -- checks to see if "guarding" squad is empty
						
						SGroup_SetPlayerOwner(b.hiding_squad, player1) 
						EGroup_SetPlayerOwner(b.hideout, player1) 
						
						if b.pingUI ~= nil or b.pingUI ~= false then
							Objective_RemoveUIElements(OBJ_Medal_Objective, b.pingUI)
						end
						
						Cmd_UngarrisonSquad(b.hiding_squad, b.dest)
						
						if SGroup_ContainsSGroup(sg_hidden, b.hiding_squad, true) then
							
							SGroup_RemoveGroup(sg_hidden, b.hiding_squad)
							
						end
						
						
						Modifier_Remove(b.mod_recieved) --makes unit go back to normal
						Modifier_Remove(b.mod_damage)
						--Modifier_Remove(c.mod_vulnerability)
						b.active = false
						b.rescued = true
						
						
						
						g_rescued_commandos_count = g_rescued_commandos_count + 1
						
					end
				
				--if the squad hasn't been accounted for yet, and is actually dead, or the building it's in is dead (which also means the squad is dead too)
				elseif b.rescued == false and (SGroup_IsEmpty(b.hiding_squad) == true or EGroup_IsEmpty(b.hideout) == true) then
					
					--lost the unit
					b.active = false
					
					if b.pingUI ~= nil or b.pingUI ~= false then
						Objective_RemoveUIElements(OBJ_Medal_Objective, b.pingUI) 
					end
					
					if SGroup_ContainsSGroup(sg_hidden, b.hiding_squad, true) then
					
						SGroup_RemoveGroup(sg_hidden, b.hiding_squad)
					
					end
					
					g_failed_rescue = g_failed_rescue + 1
					
				end
				
			end
		end
		
	end

end

function Medal_Objective_Completion_Delay()

	if Event_IsAnyRunning() == false then
		
		if fg_medal_complete == 1 then
		
			Objective_Complete(OBJ_Medal_Objective)
			Rule_RemoveMe()
			
		elseif fg_medal_complete == 0 then
		
			Objective_Fail(OBJ_Medal_Objective)
			Rule_RemoveMe()
		
		end
		
		
	end
	
end



-------------------------------------------------------------------------
-- SHOOT DOWN PLANES ACTION
-------------------------------------------------------------------------

function Initialize_OBJ_Shoot_Down_Planes()

	OBJ_Shoot_Down_Planes = {
		
		SetupUI = function() 
			
			
		end,
		
		OnStart = function()
			Sound_PlayMusic("Music/SP/Caen/motivation/coh_for_the_king.bsc",3,0)
			-- start related action
			Shoot_Down_Planes_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1349105,
		Description = 1349115,
		Type = OT_Secondary,
		
	}
	
	-- Register Objective
	
	Objective_Register(OBJ_Shoot_Down_Planes)
	
	-- Initialize Data
	

	
end

function Shoot_Down_Planes_Init()

	g_need_to_shoot_down = 0
	g_shot_down = 0
	g_shot_down_previous = 0
	fg_all_shot_down = false
	
	g_time_between_attacks = 0
	
	tmkr_henschel_parked = Marker_GetTable("mkr_flying_henschel_spawn%d")
	
	sg_flying_plane = SGroup_CreateIfNotFound("sg_flying_plane")

	sg_henschel = SGroup_CreateTable("sg_henschel%d", table.getn(tmkr_henschel_parked))
	
	sg_obstructions = SGroup_CreateIfNotFound("sg_obstructions") -- sgroup obstructions on runway
	eg_obstructions = EGroup_CreateIfNotFound("eg_obstructions") -- egroup obstructions on runway

	eg_elite_entities = EGroup_CreateIfNotFound("eg_elite_entities")
	sg_elite_squads = SGroup_CreateIfNotFound("sg_elite_squads")
	
	sg_shoot_henschel_squad_potential = SGroup_CreateIfNotFound("sg_shoot_henschel_squad_potential")
	sg_shoot_henschel_squad_target = SGroup_CreateIfNotFound("sg_shoot_henschel_squad_target")
	eg_shoot_henschel_entity_potential = EGroup_CreateIfNotFound("eg_shoot_henschel_entity_potential")
	eg_shoot_henschel_entity_target = EGroup_CreateIfNotFound("eg_shoot_henschel_entity_target")
	
	t_plane_info = {
	
		ground_state = { 
			
			{name = sg_henschel[1], blueprint = SBP.ELITE.HENSCHEL_TAKEOFF, loc = mkr_flying_henschel_spawn1},
			{name = sg_henschel[2], blueprint = SBP.ELITE.HENSCHEL_TAKEOFF, loc = mkr_flying_henschel_spawn2},
			{name = sg_henschel[3], blueprint = SBP.ELITE.HENSCHEL_TAKEOFF, loc = mkr_flying_henschel_spawn3},
		},
		
		flying = {
			
			{name = sg_flying_plane, indicatorID = false, blueprint = SBP.ELITE.HENSCHEL_TAKEOFF, loc = mkr_flying_plane_spawn, path = "Takeoff", takeoff = mkr_takeoff_point} -- opelblitz temporary target
			
		},
		
				-- variables for this secondary function
		action = {
			
			f_plane_taxi = false,
			f_stationary_destroyed = false,
			f_flying_destroyed = false,
			f_takeoff_over = false,
			f_flying_deployed = false,
			f_point_of_no_return = false,
			f_obstructed = false,
			g_flying_planes_downed = 0,
			g_flying_planes_escaped = 0,
			g_flying_planes_spawned = 0,
			g_plane_number = 1
		},
		
		startdialogue = {
			
			{ACTOR.CXP1.Chubb, 1341470}, --They're moving those planes out of the hangar!
			{ACTOR.CXP1.Chubb, 1341480}, --Quickly, shoot them down with something before they can get into the air to attack us!
			
		},
		
		successfuldialogue = {
			
			{ACTOR.CXP1.Chubb, 1341490}, --Those planes won't be bothering us now
			
		},
		

	}
	


end


function Shoot_Down_Planes_Preset()

	
	for k, v in pairs(t_plane_info.ground_state) do 
		
		Util_CreateSquads(player2, v.name, v.blueprint, v.loc, nil, 1)
		
    end
	
end


function Shoot_Down_Planes_Kickoff()

	
	Util_AutoIntel(t_plane_info.startdialogue) -- calls dialogue
	
	Rule_AddInterval(Shoot_Down_Planes_Flying_Spawner, 5) -- start the flying plane spawn function
	
end


function Shoot_Down_Planes_Flying_Spawner_Delay() -- delay for spawning planes

	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsEmpty(sg_flying_plane) == true then
			
			if Rule_Exists(Shoot_Down_Planes_Flying_Spawner) == false then
				
				Rule_AddDelayedInterval(Shoot_Down_Planes_Flying_Spawner, 10, 5)
				
				Rule_RemoveMe()
				
			end
			
		end
		
	end

end

-- function for spawning planes 
function Shoot_Down_Planes_Flying_Spawner() 
	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		-- if sg_flying_plane is empty, and the number of planes spawned is < 3
		if SGroup_IsEmpty(sg_flying_plane) and t_plane_info.action.g_flying_planes_spawned < table.getn(tmkr_henschel_parked) then 
		
			for k, v in pairs(t_plane_info.flying) do
				-- checks to see if the manager is running
				if Rule_Exists(Shoot_Down_Planes_Flying_Manager) == false then 
					
					SGroup_AddGroup(sg_flying_plane, sg_henschel[t_plane_info.action.g_plane_number])
					
					-- kicks off SGroup reveal function
					Rule_AddOneShot(Shoot_Down_Planes_FOW_Delay, 1) 
					-- increments # of flying planes spawned
					t_plane_info.action.g_flying_planes_spawned = t_plane_info.action.g_flying_planes_spawned + 1 
					
					
					if t_plane_info.action.g_plane_number < table.getn(tmkr_henschel_parked) then
						
						t_plane_info.action.g_plane_number = t_plane_info.action.g_plane_number + 1
						
					end
					
					-- tells the plane to move down its path
					Rule_AddOneShot(Shoot_Down_Planes_Flying_Manager, 1) 
					-- spawn delayer activated
					Rule_AddInterval(Shoot_Down_Planes_Flying_Spawner_Delay, 1) 
					
					
					-- add ping to flying unit
					v.indicatorID = Objective_AddUIElements(OBJ_Shoot_Down_Planes, sg_flying_plane, true, 1349153, true)
					
					Rule_AddInterval(Shoot_Down_Planes_Takeoff_Detect, 2)
					
					Rule_RemoveMe()
					
				end
				
			end
			
		-- if # of planes is greater than number of planes, then wait 15 seconds before doing check (to allow last plane to die or take off)
		elseif t_plane_info.action.g_flying_planes_spawned >= table.getn(tmkr_henschel_parked) then  
			
			Rule_AddDelayedInterval(Shoot_Down_Planes_WinCheck, 5, 1)
			
			Rule_RemoveMe()
			
		end
		
	end
	
end

-- Reveals flying plane SGroup
function Shoot_Down_Planes_FOW_Delay() 
	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_plane_info.flying) do 
			
			FOW_RevealSGroupOnly(v.name, -1)
			
		end
		
	end
	
end

-- starts plane down the runway
function Shoot_Down_Planes_Flying_Manager() 

	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_plane_info.flying) do 
			
			if SGroup_IsEmpty(v.name) == true then
				
				Rule_RemoveMe()
				
			else
				
				Squad_SetAnimatorState(SGroup_GetSpawnedSquadAt(v.name, 1), "taxi", "on")
				Cmd_SquadPath(v.name, v.path, true, false, false, 0) -- mkr_takeoff_point
				
				if Rule_Exists(Shoot_Down_Planes_Takeoff) == false then
					
					Rule_AddInterval(Shoot_Down_Planes_Takeoff, 1)
					
				end
				
				if Rule_Exists(Shoot_Down_Planes_Obstruction_Detection) == false then
					
					Rule_AddInterval(Shoot_Down_Planes_Obstruction_Detection, 1)
					
				end
				
				Rule_RemoveMe()
				
			end
		end
	end
end





function Shoot_Down_Planes_Takeoff()

	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
			
		for k, v in pairs(t_plane_info.flying) do 
			
			if SGroup_IsEmpty(v.name) == true or t_plane_info.action.f_obstructed == true  then
				
				Objective_RemoveUIElements(OBJ_Shoot_Down_Planes, v.indicatorID)
				
				Rule_RemoveMe()
				
			else
				
				if Prox_AreSquadsNearMarker(v.name, mkr_takeoff_start, false)  then --mkr_counterattack2_rally
					
					t_plane_info.action.f_point_of_no_return = true
					
					SGroup_SetInvulnerable(v.name, true)
					
					--SGroup_SetPlayerOwner(v.name, nil)
					
					Objective_RemoveUIElements(OBJ_Shoot_Down_Planes, v.indicatorID)
					
					t_plane_info.action.g_flying_planes_escaped = t_plane_info.action.g_flying_planes_escaped + 1
					
					Squad_SetAnimatorState(SGroup_GetSpawnedSquadAt(v.name, 1), "takeoff", "on")
					
					Rule_AddOneShot(Shoot_Down_Planes_Remover, 4)
					
					
					if t_plane_info.action.g_flying_planes_escaped == 1 then
						
						-- start attacks?
						
						g_time_between_attacks = 50
						
						
						if Rule_Exists(Shoot_Down_Henschel_Control) == false then
							
							Rule_AddInterval(Shoot_Down_Henschel_Control, 1)
							
						end
						
						
					elseif t_plane_info.action.g_flying_planes_escaped > 1 then 
						-- variable to adjust time between attacks here
						
						if t_plane_info.action.g_flying_planes_escaped == 2 then
							
							g_time_between_attacks = g_time_between_attacks - 15
							
						elseif t_plane_info.action.g_flying_planes_escaped == 3 then
							
							g_time_between_attacks = g_time_between_attacks - 15
							
						end
						
						
						
					end
					
					Rule_RemoveMe()
				end
			end
		end
		
	end

end


function Shoot_Down_Planes_Remover()
	
	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		
		for k, v in pairs(t_plane_info.flying) do 
			
			if SGroup_IsEmpty(v.name) == false then
				
				t_plane_info.action.f_point_of_no_return = false -- resets point of no return flag
				
				--print("kill sgroup")
				--print(SGroup_GetName(v.name))
				SGroup_DestroyAllSquads(v.name)
				
			end
			
		end
		
	end
	
end


function Shoot_Down_Planes_Takeoff_Detect() -- detects to see if the plane reaches the takeoff marker and "escaped"

	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs(t_plane_info.flying) do 
			
			if SGroup_IsEmpty(v.name) == false then
			
				if Prox_AreSquadsNearMarker(v.name, v.takeoff, false) then
					
					--Objective_RemoveUIElements(OBJ_Shoot_Down_Planes, v.indicatorID)
					
					Rule_RemoveMe()
					
				elseif SGroup_IsEmpty(v.name) then
					
					Objective_RemoveUIElements(OBJ_Shoot_Down_Planes, v.indicatorID)
					
					--t_plane_info.action.g_plane_number = t_plane_info.action.g_plane_number + 1 -- iterates to next plane
					
					Rule_RemoveMe()
					
				end
				
			else
				
				Rule_RemoveMe()
				
			end
			
		end
		
	end
	
end


function Shoot_Down_Planes_Obstruction_Detection() -- detects obstructions in the way of the plane
	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		if SGroup_IsEmpty(sg_flying_plane) == true or t_plane_info.action.f_takeoff_over == true or t_plane_info.action.f_point_of_no_return == true then --t_plane_info.action.f_flying_destroyed == true
			
			--print("removed!")
			
			Rule_RemoveMe()
			
		else
			
			if SGroup_IsEmpty(sg_flying_plane) == false and t_plane_info.action.f_point_of_no_return == false then
				
				local plane_detection_loc = SGroup_GetOffsetPosition(sg_flying_plane, OFFSET_FRONT, 10)
				
				Player_GetAllSquadsNearMarker(player1, sg_obstructions, plane_detection_loc, 10)
				Player_GetAllEntitiesNearMarker(player1, eg_obstructions, plane_detection_loc, 10)
				
				if SGroup_IsEmpty(sg_obstructions) == false or EGroup_IsEmpty(eg_obstructions) == false then
					
					t_plane_info.action.f_obstructed = true
					
					Cmd_Stop(sg_flying_plane)
					
					Rule_AddInterval(Shoot_Down_Planes_Return, 1)
					
					--print("removed too!")
					Rule_RemoveMe()
				
				end	
		
			end
			
		end
		
	end
end


function Shoot_Down_Planes_Return() -- attempts to return the plane to the beginning of its run
	
	if SGroup_IsEmpty(sg_flying_plane) == true or fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		if Prox_AreSquadsNearMarker(sg_flying_plane, mkr_runway_start, false) == false then
			
			if SGroup_IsEmpty(sg_flying_plane) == false then
				
				Cmd_Move(sg_flying_plane, mkr_runway_start)
				
			end
			
		else 
			t_plane_info.action.f_obstructed = false
			
			if Rule_Exists(Shoot_Down_Planes_Flying_Manager) == false then
				
				Rule_AddOneShot(Shoot_Down_Planes_Flying_Manager, 10)
				
				Rule_RemoveMe()
				
			end
			
		end
		
	end


end




function Shoot_Down_Planes_WinCheck() -- checks to see if the number of planes escaped < number of planes spawned.

	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		if t_plane_info.action.g_flying_planes_escaped <= 0  then
			
			t_plane_info.action.f_flying_destroyed = true
			t_plane_info.action.f_takeoff_over = true
			Objective_Complete(OBJ_Shoot_Down_Planes)
			
			Util_AutoIntel(t_plane_info.successfuldialogue)
			
			fg_all_shot_down = true
			
			Rule_RemoveMe()
			
		elseif t_plane_info.action.g_flying_planes_escaped >= 1  then
			t_plane_info.action.f_flying_destroyed = false
			
			t_plane_info.action.f_takeoff_over = true
			
			g_need_to_shoot_down = t_plane_info.action.g_flying_planes_spawned - t_plane_info.action.g_flying_planes_escaped 
			
			Rule_AddInterval(Shoot_Down_Planes_WinCheck2, 1)
			Rule_AddInterval(Shoot_Down_Planes_Counter, 1)
			
			Objective_UpdateText(OBJ_Shoot_Down_Planes, 1349106, 1349116, true)
			-- dialogue here to show that some planes are going to be attacking your troops.  Shooting those down will give you the objective!
			
			--Objective_Fail(OBJ_Shoot_Down_Planes)
			
			Rule_RemoveMe() -- here for now to allow for debug
			
		end
		
	end

end


function Shoot_Down_Planes_WinCheck2() -- for 2nd phase of shoot down planes

	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
		--Objective_Fail(OBJ_Shoot_Down_Planes)
		
	elseif fg_all_shot_down == true then
		
		Objective_Complete(OBJ_Shoot_Down_Planes)
		
		Rule_RemoveMe()
		
	end

end


function Shoot_Down_Planes_Shot_Down_Checker() -- checks to see if any planes in flight were shot down
-- assumes that 1 plane per attack is flying by.

	if fg_all_shot_down == true or fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		if EGroup_IsEmpty(eg_elite_entities) then 
			
			Player_GetAll(player2, sg_elite_squads, eg_elite_entities)
			EGroup_Filter(eg_elite_entities, EBP.SP.HENSCHEL_AIR, FILTER_KEEP)
			if EGroup_IsEmpty(eg_elite_entities) == false then
				
				print("--------------------------------------------new plane-------------------------------------------------------")
				
				-- assumes that 1 plane per attack is flying by
				
				Rule_AddEGroupEvent(Shoot_Down_Planes_Iterate, eg_elite_entities, GE_EntityKilled )   
				Rule_RemoveMe()
				
			else
				print("-------------------------------------------------no new planes--------------------------------------------------")
				
			end
			
		end
	end
		
end

-- iterates number of planes shot down
function Shoot_Down_Planes_Iterate() 
	print("---------------------------------------plane shot down------------------------------------------------------------")
	g_shot_down_previous = g_shot_down
	g_shot_down = g_shot_down + 1
	print("shot down: "..g_shot_down)
	g_time_between_attacks = g_time_between_attacks + 15
	
end



function Shoot_Down_Planes_Counter() -- compares number of planes shot down with number which took off.
	
	if fg_all_objectives_completed == true then
		
		Rule_RemoveMe()
		
	elseif g_shot_down >= t_plane_info.action.g_flying_planes_escaped then
		
		fg_all_shot_down = true
		
		Rule_RemoveMe()
		
		
	end

end


function Shoot_Down_Henschel_Control()

	
	if fg_all_objectives_completed == true then
	
		Rule_RemoveMe()
	
	else
	
		if fg_all_shot_down == true then
			
			Rule_RemoveMe()
			
		else
			
			Rule_AddInterval(Shoot_Down_Henschel_Attack_Timer, 5)
			
			--Objective_UpdateText(OBJ_Shoot_Down_Planes, 1349106, 1349116, true)
			
			
			Rule_RemoveMe()
			
		end
	
	end


end




-------------------------------------------------------------------------
-- Henschel Attack
-------------------------------------------------------------------------

function Shoot_Down_Henschel_Attack_Timer() -- detector

	if fg_all_shot_down == true or fg_all_objectives_completed == true then
	
		Rule_RemoveMe()
		
	else
		print("looking...")
		print(Prox_ArePlayersNearMarker(player1, mkr_enemy_territory, false))
		if Prox_ArePlayersNearMarker(player1, mkr_enemy_territory, false) then
		
			local random_attack_time = World_GetRand(5, 6)
			
			print("random attack time: "..random_attack_time)
			print(random_attack_time)
			
			if Rule_Exists(Shoot_Down_Henschel_Attack) == false and fg_all_shot_down == false then
				
				Rule_AddDelayedInterval(Shoot_Down_Henschel_Attack, random_attack_time, 1) --random_attack_time
				Rule_RemoveMe()
				
			end
			
		
		end
		
	end

end


function Shoot_Down_Henschel_Attack()

	if fg_all_shot_down == true or fg_all_objectives_completed == true then --f_counterattack_start == true
		
		Rule_RemoveMe()
		
	else
		
		--local random_attack_delay = World_GetRand(60, 120) -- delayed attack of 1 to 2 minutes
		
		if g_time_between_attacks > 0 then
		
			if SGroup_IsEmpty(sg_shoot_henschel_squad_potential) == true then  
				
				sg_shoot_henschel_squad_potential = Player_GetSquadConcentration(player1)
				
				SGroup_Add(sg_shoot_henschel_squad_target, SGroup_GetRandomSpawnedSquad(sg_shoot_henschel_squad_potential))
				
				-- if the concentration is still empty, then check to see if the entity concentration is empty
				if SGroup_IsEmpty(sg_shoot_henschel_squad_target) == true then  
					
					
					print("sgroup empty")
					
					if EGroup_IsEmpty(eg_shoot_henschel_entity_target) == true then
						
						eg_shoot_henschel_entity_potential = Player_GetEntityConcentration(player1)
						
						EGroup_Add(eg_shoot_henschel_entity_target, EGroup_GetRandomSpawnedEntity(eg_shoot_henschel_entity_potential))
						
						-- if entity group is still empty then
						if EGroup_IsEmpty(eg_shoot_henschel_entity_target) == true then
							-- do nothing
							Rule_RemoveMe()
							
						else -- if the entity group has stuff in it, attack!
							--attack!
							--f_henschel_attacked = true
							
							if EGroup_IsEmpty(eg_shoot_henschel_entity_target) == false then
							
								FOW_RevealEGroup(eg_shoot_henschel_entity_target, 20)
								Cmd_Ability(player2, ABILITY.SP.HENSCHEL_ALL, eg_shoot_henschel_entity_target, nil, true) --ABILITY.COMMANDER_TREE.ELITE.HENSCHEL
								
								if Rule_Exists(Shoot_Down_Planes_Shot_Down_Checker) == false then
									Rule_AddInterval(Shoot_Down_Planes_Shot_Down_Checker, 1)
									print("shoot down checker activated")
								end
								
							end
							
							--Rule_AddOneShot(Shoot_Down_Henschel_Control_No_Mans, 30)
							Rule_AddDelayedInterval(Shoot_Down_Henschel_Control, g_time_between_attacks, 1) 
							
							EGroup_Clear(eg_shoot_henschel_entity_potential)
							EGroup_Clear(eg_shoot_henschel_entity_target)
							
							Rule_RemoveMe()
							
						end
						
					else
						
						if EGroup_IsEmpty(eg_shoot_henschel_entity_target) == false then
						
							FOW_RevealEGroup(eg_shoot_henschel_entity_target, 20)
							Cmd_Ability(player2, ABILITY.SP.HENSCHEL_ALL, eg_shoot_henschel_entity_target, nil, true) --ABILITY.COMMANDER_TREE.ELITE.HENSCHEL
							
						end
						
						--Rule_AddOneShot(Shoot_Down_Henschel_Control_No_Mans, 30)
						Rule_AddDelayedInterval(Shoot_Down_Henschel_Control, g_time_between_attacks, 1)
						
						EGroup_Clear(eg_shoot_henschel_entity_potential)
						EGroup_Clear(eg_shoot_henschel_entity_target)
						
						Rule_RemoveMe()
						
					end
					
				else -- if the squad group has stuff in it, attack!
						
				--attack!
				--f_henschel_attacked = true
					print("sgroup not empty")
					
					if SGroup_IsEmpty(sg_shoot_henschel_squad_target) == false then
						FOW_RevealSGroup(sg_shoot_henschel_squad_target, 20)
						Cmd_Ability(player2, ABILITY.SP.HENSCHEL_ALL, sg_shoot_henschel_squad_target, nil, true) --ABILITY.COMMANDER_TREE.ELITE.HENSCHEL
						
						if Rule_Exists(Shoot_Down_Planes_Shot_Down_Checker) == false then
							Rule_AddInterval(Shoot_Down_Planes_Shot_Down_Checker, 1)
							print("shoot down checker activated")
						end
						
					end
					
					Rule_AddDelayedInterval(Shoot_Down_Henschel_Control, g_time_between_attacks, 1) 
					
					SGroup_Clear(sg_shoot_henschel_squad_potential)
					SGroup_Clear(sg_shoot_henschel_squad_target)
					
					Rule_RemoveMe()
				
				end
				
			else 
				
				print("not empty?")
				
				if SGroup_IsEmpty(sg_shoot_henschel_squad_target) == false then
					FOW_RevealSGroup(sg_shoot_henschel_squad_target, 20)
					Cmd_Ability(player2, ABILITY.SP.HENSCHEL_ALL, sg_shoot_henschel_squad_target, nil, true) --ABILITY.COMMANDER_TREE.ELITE.HENSCHEL
				end	
					
				Rule_AddDelayedInterval(Shoot_Down_Henschel_Control, g_time_between_attacks, 1) 
				
				SGroup_Clear(sg_shoot_henschel_squad_potential)
				SGroup_Clear(sg_shoot_henschel_squad_target)
				
				Rule_RemoveMe()
				
				
			end
		end
		
	end	

end





----------------------------------------------------------------
-- Runway Bunkers

----------------------------------------------------------------

function Runway_Bunkers_Init()

	--teg_runway_bunker = EGroup_CreateTable("eg_runway_bunker%d", 7)  -- this method didn't work?
	
	eg_runway_bunker1 = EGroup_CreateIfNotFound("eg_runway_bunker1")
	eg_runway_bunker2 = EGroup_CreateIfNotFound("eg_runway_bunker2")
	eg_runway_bunker3 = EGroup_CreateIfNotFound("eg_runway_bunker3")
	eg_runway_bunker4 = EGroup_CreateIfNotFound("eg_runway_bunker4")
	eg_runway_bunker5 = EGroup_CreateIfNotFound("eg_runway_bunker5")
	eg_runway_bunker6 = EGroup_CreateIfNotFound("eg_runway_bunker6")
	eg_runway_bunker7 = EGroup_CreateIfNotFound("eg_runway_bunker7")
	
	
	
	
	t_bunker_status = {
	
		{name = eg_runway_bunker2, statepercent = 1, entname = nil},
		{name = eg_runway_bunker4, statepercent = 1, entname = nil},
		{name = eg_runway_bunker5, statepercent = 1, entname = nil},
		{name = eg_runway_bunker6, statepercent = 1, entname = nil},
	
	}
	
	for k, v in pairs(t_bunker_status) do
		
		if EGroup_IsEmpty(v.name) == false then
		
			Modify_DisableHold(v.name, false)
			--table.insert(halfbuilt_entity, EGroup_GetSpawnedEntityAt(v.name, 1))
			v.entname = EGroup_GetSpawnedEntityAt(v.name, 1)
			Entity_SetAnimatorVariable(v.entname, "Build", v.statepercent)
		
		end
		
	end

	
	--EGroup_SetPlayerOwner(eg_runway_bunker2, player2) -- player2
	--Cmd_InstantUpgrade(eg_runway_bunker2, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
	
	teg_runway_bunker = {eg_runway_bunker1, eg_runway_bunker2, eg_runway_bunker3, eg_runway_bunker4, eg_runway_bunker5, eg_runway_bunker6, eg_runway_bunker7}
	
	tsg_runway_guard = SGroup_CreateTable("tsg_runway_guard%d", table.getn(teg_runway_bunker))
	
	t_runway_spawn = {
	
		bunker_soldiers = {	{name = tsg_runway_guard[1], blueprint = SBP.AXIS.GRENADIER, loc = teg_runway_bunker[1]},
						{name = tsg_runway_guard[2], blueprint = SBP.AXIS.GRENADIER, loc = teg_runway_bunker[2]},
						{name = tsg_runway_guard[3], blueprint = SBP.AXIS.GRENADIER, loc = teg_runway_bunker[3]},
						{name = tsg_runway_guard[4], blueprint = SBP.AXIS.GRENADIER, loc = teg_runway_bunker[4]},
						{name = tsg_runway_guard[5], blueprint = SBP.AXIS.GRENADIER, loc = teg_runway_bunker[5]},
						{name = tsg_runway_guard[6], blueprint = SBP.AXIS.GRENADIER, loc = teg_runway_bunker[6]},
						{name = tsg_runway_guard[7], blueprint = SBP.AXIS.GRENADIER, loc = teg_runway_bunker[7]},
						},
						
		fodder_soldiers = {},
	}


end


function Runway_Bunkers_Preset()

	for k, v in pairs(teg_runway_bunker) do 
	
		if EGroup_IsEmpty(v) == false then -- sets crew spawn building to enemy and upgrades it
			EGroup_SetPlayerOwner(v, player2)
			Cmd_InstantUpgrade(v, UPG.AXIS.BUNKER_MG42, 1)
		end
		
    end
	
	
	for k, squad in pairs(t_runway_spawn.bunker_soldiers) do
		
		if EGroup_IsEmpty(squad.loc) == false then -- sets crew spawn building to enemy and upgrades it
		
			Util_CreateSquads(player2, squad.name, squad.blueprint, squad.loc)
			
			if squad.name ~= tsg_runway_guard[4] then
				SGroup_AddGroup(sg_hangar_forces, squad.name)
			end
		end
		
	end
	--[[
	for k, v in pairs(tsg_runway_bunker) do 
	
		Cmd_InstantUpgrade(v, UPG.AXIS.BUNKER_MG42, 1) -- upgrade the bunker to MG
		
	end]]


end



-------------------------------------------------------------------------

-- Barracks

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Barracks_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	
	sg_barracks_guard = SGroup_CreateTable("sg_barracks_guard%d", 4)
	sg_barracks_tank = SGroup_CreateIfNotFound("sg_barracks_tank")
	sg_barracks_gunner = SGroup_CreateIfNotFound("sg_barracks_gunner")
	sg_barracks_group = SGroup_CreateIfNotFound("sg_barracks_group")
	
	--weapon pickups
	tmkr_barracks_pickups = Marker_GetTable("mkr_barracks_pickup%d")
	g_barracks_pickup_count = table.getn(tmkr_barracks_pickups)
	teg_barracks_pickups = EGroup_CreateTable("eg_barracks_pickups%d", g_barracks_pickup_count)	
	
	
	t_barracks_spawn ={
		
		guards ={
			
			{name =  sg_barracks_guard[1], blueprint = t_dif.g_soldier_type2, loc = mkr_barracks_guard1, 1},
			{name =  sg_barracks_guard[2], blueprint = SBP.AXIS.PIONEER, loc = mkr_barracks_guard2, 1},
			--{name =  sg_barracks_guard[3], blueprint = SBP.AXIS.VOLKSGRENADIER, loc = eg_barracks1, 1},
			--{name =  sg_barracks_guard[4], blueprint = SBP.AXIS.GRENADIER, loc = eg_barracks2, 1},
			
		},
		
		barrack_guards = {
		
			{name =  sg_barracks_guard[3], blueprint = t_dif.g_soldier_type2, loc = eg_barracks1, 1, alternatespawn = mkr_counterattack_spawn1, alternatedestination = mkr_barracks_guard1 },
		
		},
		
		tanks ={
			{name =  sg_barracks_tank, blueprint = SBP.AXIS.PUMA, loc = mkr_barracks_tank1, 1},
			
		},
		
		pickups = {
		
			{name = teg_barracks_pickups[1], blueprint = EBP.PICKUP.AXIS.PANZERSCHRECK, loc = tmkr_barracks_pickups[1]},
		},
	
		
	}

	
	
	fg_moved_to_wall = false
	fg_barracks_guard1_on = false
	fg_barracks_v_moved = false
	fg_barracks_guard3_on = false
		
	if EGroup_IsEmpty(eg_barracks_gun) == false then
		--Modify_DisableHold(eg_barracks_gun, false)
	end
	
	
end

-- preset any units or events needed before the kickoff
function Barracks_Preset()

	-- spawn squads
	
	
	for k, squad in pairs(t_barracks_spawn.guards) do
		
		Util_CreateSquads(player2, squad.name, squad.blueprint, squad.loc)
		SGroup_AddGroup(sg_barracks_group, squad.name)
		
	end
	
	-- spawn barracks guards
	for k, squad in pairs(t_barracks_spawn.barrack_guards) do
		
		if EGroup_IsEmpty(squad.loc) == false then
			
			Util_CreateSquads(player2, squad.name, squad.blueprint, squad.loc)
			SGroup_AddGroup(sg_barracks_group, squad.name)
			
		else
			
			Util_CreateSquads(player2, squad.name, squad.blueprint, squad.alternatespawn, squad.alternatedestination)
			SGroup_AddGroup(sg_barracks_group, squad.name)
			
		end
		
	end
	
	
	-- spawn vehicles
	for k, tank in pairs(t_barracks_spawn.tanks) do
		
		Util_CreateSquads(player2, tank.name, tank.blueprint, tank.loc)
		SGroup_AddGroup(sg_barracks_group, tank.name)
		
	end
	
	-- pickups
	for k, v in pairs(t_barracks_spawn.pickups) do
	
		local pickup = v
		
		Util_CreateEntities(nil, pickup.name, pickup.blueprint, pickup.loc, 1)
	
	end
	
	Util_CreateSquads(player2, sg_barracks_gunner, SBP.ELITE.LUFTWAFFE, mkr_barracks_gunner_spawn) --mkr_barracks_gunner_spawn
	--SGroup_AddGroup(sg_barracks_group, sg_barracks_gunner)
	
	-- start enemy behavior
	Rule_AddOneShot(Barracks_Gunner_Move, 1)
	
	-- do other cool things

end

-- start the related action
function Barracks_Kickoff()

	-- action that starts when this encounter is triggered
	Rule_AddInterval(Barracks_Alert, 1)
	
	
end

function Barracks_Gunner_Move()

	if SGroup_IsEmpty(sg_barracks_gunner) == false and EGroup_IsEmpty(eg_barracks_gun) == false then
		Cmd_Garrison(sg_barracks_gunner, eg_barracks_gun)
	end

end


-- controls what the barracks enemies do when the player encounters them, the gunner squad does its own thing already so it's not covered here.
function Barracks_Alert()
	
	if SGroup_IsEmpty(sg_barracks_group) == true then
		
		Rule_RemoveMe()
		
	else
		
		--barracks guard 2
		if SGroup_IsEmpty(sg_barracks_guard[2]) == false then
			
			if fg_moved_to_wall == false then
				
				if SGroup_IsUnderAttackByPlayer(sg_barracks_group, player1, 1) then 	-- if any of the entire barracks group is under attack	
					
					-- moves the pioneers to the sandbag wall
					Cmd_Retreat(sg_barracks_guard[2], mkr_barracks_guard2_wall)
					fg_moved_to_wall = true
					
				end
				
			elseif fg_moved_to_wall == true then
				
				Cmd_Move(sg_barracks_guard[2], mkr_barracks_guard2_wall, nil, nil, nil, nil, nil, 5) -- runs to area by sandbags
				
			end
			
		end
		
		-- barracks guard 1
		if SGroup_IsEmpty(sg_barracks_guard[1]) == false then
			
			-- if any of the entire barracks group is under attack		
			if SGroup_IsUnderAttack(sg_barracks_group, false, 1) and fg_barracks_guard1_on == false then
				
				Cmd_Move(sg_barracks_guard[1], mkr_no_glider_zone4, nil, nil, nil, nil, nil, 5) -- runs to area by stacks of crap
				
				fg_barracks_guard1_on = true
				
			end
			
		end
		
		-- barracks guard 3
		if SGroup_IsEmpty(sg_barracks_guard[3]) == false then
			
			-- if any of the entire barracks group is under attack			
			if SGroup_IsUnderAttack(sg_barracks_group, false, 1) and fg_barracks_guard3_on == false then
				
				Cmd_UngarrisonSquad(sg_barracks_guard[3], mkr_barracks_guard1_wall) -- runs to area by sandbags
				
				
				fg_barracks_guard3_on = true
				
			elseif SGroup_IsUnderAttack(sg_barracks_guard[3], false, 1) and fg_barracks_guard3_on == true then
			
				Cmd_Move(sg_barracks_guard[3], mkr_barracks_guard1_wall, nil, nil, nil, nil, nil, 5) -- runs to area by sandbags
			
			end
			
		end
		
		-- barracks vehicle
		if SGroup_IsEmpty(sg_barracks_tank) == false then
			
			-- if any of the entire barracks group is under attack			
			if SGroup_IsUnderAttack(sg_barracks_group, false, 1) and fg_barracks_v_moved == false then
				
				Cmd_Move(sg_barracks_tank, mkr_barracks_tank_move)
				
				fg_barracks_v_moved = true
				
			end
			
		end
		
	end
	
end
------------------------------

---------------
--Capture Carpiquet (in case player didn't do that last mission)
---------------

function Capture_Carpiquet_Init()

	t_capture_carpiquet_dialogue = {
	
		
		carpiquet_captured = {
		
			{ACTOR.CXP1.GenericCommonwealth, 1341430}, -- RCR reporting for duty.
			{ACTOR.CXP1.Degnan, 1341440}, -- And it's about bloody time lads!
			
		},
	
	}




end

-- destroyed parked planes text not needed aymore: 1341470, 1341480
-- mines not used anymore, 1341500, 134510, 1341520











---------------------------

function Carpiquet_B_Fail_Check()

	Player_GetAll(player1)	
	
	if SGroup_IsEmpty(sg_allsquads) == true then
		Game_EndSP(false, 1349160)
	end

end




----------------------------
function Rule_EndMission()

    if Event_IsAnyRunning() == false then
        
		Rule_RemoveMe()
        Rule_AddDelayedInterval(Rule_EndMissionB, 1, 1)
		
    end

end

function Rule_EndMissionB()

    if Event_IsAnyRunning() == false then
		
		Game_EndSP(true)
		
    end

end

function Test_Respawn()

--print(t_landing_data[1].respawn_next) -- carried over from previous mission!!!!!
	if t_landing_data[1].respawn_next == true then
	
		--[[
		sg_hangar_aggressor = SGroup_CreateIfNotFound("sg_hangar_aggressor")
		
		Util_CreateSquads(player1, sg_hangar_aggressor, SBP.CW.COMMANDOS, eg_hideout1)
		--Util_CreateSquads(player1, sg_hangar_aggressor, SBP.CW.COMMANDOS, mkr_barracks_guard1)]]
		
		
		
		
		
	end
	
	for k, v in pairs(t_respawn) do
	
		Util_CreateSquads(player1, v.name, v.blueprint, v.pos, nil, 1, v.number) 
	
	end
end

function Shoot_Down_Test()

	g_counterattack_countdown = 0
	fg_axis_retreat = true
	Objective_Start(OBJ_Shoot_Down_Planes)

end




-------------------------
--Control Tower Fuel Sheds Chain Reaction
------------------------
function Shed_Chain_Reaction_Init()

	eg_control_tower_sheds_blowup = EGroup_CreateIfNotFound("eg_control_tower_sheds_blowup")
	
	tmkr_sheds_blast = Marker_GetTable("mkr_shed_blast_radius%d")
	tsg_sheds_collateral = SGroup_CreateTable("sg_sheds_collateral%d", 3)
	
	eg_control_tower_sheds_blowup1 = EGroup_CreateIfNotFound("eg_control_tower_sheds_blowup1")
	eg_control_tower_sheds_blowup2 = EGroup_CreateIfNotFound("eg_control_tower_sheds_blowup2")
	
	
	t_sheds_explodegroup = {
	
		{egroup = eg_control_tower_sheds_blowup1, count = EGroup_Count(eg_control_tower_sheds_blowup1), collateral = tsg_sheds_collateral[1], blast = tmkr_sheds_blast[1], destroyed = false},
		{egroup = eg_control_tower_sheds_blowup2, count = EGroup_Count(eg_control_tower_sheds_blowup2), collateral = tsg_sheds_collateral[2], blast = tmkr_sheds_blast[2], destroyed = false},
		
	}
	
	g_sheds_destroyed_count = 0
	g_sheds_group_number = table.getn(t_sheds_explodegroup)
	
	f_sheds_chain_reaction = false
	
	

end



function Shed_Chain_Reaction()

	if EGroup_IsEmpty(eg_control_tower_sheds_blowup) == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs (t_sheds_explodegroup) do
			
			if f_sheds_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
				
				if EGroup_Count(v.egroup) < v.count then
					
					
					EGroup_SetDemolitions(player1, v.egroup, 5)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					

					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					Commando_Sheds_Collateral(v.collateral)
					
					f_sheds_chain_reaction = true
					
					g_sheds_destroyed_count = g_sheds_destroyed_count + 1
					
					break
					
				end
				
			elseif f_sheds_chain_reaction == true then -- the rest goes boom
				
				if EGroup_IsEmpty(v.egroup) == false then
					
					EGroup_SetDemolitions(player1, v.egroup, 5)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					

					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					Commando_Sheds_Collateral(v.collateral)
					
					g_sheds_destroyed_count = g_sheds_destroyed_count + 1
					
					break
					
				end
				
			end	
		
		end
		
		if g_sheds_destroyed_count == g_sheds_group_number then
			
			EGroup_Kill(eg_control_tower_sheds_blowup)
				
			Rule_RemoveMe()
			
		end
		
	end
	
end


-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Sheds_Collateral(collateral)

	SGroup_Kill(collateral)

end



-------------------------
--Forward Chain Reaction
------------------------
function Forward_Chain_Reaction_Init()

	eg_forward_fuel_blowup = EGroup_CreateIfNotFound("eg_forward_fuel_blowup")

	tmkr_forward_blast = {mkr_forward_fuel_blast_radius}
	tsg_forward_collateral = SGroup_CreateTable("sg_forward_collateral%d", 3)
	
	eg_forward_fuel_blowup1 = EGroup_CreateIfNotFound("eg_forward_fuel_blowup1")
	eg_forward_fuel_blowup2 = EGroup_CreateIfNotFound("eg_forward_fuel_blowup2")
	eg_forward_fuel_blowup3 = EGroup_CreateIfNotFound("eg_forward_fuel_blowup3")
	
	t_forward_explodegroup = {
	
		{egroup = eg_forward_fuel_blowup1, count = EGroup_Count(eg_forward_fuel_blowup1), collateral = tsg_forward_collateral[1], blast = tmkr_forward_blast[1], destroyed = false},
		{egroup = eg_forward_fuel_blowup2, count = EGroup_Count(eg_forward_fuel_blowup2), collateral = tsg_forward_collateral[2], blast = tmkr_forward_blast[1], destroyed = false},
		{egroup = eg_forward_fuel_blowup3, count = EGroup_Count(eg_forward_fuel_blowup3), collateral = tsg_forward_collateral[3], blast = tmkr_forward_blast[1], destroyed = false},
		
	}
	
	g_forward_destroyed_count = 0
	g_forward_group_number = table.getn(t_forward_explodegroup)
	
	f_forward_chain_reaction = false

end



function Forward_Chain_Reaction()

	if EGroup_IsEmpty(eg_forward_fuel_blowup) == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs (t_forward_explodegroup) do
			
			
			if f_forward_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
				
				if EGroup_Count(v.egroup) < v.count then
					
					
					EGroup_SetDemolitions(player1, v.egroup, 5)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					

					
					f_forward_chain_reaction = true
					
					g_forward_destroyed_count = g_forward_destroyed_count + 1
					
					break
				
				end
				
			elseif f_forward_chain_reaction == true then -- the rest goes boom
				
				if EGroup_IsEmpty(v.egroup) == false then
				
					EGroup_SetDemolitions(player1, v.egroup, 5)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					
					g_forward_destroyed_count = g_forward_destroyed_count + 1
					
					break
					
				end
				
			end	
			
		end
		
		if g_forward_destroyed_count == g_forward_group_number then
		
			Player_GetAllSquadsNearMarker(player2, tsg_forward_collateral[1], mkr_forward_fuel_blast_radius)
			Commando_Forward_Collateral(tsg_forward_collateral[1])
			
			EGroup_Kill(eg_forward_fuel_blowup)
				
			Rule_RemoveMe()
			
		end
		
	end
	
end


-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Forward_Collateral(collateral)

	SGroup_Kill(collateral)

end


-------------------------
--Hangar2 Chain Reaction
------------------------
function Hangar2_Chain_Reaction_Init()

	eg_hangar2_blowup = EGroup_CreateIfNotFound("eg_hangar2_blowup")

	tmkr_hangar2_blast = {mkr_hangar2_blast_radius}
	tsg_hangar2_collateral = SGroup_CreateTable("sg_hangar2_collateral%d", 3)
	
	eg_hangar2_blowup1 = EGroup_CreateIfNotFound("eg_hangar2_blowup1")

	
	t_hangar2_explodegroup = {
		
		{egroup = eg_hangar2_blowup1, count = EGroup_Count(eg_hangar2_blowup1), collateral = tsg_hangar2_collateral[1], blast = tmkr_hangar2_blast[1], destroyed = false},
		
	}
	
	g_hangar2_destroyed_count = 0
	g_hangar2_group_number = table.getn(t_hangar2_explodegroup)
	
	f_hangar2_chain_reaction = false

end



function Hangar2_Chain_Reaction()

	if EGroup_IsEmpty(eg_hangar2_blowup) == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs (t_hangar2_explodegroup) do
			
			if f_hangar2_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
				
				if EGroup_Count(v.egroup) < v.count then
					
					EGroup_SetDemolitions(player1, v.egroup, 1)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					Commando_Hangar2_Collateral(v.collateral)
					
					f_hangar2_chain_reaction = true
					
					g_hangar2_destroyed_count = g_hangar2_destroyed_count + 1
					
					break
					
				end
				
			elseif f_hangar2_chain_reaction == true then -- the rest goes boom
				
				if EGroup_IsEmpty(v.egroup) == false then
					
					EGroup_SetDemolitions(player1, v.egroup, 1)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					Commando_Hangar2_Collateral(v.collateral)
					
					g_hangar2_destroyed_count = g_hangar2_destroyed_count + 1
					
					break
					
				end
				
			end	
		
		end
		
		if g_hangar2_destroyed_count == g_hangar2_group_number then
			
			local neutral_egroup = EGroup_CreateIfNotFound("neutral_egroup")
			
			World_GetNeutralEntitiesNearMarker(neutral_egroup, mkr_hangar2_blast_radius)
			
			EGroup_SetDemolitions(player1, neutral_egroup, 1)
			Cmd_DetonateDemolitions(player1, neutral_egroup)
			
			if EGroup_IsEmpty(neutral_egroup) == false then
				
				EGroup_Kill(neutral_egroup)
				
			end
			
			EGroup_Kill(eg_hangar2_blowup)
				
			Rule_RemoveMe()
			
		end
		
	end
	
end


-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Hangar2_Collateral(collateral)

	SGroup_Kill(collateral)

end



-------------------------
--Hangar3 Chain Reaction
------------------------
function Hangar3_Chain_Reaction_Init()

	eg_hangar3_blowup = EGroup_CreateIfNotFound("eg_hangar3_blowup")

	tmkr_hangar3_blast = {mkr_hangar3_blast_radius}
	tsg_hangar3_collateral = SGroup_CreateTable("sg_hangar3_collateral%d", 3)
	
	eg_hangar3_blowup1 = EGroup_CreateIfNotFound("eg_hangar3_blowup1")

	
	t_hangar3_explodegroup = {
		
		{egroup = eg_hangar3_blowup1, count = EGroup_Count(eg_hangar3_blowup1), collateral = tsg_hangar3_collateral[1], blast = tmkr_hangar3_blast[1], destroyed = false},
		
	}
	
	g_hangar3_destroyed_count = 0
	g_hangar3_group_number = table.getn(t_hangar3_explodegroup)
	
	f_hangar3_chain_reaction = false

end



function Hangar3_Chain_Reaction()

	if EGroup_IsEmpty(eg_hangar3_blowup) == true then
		
		Rule_RemoveMe()
		
	else
		
		for k, v in pairs (t_hangar3_explodegroup) do
			
			if f_hangar3_chain_reaction == false then -- detects to see if one is destroyed, then the group goes boom
				
				if EGroup_Count(v.egroup) < v.count then
					
					
					EGroup_SetDemolitions(player1, v.egroup, 1)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					Commando_Hangar3_Collateral(v.collateral)
					
					f_hangar3_chain_reaction = true
					
					g_hangar3_destroyed_count = g_hangar3_destroyed_count + 1
					
					break
					
				end
				
			elseif f_hangar3_chain_reaction == true then -- the rest goes boom
				
				if EGroup_IsEmpty(v.egroup) == false then
					
					EGroup_SetDemolitions(player1, v.egroup, 1)
					Cmd_DetonateDemolitions(player1, v.egroup)
					
					if EGroup_IsEmpty(v.egroup) == false then
						
						EGroup_Kill(v.egroup)
						
					end
					
					Player_GetAllSquadsNearMarker(player2, v.collateral, v.blast)
					Commando_Hangar3_Collateral(v.collateral)
					
					g_hangar3_destroyed_count = g_hangar3_destroyed_count + 1
					
					break
					
				end
				
			end	
			
		end
		
		if g_hangar3_destroyed_count == g_hangar3_group_number then
			
			local neutral_egroup = EGroup_CreateIfNotFound("neutral_egroup")
			
			World_GetNeutralEntitiesNearMarker(neutral_egroup, mkr_hangar3_blast_radius)
			
			
			if EGroup_IsEmpty(neutral_egroup) == false then
				
				EGroup_Kill(neutral_egroup)
				
			end
			
			EGroup_Kill(eg_hangar3_blowup)
			
			Rule_RemoveMe()
			
		end
		
	end
	
end


-- helper function to destroy sgroups that are in the area as collateral damage
function Commando_Hangar3_Collateral(collateral)

	SGroup_Kill(collateral)

end










	
-------------------------
--Turret neutralization nag
-------------------------


function Turret_Nag_Control() -- random nag speech when capturing lines

	if t_secureAirfield.completed.neutralize_88s_completed == true then
		
		Rule_RemoveMe()
		
	else
		
		if Rule_Exists(Turret_Nag_Speech) == false then
			
			Rule_AddDelayedInterval(Turret_Nag_Speech, 5, 1)
			
			Rule_RemoveMe()
			
		end
		
	end
end


function Turret_Nag_Speech() -- NPC Speech_SetGlobalStealthRead

	if t_secureAirfield.completed.neutralize_88s_completed == true then
		
		Rule_RemoveMe()
		
	else
		if Rule_Exists(Turret_Nag_Control) == false and Event_IsAnyRunning() == false then
			
			Util_AutoIntel(t_88s_dialogue.nag_88s)
			
			local random_time = World_GetRand(60*5, 60*8) 
			
			Rule_AddDelayedInterval(Turret_Nag_Control, random_time, 1)
			Rule_RemoveMe()
			
		end
	end
end

-------------------
--Clear Hangars Nag
-------------------


function Clear_Hangars_Nag_Control() -- random nag speech when capturing lines

	local status_completed = t_secureAirfield.completed

	if status_completed.clear_hangars == true then
		
		Rule_RemoveMe()
		
	else
		
		if Rule_Exists(Clear_Hangars_Nag_Speech) == false then
			
			Rule_AddDelayedInterval(Clear_Hangars_Nag_Speech, 5, 1)
			
			Rule_RemoveMe()
			
		end
		
	end
end


function Clear_Hangars_Nag_Speech() -- NPC Speech_SetGlobalStealthRead

	local status_completed = t_secureAirfield.completed
	
	if status_completed.clear_hangars == true then
		
		Rule_RemoveMe()
		
	else
		if Rule_Exists(Clear_Hangars_Nag_Control) == false and Event_IsAnyRunning() == false then
			
			Util_StartIntel(EVENTS.HANGARS_NAG)
			
			local random_time = World_GetRand(60*5, 60*8)
			
			Rule_AddDelayedInterval(Clear_Hangars_Nag_Control, random_time, 1)
			Rule_RemoveMe()
			
		end
	end
end


-------------------
--Clear Tower Nag
-------------------


function Clear_Tower_Nag_Control() -- random nag speech when capturing lines

	local status_completed = t_secureAirfield.completed
	
	if status_completed.clear_control_tower == true then
		
		Rule_RemoveMe()
		
	else
		if Rule_Exists(Clear_Tower_Nag_Speech) == false then
			
			Rule_AddDelayedInterval(Clear_Tower_Nag_Speech, 5, 1)
			
			Rule_RemoveMe()
			
		end
	end
end


function Clear_Tower_Nag_Speech() -- NPC Speech_SetGlobalStealthRead

	local status_completed = t_secureAirfield.completed
	
	if status_completed.clear_control_tower == true then
		
		Rule_RemoveMe()
		
	else
		
		if Rule_Exists(Clear_Tower_Nag_Control) == false and Event_IsAnyRunning() == false then
			
			Util_StartIntel(EVENTS.TOWER_NAG)
			
			local random_time = World_GetRand(60*5, 60*8) 
			
			Rule_AddDelayedInterval(Clear_Tower_Nag_Control, random_time, 1)
			Rule_RemoveMe()
			
		end
	end
	
end
