-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Hell's Highway Ambush

--~ 	Util_CreateSquads(player, sgroup, sbp, location[, destination, numsquads, loadout, attackmove, facing, upgrades] )

-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")



-------------------------------------------------------------------------

-- [[ SETUP ]]

-------------------------------------------------------------------------

function OnGameSetup()
	-- string numbers should reference dat files
	-- "allies_commonwealth" "allies" "axis" "axis_panzer_elite"
	player1 = Setup_Player(1, 1309230, TRACE_AXIS_PANZER_ELITE, 1)
	player2 = Setup_Player(2, 1309236, TRACE_ALLIES_COMMONWEALTH, 2)
	
end

function OnGameRestore()
	player1 = World_GetPlayerAt(1)
	player2 = World_GetPlayerAt(2)
	
	-- function takes care of restoring all global mission parameters after a save/load
	Game_DefaultGameRestore()
end




-------------------------------------------------------------------------

-- [[ ONINIT ]]

-------------------------------------------------------------------------

function OnInit()
	g_MissionSpeechPath = "omg\\sp\\Mission4"
	
	g_AIControl_Enable = false
	g_AIControl_Pause = true
	
	-- a constant that stores the mission number for use with
	-- setting the global speech paths, tech tree setup, and 
	-- the player's starting resources
	MISSION_NUMBER = 0204
	
	--[[ PRESET GAME STATE ]]
	Setup_MissionPreset(MISSION_NUMBER)
	
	--[[ PRESET DEBUG CONDITIONS ]]
	HHAmbush_Debug()
	
	--[[ SET DIFFICULTY ]]
	HHAmbush_Difficulty()
	
	--[[ REGISTER OBJECTIVES ]]
	HHAmbush_ObjectiveRegister()
	
	--[[ MOD INITIAL STATS ]]
	HHAmbush_ModifyStats()
	
	--[[ SET RESTRICTIONS ]]
	HHAmbush_Restrictions()
	
	--[[ SET AI ]]
	HHAmbush_CpuInit()
	
	--[[ MISSION PRESETS ]]
	HHAmbush_MissionPreset()
	
	--[[ GAME START CHECK ]]
	-- NOTE, the NIS CANNOT START AT THE LOADING SCREEN
	-- it needs to start after the loading of the mission has completed (thus it needs to be a Rule)
	Rule_Add(HHAmbush_NISStart)

end

Scar_AddInit(OnInit)

function HHAmbush_Debug()
	
	-- looks for the command line option [-debug]
	if Misc_IsCommandLineOptionSet("debug") then
		
		g_debug = true
		
		Scar_DebugConsoleExecute("bind([[ALT+3]], [[Scar_DoString('Debug_FinishObj1()')]])")
		
		-- reveal FOW
		FOW_Enable(false)
		
	end
		
		-- set up bindings for NISes
		Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('Util_StartNIS(NIS_OPENING)')]])")
		Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS02)')]])")
		
	
end

-------------------------------------------------------------------------
------------ DEBUG FUNCTIONS ------------------------
-------------------------------------------------------------------------
function Debug_FinishObj1()

	for i=1, table.getn(tsg_kr_primary_target) do
		SGroup_Kill(tsg_kr_primary_target[i])
	end
	
	-- capture the road for the player to give them a fighting chance for the ambush
	EGroup_InstantCaptureStrategicPoint(teg_road_rp[4], player1)
	EGroup_InstantCaptureStrategicPoint(teg_road_rp[5], player1)
	EGroup_InstantCaptureStrategicPoint(teg_road_rp[6], player1)
	
	Util_CreateSquads(player1, sg_temp, SBP.ELITE.PANZERGRENADIER, eg_ambush_garrison_church)
	Cmd_InstantUpgrade(eg_ambush_garrison_church, UPG.SP.HELLS_AMBIENT_BUILDING)

	
end


function HHAmbush_ObjectiveRegister()

	--[[ *** MUST INITIALIZE THE OBJ TABLE BEFORE REGISTERING *** ]]
	Initialize_OBJ_KillRecce()
	Initialize_OBJ_GarrisonChurch()
	Initialize_OBJ_RoadCapture()
	Initialize_OBJ_DestroyPriests()
	Initialize_OBJ_Medal()
	
	TownDefense_Init()
	_Leapfrog_Init()
	RepairTeamInit()
	EngineerBuilding_Init()
	HHAmbush_JeepInit()
	
end

function HHAmbush_ModifyStats()

	-- mod resource rates
	t_player1_res_mods= {}
	
	-- modify the speed at which the avre fires its petard
	Modify_AbilityRechargeTime(player2, ABILITY.CW.FIRE_AVRE_PETARD, 0.6)
	Modify_AbilityRechargeTime(player2, ABILITY.COMMANDER_TREE.CW.DECOY_ARTILLERY, 0.01)
	Modify_AbilityMaxCastRange(player2, ABILITY.CW.PRIEST_BARRAGE, 5)
	Modify_AbilityRechargeTime(player2, ABILITY.CW.PRIEST_BARRAGE, 0.3)

	local modifier = Modifier_Create(MAT_EntityType, "modifiers\\health_maximum_modifier.lua", MUT_Multiplication, false, 0.5, EBP.ELITE.TANK_TRAP)
	Modifier_ApplyToPlayer(modifier, player1)

	-- modifying resource rate because the player does not have an HQ which generates resources.
	t_player1_res_mods[1] = Modify_PlayerResourceRate(player1, RT_Manpower, 1.75)
--~ 	t_player1_res_mods[2] = Modify_PlayerResourceRate(player1, RT_Munition, 2)
--~ 	t_player1_res_mods[3] = Modify_PlayerResourceRate(player1, RT_Fuel, 1)
	
end

function HHAmbush_Restrictions()

	--[[ UN/RESTRICT UPGRADES ]]
	Player_SetConstructionMenuAvailability(player1, TYPE.CONSTRUCT.ELITE.BASIC, ITEM_REMOVED)
	Cmd_InstantUpgrade(player1, UPG.ELITE.PANZERJAGER)
		
	--[[ RESOURCES ]]
	Player_SetResource(player1, RT_Manpower, 400)
	Player_SetResource(player1, RT_Munition, 300)
	Player_SetResource(player1, RT_Fuel, 200)
	
	--[[ UN/RESTRICT BUILDING CONSTRUCTION ]]
	Player_SetEntityProductionAvailability( player1, EBP.ELITE.KAMPFGRUPPE, ITEM_LOCKED )
	Player_SetEntityProductionAvailability( player1, EBP.ELITE.LOGISTIK, ITEM_LOCKED )
	
	--[[ UN/RESTRICT ABILITIES 	]]
	
	-- UN/RESTRICT POP CAP
	g_pop_cap_start = 40
	Player_SetPopCapOverride(player1, g_pop_cap_start)

end



function HHAmbush_CpuInit()

	--[[ left as an example
	
	-- set up Player3 AI  
	Util_AI_Setup(player3, {Util_DifVar({10, 15, 20, 30}), 5}, player3, Game_GetSPDifficulty(), 7, Util_DifVar({1, 2, 3, 5}), 2, 3)
	
	-- Set up AI's resources
	Player_SetResource(player3, RT_Manpower, 1000)
	Player_SetResource(player3, RT_Munition, 100)
	Player_SetResource(player3, RT_Fuel, 100)
	
	-- tell AI to go after strongest threat instead of the weakest
	AI_DoString( player3, "s_personality.attack_prefer_threat = true" )
	AI_DoString( player3, "s_personality.defend_prefer_threat = true" )

	-- tell AI not to "defend" territories outside of the ring around its base
	AI_EnableComponent(player3, false, COMPONENT_ForwardDefending)
	
	-- disable use of comapny commander menu and abilities
	AI_DoString( player3, "s_commandtree_enabled = false" )
	AI_DoString( player3, "s_playerabilities_enabled = false" )
	
	AI_EnableComponent(player3, false, COMPONENT_Attacking)
	
	]]

end



function HHAmbush_Difficulty()
	
	-- get the difficulty
	g_difficulty = Game_GetSPDifficulty()  -- set a global difficulty variable
	print("********* DIFFICULTY: "..g_difficulty)
	
	-- set health bonus for player 1
	Setup_Difficulty(player1, g_difficulty) -- pass the player and difficulty global variable into the Set Health function
	Setup_Difficulty(player2, g_difficulty) -- do it for each player that you have defined
	
	t_difficulty = {
		rc_total_time 			= Util_DifVar( {21*60, 24*60, 24*60, 23*60} ),			-- amount of time that is given to the player to prepare defenses
		rc_setup_diff 			= Util_DifVar( {6*60, 6*60, 5*60, 4*60} ),			-- amount of time that is given to the player to prepare defenses
		rc_final_push			= Util_DifVar( {15, 1.5*60, 2.5*60, 3*60 } ),				-- amount of time before they make a final push for the points
		rc_arty_time			= Util_DifVar( {9*60, 11*60, 14*60, 15*60 } ),			-- amount of time before the artillery starts attacking
		rc_at_armor				= Util_DifVar( {7*60, 9*60, 12*60, 13*60  } ),			-- amount of time before the heavy armor enters the map
		rc_avre_time			= Util_DifVar( {14*60, 16*60, 18*60, 20*60  } ),		-- amount of time before the avre enters the map to destroy roadblocks
	}
	
	
end


-------------------------------------------------------------------------

-- MISSION Preset 

-------------------------------------------------------------------------

function HHAmbush_MissionPreset()

	-- create the temporary starting units for player 1
	--[[ this is an example of what you might do - sgroup and marker must exist
	local sbps = {SBP.ALLIES.RIFLEMEN, SBP.ALLIES.ENGINEER, SBP.ALLIES.JEEP, SBP.ALLIES.RIFLEMEN}
	for i = 1, 5 do
		Util_CreateSquadsAtMarker(player1, sg_player1[i], sbps[i], mkr_marker[1], 1)
	end
	]]
	
	eg_town_church = EGroup_CreateIfNotFound("eg_town_church")
	eg_town_rp = EGroup_CreateIfNotFound("eg_town_rp")
	eg_ambush_rp_control = EGroup_CreateIfNotFound("eg_ambush_rp_control")
	teg_ambush_player_rp = EGroup_GetWBTable("eg_ambush_player_rp%d")
	tmkr_player_start = Marker_GetTable("mkr_ambush_player_start%d")
	tsg_player_start = SGroup_CreateTable("sg_player_start%d", table.getn(tmkr_player_start))
	tmkr_player_tech = Marker_GetTable("mkr_ambush_player_tech%d")
	teg_player_tech = EGroup_CreateTable("eg_player_tech%d", table.getn(tmkr_player_tech))
	teg_bridge = EGroup_GetWBTable("eg_bridge%d")
	
	t_hh_ambush = {
		fg_reinforcements_hint 			= false,
		timer_reinforcements_hint 		= "HH AMBUSH REINFORCEMENTS TIMER",
		timer_reinforcements_hint_amt	= 30,
		reinforcements_hint_id			= false,
	}
	
	-- player's starting units
	t_player_start_squads = {
		{ 
			-- provided by the NIS
			sbp 		= false,
			upg			= {},
		},
		{ 
			-- provided by the NIS
			sbp 		= false,
			upg			= {},
		},
		{ 
			-- provided by the NIS
			sbp 		= false,
			upg			= {},
		},
		{ 
			sbp 		= SBP.ELITE.ARMOURCAR_222,
			upg			= {},
		},
		{ 
			sbp 		= SBP.ELITE.HALFTRACK_250,
			upg			= {},
		},
		{ 
			sbp 		= SBP.ELITE.PANZERGRENADIER,
			upg			= {UPG.ELITE.MP44},
		},
		{ 
			sbp 		= SBP.ELITE.PANZERGRENADIER,
			upg			= {UPG.ELITE.PANZERSCHRECK},
			spawn		= tsg_player_start[5],
		},
	}
	
	for k=1, table.getn(t_player_start_squads) do
		local this = t_player_start_squads[k]
		this.sgroup = tsg_player_start[k]
		if this.sbp ~= false then
			if this.spawn == nil then
				this.spawn = tmkr_player_start[k]
			end
			Util_CreateSquads(player1, this.sgroup, this.sbp, this.spawn)
			Cmd_InstantUpgrade(this.sgroup, this.upg)
		end
	end

	-- give the player some starting resource points at the beginning of the mission
	for i=1, table.getn(teg_ambush_player_rp) do
		EGroup_InstantCaptureStrategicPoint(teg_ambush_player_rp[i], player1)
	end
	
	EGroup_InstantCaptureStrategicPoint(eg_rp25, player1)
	
	-- remove the building that is used as the HQ for Hunt
	EGroup_SetPlayerOwner(eg_player_hq, player2)
	EGroup_DeSpawn(eg_player_hq)
	
	EGroup_DestroyAllEntities(eg_ambush_base_destroy)
	
	Util_CreateEntities(player1, eg_ambush_rp_control, EBP.STRAT_POINT.CONTROL_STRUCTURE_SP, mkr_ambush_rp_control, 1)
	
	-- Make the intro building for Hell's highway Hunt invulnerable
	-- Added by Ryan, 08/12/07
	EGroup_SetInvulnerable(eg_intro_building, true)
	EGroup_DeSpawn(eg_intro_building)
	
	-- setup the bridge manager for the mission
	for i=1, table.getn(teg_bridge) do 
		BridgeTerritory_Add(teg_bridge[i], EGroup_FromName("eg_rp_bridge"..i), EGroup_FromName("eg_rp_bridge"..i.."_1"), EGroup_FromName("eg_rp_bridge"..i.."_2"))
	end
	
	-- Set repair buildings to invulnerable for Hunt
	EGroup_SetInvulnerable(eg_hunt_rt_base1, 0.5)
	EGroup_SetInvulnerable(eg_hunt_rt_base2, 0.5)
	EGroup_SetInvulnerable(eg_hunt_rt_base3, 0.5)
	
	-- if areas of your script need to be kicked off early
	KillRecce_Preset()
	TownDefense_Preset()
	
end





-------------------------------------------------------------------------

-- MISSION START 

-------------------------------------------------------------------------
function HHAmbush_NISStart()
	
	Player_GetAll(player1, sg_temp)
	SGroup_Hide(sg_temp, true)
	Player_GetAll(player2, sg_temp)
	SGroup_Hide(sg_temp, true)
	Util_StartNIS(NIS_OPENING_BLEND, HHAmbush_PostNIS)
	
	Rule_RemoveMe()

end

function HHAmbush_PostNIS()

	-- delay first objective
	Rule_AddOneShot(HHAmbush_DelayKillRecce, 3)
	Player_GetAll(player1, sg_temp)
	SGroup_Hide(sg_temp, false)
	Player_GetAll(player2, sg_temp)
	SGroup_Hide(sg_temp, false)
	EngineerBuilding_Kickoff()
	
	Cmd_Move(t_player_start_squads[6].sgroup, Util_GetOffsetPosition(t_player_start_squads[6].sgroup, OFFSET_FRONT, 30))
	
	Misc_SetSquadControlGroup(SGroup_GetSpawnedSquadAt(t_player_start_squads[1].sgroup, 1), 1)
	Misc_SetSquadControlGroup(SGroup_GetSpawnedSquadAt(t_player_start_squads[2].sgroup, 1), 1)
	
	Rule_AddDelayedInterval(KR_ForceSitRep, 30, 2)
	Rule_AddInterval(HHAmbush_UnlockConstruction, 1)
	Rule_AddInterval(HHAmbush_ShowReinforcements, 2)
	Rule_AddInterval(GarrisonChurch_CheckTerritory, 2)
	Rule_AddInterval(HHAmbush_MarderHint, 1)
	HHAmbush_JeepKickoff()
	Rule_RemoveMe()

end



function HHAmbush_DelayKillRecce()
	Objective_Start(OBJ_KillRecce)
end
















-------------------------------------------------------------------------
-- Assasinate/Kill Recce Elements 
-------------------------------------------------------------------------
-- The player needs to focus on drawing out various recce elements within the
-- city and assassinating them.  The recce elements will respond to various
-- threats by moving units out of the city to deal with these threats.
-------------------------------------------------------------------------
function Initialize_OBJ_KillRecce()

	OBJ_KillRecce = {
		
		SetupUI = function() 
			-- mark a point or position
			OBJ_KillRecce.mapElementID = Objective_AddUIElements(OBJ_KillRecce, mkr_ambush_scout_road, true, false, true)
			
		end,
		
		OnStart = function()
			
			-- win/lose check
			Rule_AddInterval(KillRecce_WinCheck, 5)
			Sound_PlayMusic("Music/SP/OMG/Motivation/OMG/omg_m01_cue2.bsc",1,1)
			Sound_PlayStreamed("Ambiences/Ambiences_Streamed/CXP2/SP/Distant_Fighting")
			
			-- start related action
			Rule_Add(KillRecce_Kickoff)
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			Util_AutoIntel(t_kr.events.obj_complete)
			Rule_AddDelayedInterval(KillRecce_AmbientCelebrate, 2, 1)
			Sound_StopMusic(8,3)
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1449064,
		Description = 1449065,
		TitleEnd = 1449060,
		Type = OT_Primary,
		

	}
	
	-- Register Objective
	Objective_Register(OBJ_KillRecce)
	
	-- Initialize Data
	KillRecce_Init()
	
end

-------------------------------------------------------------------------
-- Kill Recce - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to  be there for the Obj to work
-- does not need to be called at 'OnInit()'
function KillRecce_Init()

	-- define sgroups, egroups, etc associated with this obj
	teg_kr_sp = EGroup_GetWBTable("eg_kr_sp%d")
	teg_rp = EGroup_GetWBTable("eg_rp%d")
	
	-- a set of points that we want a squad of the recce groups to go out and capture first.
	teg_kr_capture_rp = {
		eg_rp5,
		eg_rp4,
		eg_rp6,
		eg_rp7,
		eg_rp9,
		eg_rp2,
	}
	
	-- instantiate the table.
	OBJ_KillRecce.mapElementID = {}
	
	t_kr_soldiers = {
		SBP.CW.TOMMIES,
		SBP.CW.SAPPER,
		SBP.CW.LIEUTENANT,
		SBP.CW.CAPTAIN,
		SBP.CW.COMMANDOS,
		SBP.CW.VICKERS_MG_SP,
	}
	
    t_kr = {
		total_recce				= 1,				-- the number of squads that the player needs to kill to complete the objective
		vulnerability_factor	= 0.5,				-- the vulnerability factor of the recce commanders that are to be killed for this objective
	}
	
	KillRecce_InitEvents()
	
	tsg_kr_primary_target = SGroup_CreateTable("tsg_kr_primary_target%d", t_kr.total_recce)
	
	t_kr.primary_targets = {}
	for i=1, table.getn(tsg_kr_primary_target) do
		t_kr.primary_targets[i] = {
			sgroup				= tsg_kr_primary_target[i],
			ui_state			= false,
		}
	end
	
	t_kr.recce_group = {}
	
	-- determine the number of recce squads defending the town based on the difficulty of the mission
	local recce_num = Util_DifVar({2, 3, 3, 4})
	
	for i=1, recce_num do
		t_kr.recce_group[i] = {}
	end
	
	t_kr.recce_group[1].squads = {
		{
			sbp			= SBP.CW.TOMMIES,
			upg			= {UPG.CW.BREN},
		},
		{
			sbp			= SBP.CW.TOMMIES,
			upg			= {UPG.CW.RECON_TEAM},
		},
	}
	
	t_kr.recce_group[1].rides = {
		{
			sbp			= SBP.CW.BREN_CARRIER,
			upg			= {},
		},
		{
			sbp			= SBP.CW.BREN_CARRIER,
			upg			= {},
		},
	}
	
	t_kr.recce_group[1].squads[1].pref_ride = t_kr.recce_group[1].rides[1]
	t_kr.recce_group[1].squads[2].pref_ride = t_kr.recce_group[1].rides[2]
	
	t_kr.recce_group[1].states = {
		{	-- PURPOSE: default state of the recce groups (do nothing)
			state		= "default",													-- the name of the state
			ExecState 	= function() KR_ExecDefault(t_kr.recce_group[1]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckDefault(t_kr.recce_group[1]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterDefault(t_kr.recce_group[1]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitDefault(t_kr.recce_group[1]) end,			-- this function transitions out of this state
			priority 	= 1																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Mobilize state spawns the squads and gets them to go to their vehicles.
			state		= "mobilize",													-- the name of the state
			ExecState 	= function() KR_ExecMobilize(t_kr.recce_group[1]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckMobilize(t_kr.recce_group[1]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterMobilize(t_kr.recce_group[1]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitMobilize(t_kr.recce_group[1]) end,			-- this function transitions out of this state
			priority 	= 10																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Retreat state forces all the squads to run back to the beginning of the road
			state		= "retreat",													-- the name of the state
			ExecState 	= function() KR_ExecRetreat(t_kr.recce_group[1]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckRetreat(t_kr.recce_group[1]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterRetreat(t_kr.recce_group[1]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitRetreat(t_kr.recce_group[1]) end,			-- this function transitions out of this state
			priority 	= 8																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Defend state spawns the squads and gets them to go to their vehicles.
			state		= "defend",													-- the name of the state
			ExecState 	= function() KR_ExecDefend(t_kr.recce_group[1]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckDefend(t_kr.recce_group[1]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterDefend(t_kr.recce_group[1]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitDefend(t_kr.recce_group[1]) end,			-- this function transitions out of this state
			priority 	= 5																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: StratPoint state of the recce groups - check to see if one of the strat points needs to be recaptured
			state		= "strat_point",													-- the name of the state
			ExecState 	= function() KR_ExecStratPoint(t_kr.recce_group[1]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckStratPoint(t_kr.recce_group[1]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterStratPoint(t_kr.recce_group[1]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitStratPoint(t_kr.recce_group[1]) end,			-- this function transitions out of this state
			priority 	= 4																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Venture state of the recce groups (do nothing)
			state		= "venture",													-- the name of the state
			ExecState 	= function() KR_ExecVenture(t_kr.recce_group[1]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckVenture(t_kr.recce_group[1]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterVenture(t_kr.recce_group[1]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitVenture(t_kr.recce_group[1]) end,			-- this function transitions out of this state
			priority 	= 3																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Demobilize state orders squads back to their safehouse
			state		= "demobilize",														-- the name of the state
			ExecState 	= function() KR_ExecDemobilize(t_kr.recce_group[1]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckDemobilize(t_kr.recce_group[1]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterDemobilize(t_kr.recce_group[1]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitDemobilize(t_kr.recce_group[1]) end,			-- this function transitions out of this state
			priority 	= 2																	-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
	}
	
	-- the final recce group that the player will encounter.
	t_kr.recce_group[2].squads = {
		{
			sbp			= SBP.CW.COMMAND_CROMWELL,
			upg			= {UPG.CW.TANKCOMMANDER},
		},
		{
			sbp			= SBP.CW.STUART,
			upg			= {UPG.CW.TANKCOMMANDER},
		},
		{
			sbp			= SBP.CW.BREN_CARRIER,
			upg			= {UPG.CW.BREN_CARRIER_MMG},
		},
	}
	
	-- no rides for the command tank group
	t_kr.recce_group[2].rides = {
	}
	
	t_kr.recce_group[2].states = {
		{	-- PURPOSE: default state of the recce groups (do nothing)
			state		= "default",													-- the name of the state
			ExecState 	= function() KR_ExecDefault(t_kr.recce_group[2]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckDefault(t_kr.recce_group[2]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterDefault(t_kr.recce_group[2]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitDefault(t_kr.recce_group[2]) end,			-- this function transitions out of this state
			priority 	= 1																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Mobilize state spawns the squads and gets them to go to their vehicles.
			state		= "mobilize",													-- the name of the state
			ExecState 	= function() KR_ExecMobilize(t_kr.recce_group[2]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckMobilize(t_kr.recce_group[2]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterMobilize(t_kr.recce_group[2]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitMobilize(t_kr.recce_group[2]) end,			-- this function transitions out of this state
			priority 	= 10																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Retreat state forces all the squads to run back to the beginning of the road
			state		= "retreat",													-- the name of the state
			ExecState 	= function() KR_ExecRetreat(t_kr.recce_group[2]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckRetreat(t_kr.recce_group[2]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterRetreat(t_kr.recce_group[2]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitRetreat(t_kr.recce_group[2]) end,			-- this function transitions out of this state
			priority 	= 8																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Defend state spawns the squads and gets them to go to their vehicles.
			state		= "defend",													-- the name of the state
			ExecState 	= function() KR_ExecDefend(t_kr.recce_group[2]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckDefend(t_kr.recce_group[2]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterDefend(t_kr.recce_group[2]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitDefend(t_kr.recce_group[2]) end,			-- this function transitions out of this state
			priority 	= 5																-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: Demobilize state orders squads back to their safehouse
			state		= "demobilize",														-- the name of the state
			ExecState 	= function() KR_ExecDemobilize(t_kr.recce_group[2]) end,			-- the function to execute the state
			CheckState 	= function() return KR_CheckDemobilize(t_kr.recce_group[2]) end,	-- the function that checks if the current state is valid
			EnterState	= function() KR_EnterDemobilize(t_kr.recce_group[2]) end,			-- this function transitions into this state
			ExitState	= function() KR_ExitDemobilize(t_kr.recce_group[2]) end,			-- this function transitions out of this state
			priority 	= 2																	-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
	}

	if t_kr.recce_group[3] ~= nil then
		t_kr.recce_group[3].squads = {
			{
				sbp			= SBP.CW.LIEUTENANT,
				upg			= {},
			},
			{
				sbp			= SBP.CW.SAPPER,
				upg			= {UPG.ALLIES.ENGINEER_FLAMETHROWER},
			},
			{
				sbp			= SBP.CW.TOMMIES,
				upg			= {UPG.CW.BREN},
			},
		}
	
		t_kr.recce_group[3].rides = {
			{
				sbp			= SBP.ALLIES.HALFTRACK,
				upg			= {},
			},
		}
	
		t_kr.recce_group[3].squads[1].pref_ride = t_kr.recce_group[3].rides[1]
		t_kr.recce_group[3].squads[2].pref_ride = t_kr.recce_group[3].rides[1]
		t_kr.recce_group[3].squads[3].pref_ride = t_kr.recce_group[3].rides[1]
		
		t_kr.recce_group[3].states = {
			{	-- PURPOSE: default state of the recce groups (do nothing)
				state		= "default",														-- the name of the state
				ExecState 	= function() KR_ExecDefault(t_kr.recce_group[3]) end,				-- the function to execute the state
				CheckState 	= function() return KR_CheckDefault(t_kr.recce_group[3]) end,		-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterDefault(t_kr.recce_group[3]) end,				-- this function transitions into this state
				ExitState	= function() KR_ExitDefault(t_kr.recce_group[3]) end,				-- this function transitions out of this state
				priority 	= 1																	-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: Mobilize state spawns the squads and gets them to go to their vehicles.
				state		= "mobilize",													-- the name of the state
				ExecState 	= function() KR_ExecMobilize(t_kr.recce_group[3]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckMobilize(t_kr.recce_group[3]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterMobilize(t_kr.recce_group[3]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitMobilize(t_kr.recce_group[3]) end,			-- this function transitions out of this state
				priority 	= 10																-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: Retreat state forces all the squads to run back to the beginning of the road
				state		= "retreat",													-- the name of the state
				ExecState 	= function() KR_ExecRetreat(t_kr.recce_group[3]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckRetreat(t_kr.recce_group[3]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterRetreat(t_kr.recce_group[3]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitRetreat(t_kr.recce_group[3]) end,			-- this function transitions out of this state
				priority 	= 8																-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: Defend state spawns the squads and gets them to go to their vehicles.
				state		= "defend",													-- the name of the state
				ExecState 	= function() KR_ExecDefend(t_kr.recce_group[3]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckDefend(t_kr.recce_group[3]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterDefend(t_kr.recce_group[3]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitDefend(t_kr.recce_group[3]) end,			-- this function transitions out of this state
				priority 	= 5																-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: StratPoint state of the recce groups - check to see if one of the strat points needs to be recaptured
				state		= "strat_point",													-- the name of the state
				ExecState 	= function() KR_ExecStratPoint(t_kr.recce_group[3]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckStratPoint(t_kr.recce_group[3]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterStratPoint(t_kr.recce_group[3]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitStratPoint(t_kr.recce_group[3]) end,			-- this function transitions out of this state
				priority 	= 3																-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: Demobilize state orders squads back to their safehouse
				state		= "demobilize",														-- the name of the state
				ExecState 	= function() KR_ExecDemobilize(t_kr.recce_group[3]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckDemobilize(t_kr.recce_group[3]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterDemobilize(t_kr.recce_group[3]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitDemobilize(t_kr.recce_group[3]) end,			-- this function transitions out of this state
				priority 	= 2																	-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
		}
	end
	
	if t_kr.recce_group[4] ~= nil then
		t_kr.recce_group[4].squads = {
			{
				sbp			= SBP.CW.SAPPER,
				upg			= {UPG.CW.PIAT},
			},
			{
				sbp			= SBP.CW.LIEUTENANT,
				upg			= {},
			},
			{
				sbp			= SBP.CW.STUART,
				upg			= {},
			},
		}
	
		t_kr.recce_group[4].rides = {
			{
				sbp			= SBP.CW.BREN_CARRIER,
				upg			= {},
			},
		}
	
		t_kr.recce_group[4].squads[1].pref_ride = t_kr.recce_group[4].rides[1]
		t_kr.recce_group[4].squads[2].pref_ride = t_kr.recce_group[4].rides[1]
		
		t_kr.recce_group[4].states = {
			{	-- PURPOSE: default state of the recce groups (do nothing)
				state		= "default",														-- the name of the state
				ExecState 	= function() KR_ExecDefault(t_kr.recce_group[4]) end,				-- the function to execute the state
				CheckState 	= function() return KR_CheckDefault(t_kr.recce_group[4]) end,		-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterDefault(t_kr.recce_group[4]) end,				-- this function transitions into this state
				ExitState	= function() KR_ExitDefault(t_kr.recce_group[4]) end,				-- this function transitions out of this state
				priority 	= 1																	-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: Mobilize state spawns the squads and gets them to go to their vehicles.
				state		= "mobilize",													-- the name of the state
				ExecState 	= function() KR_ExecMobilize(t_kr.recce_group[4]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckMobilize(t_kr.recce_group[4]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterMobilize(t_kr.recce_group[4]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitMobilize(t_kr.recce_group[4]) end,			-- this function transitions out of this state
				priority 	= 10																-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: Retreat state forces all the squads to run back to the beginning of the road
				state		= "retreat",													-- the name of the state
				ExecState 	= function() KR_ExecRetreat(t_kr.recce_group[4]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckRetreat(t_kr.recce_group[4]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterRetreat(t_kr.recce_group[4]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitRetreat(t_kr.recce_group[4]) end,			-- this function transitions out of this state
				priority 	= 8																-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: Defend state spawns the squads and gets them to go to their vehicles.
				state		= "defend",													-- the name of the state
				ExecState 	= function() KR_ExecDefend(t_kr.recce_group[4]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckDefend(t_kr.recce_group[4]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterDefend(t_kr.recce_group[4]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitDefend(t_kr.recce_group[4]) end,			-- this function transitions out of this state
				priority 	= 5																-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: StratPoint state of the recce groups - check to see if one of the strat points needs to be recaptured
				state		= "strat_point",													-- the name of the state
				ExecState 	= function() KR_ExecStratPoint(t_kr.recce_group[4]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckStratPoint(t_kr.recce_group[4]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterStratPoint(t_kr.recce_group[4]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitStratPoint(t_kr.recce_group[4]) end,			-- this function transitions out of this state
				priority 	= 3																-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
			{	-- PURPOSE: Demobilize state orders squads back to their safehouse
				state		= "demobilize",														-- the name of the state
				ExecState 	= function() KR_ExecDemobilize(t_kr.recce_group[4]) end,			-- the function to execute the state
				CheckState 	= function() return KR_CheckDemobilize(t_kr.recce_group[4]) end,	-- the function that checks if the current state is valid
				EnterState	= function() KR_EnterDemobilize(t_kr.recce_group[4]) end,			-- this function transitions into this state
				ExitState	= function() KR_ExitDemobilize(t_kr.recce_group[4]) end,			-- this function transitions out of this state
				priority 	= 2																	-- a value from 1-10 (low to high) that indicates the importance of this state over others
			},
		}
	end
	-- setting up the spawn/management tables for the various sgroups
	for i=1, table.getn(t_kr.recce_group) do 
		
		local squads = SGroup_CreateTable("sg_kr" ..i.. "_%d", table.getn(t_kr.recce_group[i].squads))
		local markers = Marker_GetTable("mkr_kr_sp" ..i.. "_%d")
		local attacker = SGroup_CreateIfNotFound("sg_kr_attacker"..i)
		
		t_kr.recce_group[i].eg_active_rp 			= false							-- the resource/strategic point that this recce group is responsible for defending.
		t_kr.recce_group[i].fg_mobilize 			= false							-- a flag to indicate whether or not the recce group is busy mobilizing their forces.
		t_kr.recce_group[i].fg_busy 				= false							-- a flag to indicate whether or not the recce group is already actively engaged in another state.
		t_kr.recce_group[i].timer_respawn 			= "KR RECCE GROUP RESPAWN"..i	-- the timer to control how quickly the squads are spawned while mobilizing.
		t_kr.recce_group[i].timer_respawn_amt 		= 5								-- a timer that controls the amount of respawn time
		t_kr.recce_group[i].eg_spawn 				= teg_kr_sp[i] 					-- the building from which squads spawn and despawn (home base)
		t_kr.recce_group[i].sg_attacker 			= attacker						-- the sgroup which the squads will attack
		t_kr.recce_group[i].sg_leader 				= squads[1]						-- the sgroup which is "commanding" all the soldiers, which is always the
		t_kr.recce_group[i].td_defense_group_id		= false							-- the id referencing the town defense that this particular recce group is currently defending
		t_kr.recce_group[i].pos_attack				= false							-- the position to which the squads will move when responding to an attack
		t_kr.recce_group[i].fg_defend_town			= true							-- a flag to indicate whether or not this group should defend the town members
		
		for k, this in pairs(t_kr.recce_group[i].squads) do
			
			this.sgroup = squads[k]
			
			if KR_IsSoldier(this.sbp) then
				this.spawn = teg_kr_sp[i]
				this.fg_soldier = true
			else
				this.spawn = markers[k]
				this.fg_soldier = false
			end
		end
		
		squads = SGroup_CreateTable("sg_kr_rides" .. i .. "_%d", table.getn(t_kr.recce_group[i].rides))
		markers = Marker_GetTable("mkr_kr_sp_ride" ..i.. "_%d")
		
		for k, this in pairs(t_kr.recce_group[i].rides) do
			this.sgroup = squads[k]
			this.spawn = markers[k]
			
			if this.sbp == SBP.CW.BREN_CARRIER then
				this.capacity_squads = 2
				this.capacity_members = 6
			elseif this.sbp == SBP.ALLIES.HALFTRACK then
				this.capacity_squads = 3
				this.capacity_members = 12
			end
		end
		
	end
	
	t_kr.recce_group[2].fg_defend_town = false
	t_kr.recce_group[2].fg_defend_jeeps = true
	
	t_kr.flank_data = {
		offset_flanks = {
			OFFSET_LEFT,
			OFFSET_RIGHT,
			OFFSET_FRONT_LEFT,
			OFFSET_FRONT_RIGHT,
			OFFSET_BACK_RIGHT,
			OFFSET_BACK_LEFT,
		},
		offset_dist = 15,
	}
	
	KR_GetAllRPs()


end

function KillRecce_InitEvents()
	----------------------------------------------------------------------------
	-- INTEL EVENTS
	----------------------------------------------------------------------------
	-- a table that will contain all the associated events for this objective.
	t_kr.events = {
		obj_start = {
			{ACTOR.CXP2.Wolfgang, 1440550},
--~ 			{ACTOR.CXP2.Wolfgang, 1440560}, -- removing because it doesn't make sense without a sitrep.
			{ACTOR.CXP2.Wolfgang, 1440570},
		},
		
		-- flag to indicate whether this intel has been triggered or not
		fg_command_tank_spotted = false,
		command_tank_spotted = {
			{ACTOR.CXP2.Deinhard, 1440650},
			{ACTOR.CXP2.Deinhard, 1440660},
		},
		
		fg_road_covered = false,
		road_covered = {
			{ACTOR.CXP2.Aldrich, 1440620},
			{ACTOR.CXP2.Aldrich, 1440640},
			{ACTOR.CXP2.Aldrich, 1440645},
		},
		
		obj_complete = {
			{ACTOR.CXP2.GenericCommonwealth, 1440670},
			{ACTOR.CXP2.Deinhard, 1440680},
			{ACTOR.CXP2.Deinhard, 1440690},
		},
		
		-- celebration of the completion of the objective
		am_complete = {
			{{ACTOR.CXP2.GenericPanzerElite, 1440700}},
			{{ACTOR.CXP2.GenericPanzerElite, 1440710}},
			{{ACTOR.CXP2.GenericPanzerElite, 1440720}},
		},
		
		fg_sappers_contact = false,
		am_sappers_contact = {
			{ACTOR.CXP2.GenericPanzerElite, 1440610},
		},
		
		fg_lt_contact = false,
		am_lt_contact = {
			{ACTOR.CXP2.GenericPanzerElite, 1440590},
		},
		
		fg_tommy_contact = false,
		am_tommy_contact = {
			{ACTOR.CXP2.GenericPanzerElite, 1440600},
		},
		
		fg_stuart_contact = false,
		am_stuart_contact = {
			{ACTOR.CXP2.GenericPanzerElite, 1440580},
		},
		
	}

end

function KillRecce_Preset()

	-- spawn squads
	KR_SpawnSquads()
	
	-- start enemy behavior
	for i=1, table.getn(teg_rp) do 
		if not EGroup_IsEmpty(teg_rp[i])
		and Player_OwnsEGroup(player2, teg_rp[i]) == false 
		and Player_OwnsEGroup(player1, teg_rp[i]) == false then
			table.insert(teg_kr_capture_rp,  teg_rp[i])
		end
	end

end

-- example of how to finish an Obj
function KillRecce_WinCheck()
	
	-- one of them must be set to true before the player can win or lose the objective
	local num = 0
	for i=1, table.getn(tsg_kr_primary_target) do
		if SGroup_IsEmpty(tsg_kr_primary_target[i]) then
			num = num + 1
		end
	end
	
	if num == t_kr.total_recce then
		Rule_RemoveMe()
		Rule_AddInterval(TD_Retreat, 2)
		Objective_Complete(OBJ_KillRecce)
		Rule_AddDelayedInterval(GarrisonChurch_DelayStart, 5, 1)
	end
	
end



function KillRecce_AmbientCelebrate()

	if Event_IsAnyRunning() == false then
		local rand = World_GetRand(1, table.getn(t_kr.events.am_complete))
		Util_AutoAmbient(t_kr.events.am_complete[rand])
		Rule_RemoveMe()
	end

end


function KR_ForceSitRep()

	if Objective_IsComplete(OBJ_KillRecce) then
		Rule_RemoveMe()
		return
	end
	
	sg_scout_road = SGroup_CreateIfNotFound("sg_scout_road")
	
	-- a check to see if the player has "scouted" the road
	if g_scout_road == nil then
		
		Player_GetAllSquadsNearMarker(player1, sg_scout_road, mkr_ambush_scout_road, 25)
		
		if SGroup_IsEmpty(sg_scout_road) then
			return
		else
			g_scout_road = true
		end
		
	end

	Player_GetAll(player1, sg_temp)
	
	if SGroup_IsUnderAttack(sg_temp, ANY, 5) == false 
	and SGroup_IsDoingAttack(sg_temp, ANY, 5) == false
	and Event_IsAnyRunning() == false then
	
		-- surreptitiously add in the sitrep and pretend it was always there
		OBJ_KillRecce.OnStart = function() end
		
		
		OBJ_KillRecce.SitRep = {
			Movie = "CXP2_SR_04-01",
			Force = false,
			SpeechTiming =
			{
				{ 1,	ACTOR.CXP2.Wolfgang, 1442000 },
				{ 6,	ACTOR.CXP2.Wolfgang, 1442010 },
				{ 10.5,	ACTOR.CXP2.Wolfgang, 1442020 },
				{ 18,	ACTOR.CXP2.Voss, 1442030 },
				{ 25,	ACTOR.CXP2.Voss, 1442040 },
				{ 34,	ACTOR.CXP2.Voss, 1442041 },
			},
		}
		
		-- and force the sitrep to play
		Objective_UpdateText(OBJ_KillRecce, 1449050, 1449051, true)
		Obj_SetObjectiveFunction(OBJ_KillRecce.ID, FN_OnActivate, __ObjectiveOnActivateCallback)
		Objective_ForceSitRep(OBJ_KillRecce)
		
		Rule_Add(KR_PostSitRep)
		Rule_RemoveMe()
	end

end

function KR_PostSitRep()

	if Event_IsAnyRunning() == false then
		Objective_RemoveUIElements(OBJ_KillRecce, OBJ_KillRecce.mapElementID)
		OBJ_KillRecce.mapElementID = Objective_AddUIElements(OBJ_KillRecce, tsg_kr_primary_target[1], true, 1449052, true)
		
		Rule_AddDelayedInterval(HHAmbush_MarderSelected, 5, 3)
		Rule_RemoveMe()
	end

end




-- start the related action
function KillRecce_Kickoff()
	
	if Event_IsAnyRunning() == false then
		
		Util_AutoIntel(t_kr.events.obj_start)
		-- action that starts with the Obj being granted
		t_kr.recce_group[2].state_machine_id = StateMachine_AddTable(t_kr.recce_group[2].states)
		
		if g_difficulty >= GD_NORMAL then
			t_kr.recce_group[3].state_machine_id = StateMachine_AddTable(t_kr.recce_group[3].states)
		end
		
		if g_difficulty >= GD_EXPERT then
			t_kr.recce_group[4].state_machine_id = StateMachine_AddTable(t_kr.recce_group[4].states)
		end
		
		t_kr.recce_group[1].state_machine_id = StateMachine_AddTable(t_kr.recce_group[1].states)
		
		Rule_AddInterval(HHAmbush_ReinforceHint, 3)
		Rule_RemoveMe()
	end
	
end

-- returns a random upgrade that Tommies can use
function KR_RandomTommyUpgrade()

	temp = {UPG.CW.RECON_TEAM, UPG.CW.RIFLE_GRENADE, UPG.CW.BREN}
	local rand = World_GetRand(1, table.getn(temp))
	return temp[rand]

end

-- return true or false depending on whether or not the SPB supplied is
-- considered a soldier (i.e. garrisonable in a building)
function KR_IsSoldier(sbp)

	for k, this in pairs(t_kr_soldiers) do
		if this == sbp then
			return true
		end
	end
	
	return false

end


function KR_FlankTarget(recce_group)

	for k, this in pairs(recce_group) do
		if not SGroup_IsEmpty(this.sgroup) then
			
			local target = recce_group.pos_attack
			-- choose a specific squad from the attackers to flank, rather than attacking everyone that is present
			SGroup_Clear(sg_temp)
			if not SGroup_IsEmpty(recce_group.sg_attacker) then
				local squad = SGroup_GetRandomSpawnedSquad(recce_group.sg_attacker)
				SGroup_Add(sg_temp, squad)
			end
			
			-- change the target to one of the squads in the attacker group
			if not SGroup_IsEmpty(sg_temp) then
				target = sg_temp
			end
			if k == 1 then
					Cmd_AttackMove(this.sgroup, recce_group.pos_attack)
			elseif t_kr.flank_data.offset_flanks[k] ~= nil then
				Cmd_Move(this.sgroup, target, nil, nil, nil, t_kr.flank_data.offset_flanks[k], t_kr.flank_data.offset_dist)
			else
				Cmd_AttackMove(this.sgroup, target)
			end
			
		end
	end

end

-- this function gathers all the resource points owned
-- by player2 on the map and loops through them, creates
-- a separate egroup for each one and sets up some associated data.
function KR_GetAllRPs()

	t_kr.strat_points = {}
	t_rps = {
		EBP.STRAT_POINT.FUEL_HIGH,
		EBP.STRAT_POINT.FUEL_MED,
		EBP.STRAT_POINT.FUEL_LOW,
		EBP.STRAT_POINT.MUN_HIGH,
		EBP.STRAT_POINT.MUN_LOW,
		EBP.STRAT_POINT.MUN_MED,
		EBP.STRAT_POINT.NO_RESOURCE,
	}
	
	Player_GetAll(player2, sg_temp, eg_temp)
	EGroup_Filter(eg_temp, t_rps, FILTER_KEEP)
	
	_CreateRPs = function(gid, idx, eid)
		
		t_kr.strat_points[idx] = {}
		local this = t_kr.strat_points[idx]
		
		this.egroup = EGroup_CreateIfNotFound("eg_kr_rp"..idx)  -- the egroup containing the strat point
		this.fg_recapped = false								-- whether or not they have capped the strat point
		
		EGroup_Add(this.egroup, eid)
		
	end
	
	EGroup_ForEach(eg_temp, _CreateRPs)

end

-- this function is reponsible for spawning all the starting squads at the beginning of the mission
function KR_SpawnSquads()

	for i=1, table.getn(t_kr.recce_group) do
	
		for k, this in pairs(t_kr.recce_group[i].squads) do
			if this.fg_soldier == false
			or this.sbp == SBP.CW.LIEUTENANT
			or k == 1 then
				if scartype(this.spawn) ~= ST_EGROUP or not EGroup_IsEmpty(this.spawn) then
					Util_CreateSquads(player2, this.sgroup, this.sbp, this.spawn, nil, nil, nil, nil, nil, this.upg)
				end
				
				-- hack to add in the command tank as the primary target for the mission
				if k == 1 
				and i==2 
				and not SGroup_IsEmpty(this.sgroup)then
					SGroup_AddGroup(tsg_kr_primary_target[1], this.sgroup)
					if this.sbp == SBP.CW.LIEUTENANT then
						Modify_Vulnerability(this.sgroup, t_kr.vulnerability_factor)
					end
				end
				
				
			end
			
		end
		
		for k, this in pairs(t_kr.recce_group[i].rides) do
			Util_CreateSquads(player2, this.sgroup, this.sbp, this.spawn, nil, nil, nil, nil, nil, this.upg)
		end
	
	end

end

-- this function is responsible for ordering squads to get out of buildings
-- occupy the vehicles and move to the necessar destination.
function KR_Mobilize(recce_group)

	for k, this in pairs(recce_group.squads) do
	
		if this.fg_soldier == true then
			
			-- check if the soldiers need to be spawned
			if SGroup_IsEmpty(this.sgroup) 
			and recce_group.fg_mobilize ~= "no_spawn" then
				if Timer_Exists(recce_group.timer_respawn) == false
				or Timer_GetRemaining(recce_group.timer_respawn) == 0 then
					
					-- this assumes that the spawn location for the squads is always an egroup
					if not EGroup_IsEmpty(this.spawn) then
						Util_CreateSquads(player2, this.sgroup, this.sbp, this.spawn, nil, nil, nil, nil, nil, this.upg)
					end
					
					this.fg_can_load = true
					-- this is to prevent "clown spawning", but speeds up the process when the player cannot see the buildings
					if Player_CanSeeEGroup(player1, this.spawn, ANY) then
						Timer_Start(recce_group.timer_respawn, recce_group.timer_respawn_amt)
					end
				end
			-- check if they are in a building
			else
				KR_OccupyVehicles(this, recce_group.rides)
			end
		
		end
	
	end

end

-- this function takes a recce_squad and orders them to get into an available vehicles for riding
function KR_OccupyVehicles(this, rides)
--~ 	print("KR_OccupyVehicles: Start")
	-- variable used to indicate whether or not the squad was able to find a vehicle to get into
	local all_full = true
	local sg_ride
	if SGroup_IsInHoldEntity(this.sgroup, ANY) then
		Cmd_UngarrisonSquad(this.sgroup)
		all_full = false
	elseif not SGroup_IsInHoldSquad(this.sgroup, ANY) 
	and this.fg_can_load ~= false then
		
		-- first pick the preferred ride
		if this.pref_ride ~= nil
		and not SGroup_IsEmpty(this.pref_ride.sgroup)
		and SGroup_CanLoadSGroup(this.pref_ride.sgroup, this.sgroup, ALL)
		and KR_IsVehicleFull(this.pref_ride.sgroup, this.pref_ride.capacity_squads, this.pref_ride.capacity_members) == false then
			print("KR_OccupyVehicles: ".. SGroup_GetName(this.sgroup) .." getting in a Vehicle")
			all_full = false
			if not SGroup_IsMoving(this.sgroup, ANY) then 
				Cmd_Garrison(this.sgroup, this.pref_ride.sgroup)
			end
			sg_ride = this.pref_ride.sgroup
		else
			-- check for the available rides and load the squads
			-- into those "rides."
			for j, ride in pairs(rides) do
				
				-- pick a vehicle that is not full to get into
				-- there should be enough vehicles for everyone
				if not SGroup_IsEmpty(ride.sgroup)
				and SGroup_CanLoadSGroup(ride.sgroup, this.sgroup, ALL)
				and KR_IsVehicleFull(ride.sgroup, ride.capacity_squads, ride.capacity_members) == false then
					all_full = false
					if not SGroup_IsMoving(this.sgroup, ANY) then 
						Cmd_Garrison(this.sgroup, ride.sgroup)
					end
					
					sg_ride = ride.sgroup
				end
			end
		end

		-- all full is only triggered when the vehicle cannot
		-- load all the squads (even if it is not full -- like the squad is too large)
		if all_full then
			this.fg_can_load = false
		else
			-- order the "ride" to go and pick the squads up to speed things up a bit
			-- brw - problem, the squads try to move out of the way of the moving vehicle
			if not SGroup_IsMoving(sg_ride, ANY) 
			and Prox_SGroupSGroup(sg_ride, this.sgroup, PROX_CENTER) > 20 then
				Cmd_Move(sg_ride, Util_GetPosition(this.sgroup))
			else
				Cmd_Stop(sg_ride)
			end
		end
		
	end
	
	-- give the result as the opposite of what happened, because
	-- if the squad is NOT all full, then the squad should be able to occupy 
	-- an available vehicle.
	return not all_full

end


-- this orders the squads out of the vehicle and into the building
function KR_Demobilize(recce_group)

	for k, this in pairs(recce_group.squads) do
		
		if not SGroup_IsEmpty(this.sgroup) then
			if Prox_AreSquadsNearMarker(this.sgroup, Util_GetPosition(this.spawn), ANY, 30) == false then
				
				if SGroup_IsInHoldEntity(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup)
				elseif SGroup_IsIdle(this.sgroup, ANY) then
					Cmd_Move(this.sgroup, this.spawn)
				end			
				
			elseif this.fg_soldier == true then
				
				-- check if the sgroup has made it into the building
				if SGroup_IsInHoldEntity(this.sgroup, ANY) then
					if Prox_AreSquadMembersNearMarker(this.sgroup, Util_GetPosition(this.spawn), ANY, 10) == false then
						Cmd_UngarrisonSquad(this.sgroup)
					elseif k ~= 1 then
						-- despawn squads that are in the building, except the commander
						SGroup_DestroyAllSquads(this.sgroup)
					end
				elseif not SGroup_IsInHoldSquad(this.sgroup, ANY)
				and not SGroup_IsMoving(this.sgroup, ANY) then
					Cmd_Garrison(this.sgroup, this.spawn)
				elseif SGroup_IsInHoldSquad(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup)
				end
				
			end
		end
		
	end
	
	for k, this in pairs(recce_group.rides) do
	
		if not SGroup_IsEmpty(this.sgroup) then
			
			local pos = this.spawn
			
			if SGroup_IsHoldingAny(this.sgroup) then
				pos = Util_GetPosition(recce_group.eg_spawn)
			end
			
			if Prox_AreSquadsNearMarker(this.sgroup, pos, ANY, 30) == false 
			and SGroup_IsIdle(this.sgroup, ANY) then
				Cmd_Move(this.sgroup, Util_GetRandomPosition(pos, 15))
			end
		end
	end

end

-- utility function that will indicate whether or not a vehicle is full.
function KR_IsVehicleFull(sgroup, squad_capacity, members_capacity)

	local _sg = SGroup_CreateIfNotFound("_sg")

	if not SGroup_IsEmpty(sgroup) then
		if SGroup_IsHoldingAny(sgroup) then
			SGroup_GetSquadsHeld(sgroup, _sg)
			local num = SGroup_CountSpawned(_sg)
			if num >= squad_capacity then
				SGroup_Destroy(_sg)
				return true
			end
			
			num = SGroup_TotalMembersCount(_sg)
			if num >= members_capacity then
				SGroup_Destroy(_sg)
				return true
			end
			
		end
	end
	
	SGroup_Destroy(_sg)
	return false

end


-------------------------------------------------------------------------
-- RECCE DEFEAULT
-- this state is responsible for ordering the recce elements back
-- inside of the town to defend it until the bigger guns arrive.
-------------------------------------------------------------------------
-- these states determine what the recce elements should do in 
-- response to one of its strat points being taken
function KR_CheckDefault(recce_group)

	return true
	
end

function KR_EnterDefault(recce_group)
	
	recce_group.fg_mobilize = false
	recce_group.fg_finished_mobilizing = false


end


function KR_ExitDefault(recce_group)


end


function KR_ExecDefault(recce_group)

	recce_group.fg_busy = false
	
	-- if the commander of the recce group is dead then we no longer
	-- need to continue to support this group
	if SGroup_IsEmpty(recce_group.squads[1].sgroup) then
		StateMachine_RemoveTable(recce_group.state_machine_id)
	end

end

function KR_StopSquads(recce_group)
	
	for k, this in pairs(recce_group.squads) do
		if not SGroup_IsEmpty(this.sgroup) then
			Cmd_Stop(this.sgroup)
		end
	end

	for k, this in pairs(recce_group.rides) do
		if not SGroup_IsEmpty(this.sgroup) then
			Cmd_Stop(this.sgroup)
		end
	end
	
end


-------------------------------------------------------------------------
-- RECCE VENTURE STATES 
--  this behavior is not given to all the recce groups.
--  it basicall orders a squad to "venture" out and
--  continue capture points and move the recce command forward towards
--  the player
-------------------------------------------------------------------------

-- this orders the particular squad to go out and capture various points that player2 does not own yet.
function KR_CheckVenture(recce_group)

	if SGroup_IsEmpty(recce_group.sg_leader) then
		return false
	end

	if recce_group.eg_active_rp ~= false
	and Player_OwnsEGroup(player2, recce_group.eg_active_rp) == false then
		return true
	end
	
	-- loop through the various tables to remove them from checking
	-- and adding them to the strat points to be monitored
	for i=table.getn(teg_kr_capture_rp), 1, -1 do
		if Player_OwnsEGroup(player2, teg_kr_capture_rp[i]) then
			
			-- add this point now to be monitored for recapture by
			-- the recce groups
			local temp = {
				egroup = teg_kr_capture_rp[i],
				fg_recapped = false,
			}
			
			table.insert(t_kr.strat_points, temp)
			table.remove(teg_kr_capture_rp, i)
		end
	end
	
	-- first check if the current point to be captured is owned by player2
	if recce_group.eg_active_rp == false 
	or Player_OwnsEGroup(player2, recce_group.eg_active_rp) then
	
		-- indicate that we have not found a point yet.
		recce_group.eg_active_rp = false
		
		-- find a new point to capture,
		-- do them in a specific order, so that the player encounters the initial recce group right away
		for i=1, table.getn(teg_kr_capture_rp) do 
			
			if Player_OwnsEGroup(player2, teg_kr_capture_rp[i]) == false then
				recce_group.eg_active_rp = teg_kr_capture_rp[i]
				return true
			end
			
		end
		
	end
	
	return false

end

function KR_EnterVenture(recce_group)

end

function KR_ExitVenture(recce_group)

end

function KR_ExecVenture(recce_group)
	
	-- the idea is the same, just use the strat point code to execute, if 
	-- this ever needs to be executed
	KR_ExecStratPoint(recce_group)

end


-------------------------------------------------------------------------
-- RECCE DEFEND STRATEGIC POINT
-- this state is responsible for defending the various strategic points
-- around the town.
-------------------------------------------------------------------------
-- these states determine what the recce elements should do in 
-- response to one of its strat points being taken
function KR_CheckStratPoint(recce_group)

	if SGroup_IsEmpty(recce_group.sg_leader) then
		return false
	end

	if recce_group.eg_active_rp ~= false
	and Player_OwnsEGroup(player2, recce_group.eg_active_rp) == false then
		return true
	end
	
	for k, this in pairs(t_kr.strat_points) do
	
		if this.fg_recapped == true then
			table.remove(t_kr.strat_points, k)
		elseif Player_OwnsEGroup(player2, this.egroup) == false then
			if recce_group.fg_busy == false
			and this.fg_responding ~= true then
				recce_group.eg_active_rp = this.egroup
				this.fg_responding = true
				return true
			end
		end
		
	end
	
	return false

end

function KR_EnterStratPoint(recce_group)
	
	for k, this in pairs(recce_group.squads) do
		
		if this.fg_soldier == true then
			this.order = false
		end
	end

	KR_StopSquads(recce_group)

end


function KR_ExitStratPoint(recce_group)

	if recce_group.eg_active_rp ~= false 
	and Player_OwnsEGroup(player2, recce_group.eg_active_rp) then
		for k, this in pairs(t_kr.strat_points) do 
			if this.egroup == recce_group.eg_active_rp then
				this.fg_recapped = true
			end
		end
		recce_group.fg_busy = false
		recce_group.eg_active_rp = false
		recce_group.fg_mobilize = false
	end

end


function KR_ExecStratPoint(recce_group)

	local all_dead = true
	-- checking to see if there are any squads that
	-- can capture the strat point available.
	for k, this in pairs(recce_group.squads) do
		if this.fg_soldier == true
		and not SGroup_IsEmpty(this.sgroup) then
			all_dead = false
		end
	end

	if recce_group.fg_mobilize == false
	or all_dead then
		recce_group.fg_mobilize = "spawn"
		recce_group.fg_busy = true
		return
	end
	
	KR_CapturePoint(recce_group, recce_group.eg_active_rp)
	
end


function KR_CapturePoint(recce_group, eg_point)
	local pos = Util_GetPosition(eg_point)
	local capture = false
	
	-- first pick a squad to capture the point
	-- this picks the last squad in the group, so that
	-- other squads don't try to capture the point
	for i=table.getn(recce_group.squads), 1, -1 do
		this = recce_group.squads[i]
		if this.fg_soldier
		and not SGroup_IsEmpty(this.sgroup) then
			this.order = "capture"
			break
		end
	end
	
	-- give commands to the various squads to control how the
	-- they go about capturing the point.
	local rides_go = true	
	
	for k, this in pairs(recce_group.squads) do
		
		local rand_pos = Util_GetRandomPosition(pos, 20)
		
		if not SGroup_IsEmpty(this.sgroup) then
			-- are the squads near the point to capture?
			-- if not, then tell them to go there.
			if Prox_AreSquadsNearMarker(this.sgroup, pos, ANY, 35) == false then
				
				-- first check if squad is in their vehicle
				if SGroup_IsInHoldSquad(this.sgroup, ANY) == false
				and this.fg_can_load ~= false then
					KR_OccupyVehicles(this, recce_group.rides)
					rides_go = false
				end
				
				-- next check if they were able to get into the vehicle
				-- if not, then we just need to tell them to move to the point
				if this.fg_can_load == false then
					if SGroup_IsInHoldEntity(this.sgroup, ANY) then
						Cmd_UngarrisonSquad(this.sgroup, rand_pos)
					elseif  SGroup_IsIdle(this.sgroup, ANY) then
						Cmd_AttackMove(this.sgroup, rand_pos)
					end
				end
			-- special case situation for soldiers that are near the
			-- capture position
			elseif this.fg_soldier == true then
				
				if SGroup_IsInHoldSquad(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup)
					
				-- check if the "capture" squad is doing the appropriate action
				elseif not SGroup_IsCapturing(this.sgroup, ANY)
				and not SGroup_IsDoingAbility(this.sgroup, ABILITY.REENABLE_CAPTURE, ANY)
				and not SGroup_IsMoving(this.sgroup, ANY)
				and this.order == "capture" then
					if SGroup_IsInHoldEntity(this.sgroup, ANY) then
						Cmd_UngarrisonSquad(this.sgroup, pos)
					-- check if the point has been "disabled"
					elseif Modifier_IsEnabledOnEGroup(eg_point, "modifiers\\enable_capture_entity_modifier.lua", ANY, true) == false then
						Cmd_Ability(this.sgroup, ABILITY.REENABLE_CAPTURE, eg_point)
					else
						Cmd_AttackMoveThenCapture(this.sgroup, eg_point)
					end
				-- checks for the rest of the squads and orders them into nearby buildings to 
				-- defend the area while it is being captured.
				elseif not SGroup_IsMoving(this.sgroup, ANY)
				and (SGroup_IsCapturing(this.sgroup, ANY) or not SGroup_IsInHoldEntity(this.sgroup, ANY)) then
					this.order = "garrison"					
					local eg_garrison = Util_GarrisonNearbyBuilding(this.sgroup, pos, 30, false)
					
					if eg_garrison == nil 
					and not SGroup_IsInCover(this.sgroup, 0.5) then
						Cmd_Move(this.sgroup, pos, nil, nil, nil, nil, nil, 30)
					end
				end
			end
		end
	end
	
	for k, this in pairs(recce_group.rides) do
	
		if not SGroup_IsEmpty(this.sgroup) then
			local rand_pos = Util_GetRandomPosition(pos, 20)
			
			-- check if the vehicle has squads is "full" or everyone has been loaded int a vehicle.
			if Prox_AreSquadsNearMarker(this.sgroup, pos, ANY, 25) == false then
				if KR_IsVehicleFull(this.sgroup, this.capacity_squads, this.capacity_members)
				or rides_go == true then
					if not SGroup_IsMoving(this.sgroup, ANY) then
						Cmd_Stop(this.sgroup)
						Cmd_Move(this.sgroup, rand_pos)
					end
				end
			end
		end
	end

end

-------------------------------------------------------------------------
-- RECCE DEFEND
-- this state is responsible for keeping the group defended and secure
-- against attacks.
-------------------------------------------------------------------------
function KR_CheckDefend(recce_group)

	SGroup_Clear(recce_group.sg_attacker)
	
	for k, this in pairs(recce_group.squads) do 
		if not SGroup_IsEmpty(this.sgroup) then
			
			-- check what the player sees to play ambient speech.
			if Player_CanSeeSGroup(player1, this.sgroup, ANY)
			and SGroup_IsOnScreen(player1, this.sgroup, ANY, 0.8) then
				
				if t_kr.events.fg_lt_contact == false 
				and this.sbp == SBP.CW.LIEUTENANT then
					Util_AutoAmbient(t_kr.events.am_lt_contact)
					t_kr.events.fg_lt_contact = true
					
				elseif t_kr.events.fg_sappers_contact == false 
				and this.sbp == SBP.CW.SAPPER then
					Util_AutoAmbient(t_kr.events.am_sappers_contact)
					t_kr.events.fg_sappers_contact = true
				elseif t_kr.events.fg_stuart_contact == false 
				and this.sbp == SBP.CW.STUART then
					Util_AutoAmbient(t_kr.events.am_stuart_contact)
					t_kr.events.fg_stuart_contact = true
				end
				
			end
			
			if SGroup_IsUnderAttack(this.sgroup, ANY, 7) then
				SGroup_GetLastAttacker(this.sgroup, recce_group.sg_attacker)
				if not SGroup_IsEmpty(recce_group.sg_attacker) then
					recce_group.pos_attack = Util_GetPosition(recce_group.sg_attacker)
				end
				
				g_scout_road = true
				return true
			end
		end
	end
	
	for k, this in pairs(recce_group.rides) do 
		if not SGroup_IsEmpty(this.sgroup) then
			if SGroup_IsUnderAttack(this.sgroup, ANY, 7) then
				SGroup_GetLastAttacker(this.sgroup, recce_group.sg_attacker)
				if not SGroup_IsEmpty(recce_group.sg_attacker) then
					recce_group.pos_attack = Util_GetPosition(recce_group.sg_attacker)
				end
				g_scout_road = true
				return true
			end
		end
	end
	
	-- if none of the direct recce squads have determined a position defend,
	-- check if any of the towns defense's are under attack from long range fire.
	
	if recce_group.fg_defend_town ~= false then
		if recce_group.pos_attack == false then
			recce_group.td_defense_group_id = TD_CheckUnderAttack(recce_group.sg_attacker)
			
			-- if we have found a position to attack, then, attack that position
			if not SGroup_IsEmpty(recce_group.sg_attacker) then
				recce_group.pos_attack = Util_GetPosition(recce_group.sg_attacker)
				return true
			end
		elseif recce_group.td_defense_group_id ~= false then
			
			-- check to see if the attacker has moved or been updated
			SGroup_Clear(recce_group.sg_attacker)
			TD_UpdateAttacker(recce_group.td_defense_group_id, recce_group.sg_attacker)
			if not SGroup_IsEmpty(recce_group.sg_attacker) then
				recce_group.pos_attack = Util_GetPosition(recce_group.sg_attacker)
				
				g_scout_road = true
				return true
			end
			
		end
	end
	
	if recce_group.fg_defend_jeeps == true then
		
		for k, this in pairs(t_jeep_patrol) do 
			if not SGroup_IsEmpty(this.sgroup) then
				if SGroup_IsUnderAttack(this.sgroup, ANY, 7) then
					Player_GetAll(player1, recce_group.sg_attacker)
					if not SGroup_IsEmpty(recce_group.sg_attacker) then
						recce_group.pos_attack = Util_GetPosition(recce_group.sg_attacker)
					end
					return true
				end
			end
		end
		
	end
	
	-- check if any of the squads are near the attack position
	-- and if so, and they are not under attack, then remove them from the defend
	-- behavior
	local all_dead = true
	if recce_group.pos_attack ~= false then
		for k, this in pairs(recce_group.squads) do 
			if not SGroup_IsEmpty(this.sgroup) then
				
				all_dead = false
				if Prox_AreSquadsNearMarker(this.sgroup, recce_group.pos_attack, ANY, 30) then
					recce_group.pos_attack = false
					return false
				end
			end
		end
		
		-- if no one is near the attack position, then keep moving towards it.
		if all_dead == false then
			return true
		end
	end

	recce_group.pos_attack = false
	return false

end



function KR_EnterDefend(recce_group)


end


function KR_ExitDefend(recce_group)

	-- reset all the appropriate parameters to their defaults
	-- for the next time they  enter the defend phase.
	if recce_group.fg_defend == true then
		TD_RemoveProtection(recce_group.td_defense_group_id)
		recce_group.fg_defend = false
		recce_group.td_defense_group_id = false
		recce_group.pos_attack = false
	end
	
end


function KR_ExecDefend(recce_group)
	
	if recce_group.pos_attack == false then
		return
	end
	
	-- this is a special of set of parameters that trigger the mobilize state, and should
	-- only occur once while the squad is "busy"
	-- once they are not "busy", the mobilization is reset.
	if recce_group.fg_mobilize == false then
		recce_group.fg_mobilize = "spawn"
		recce_group.fg_busy = true
		return
	end
	
	-- set the state of this recce group as defending
	recce_group.fg_defend = true
	
	for k, this in pairs(recce_group.squads) do
		
		local rand_pos = Util_GetRandomPosition(recce_group.pos_attack, 10)
		
		if not SGroup_IsEmpty(this.sgroup) then
			
			-- check if the squad is near the destination, then tell them to get out 
			-- of thier transport vehicle and attack
			if this.fg_soldier == true then
				if Prox_AreSquadsNearMarker(this.sgroup, recce_group.pos_attack, ANY, 40) then
					if not SGroup_IsMoving(this.sgroup, ANY) 
					and not SGroup_IsInHoldEntity(this.sgroup, ANY) 
					and not SGroup_IsInCover(this.sgroup, 0.5) then
						local eg_garrison = Util_GarrisonNearbyBuilding(this.sgroup, SGroup_GetPosition(this.sgroup), 30)
						
						if eg_garrison == nil then
							Cmd_Move(this.sgroup, SGroup_GetPosition(this.sgroup), nil, nil, nil, nil, nil, 30)
						end
					end
				elseif SGroup_IsInHoldEntity(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup, rand_pos)
				elseif SGroup_IsIdle(this.sgroup, ANY) then
					if k == 1 then
						Cmd_AttackMove(this.sgroup, recce_group.pos_attack)
					elseif t_kr.flank_data.offset_flanks[k] ~= nil 
					and SGroup_IsEmpty(recce_group.squads[1].sgroup) == false then
						Cmd_Move(this.sgroup, recce_group.squads[1].sgroup, nil, nil, nil, t_kr.flank_data.offset_flanks[k], t_kr.flank_data.offset_dist)
					else
						Cmd_AttackMove(this.sgroup, rand_pos)
					end
				end
				
			elseif SGroup_IsIdle(this.sgroup, ANY) then
				if k == 1 then
					Cmd_AttackMove(this.sgroup, recce_group.pos_attack)
				elseif t_kr.flank_data.offset_flanks[k] ~= nil 
				and SGroup_IsEmpty(recce_group.squads[1].sgroup) == false then
					Cmd_Move(this.sgroup, recce_group.squads[1].sgroup, nil, nil, nil, t_kr.flank_data.offset_flanks[k], t_kr.flank_data.offset_dist)
				else
					Cmd_AttackMove(this.sgroup, rand_pos)
				end
			end
		end
	end
	
	-- for the transport vehicles.  Get the squads to their locations
	for k, this in pairs(recce_group.rides) do
		
		local rand_pos = Util_GetRandomPosition(recce_group.pos_attack, 15)
	
		if not SGroup_IsEmpty(this.sgroup) then
			
			-- if the ride is being attacked, the attackers need to get out of their vehicle
			-- and fight back
			if SGroup_IsHoldingAny(this.sgroup) then
					
				if SGroup_IsUnderAttack(this.sgroup, ANY, 5) then
					Cmd_Ungarrison(this.sgroup)	
				else
					Cmd_AttackMove(this.sgroup, rand_pos)
				end
			end
			
		end
	end

end

function KR_DefendPlayAmbient(recce_group)

	for k, this in pairs(recce_group.squads) do 
		
		
		
	end

end

-------------------------------------------------------------------------
-- RECCE RETREAT
-- this state is responsible for retreating the recce elements out
-- of the town and off the map when the leader has died.
-------------------------------------------------------------------------
function KR_CheckRetreat(recce_group)

	if Objective_IsComplete(OBJ_KillRecce)
	and not SGroup_IsEmpty(recce_group.sg_leader) then
		return true
	end	

	if not SGroup_IsEmpty(recce_group.sg_leader) then
		return false
	end
	
	-- *** TODO: check squad strength (compare the number of squad members
	-- spawned to the number that are left and retreat then.
	
	-- therefore if the leader IS dead, but the squads
	-- are not dead, then they need to run away
	for k, this in pairs(recce_group.squads) do
		
		if not SGroup_IsEmpty(this.sgroup) then
			return true
		end
		
	end
	
	for k, this in pairs(recce_group.rides) do
	
		if not SGroup_IsEmpty(this.sgroup) then
			return true
		end
	
	end

	return false

end

function KR_EnterRetreat(recce_group)


end


function KR_ExitRetreat(recce_group)


end


function KR_ExecRetreat(recce_group)
	
	for k, this in pairs(recce_group.squads) do
		
		if not SGroup_IsEmpty(this.sgroup)
		and not SGroup_IsMoving(this.sgroup, ANY) then
			if this.fg_soldier == true then
				if SGroup_IsInHoldEntity(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup)
				else
					Cmd_Retreat(this.sgroup, mkr_sp_convoy, mkr_sp_convoy)
					if Prox_AreSquadMembersNearMarker(this.sgroup, mkr_sp_convoy, ANY, 10) then
						SGroup_DestroyAllSquads(this.sgroup)
					end
				end
			else
				Cmd_Move(this.sgroup, mkr_sp_convoy, false, mkr_sp_convoy)
			end
		end
		
	end
	
	for k, this in pairs(recce_group.rides) do
	
		if not SGroup_IsEmpty(this.sgroup)
		and not SGroup_IsMoving(this.sgroup, ANY) then
			Cmd_Move(this.sgroup, mkr_sp_convoy, false, mkr_sp_convoy)
		end
	
	end

end


-------------------------------------------------------------------------
-- RECCE MOBILIZE
-- this state is responsible for getting the squads out of
-- buildings and into vehicles to move somewhere
-------------------------------------------------------------------------
function KR_CheckMobilize(recce_group)

	-- some exterior state must indicate that the recce_group must 
	-- mobilize, and this function manages the mobilization
	if recce_group.fg_mobilize == false
	or recce_group.fg_mobilize == "finished" then
		return false
	end
	
	if SGroup_IsEmpty(recce_group.sg_leader) then
		return false
	end
	
	-- check if the spawn building still exists, if not then stop the squads from spawing from the building
	-- also check if the recce commander is still alive.  If not then he do not mobilize any more.
	-- ** TODO, if the recce commander is still alive, do we want him to move to a different building?
	if EGroup_IsEmpty(recce_group.eg_spawn)
	or Player_OwnsEGroup(player2, recce_group.eg_spawn) == false then
		recce_group.fg_mobilize = "finished"
		return false
	end
	
	for k, this in pairs(recce_group.squads) do
	
		if this.fg_soldier == true then
			-- check if the sgroup has been spawned yet
			if SGroup_IsEmpty(this.sgroup)
			and recce_group.fg_mobilize ~= "no_spawn" then
				return true
			end
			
			-- check if all the squads are loaded into the appropriate vehicles
			-- fg_can_load is a flag to indicate whether or not there
			-- are enough vehicles and enough room to load the vehicles.
			if not SGroup_IsEmpty(this.sgroup)
			and not SGroup_IsInHoldSquad(this.sgroup, ANY)
			and this.fg_can_load ~= false then
				return true
			end
		
		end
	
	end
	
	return false	

end

function KR_EnterMobilize(recce_group)

	Timer_Start(recce_group.timer_respawn, recce_group.timer_respawn_amt)

end


function KR_ExitMobilize(recce_group)

	recce_group.fg_mobilize = "finished"
	
	-- reset all the squads to indicate that they can be loaded into vehicles
	for k, this in pairs(recce_group.squads) do
	
		if this.fg_soldier == true then
			this.fg_can_load = true
		end
	
	end

end


function KR_ExecMobilize(recce_group)

	KR_Mobilize(recce_group)
	
end


-------------------------------------------------------------------------
-- RECCE DEMOBILIZE
-- this state is reponsible for checking whether or not squads
-- should be demobilizing back to their base and hanging out 
-- protecting the city.
-------------------------------------------------------------------------
function KR_CheckDemobilize(recce_group)
	
	-- if the building which the squads are supposed 
	if EGroup_IsEmpty(recce_group.eg_spawn) then
		return false
	end
	
	for k, this in pairs(recce_group.squads) do
		
		if not SGroup_IsEmpty(this.sgroup) then
			if this.fg_soldier == true then
				
				-- if any of the squads are not the leader,
				-- and not dead yet, then we need to contine demobilizing.
				if k ~= 1 then
					return true
				elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == false then
					return true
				end
				
			else
				if Prox_AreSquadMembersNearMarker(this.sgroup, Util_GetPosition(this.spawn), ANY, 10) == false then				
					return true
				end
			end
		end
	end
	
	return false

end

function KR_EnterDemobilize(recce_group)

	KR_StopSquads(recce_group)

end


function KR_ExitDemobilize(recce_group)

	if recce_group.fg_mobilize == "finished" then
		recce_group.fg_mobilize = false
	end
	
end


function KR_ExecDemobilize(recce_group)

	-- do not try to demobilize
	if EGroup_IsEmpty(recce_group.eg_spawn) then
		return
	end

	-- first order the squads to mobilize which will get all of those possible, into vehicles
	if recce_group.fg_mobilize == false then
		recce_group.fg_mobilize = "no_spawn"
		return
	end

	KR_Demobilize(recce_group)

end







-------------------------------------------------------------------------



-------------------------------------------------------------------------

-- Town Defense

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function TownDefense_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_town_at = Marker_GetTable("mkr_ambush_town_at%d")
	teg_td_at = EGroup_CreateTable("eg_td_at%d", table.getn(tmkr_town_at))
	tsg_td_at = SGroup_CreateTable("sg_td_at%d", table.getn(tmkr_town_at))
	teg_town = EGroup_GetWBTable("eg_ambush_town%d")
	tsg_td_defense_group = SGroup_CreateTable("sg_td_defense_group%d", 6)
	tsg_td_def_group_attacker = SGroup_CreateTable("sg_td_def_group_attacker%d", table.getn(tsg_td_defense_group))
	
	-- put an mg into the same building that the recce commander occupies.
	for i=1, table.getn(teg_kr_sp) do
		table.insert(teg_town, teg_kr_sp[i])
	end	
	tsg_town_mg	= SGroup_CreateTable("sg_td_mg%d", table.getn(teg_town))
	
	t_enc_td = {}
	
	-- a list of sbps that the player can use to sight
	-- their targets from a distance. 
	t_enc_td.range_sbps = {
		SBP.ELITE.MORTAR,
		SBP.ELITE.HALFTRACK_MORTAR,
		SBP.ELITE.HUMMEL,
		SBP.AXIS.MORTAR,
		SBP.ELITE.HALFTRACK_SNIPER,
		SBP.ELITE.ARMOURCAR_221,
		SBP.ELITE.ARMOURCAR_222,
		SBP.ELITE.MARDER,
	}
	
	t_enc_td.mg_squads = {}
	for i=1, table.getn(tsg_town_mg) do
		t_enc_td.mg_squads[i] = {
			sgroup			= tsg_town_mg[i],
			spawn			= teg_town[i],
			sbp				= SBP.CW.VICKERS_MG_SP,
		}	
	end
	
	t_enc_td.at_guns = {}
	for i=1, table.getn(teg_td_at) do
		t_enc_td.at_guns[i] = {
			egroup			= teg_td_at[i],
			sgroup			= tsg_td_at[i],
			spawn			= tmkr_town_at[i],
			ebp				= EBP.SYNC_WEAPON.AT_57MM,
			sbp				= SBP.CW.TOMMIES,
			sw_id			= false
		}	
	end
	
	t_enc_td.patrols = {
		{
			sbp 		= SBP.CW.TOMMIES,
			upg			= {},
		},
	}
	
	-- this table organizes disparate groups of squads by putting them into 
	-- a table together, collectively marking them as "one group" for defense
	-- purposes.
	-- i.e. if one of the group gets attacked, the defenders respond, but not
	-- to every squad, and squads can be marked as "being defended"
	t_enc_td.defense_group = {}
	for i=1, table.getn(tsg_td_defense_group) do
		t_enc_td.defense_group[i] = {
			sgroup 			= tsg_td_defense_group[i],
			defended		= false,
			sg_attacker		= tsg_td_def_group_attacker[i],
		}
	end	

end

-- preset any units or events needed before the kickoff
function TownDefense_Preset()

	-- spawn squads
	for k, this in pairs(t_enc_td.at_guns) do
		
		Util_CreateEntities(nil, this.egroup, this.ebp, this.spawn, 1)
		Util_CreateSquads(player2, this.sgroup, this.sbp, this.spawn, nil, 1, 3)
		this.sw_id = SyncWeapon_GetFromEGroup(this.egroup)
	end
	
	for k, this in pairs(t_enc_td.mg_squads) do
		if not EGroup_IsEmpty(this.spawn) then
			Util_CreateSquads(player2, this.sgroup, this.sbp, this.spawn)
		end
	end
	
	SGroup_AddGroup(t_enc_td.defense_group[2].sgroup, tsg_town_mg[5])

	SGroup_AddGroup(t_enc_td.defense_group[1].sgroup, tsg_town_mg[1])

	SGroup_AddGroup(t_enc_td.defense_group[3].sgroup, tsg_town_mg[3])
	SGroup_AddGroup(t_enc_td.defense_group[3].sgroup, tsg_town_mg[2])

	SGroup_AddGroup(t_enc_td.defense_group[4].sgroup, tsg_town_mg[6])
	SGroup_AddGroup(t_enc_td.defense_group[4].sgroup, tsg_town_mg[4])
	
	Rule_AddInterval(TownDefense_ManATGuns, 3)

end

function TownDefense_ManATGuns()

	local all_manned = true
	for k, this in pairs(t_enc_td.at_guns) do
		if SyncWeapon_IsOwnedByPlayer(this.sw_id, player2) == false 
		and SGroup_IsEmpty(this.sgroup) == false then
			all_manned = false
			Cmd_CaptureTeamWeapon(this.sgroup, this.egroup)
		elseif SGroup_IsEmpty(this.sgroup) then
			all_manned = false
			Player_GetAllSquadsNearMarker(player2, this.sgroup, this.spawn, 5)
			if not SGroup_IsEmpty(this.sgroup) then
				ATGun_AddGroup(this.sgroup, player2)
			end
		end
	end
	
	if all_manned then
		SGroup_AddGroup(t_enc_td.defense_group[5].sgroup, tsg_td_at[1])
		SGroup_AddGroup(t_enc_td.defense_group[6].sgroup, tsg_td_at[2])
		Rule_RemoveMe()
	end

end

-- start the related action
function TownDefense_Kickoff()

	-- not currently used
	
end

-- checks if any of the squads that are defending the town are
-- under attack.  If they are it returns the id of the defense
-- group which will need to get released later.
function TD_CheckUnderAttack(sg_attacker, check_def)
	
	-- check the squads that might be attacking the border defenses around the town.
	for k, this in pairs(t_enc_td.defense_group) do
		
		if not SGroup_IsEmpty(this.sgroup) then
			
			if SGroup_IsUnderAttack(this.sgroup, ANY, 10)
			or SGroup_IsDoingAttack(this.sgroup, ANY, 10 ) then
				
				if this.defended == false then
					SGroup_GetLastAttacker(this.sgroup, this.sg_attacker)
					
					-- this may be a little too generic a solution since it talks about the main roads
					if ( k == 5 or k== 6 )
					and t_kr.events.fg_road_covered == false then
						Util_AutoIntel(t_kr.events.road_covered)
						t_kr.events.fg_road_covered = true
					end					
					
					if not SGroup_IsEmpty(this.sg_attacker) then
						
						-- this is a variable that indicates whether or not this group of defenders are currently under attack.
						if check_def ~= false then
							this.defended = true
						end
						
						SGroup_AddGroup(sg_attacker, this.sg_attacker)
						return k
					end
				end
			else
				-- if the squad is not under attack, then clear the last attacker,
				SGroup_Clear(this.sg_attacker)
			end
		end
		
	end
	
	return false

end

-- indicates to the code that the squad has already 
function TD_RemoveProtection(id)
	for k, this in pairs(t_enc_td.defense_group) do
		if id == k then
			this.defended = false
		end
	end
end

-- the function manages updating the attacker code
function TD_UpdateAttacker(id, sg_attacker)

	for k, this in pairs(t_enc_td.defense_group) do
		if id == k then
			
			if SGroup_IsUnderAttack(this.sgroup, ANY, 10) then
				SGroup_GetLastAttacker(this.sgroup, this.sg_attacker)
				SGroup_Filter(this.sg_attacker, t_enc_td.range_sbps, FILTER_KEEP)				
				if not SGroup_IsEmpty(this.sg_attacker) then
					SGroup_AddGroup(sg_attacker, this.sg_attacker)
				end
			end
		end
	end

end

-- debugging function to reset all the squads to check whether or not 
-- they are being defended at the moment
function TD_ClearDefended()
	for k, this in pairs(t_enc_td.defense_group) do
		this.defended = false
	end

end

-- this function manages the retreating of the Town's Defenses
function TD_Retreat()

	local all_dead = true
	
	for k, this in pairs(t_enc_td.at_guns) do
		if not SGroup_IsEmpty(this.sgroup) then
			all_dead = false			
			if SyncWeapon_IsOwnedByPlayer(this.sw_id, player2) then
				Cmd_AbandonTeamWeapon(this.sgroup, true)
			elseif not SGroup_IsMoving(this.sgroup, ANY) then
				Cmd_Retreat(this.sgroup, mkr_sp_convoy, mkr_sp_convoy)
			end
		else
			
			Player_GetAllSquadsNearMarker(player2, this.sgroup, this.spawn, 8)
			if not SGroup_IsEmpty(this.sgroup) then
				all_dead = false
			end
		end
	end
	
	-- go through the various MG squads and order them out of the 
	-- buildings and tell them to leave the map.
	for k, this in pairs(t_enc_td.mg_squads) do
		if not SGroup_IsEmpty(this.sgroup) then
			all_dead = false
			if not SGroup_IsMoving(this.sgroup, ANY) then
				
				if SGroup_IsInHoldEntity(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup)
				else
					Cmd_Retreat(this.sgroup, mkr_sp_convoy, mkr_sp_convoy, true)
					
				end
			end
		end
	end
	
	-- if all the sgroups are empty, then remove this rule.
	if all_dead then
		Rule_RemoveMe()
	end
	
end





















-------------------------------------------------------------------------
-- ROAD CAPTURE 
-------------------------------------------------------------------------
-- Short descriptive name of what the player is cht_eventsed to do
-- give a brief description of win conditions and loose conditions if any 
-- also describe the kind of challenges the player will face
-------------------------------------------------------------------------
function Initialize_OBJ_RoadCapture()

	OBJ_RoadCapture = {
		
		SetupUI = function() 
			-- mark a point or position
			-- indicate to the player the best location to set up the ambush
			if Player_OwnsEGroup(player1, t_rc_points[4].egroup, ANY) then
				OBJ_RoadCapture.mapElementID[4] = Objective_AddUIElements(OBJ_RoadCapture, t_rc_points[4].egroup, true, 1449102, true, 2)
			else
				OBJ_RoadCapture.mapElementID[4] = Objective_AddUIElements(OBJ_RoadCapture, t_rc_points[4].egroup, true)
			end
			
		end,
		
		OnStart = function()
			
			-- announce the goal
			Util_AutoIntel(t_obj_rc.events.obj_start)
			Sound_PlayMusic("Music/SP/OMG/Preparation/OMG/BUILD_OR_FAIL.bsc",1,1)
			Game_LoadAtmosphere("data:art/scenarios/presets/atmosphere/CXP2_HELLS_HIGHWAY_NIGHT_00.aps", t_obj_rc.total_time)
			Player_SetAbilityAvailability(player1, ABILITY.SP.HELLS_PANZER_GRENADIERS, ITEM_REMOVED)
			
			-- start related action
			RoadCapture_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1449104,
		Description = 1449105,
		TitleEnd = 1449130,
		Type = OT_Primary,
		mapElementID = {},
		SitRep = {
			Movie = "CXP2_SR_04-02",
			Force = true,
			SpeechTiming =
			{
				{ 1,	ACTOR.CXP2.Wolfgang, 1441010 },
				{ 3.7,	ACTOR.CXP2.Wolfgang, 1441015 },
				{ 10,	ACTOR.CXP2.Wolfgang, 1441020 },
				{ 12.4,	ACTOR.CXP2.Wolfgang, 1441025 },
				{ 18.5,	ACTOR.CXP2.Voss, 1441030 },
				{ 23,	ACTOR.CXP2.Voss, 1441040 },
				{ 30,	ACTOR.CXP2.Voss, 1441050 },
				{ 34.4,	ACTOR.CXP2.Voss, 1441060 },
				{ 37,	ACTOR.CXP2.Voss, 1441070 },
			},
		},
	}
	
	-- Register Objective
	Objective_Register(OBJ_RoadCapture)
	-- Initialize Data
	RoadCapture_Init()
	
end

-------------------------------------------------------------------------
-- Road Capture - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function RoadCapture_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_sp_road = Marker_GetTable("mkr_rc_sp1_%d")
	tmkr_sp_bridge = Marker_GetTable("mkr_rc_sp3_%d")
	tmkr_sp_farm = Marker_GetTable("mkr_rc_sp2_%d")
	tmkr_ambush_roadblock = Marker_GetTable("mkr_ambush_roadblock%d")
	tmkr_arty_sectors = Marker_GetTable("mkr_ambush_arty_sector%d")
	tmkr_ambush_trap_hint = Marker_GetTable("mkr_ambush_trap_hint%d")
	tmkr_ambush_clear_bridge = Marker_GetTable("mkr_ambush_clear_bridge%d")
	
	teg_road_rp = EGroup_GetWBTable("eg_road_rp%d")
	teg_ambush_base = EGroup_GetWBTable("eg_ambush_base%d")
	sg_rc_last_attacker = SGroup_CreateIfNotFound("sg_rc_last_attacker")
	eg_jager_kommand = EGroup_CreateIfNotFound("eg_jager_kommand")
	eg_pe_support = EGroup_CreateIfNotFound("eg_pe_support")
	teg_ambush_trap_hint = EGroup_GetWBTable("eg_ambush_trap_hint%d")
	sg_rc_ride_town	= SGroup_CreateIfNotFound("sg_rc_ride_town")
	sg_rc_town_all = SGroup_CreateIfNotFound("sg_rc_town_all")
	sg_rc_avre = SGroup_CreateIfNotFound("sg_rc_avre")
	eg_road_blocks = EGroup_CreateIfNotFound("eg_road_blocks")
	
	OBJ_RoadCapture.mapElementID = {}
	
	-- this is a table that contains all the points along the road.
	t_rc_points = {}
	for i=1, table.getn(teg_road_rp) do 
		t_rc_points[i] = {
			egroup 			= teg_road_rp[i],					-- the egroup marking the resource point that the player needs to defend
			fg_recce		= false,							-- a flag to indicate whether this point has been "recced", i.e. enough time has passed for capture
			fg_captured		= false,							-- a flag indicating whether or not the point has been capped.
			tmkr_arty		= {},								-- a table of markers that the artillery will use to bombard the point if needed.
			capped_event	= false,							-- the speech event to play when a point along the road gets captured
			fg_capturing_speech = false,						-- a flag to keep the capturing speech from continuing to play while a point is being capped.
		}
		
		OBJ_RoadCapture.mapElementID[i] = false
	end
	
	t_rc_paths = {
		{
			tmkr = tmkr_sp_road,
			paths = {"path_ambush_town1_1", "path_ambush_town1_2", "path_ambush_town1_3"},
		},
		{
			tmkr = tmkr_sp_bridge,
			paths = {"path_ambush_town2_1", "path_ambush_town2_2",},
		},
		{
			tmkr = tmkr_sp_farm,
			paths = {"path_ambush_town3_1", "path_ambush_town3_2", "path_ambush_town3_3"},
		},
	}
	
	t_rc_points[1].tmkr_arty = Marker_GetTable("mkr_rc_arty1_%d")
	t_rc_points[2].tmkr_arty = Marker_GetTable("mkr_rc_arty1_%d")
	t_rc_points[3].tmkr_arty = Marker_GetTable("mkr_rc_arty2_%d")
	t_rc_points[4].tmkr_arty = Marker_GetTable("mkr_rc_arty2_%d")
	t_rc_points[5].tmkr_arty = Marker_GetTable("mkr_rc_arty3_%d")
	t_rc_points[6].tmkr_arty = Marker_GetTable("mkr_rc_arty3_%d")
	t_rc_points[7].tmkr_arty = false 								-- don't artillery the last point
	
	t_obj_rc = {
		active_point 			= t_rc_points[1],				-- the current point that needs to be scounted and captured
		active_point2			= t_rc_points[2],				-- a point near the active point that the infantry may decide to capture
		fg_recce_started		= false,						-- checks whether the recon group has started moving yet.
		fg_recce_point_timer_started = false,					-- checks whether a timer has been started to see how long the recce group has sat on a point before capturing it.
		timer_recce				= "RC RECCE TIMER",				
		timer_recce_amt			= 30,				
		timer_recce_point		= "RC RECCE TIMER POINT",
		timer_recce_point_amt	= 15,
		leapfrog_recce_id		= false,
		recce_first_sp			= true,							-- flag to track whether or not this is the first time the squad has spawned
		
		timer_sp_capture		= "RC CAPTURE SPAWN TIMER",		-- timer that determines how quickly the capture infantry will respawn
		timer_sp_capture_amt	= 1*60,
		leapfrog_capture_id		= false,						-- an id used by the leapfrogging code to manage the leapfrog
		capture_first_sp		= true,							-- flag to track whether or not this is the first time the squad has spawned
		
		timer_sp_armor			= "RC ARMOR SPAWN TIMER",		-- timer that determines how quickly the armor will respawn
		timer_sp_armor_amt		= 1.5*60,
		sg_target				= sg_rc_last_attacker,			-- the target for the armor and at armor to attack
		tc_armor_id				= false,						-- the TankCombat id for the AT Armor
		armor_first_sp			= true,							-- flag to track whether or not this is the first time the squad has spawned
		
		timer_sp_armor_at		= "RC ARMOR AT SPAWN TIMER",	-- timer that determines how quickly the AT armor will respawn
		timer_sp_armor_at_amt	= 2.5*60,
		tc_armor_at_id			= false,						-- the TankCombat id for the AT Armor
		armor_at_first_sp		= true,							-- flag to track whether or not this is the first time the squad has spawned
		
		timer_arty_start		= "RC ARTY TIMER",				-- difficulty param, a timer to manage the artillery, and how often it fires
		timer_arty_wait_amt		= 1.25*60,						-- the time to wait between bombardments to let the other elements attack the point
		arty_retreat_amt		= 30,							-- the amount of time to give the other elements the ability to retreat from the bombardment
		fg_arty_spawned			= false,						-- a flag to check whether or not the artillery has been spawned
		
		timer_offmap_arty		= "RC OFFMAP ARTY TIMER",		-- a timer to track how often the off-map arty fires on the player near the spawn points
		timer_offmap_arty_amt	= 90,
		
		setup_amount			= t_difficulty.rc_total_time - t_difficulty.rc_setup_diff, -- time on the timer that the player has before the allies spawn onto the map.
		total_time				= t_difficulty.rc_total_time,	-- amount of time the player has to finish the objective
		ua_capture_time			= 13*60,						-- amount of time left before the squads try to capture the points while player is under attack
		ua_capture2_time		= 8.5*60,						-- amount of time left before the 2nd group of squads try to capture points
		ua_armor_at_time		= t_difficulty.rc_at_armor,		-- amount of time left before the at armor tries to attack the player
		ua_artillery_time		= t_difficulty.rc_arty_time,	-- amount of time left before the priests arrive and start bombarding the player.
		ua_final_push			= t_difficulty.rc_final_push,	-- amount of time left before the final squads approach and try to take the player out in a massive assault (planes?)
		ua_town_time			= 15*60,						-- amount of time left before the town squads start spawning and garrisoning the town.
		ua_avre_time			= t_difficulty.rc_avre_time,	-- amount of time at which the AVRE is triggered and moving forward
		ua_retreat_time			= 45,						-- amount of time at which everyone starts retreating, and the player can push back
		
		points_owned			= 0,							-- a value to track the number of the road points that the player owns
		
		timer_town_sp			= "RC TOWN SPAWN TIMER",		-- a timer to track the spawning of 
		timer_town_sp_amt		= 1.5*60,				
		pos_town 				= Util_GetRandomPosition(eg_ambush_garrison_church, 80),	-- a random position in the town to move squads to attack the town
		sg_town_all				= sg_rc_town_all,				-- sgroups for all the town squads
		sg_ride_town			= sg_rc_ride_town,				-- sgroups for the town rides
		
		timer_avre_sp 			= "RC AVRE SPAWN TIMER",
		timer_avre_sp_amt		= 1.5*60,
		timer_complete			= "RC COMPLETE MISSION TIMER",
		timer_complete_amt		= 60,
		
		
	}
	
	-- a table to track the addition and removal of flashing buttons
	t_rc_flashing_buttons = {}
	
	-- initalize the speech events
	RoadCapture_InitEvents()
	
	-- set up the events that play specific speech for when a point is captured
	t_rc_points[3].capped_event = t_obj_rc.events.road_capped3
	t_rc_points[4].capped_event = t_obj_rc.events.road_capped4
	t_rc_points[5].capped_event = t_obj_rc.events.road_capped5
	t_rc_points[6].capped_event = t_obj_rc.events.road_capped6
	t_rc_points[7].capped_event = t_obj_rc.events.road_capped7
	
	t_obj_rc.timed_events = {
		{
			obj_time 			= 7*60,
			exec_func			= RoadCapture_HenschelEvent, 	-- the point at which the henschel is introduced to the player
		},
		{
			obj_time 			= 14*60,
			exec_func			= RC_AmbientTimeEvents, 	-- ambient speech encouragement for the player
		},
		{
			obj_time 			= 12*60,
			exec_func			= RoadCapture_TimeEvents, 	-- speech events to play as the mission progresses
		},
		{
			obj_time 			= 11.5*60,
			exec_func			= RC_AmbientTimeEvents, 	-- ambient speech encouragement for the player
		},
		{
			obj_time 			= 9*60,
			exec_func			= RoadCapture_TimeEvents, 	-- speech events to play as the mission progresses
		},
		{
			obj_time 			= 8.5*60,
			exec_func			= RC_AmbientTimeEvents, 	-- ambient speech encouragement for the player
		},
		{
			obj_time 			= 5*60,
			exec_func			= RoadCapture_TimeEvents, 	-- speech events to play as the mission progresses
		},
		{
			obj_time 			= 4.5*60,
			exec_func			= RC_AmbientTimeEvents, 	-- ambient speech encouragement for the player
		},
		{
			obj_time 			= (t_obj_rc.ua_final_push),
			exec_func			= RC_FinalPushAmbientSpeech, 	-- ambient speech to play during the final push
		},
		{
			obj_time 			= (t_obj_rc.ua_retreat_time),
			exec_func			= RoadCapture_TimeEvents, 	-- speech events to play as the mission progresses
		},
		{
			obj_time 			= (t_obj_rc.ua_retreat_time - 15),
			exec_func			= RC_AmbientTimeEvents, 	-- ambient events to play as the mission progresses
		},
	}

	t_obj_rc.squads_rides = {
		{	sbp 		= SBP.CW.BREN_CARRIER,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.BREN_CARRIER,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.BREN_CARRIER,
			upg 		= {},
		},
	}
	
	for i=1, table.getn(t_obj_rc.squads_rides) do 
		t_obj_rc.squads_rides[i].sgroup = SGroup_CreateIfNotFound("sg_rc_rides1_"..i)
		t_obj_rc.squads_rides[i].spawn = tmkr_sp_road[i]
		this = t_obj_rc.squads_rides[i]
		if this.sbp == SBP.CW.BREN_CARRIER then
			this.capacity_squads = 2
			this.capacity_members = 6
		elseif this.sbp == SBP.ALLIES.HALFTRACK then
			this.capacity_squads = 3
			this.capacity_members = 12
		end
		
	end
	
	-- units are paired up in groups to work together.
	t_obj_rc.squads_capture = {
		{	sbp 		= SBP.CW.TOMMIES,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.SAPPER,
			upg 		= {UPG.CW.PIAT},
		},
		{	sbp 		= SBP.CW.LIEUTENANT,
			upg 		= {},
		},
	}

	for i=1, table.getn(t_obj_rc.squads_capture) do 
		t_obj_rc.squads_capture[i].sgroup = SGroup_CreateIfNotFound("sg_rc_capture1_"..i)
		t_obj_rc.squads_capture[i].spawn = tmkr_sp_road[i]
	end
	
	-- setting up the preferred ride data
	t_obj_rc.squads_capture[1].pref_ride = t_obj_rc.squads_rides[1]
	t_obj_rc.squads_capture[2].pref_ride = t_obj_rc.squads_rides[2]
	t_obj_rc.squads_capture[3].pref_ride = t_obj_rc.squads_rides[3]
	
	t_obj_rc.squads_rides2 = {
		{	sbp 		= SBP.CW.BREN_CARRIER,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.BREN_CARRIER,
			upg 		= {},
		},
	}
	
	for i=1, table.getn(t_obj_rc.squads_rides2) do 
		t_obj_rc.squads_rides2[i].sgroup = SGroup_CreateIfNotFound("sg_rc_rides2_"..i)
		t_obj_rc.squads_rides2[i].spawn = tmkr_sp_road[i]
		this = t_obj_rc.squads_rides2[i]
		if this.sbp == SBP.CW.BREN_CARRIER then
			this.capacity_squads = 2
			this.capacity_members = 6
		elseif this.sbp == SBP.ALLIES.HALFTRACK then
			this.capacity_squads = 3
			this.capacity_members = 12
		end
		
	end
	
	t_obj_rc.squads_capture2 = {
		{	sbp 		= SBP.CW.TOMMIES,
			upg 		= {UPG.CW.RIFLE_GRENADE},
		},
		{	sbp 		= SBP.CW.LIEUTENANT,
			upg 		= {},
		},
	}
	
	for i=1, table.getn(t_obj_rc.squads_capture2) do 
		t_obj_rc.squads_capture2[i].sgroup = SGroup_CreateIfNotFound("sg_rc_capture2_"..i)
		t_obj_rc.squads_capture2[i].spawn = tmkr_sp_road[i]
	end
	
	-- setting up the preferred ride data
	t_obj_rc.squads_capture2[1].pref_ride = t_obj_rc.squads_rides2[1]
	t_obj_rc.squads_capture2[2].pref_ride = t_obj_rc.squads_rides2[2]
	
	t_obj_rc.squads_recce = {		
		{	sbp 		= SBP.CW.STUART,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.STUART,
			upg 		= {},
		},
	}
	
	for i=1, table.getn(t_obj_rc.squads_recce) do 
		t_obj_rc.squads_recce[i].sgroup = SGroup_CreateIfNotFound("sg_rc_recce"..i)
		t_obj_rc.squads_recce[i].spawn = tmkr_sp_road[i]
	end
	
	t_obj_rc.squads_armor = {
		{	sbp 		= SBP.CW.CROMWELL,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.CROMWELL,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.STUART,
			upg 		= {},
		},
	}

	t_obj_rc.tsg_armor = {}
	for i=1, table.getn(t_obj_rc.squads_armor) do 
		t_obj_rc.squads_armor[i].sgroup = SGroup_CreateIfNotFound("sg_rc_armor"..i)
		t_obj_rc.squads_armor[i].spawn = tmkr_sp_road[i]
		table.insert(t_obj_rc.tsg_armor, t_obj_rc.squads_armor[i].sgroup)
	end
	
	t_obj_rc.squads_armor_at = {
		{	sbp 		= SBP.CW.CHURCHILL,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.CHURCHILL,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.CHURCHILL_CROC,
			upg 		= {},
		},
	}

	t_obj_rc.tsg_armor_at = {}
	for i=1, table.getn(t_obj_rc.squads_armor_at) do 
		t_obj_rc.squads_armor_at[i].sgroup = SGroup_CreateIfNotFound("sg_rc_armor_at"..i)
		t_obj_rc.squads_armor_at[i].spawn = tmkr_sp_road[i]
		table.insert(t_obj_rc.tsg_armor_at, t_obj_rc.squads_armor_at[i].sgroup)
	end
	
	t_obj_rc.squads_arty = {
		{	sbp 		= SBP.CW.PRIEST,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.PRIEST,
			upg 		= {},
		},
	}

	for k, this in pairs(t_obj_rc.squads_arty) do 
		this.sgroup 			= SGroup_CreateIfNotFound("sg_rc_arty"..k)
		this.spawn 				= tmkr_sp_road[k]
		this.barrage_offset 	= 15							-- the amount of distance by which to miss their target
		this.sg_arty_attack		= false							-- the target for the artillery strike
	end
	
	t_obj_rc.squads_arty[1].spawn = tmkr_sp_bridge[1]
	t_obj_rc.squads_arty[2].spawn = tmkr_sp_farm[1]
	
	t_obj_rc.squads_town = {
		{	sbp 		= SBP.CW.SAPPER,
			upg 		= {},
		},
		{	sbp 		= SBP.CW.TOMMIES,
			upg 		= {UPG.CW.RECON_TEAM},
		},
	}
	
	-- hack, only to get to the halftrack for the town squads to retreat
	-- with everyone else
	t_obj_rc.squads_town_ride = {
		{	sgroup		= sg_rc_ride_town,
			sbp 		= SBP.ALLIES.HALFTRACK,
			upg 		= {},
		},
	}

	for k, this in pairs(t_obj_rc.squads_town) do 
		this.sgroup 			= SGroup_CreateIfNotFound("sg_rc_town"..k)
		this.spawn 				= tmkr_sp_road[k]
	end
	
	t_obj_rc.squads_avre = {
		{	sbp 		= SBP.CW.CHURCHILL_AVRE,
			upg 		= {},
		},
	}
	
	for k, this in pairs(t_obj_rc.squads_avre) do 
		this.sgroup 			= sg_rc_avre
		this.spawn 				= tmkr_sp_road[k]
	end
	
	t_obj_rc.states = {
		{	-- PURPOSE: default state of the vehicles to see if a capture point is safe or not
			state		= "recce",									-- the name of the state
			ExecState 	= function() RC_RecceExec() end,			-- the function to execute the state
			CheckState 	= function() return RC_RecceCheck() end,		-- the function that checks if the current state is valid
			EnterState	= function() RC_RecceEnter() end,				-- this function transitions into this state
			ExitState	= function() RC_RecceExit() end,				-- this function transitions out of this state
			priority 	= 1												-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: default state of the vehicles to see if a capture point is safe or not
			state		= "retreat",									-- the name of the state
			ExecState 	= function() RC_RetreatExec() end,			-- the function to execute the state
			CheckState 	= function() return RC_RetreatCheck() end,		-- the function that checks if the current state is valid
			EnterState	= function() RC_RetreatEnter() end,				-- this function transitions into this state
			ExitState	= function() RC_RetreatExit() end,				-- this function transitions out of this state
			priority 	= 10												-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: default state of the vehicles to see if a capture point is safe or not
			state		= "under_attack",									-- the name of the state
			ExecState 	= function() RC_UnderAttackExec() end,			-- the function to execute the state
			CheckState 	= function() return RC_UnderAttackCheck() end,		-- the function that checks if the current state is valid
			EnterState	= function() RC_UnderAttackEnter() end,				-- this function transitions into this state
			ExitState	= function() RC_UnderAttackExit() end,				-- this function transitions out of this state
			priority 	= 9												-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
		{	-- PURPOSE: default state of the vehicles to see if a capture point is safe or not
			state		= "capture",									-- the name of the state
			ExecState 	= function() RC_CaptureExec() end,			-- the function to execute the state
			CheckState 	= function() return RC_CaptureCheck() end,		-- the function that checks if the current state is valid
			EnterState	= function() RC_CaptureEnter() end,				-- this function transitions into this state
			ExitState	= function() RC_CaptureExit() end,				-- this function transitions out of this state
			priority 	= 2												-- a value from 1-10 (low to high) that indicates the importance of this state over others
		},
	}
	
end

----------------------------------------------------------------------
-- INTEL EVENTS
----------------------------------------------------------------------
function RoadCapture_InitEvents()

	t_obj_rc.events = {
	
		-- objective is started
		obj_start = {
			{ACTOR.CXP2.Wolfgang, 1441100},
			{ACTOR.CXP2.Wolfgang, 1441110},
		},
		
		fg_build_marders = false,
		build_marders = {
			{ACTOR.CXP2.Deinhard, 1441112},
			{ACTOR.CXP2.Deinhard, 1441114},
		},
		
		-- as the column first enters the map and starting heading towards the player.
		colum_approaches = {
			{ACTOR.CXP2.Deinhard, 1441310},
		},
		
		-- the first time the normal armor is spawned on the map
		fg_armor = false,
		armor_approaches = {
			{{ACTOR.CXP2.GenericPanzerElite, 1441460}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441470}},
		},
		
		-- the first time the infantry capture squads are spawned on the map
		fg_inf = false,
		inf_approaches = {
			{ACTOR.CXP2.GenericPanzerElite, 1441510},
			{ACTOR.CXP2.GenericPanzerElite, 1441520},
		},
		
		-- the first time the heavy armor is spawned on the map
		fg_armor_at = false,
		armor_at_approaches = {
			{{ACTOR.CXP2.GenericPanzerElite, 1441480}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441490}},
		},
		
		inf_capturing = {
			{{ACTOR.CXP2.Deinhard, 1441630}},
			{{ACTOR.CXP2.Deinhard, 1441632}},
			{{ACTOR.CXP2.Deinhard, 1441634}},
			{{ACTOR.CXP2.Deinhard, 1441636}},
			{{ACTOR.CXP2.Deinhard, 1441638}},
			{{ACTOR.CXP2.Deinhard, 1441640}},
		},
		
		-- the point number matches the number of egroups along the road.	
		road_capped3 = {
			{ACTOR.CXP2.Deinhard, 1441650},
			{ACTOR.CXP2.Deinhard, 1441660},
		},
		
		road_capped4 = {
			{ACTOR.CXP2.Wolfgang, 1441670},
		},
		
		road_capped5 = {
			{ACTOR.CXP2.Wolfgang, 1441680},
		},
		
		road_capped6 = {
			{ACTOR.CXP2.Wolfgang, 1441690},
		},
		
		road_capped7 = {
			{ACTOR.CXP2.Wolfgang, 1441700},
		},
		
		-- when the first artillery bombardment starts hitting the player.
		fg_arty_start = false,
		arty_start = {
			{ACTOR.CXP2.Deinhard, 1441570},
			{ACTOR.CXP2.Deinhard, 1441580},
		},
		
		-- responses when the player is bombarded with artillery.
		arty_rand = {
			{{ACTOR.CXP2.Deinhard, 1441590}},
			{{ACTOR.CXP2.Deinhard, 1441600}},
			{{ACTOR.CXP2.Deinhard, 1441610}},
			{{ACTOR.CXP2.Deinhard, 1441620}},
		},
		
		henschel_support = {
			{ACTOR.CXP2.GenericPanzerElite, 1441870},
			{ACTOR.CXP2.GenericPanzerElite, 1441880},
			{ACTOR.CXP2.GenericPanzerElite, 1441890},
		},
		
		time_progression = {
			{{ACTOR.CXP2.Wolfgang, 1441770}},
			{{ACTOR.CXP2.Wolfgang, 1441760}},
			{{ACTOR.CXP2.Wolfgang, 1441790}},
			{{ACTOR.CXP2.Wolfgang, 1441780}},
		},
		
		am_road_progress = {
			{{ACTOR.CXP2.GenericPanzerElite, 1441710}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441720}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441730}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441740}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441750}},
		},
		
		fg_jager_built = false,
		panzer_jager_built = {
			{ACTOR.CXP2.Deinhard, 1441118}
		},
		
		fg_at_guns_spotted = false,
		at_guns_spotted = {
			{{ACTOR.CXP2.Deinhard, 1441160}},
			{{ACTOR.CXP2.Deinhard, 1441170}},
			{{ACTOR.CXP2.Deinhard, 1441180}},
		},
		
		fg_call_up_marders = false,
		call_up_marders = {
			{ACTOR.CXP2.Wolfgang, 1441120},
		},
		
		fg_scorch_point = false,
		scorch_point = {
			{ACTOR.CXP2.Wolfgang, 1441130},
		},
		
		fg_scorch_point_acquired = false,
		scorch_point_acquired = {
			{ACTOR.CXP2.Wolfgang, 1441990},
			{ACTOR.CXP2.Wolfgang, 1441995},
		},
		
		fg_roadblocks = false,
		roadblocks = {
			{ACTOR.CXP2.Wolfgang, 1441980},
			{ACTOR.CXP2.Wolfgang, 1441985},
		},
		
		fg_booby_trap_point = false,
		booby_trap_point = {
			{ACTOR.CXP2.Wolfgang, 1441960},
		},
		
		fg_booby_trap_buildings = false,
		booby_trap_buildings = {
			{{ACTOR.CXP2.Wolfgang, 1441970}},
			{{ACTOR.CXP2.Wolfgang, 1441150}},
		},
		
		---------------------------------------------
		-- AMBIENT SPEECH HOOK UPS
		---------------------------------------------
		am_final_push = {
			{{ACTOR.CXP2.GenericPanzerElite, 1441800}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441810}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441820}},
		},
		
		am_henschel = {
			{{ACTOR.CXP2.GenericPanzerElite, 1441930}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441940}},
			{{ACTOR.CXP2.GenericPanzerElite, 1441950}},
		},
		
	}
	
	t_rc_british = {
		fg_first_contact = false,
		first_contact = {
			{{ACTOR.CXP2.GenericCommonwealth, 1441370}},
			{{ACTOR.CXP2.GenericCommonwealth, 1441380}},
			{{ACTOR.CXP2.GenericCommonwealth, 1441390}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443010}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443020}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443030}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443040}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443050}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443060}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443070}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443080}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443090}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443100}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443110}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443120}},
		},
				
		under_attack = {
			{{ACTOR.CXP2.GenericCommonwealth, 1443140}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443150}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443160}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443170}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443180}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443190}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443200}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443210}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443220}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443230}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443240}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443250}},
		},
		
		retreat_amt = 60,
		retreat_timer = "BRITISH SPEECH RETREAT",
		retreat = {
			{{ACTOR.CXP2.GenericCommonwealth, 1441430}},
			{{ACTOR.CXP2.GenericCommonwealth, 1441440}},
			{{ACTOR.CXP2.GenericCommonwealth, 1441450}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443260}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443270}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443280}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443290}},
			{{ACTOR.CXP2.GenericCommonwealth, 1443300}},
		},	
	}

end

-- preset any units or events needed before the kickoff, but you do not
-- want them to occur at the outset of the map.
-- Example: Often units are needed to exist before the objective start (because they start the objective)
-- then spawn those units here when they need to be spawned
function RoadCapture_Preset()

	-- spawn squads
	
	-- start enemy behavior
	
	-- do other cool things

end
function RoadCapture_DelayObjStart()

	if Event_IsAnyRunning() == false then
		Objective_Start(OBJ_RoadCapture)		
		Rule_RemoveMe()
	end

end

-- start the related action
function RoadCapture_Kickoff()

	Objective_StartTimer(OBJ_RoadCapture, COUNT_DOWN, t_obj_rc.total_time - t_obj_rc.setup_amount, 15)
	Rule_AddInterval(RoadCapture_StartAttack, 0.5)
	Rule_AddInterval(RC_PanzerJagerBuilt, 3)
	Rule_AddInterval(RC_SpeechSuggestions, 4)
	Rule_AddDelayedInterval(RoadCapture_CheckStructuresBuilt, 20, 1)
	Rule_AddDelayedInterval(Medal_DelayStart, 1.5*60, 1)
	
	-- check some variables to determine what speech we should play depending
	-- on what elements of the commander tree the player has upgraded
	if Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_01) then
		t_obj_rc.events.fg_booby_trap_point = true
	end
	
	if Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_11) then
		t_obj_rc.events.fg_scorch_point_acquired = true
	end
	
end

function RoadCapture_CheckStructuresBuilt()

	-- speech
	if t_obj_rc.events.fg_build_marders == false then
		Util_AutoIntel(t_obj_rc.events.build_marders)
		t_obj_rc.events.fg_build_marders = true
	end

	EGroup_Clear(eg_temp)
	Player_GetAll(player1, sg_temp, eg_temp)
	local buildings = {EBP.ELITE.KAMPFGRUPPE, EBP.ELITE.LOGISTIK}
	EGroup_Filter(eg_temp, buildings, FILTER_KEEP)
	EGroup_FilterUnderConstruction(eg_temp, FILTER_REMOVE)
	
	if EGroup_IsEmpty(eg_temp) == false then
		
		-- flash the buttons telling the player how to build a Jager-Kommand
		local flash_id = UI_FlashConstructionMenu(TYPE.CONSTRUCT.ELITE.BASIC, true, BT_UI_Weak_CommandBtn)
		RC_AddToButtonFlashTracker("CONSTRUCTION JAGER BUTTON FLASH", flash_id)
		
		local flash_id = UI_FlashConstructionButton(EBP.ELITE.PANZERJAGER, true, BT_UI_Weak_CommandBtn)
		RC_AddToButtonFlashTracker("PANZER JAGER BUTTON FLASH", flash_id)
		
		UI_SetBuildingPlacementCallback(RC_ConstructJagerCallback)
		Rule_RemoveMe()
	end

end

-- starts the attack of the actual convoy moving down the road
-- and attack the various points along the road.
function RoadCapture_StartAttack()

	if Objective_GetTimerSeconds(OBJ_RoadCapture) <= 0 then
		Rule_Add(RoadCapture_StartNIS)
		Objective_PauseTimer(OBJ_RoadCapture)
		Rule_RemoveMe()
	end
	
end

function RoadCapture_StartNIS()
	
	if Event_IsAnyRunning() == false then		
		-- order everyone to stop attacking each other
		Player_GetAll(player1, sg_temp)
		if SGroup_IsEmpty(sg_temp) == false then
			Cmd_StopSquadsExcept(sg_temp, true, true)
			SGroup_SetInvulnerable(sg_temp, true, 30)
		end
		
		Util_StartNIS(EVENTS.NIS02)
		Rule_Add(RoadCapture_PostNIS)
		Rule_RemoveMe()
	end

end

function RoadCapture_PostNIS()

	if Event_IsAnyRunning() == false then
		-- start the squads coming down the road and execute their adavances.
		Sound_PlayMusic("Music/SP/OMG/Trepidation/OMG/CONVOY.bsc",1,1)
		
		Player_GetAll(player1, sg_temp)
		SGroup_SetInvulnerable(sg_temp, false)
		
		Player_GetAll(player2, sg_temp)
		SGroup_SetInvulnerable(sg_temp, false)
		
		t_obj_rc.state_machine_id = StateMachine_AddTable(t_obj_rc.states)
		Rule_AddInterval(RT_Kickoff, 1)
		Objective_StartTimer(OBJ_RoadCapture, COUNT_DOWN, t_obj_rc.setup_amount, 30)
		Rule_AddOneShot(RoadCapture_PostNISDelaySpeech, 3)
		Objective_UpdateText(OBJ_RoadCapture, 1449100, 1449101, true) 
		Rule_AddInterval(RoadCapture_FailCheck, 5)
		Rule_AddInterval(RC_ClearBridges, 20)
		Rule_AddInterval(RoadCapture_WinCheck, 2)
		Rule_AddInterval(RC_ArtilleryRule, 15)
		
		if Rule_Exists(RC_InvadeTown) == false then
			Rule_AddInterval(RC_InvadeTown, 5)
		end
		
		if Rule_Exists(RC_DestroyRoadBlocks) == false then
			Rule_AddInterval(RC_DestroyRoadBlocks, 4)
		end
		Rule_RemoveMe()
	end

end

function RoadCapture_PostNISDelaySpeech()

	Util_AutoIntel(t_obj_rc.events.colum_approaches)
	
end

-- updates the player on which ponts all the road that he does not control
function RoadCapture_UpdateMap()

	-- this function will loop through and define the specific point that the player needs
	-- to defend on his/her map
	
	-- add a counter so that only the first two points on the road are marked.
	local count = 0
	
	for i=1, table.getn(t_rc_points) do 		
		
		local this = t_rc_points[i]
		
		if Player_OwnsEGroup(player1, this.egroup) 
		and count < 2 then
			
			-- find the first ping on the map
			if OBJ_RoadCapture.mapElementID[i] == false then
				
				FOW_RevealArea(Util_GetPosition(this.egroup), 40, -1)
				-- only show the "active points" that the recon group is trying to capture
				OBJ_RoadCapture.mapElementID[i] = Objective_AddUIElements(OBJ_RoadCapture, this.egroup, true, 1449102, true, 2)
			end
			
			count = count + 1
			
		elseif OBJ_RoadCapture.mapElementID[i] ~= false then
			Objective_RemoveUIElements(OBJ_RoadCapture, OBJ_RoadCapture.mapElementID[i])
			OBJ_RoadCapture.mapElementID[i] = false	
			FOW_UnRevealArea(Util_GetPosition(this.egroup), 40)
		end
	end

end


function RC_ClearBridges()

	-- tacking on an additional function to check the area around the bridges to make sure there 
	-- aren't any wrecks blocking pathfinding across the bridges
	for i=1, table.getn(tmkr_ambush_clear_bridge) do
		
		local arty_strike = BP_GetAbilityBlueprint("abilities/sp/sp_gen_single_instant_artillery_strike_m01.lua")
		EGroup_Clear(eg_temp)
		Player_GetAllEntitiesNearMarker(player1, eg_temp, tmkr_ambush_clear_bridge[i])
		EGroup_Filter(eg_temp, EBP.ELITE.TANK_TRAP, FILTER_KEEP)
		EGroup_FilterUnderConstruction(eg_temp, FILTER_REMOVE)
		if EGroup_CountSpawned(eg_temp) > 0 then
			local pos = Entity_GetPosition(EGroup_GetSpawnedEntityAt(eg_temp, 1))
			Cmd_Ability(player2, arty_strike, pos, nil, true)
		end
		
		if Misc_IsPosOnScreen(Marker_GetPosition(tmkr_ambush_clear_bridge[i])) == false then
			Util_ClearWrecksFromMarker(tmkr_ambush_clear_bridge[i])
		end
		
	end

end

-- debug function for all the ping locations
function RC_ClearAllPings()

	for i=1, table.getn(teg_road_rp) do 
		
		-- find the first ping on the map
		if OBJ_RoadCapture.mapElementID[i] ~= false then 
			Objective_RemoveUIElements(OBJ_RoadCapture, OBJ_RoadCapture.mapElementID[i])
			OBJ_RoadCapture.mapElementID[i] = false
		end
		
	end

end

-- example of how to finish an Obj
function RoadCapture_WinCheck()
	
	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture)
	or Objective_IsFailed(OBJ_RoadCapture) then
		Rule_RemoveMe()
		return
	end
	
	-- this loops through a table and kicks off the appropriate intel event 
	-- if the timer has reached a certain point in the mission
	for k, this in pairs(t_obj_rc.timed_events) do
		if Objective_GetTimerSeconds(OBJ_RoadCapture) <= this.obj_time then
			if this.exec_func ~= false then
				this.exec_func()
			end
			
			table.remove(t_obj_rc.timed_events, k)
		end
	end
	
	if Objective_GetTimerSeconds(OBJ_RoadCapture) <= 0 then
		Objective_StopTimer(OBJ_RoadCapture)
		
		Timer_Start(t_obj_rc.timer_complete, t_obj_rc.timer_complete_amt)
		Rule_AddDelayedInterval(RoadCapture_WinCheck2, 15, 2)
		
		-- remove the FOW around the points to prevent it from carrying over to the
		-- next mission
		for i=1, table.getn(t_rc_points) do 		
			
			local this = t_rc_points[i]
			FOW_UnRevealArea(Util_GetPosition(this.egroup), 40)
			
		end
		
		Rule_RemoveMe()
	end
	
end

-- this function kicks off and gives the player and the convoy about 60 seconds to 
-- finish off the objective and kick the rest of 30th Corps out of the area.
function RoadCapture_WinCheck2()

	local t_squads = {
		t_obj_rc.squads_armor,
		t_obj_rc.squads_armor_at,
		t_obj_rc.squads_recce,
		t_obj_rc.squads_capture,
		t_obj_rc.squads_rides,
		t_obj_rc.squads_rides2,
		t_obj_rc.squads_town,
		t_obj_rc.squads_avre,
	}

	
	if RC_AreAllSquadsDead()
	or Timer_GetRemaining(t_obj_rc.timer_complete) <= 0 then
		
		Objective_Complete(OBJ_RoadCapture)
		
		-- objective is complete
		local nislet = {
			{camPos = false, waitType = NISLET_TIME, waitValue = 1},
			{camPos = false, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Wolfgang, 1441830}},
			{camPos = false, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Wolfgang, 1441840}},
		}
		
		Util_AutoNISlet(NISLET_GAME2LETTER, nislet)
		g_hhambush_win = true
		
		if Rule_Exists(HHAmbush_EndMission) == false then
			Rule_AddDelayedInterval(HHAmbush_EndMission, 5, 0.5)
		end
		
		Rule_RemoveMe()
		
	end

end

-- checks to see whether or not the player has failed the objective
function RoadCapture_FailCheck()

	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsFailed(OBJ_RoadCapture)
	or Objective_IsComplete(OBJ_RoadCapture) then
		Rule_RemoveMe()
		return
	end
	
	-- special case to check if the player has set up defenses
	-- by the time the column arrives, and if not (i.e. he has
	-- not upgraded the chruch to a field barracks, then fail
	-- the mission
	if Objective_IsComplete(OBJ_GarrisonChurch) == false then
		
		g_hhambush_win = false
		Objective_Fail(OBJ_GarrisonChurch, true)
		if Rule_Exists(HHAmbush_EndMission) == false then
			Rule_AddInterval(HHAmbush_EndMission, 1)
		end
		Rule_RemoveMe()
		return
	end

	RoadCapture_UpdateMap()

	bln_fail = true
	
	for i=1, table.getn(teg_road_rp) do 
		if Player_OwnsEGroup(player2, teg_road_rp[i]) == false then
			bln_fail = false
		end
	end
	
	if bln_fail then
		Objective_Fail(OBJ_RoadCapture)
		g_hhambush_win = false
		pos1 = Util_GetPosition(t_obj_rc.active_point.egroup)
				
		local nislet = {
			{camPos = pos1, waitType = NISLET_TIME, waitValue = 1},
			{camPos = pos1, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Voss, 1441850}},
			{camPos = pos1, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Voss, 1441860}},
		}
		
		Util_AutoNISlet(NISLET_GAME2LETTER, nislet)
		if Rule_Exists(HHAmbush_EndMission) == false then
			Rule_AddDelayedInterval(HHAmbush_EndMission, 5, 0.5)
		end
	end
	

end



function RoadCapture_HenschelEvent()

	local sg = Player_GetSquadConcentration(player2)
	
	if SGroup_CountSpawned(sg) > 0 then
		local pos_start = SGroup_GetPosition(sg)
		Cmd_Ability(player1, ABILITY.COMMANDER_TREE.ELITE.HENSCHEL, pos_start, nil, true)
		FOW_RevealArea( pos_start, 20, 30)
	end
	
	Player_SetAbilityAvailability(player1, ABILITY.COMMANDER_TREE.ELITE.HENSCHEL, ITEM_UNLOCKED)
	Util_AutoIntel(t_obj_rc.events.henschel_support)
	Rule_AddDelayedInterval(RC_HenschelAmbientSpeech, 30, 3) 

end

function RC_HenschelAmbientSpeech()
	
	if Event_IsAnyRunning() == false then
		Rule_RemoveMe()
		local rand = World_GetRand(1, table.getn(t_obj_rc.events.am_henschel))
		Util_AutoAmbient(t_obj_rc.events.am_henschel[rand])
	end

end

-- plays a bit of speech updating the player on the progression of the timer during the mission
function RoadCapture_TimeEvents()

	if table.getn(t_obj_rc.events.time_progression) > 0 then
		Util_AutoIntel(t_obj_rc.events.time_progression[1])
		table.remove(t_obj_rc.events.time_progression, 1)
	end
	
end

function RC_AmbientTimeEvents()
	
	if table.getn(t_obj_rc.events.am_road_progress) > 0 then
		local rand = World_GetRand(1, table.getn(t_obj_rc.events.am_road_progress))
		Util_AutoAmbient(t_obj_rc.events.am_road_progress[rand])
		table.remove(t_obj_rc.events.am_road_progress, rand)
	end

end


function RC_FinalPushAmbientSpeech()

	local rand = World_GetRand(1, table.getn(t_obj_rc.events.am_final_push))
	Util_AutoAmbient(t_obj_rc.events.am_final_push[rand])

end

function RC_PanzerJagerBuilt()

	EGroup_Clear(eg_jager_kommand)
	Player_GetAll(player1, sg_temp, eg_jager_kommand)
	EGroup_Filter(eg_jager_kommand, EBP.ELITE.PANZERJAGER, FILTER_KEEP)
	EGroup_FilterUnderConstruction(eg_jager_kommand, FILTER_REMOVE)
	if EGroup_IsEmpty(eg_jager_kommand) == false then
		Util_AutoIntel(t_obj_rc.events.panzer_jager_built)
		t_obj_rc.events.fg_jager_built = true
		Rule_RemoveMe()
	end

end

function RC_SpeechSuggestions()

	if Event_IsAnyRunning() == false then
		
		-- checks and plays speech telling the player to build some marders
		if t_obj_rc.events.fg_call_up_marders == false
		and t_obj_rc.events.fg_jager_built
		and not EGroup_IsEmpty(eg_jager_kommand)
		and EGroup_IsOnScreen(player1, eg_jager_kommand, ANY, 0.8) then
			Util_AutoIntel(t_obj_rc.events.call_up_marders)
			t_obj_rc.events.fg_call_up_marders = true
			HintMouseover_Add(1449125, eg_jager_kommand, 15, false)
			UI_FlashProductionButton(PITEM_Spawn, SBP.ELITE.MARDER, true, BT_UI_Strong_CommandBtn )
			return
		end
			
		-- checks and plays speech telling the player to scorch the point that the 
		-- AI is supposed to capture
		if t_obj_rc.events.fg_scorch_point == false 
		and EGroup_IsOnScreen(player1, t_obj_rc.active_point.egroup, ANY, 0.8) 
		and (Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_01) or Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_11) )then
			Util_AutoIntel(t_obj_rc.events.scorch_point)
			t_obj_rc.events.fg_scorch_point = true
			HintMouseover_Add(1449107, t_obj_rc.active_point.egroup, 10, false)
			
			if Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_01) then
				local flash_id = UI_FlashAbilityButton(ABILITY.COMMANDER_TREE.ELITE.BOOBYTRAP, true, BT_UI_Weak_AbilityBtn)
				RC_AddToButtonFlashTracker("BOOBY TRAP BUTTON FLASH", flash_id)
			end
			
			if Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_11) then
				local flash_id = UI_FlashAbilityButton(ABILITY.COMMANDER_TREE.ELITE.SCORCH_POINT, true, BT_UI_Weak_AbilityBtn)
				RC_AddToButtonFlashTracker("SCORCH POINT BUTTON FLASH", flash_id)
			end
			
			return
		end
			
		-- checks and tells the player to capture an abandoned AT Guns
		if t_obj_rc.events.fg_at_guns_spotted == false then
			for k, this in pairs(t_enc_td.at_guns) do
				World_GetNeutralEntitiesNearMarker(this.egroup, this.spawn)
				EGroup_Filter(this.egroup, EBP.SYNC_WEAPON.AT_57MM, FILTER_KEEP)
				
				if not EGroup_IsEmpty(this.egroup) 
				and t_obj_rc.events.fg_at_guns_spotted == false
				and EGroup_IsOnScreen(player1, this.egroup, ANY, 0.8) then
					local rand = World_GetRand(1, table.getn(t_obj_rc.events.at_guns_spotted))
					Util_AutoIntel(t_obj_rc.events.at_guns_spotted[rand])
					t_obj_rc.events.fg_at_guns_spotted = true
					
					for k, this in pairs(t_enc_td.at_guns) do
						HintMouseover_Add(1449108, this.egroup, 20, false)
					end
					return
				end
			end
		end
		
		-- checks view and suggestis locations for the player to build roadblocks
		if t_obj_rc.events.fg_roadblocks == false
		and t_obj_rc.events.fg_jager_built == true
		and Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_10) then
			for i=1, table.getn(tmkr_ambush_roadblock) do
				if Misc_IsPosOnScreen(Util_GetPosition(tmkr_ambush_roadblock[i])) 
				and t_obj_rc.events.fg_roadblocks == false then
					
					Util_AutoIntel(t_obj_rc.events.roadblocks)
					t_obj_rc.events.fg_roadblocks = true
					
					for i=1, table.getn(tmkr_ambush_roadblock) do
						HintMouseover_Add(1449124, tmkr_ambush_roadblock[i], 20, false)
					end
					
					local flash_id = UI_FlashConstructionMenu(TYPE.CONSTRUCT.ELITE.BASIC, true, BT_UI_Weak_CommandBtn)
					RC_AddToButtonFlashTracker("CONSTRUCTION BUTTON FLASH", flash_id)
					
					local flash_id = UI_FlashConstructionButton(EBP.ELITE.TANK_TRAP, true, BT_UI_Weak_CommandBtn)
					RC_AddToButtonFlashTracker("ROADBLOCK BUTTON FLASH", flash_id)
					
					return
					
				end
			end
		end
			
		-- checks view and suggests locations for the player to booby trap buildings
		if t_obj_rc.events.fg_booby_trap_buildings == false
		and Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_00) then
			for i=1, table.getn(tmkr_ambush_trap_hint) do
				if not EGroup_IsEmpty(teg_ambush_trap_hint[i])
				and EGroup_IsOnScreen(player1, teg_ambush_trap_hint[i], ANY, 0.8)
				and t_obj_rc.events.fg_booby_trap_buildings == false then
					local rand = World_GetRand(1,2)
					Util_AutoIntel(t_obj_rc.events.booby_trap_buildings[rand])
					t_obj_rc.events.fg_booby_trap_buildings = true
					
					for i=1, table.getn(tmkr_ambush_trap_hint) do
						HintMouseover_Add(1449106, tmkr_ambush_trap_hint[i], 20, false)
					end
					
					local flash_id
					if Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_01) then
						flash_id = UI_FlashAbilityButton(ABILITY.COMMANDER_TREE.ELITE.BOOBYTRAP, true, BT_UI_Weak_AbilityBtn)
					else
						flash_id = UI_FlashAbilityButton(ABILITY.COMMANDER_TREE.ELITE.BOOBYTRAP_BUILDING, true, BT_UI_Weak_AbilityBtn)
					end
					
					RC_AddToButtonFlashTracker("BOOBY TRAP BUILDING FLASH", flash_id)
					
					return
					
				end
			end
		end
		
		-- check if the player has acquired booby trapping ability from the CC tree
		if t_obj_rc.events.fg_booby_trap_point == false
		and Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_01) then
			Util_AutoIntel(t_obj_rc.events.booby_trap_point)
			t_obj_rc.events.fg_booby_trap_point = true
			return
		end
		
		-- check if the player has acquired scorched earth ability from the CC tree
		if t_obj_rc.events.fg_scorch_point_acquired == false 
		and Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_11) then
			Util_AutoIntel(t_obj_rc.events.scorch_point_acquired)
			t_obj_rc.events.fg_scorch_point_acquired = true
			return
		end
		
		-- check if the player has the Kompanie building constructed and selected
		-- then add a ping to the pnzrschreck button to tell the player to build those squads
		if g_tankbuster_flash == nil then
			EGroup_Clear(eg_pe_support)
			Player_GetAll(player1, sg_temp, eg_pe_support)
			EGroup_Filter(eg_pe_support, EBP.ELITE.KAMPFGRUPPE, FILTER_KEEP)
			EGroup_FilterUnderConstruction(eg_pe_support, FILTER_REMOVE)
			if EGroup_IsEmpty(eg_pe_support) == false
			and Misc_IsEGroupSelected(eg_pe_support, ANY) then
				g_tankbuster_flash = UI_FlashProductionButton(PITEM_Spawn, SBP.ELITE.TANKBUSTERS, true, BT_UI_Weak_CommandBtn)
			end
		end
		
	end
	
end


function RC_ConstructJagerCallback( ebp, phase )

	if ebp == EBP.ELITE.PANZERJAGER then
		if phase == CP_Selected
		and t_gc.structure_hint_id == nil then	
			
			Camera_MoveToPosition(Util_GetPosition(mkr_ambush_gc_build1), true, SLOW_CAMERA_PANNING)
			t_gc.structure_hint_id = HintPoint_Add(mkr_ambush_gc_build1, true, 1449154)
			Rule_AddOneShot(GC_BuildHintRemove, 30)
		end
			
	elseif ebp ~= EBP.ELITE.TANK_TRAP
	and phase == CP_FinishedPlacing then
			
			UI_ClearBuildingPlacementCallback()
			
			if Rule_Exists(GC_BuildHintRemove) then
				Rule_Remove(GC_BuildHintRemove)
				GC_BuildHintRemove()
			end
			
	end

end

function RC_AddToButtonFlashTracker(timer_name, id)

	local temp = {}
	temp.flash_id = id
	temp.timer = timer_name
	table.insert(t_rc_flashing_buttons, temp)
	
	if Rule_Exists(RC_TrackFlashingButtons) == false then
		Rule_AddInterval(RC_TrackFlashingButtons, 5)
	end

end

function RC_TrackFlashingButtons()

	for k, this in pairs(t_rc_flashing_buttons) do 
		if Timer_Exists(this.timer) == false then
			
			-- checks to see if they have selected panzer grenadiers
			-- which means, chances are they are seeing or have seen
			-- the flashing buttons
			
			SGroup_Clear(sg_temp)
			Misc_GetSelectedSquads(sg_temp, true)
			SGroup_Filter(sg_temp, SBP.ELITE.PANZERGRENADIER, FILTER_KEEP)
			if not SGroup_IsEmpty(sg_temp) then
				Timer_Start(this.timer, 30)
			end
			
		elseif Timer_GetRemaining(this.timer) <= 0 then
			-- after the time passes remove flashing buttons to reduce annoyance factor
			UI_StopFlashing(this.flash_id)
			table.remove(t_rc_flashing_buttons, k)
		end
	end
	
	if table.getn(t_rc_flashing_buttons) == 0 then
		Rule_RemoveMe()
	end

end



-- move a squad into the town quickly to garrison nearby buildings and try to clear the area.
function RC_InvadeTown()

	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture) then
		Rule_RemoveMe()
		return
	end

	if Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_town_time then
		return
	end
	
	-- spawn squads
	-- check timer to respawn the squads
	if SGroup_IsEmpty(t_obj_rc.sg_town_all) then
		
		if (Timer_Exists(t_obj_rc.timer_town_sp) == false or Timer_GetRemaining(t_obj_rc.timer_town_sp)<= 0) then
			
			local t_spawn_table = t_rc_paths[World_GetRand(1, table.getn(t_rc_paths))]
			
			-- a check that will spawn them at different locations if the player has control of a certain aspect of the road.
			-- does player have the start of the road blocked off?
			
			local tmkr_sp = t_spawn_table.tmkr
			local pos = t_spawn_table.tmkr[1]
			
			Util_CreateSquads(player2, t_obj_rc.sg_ride_town, SBP.ALLIES.HALFTRACK, pos)
			SGroup_AddGroup(t_obj_rc.sg_town_all, t_obj_rc.sg_ride_town)
			
			for k, this in pairs(t_obj_rc.squads_town) do
				-- Util_CreateSquads(player, sgroup, sbp, location[, destination, numsquads, loadout, attackmove, facing, upgrades] )
				Util_CreateSquads(player2, this.sgroup, this.sbp, t_obj_rc.sg_ride_town, nil, nil, nil, nil, nil, this.upg)
				SGroup_AddGroup(t_obj_rc.sg_town_all, this.sgroup)
			end
			
			t_obj_rc.pos_town = Util_GetRandomPosition(Util_GetPosition(eg_ambush_garrison_church), 80)
			t_obj_rc.active_path = t_spawn_table.paths[World_GetRand(1, table.getn(t_spawn_table.paths))]
			Timer_Start(t_obj_rc.timer_town_sp, t_obj_rc.timer_town_sp_amt)
			
		end
		
		return
	end
	
	-- order squads to move to the town
	if Prox_AreSquadsNearMarker(t_obj_rc.sg_town_all, Util_GetPosition(eg_ambush_garrison_church), ANY, 60) then
					
		if not SGroup_IsEmpty(t_obj_rc.sg_ride_town) 
		and not SGroup_IsMoving(t_obj_rc.sg_ride_town, ANY) then
			if SGroup_IsHoldingAny(t_obj_rc.sg_ride_town) then
				Cmd_Stop(t_obj_rc.sg_ride_town)
			else
				SGroup_RemoveGroup(t_obj_rc.sg_town_all, t_obj_rc.sg_ride_town)
				Cmd_Move(t_obj_rc.sg_ride_town, mkr_sp_convoy, nil, mkr_sp_convoy)
			end
		end
		
		for k, this in pairs(t_obj_rc.squads_town) do
			
			if not SGroup_IsEmpty(this.sgroup) then
				
				if SGroup_IsInHoldSquad(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup)
				elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == false
				and not SGroup_IsMoving(this.sgroup, ANY) then
					Cmd_Garrison(this.sgroup, eg_ambush_all_town, true)
				end
				
			end
			
		end
		
	else
		
		-- flag to check if the squads are all loaded into the vehicle
		local all_loaded = true
		
		for k, this in pairs(t_obj_rc.squads_town) do
			
			if not SGroup_IsEmpty(this.sgroup) then
				if not SGroup_IsEmpty(t_obj_rc.sg_ride_town) then
					if not SGroup_IsMoving(this.sgroup, ANY)
					and not SGroup_IsInHoldSquad(this.sgroup, ANY) then
						Cmd_Garrison(this.sgroup, t_obj_rc.sg_ride_town)
						all_loaded = false					
					end
				elseif SGroup_IsEmpty(t_obj_rc.sg_ride_town)
				and not SGroup_IsMoving(this.sgroup, ANY) then
					
					Cmd_SquadPath(this.sgroup, t_obj_rc.active_path, true, false, false, 0)
					
				end
			end
		end
		
		if all_loaded 
		and not SGroup_IsEmpty(t_obj_rc.sg_ride_town) then
			Cmd_SquadPath(t_obj_rc.sg_ride_town, t_obj_rc.active_path, true, false, false, 0)
		end
	
	end

end

function RC_DestroyRoadBlocks()

	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture) then
		Rule_RemoveMe()
		return
	end

	if Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_avre_time then
		return
	end
	
	if SGroup_IsEmpty(sg_rc_avre) then
		if Timer_Exists(t_obj_rc.timer_avre_sp) == false or Timer_GetRemaining(t_obj_rc.timer_avre_sp) <= 0 then
			-- spawn the avre
			RC_SpawnGroup(t_obj_rc.squads_avre)
			Modify_Vulnerability(sg_rc_avre, 0.75)
			Modify_WeaponDamage(sg_rc_avre, "hardpoint_01", 1.5)
			Timer_Start(t_obj_rc.timer_avre_sp, t_obj_rc.timer_avre_sp_amt)
		else
			return
		end
	elseif EGroup_IsEmpty(eg_road_blocks)
	or Prox_EGroupSGroup(eg_road_blocks, sg_rc_avre, PROX_CENTER) > 20 then
		
		-- continually check if there is a set of roadblocks that are closer to the AVRE
		EGroup_Clear(eg_temp)
		Player_GetAll(player1, sg_temp, eg_temp)
		EGroup_Filter(eg_temp, EBP.ELITE.TANK_TRAP, FILTER_KEEP)
		
		if EGroup_IsEmpty(eg_temp) == false then
			EGroup_Clear(eg_road_blocks)
			EGroup_AddEGroup(eg_road_blocks, Util_GetClosestEntityInEGroup(sg_rc_avre, eg_temp))
		end
	
	end

	if EGroup_Count(eg_road_blocks) > 0 then
	
		if not SGroup_IsEmpty(sg_rc_avre) then
			local pos = Util_GetPosition(eg_road_blocks)
			
			if not SGroup_IsMoving(sg_rc_avre, ANY)
			and not Prox_AreSquadsNearMarker(sg_rc_avre, pos, ANY, 20) then
				Cmd_Move(sg_rc_avre, pos)
			-- check if it is too close to use the ability
			elseif Prox_EGroupSGroup(eg_road_blocks, sg_rc_avre, PROX_CENTER) < 10 then
				Cmd_Move(sg_rc_avre, Util_GetOffsetPosition(sg_rc_avre, OFFSET_BACK, 5), true, nil, Util_GetPosition(eg_road_blocks))
			elseif not SGroup_IsDoingAbility(sg_rc_avre, ABILITY.CW.FIRE_AVRE_PETARD, ANY) then
				Cmd_Stop(sg_rc_avre)
				Cmd_Ability(sg_rc_avre, ABILITY.CW.FIRE_AVRE_PETARD, Util_GetPosition(eg_road_blocks), Util_GetPosition(eg_road_blocks))
			end
		end		
		
	end

end

function Util_GetClosestEntityInEGroup(var, egroupid)
	
	eg_dist = EGroup_CreateIfNotFound("eg_dist")
	local dist
	local closest = 99999
	EGroup_Clear(eg_dist)
	EGroup_Add(eg_dist, EGroup_GetRandomSpawnedEntity(egroupid))
	
	local CheckEntity = function(gid, idx, eid)
		
		dist = World_DistancePointToPoint(Util_GetPosition(var), Util_GetPosition(eid))
		if dist < closest then
			closest = dist
			EGroup_Clear(eg_dist)
			EGroup_Add(eg_dist, eid)
		end
		
	end
	
	EGroup_ForEach(egroupid, CheckEntity)
	
	return eg_dist


end




---------------------------------------------------------------
-- ************************************************************
-- ROAD CAPTURE BEHAVIOR
-- this group of functions dictate the AI behavior
-- as it tries to capture the various points along the road
-- ************************************************************
---------------------------------------------------------------




-- function used to spawn the various squads that are responsible
-- for moving down the road and capturing the various points along the road.
function RC_SpawnGroup(t_spawn, first_spawn, force_route, stagger)
	
	local t_spawn_table
	-- you can't force a route AND have them spawn on the road
	if first_spawn == true
	and force_route == nil then
		t_spawn_table = {tmkr_sp_road}
	else

		-- a check that will spawn them at different locations if the player has control of a certain aspect of the road.
		-- does player have the start of the road blocked off?
		t_spawn_table = {tmkr_sp_farm}
		
		if force_route ~= nil 
		or (Player_OwnsEGroup(player1, teg_road_rp[1], ANY) == false and Player_OwnsEGroup(player1, teg_road_rp[2], ANY) == false) then
			table.insert(t_spawn_table, tmkr_sp_road)
		end
			
		-- check if the bridge that these vehicles need to cross
		table.insert(t_spawn_table, tmkr_sp_bridge)
	end
	
	local rand = World_GetRand(1, table.getn(t_spawn_table))
	if force_route ~= nil
	and force_route <= table.getn(t_spawn_table) then
		rand = force_route
	end
	
	local tmkr_sp = t_spawn_table[rand]

	for k,this in pairs(t_spawn) do
		if SGroup_IsEmpty(this.sgroup) then
			
			local spawn = tmkr_sp[k]
			if this.sg_ride ~= nil
			and not SGroup_IsEmpty(this.sg_ride) then
				spawn = this.sg_ride
			end
			
			-- hack to have the artillery ALWAYS spawn at specific locations
			if this.sbp == SBP.CW.PRIEST then
				spawn = this.spawn
			end
			
			Util_CreateSquads(player2, this.sgroup, this.sbp, spawn, nil, nil, nil, nil, nil, this.upg)
			this.fg_can_load = true
			
			-- hack to prevent the artillery vehicles from driving on top of each other
			if this.sbp == SBP.CW.PRIEST then
				local rand = World_GetRand(1, 10)
				Modify_UnitSpeed(this.sgroup, 1+(0.01*rand))
			end
			
		end
		
	end
	

end

function RC_AreAllSquadsDead()

	local t_squads = {
		t_obj_rc.squads_armor,
		t_obj_rc.squads_armor_at,
		t_obj_rc.squads_recce,
		t_obj_rc.squads_capture,
		t_obj_rc.squads_rides,
		t_obj_rc.squads_rides2,
		t_obj_rc.squads_town,
		t_obj_rc.squads_avre,
	}

	for i=1, table.getn(t_squads) do
		if RC_AreSquadsDead(t_squads[i]) == false then			
			return false
		end
	end
	
	return true

end

-- checks if squad members are dead and near the despawn point,
-- and if not then they get despawned.
function RC_AreSquadsDead(squads)

	local all_dead = true
	for k,this in pairs(squads) do
		if SGroup_IsEmpty(this.sgroup) == false then
			if Prox_AreSquadsNearMarker(this.sgroup, mkr_sp_convoy, ANY, 15) then
				SGroup_DestroyAllSquads(this.sgroup)
			end
			return false
		end
	end
	
	return true

end

-- searches through the list of possible points and picks the next one for the AI to capture the point
function RC_MonitorPointsToCapture()

	RC_RoadProgressSpeechEvents()

	for k=1, table.getn(t_rc_points) do 		
		
		local this = t_rc_points[k]
		
		if Player_OwnsEGroup(player2, this.egroup) == false then
			
			if this.fg_captured == true then
				this.fg_recce = false
				this.fg_captured = false
				this.fg_capturing_speech = false
			end
			
			-- count the number of points the player owns
			local count = 0
			for i=1, table.getn(teg_road_rp) do 
				if Player_OwnsEGroup(player1, teg_road_rp[i]) then
					count = count + 1
				end
			end
			
			t_obj_rc.points_owned = count
			
			-- reset any leapfrogging that the recce group might have been doing
			-- if the point changed while the vehicles were leap frogging.
			if t_obj_rc.active_point ~= this
			and t_obj_rc.leapfrog_recce_id ~= false then
				Leapfrog_RemovePair(t_obj_rc.leapfrog_recce_id)
				t_obj_rc.leapfrog_recce_id = false
				t_obj_rc.fg_recce_point_timer_started = false
			end
			
			t_obj_rc.active_point2 = this
			t_obj_rc.active_point = this
			if k < table.getn(t_rc_points) then
				t_obj_rc.active_point2 = t_rc_points[k+1]
			end
			
			break
		end
	end
	
end

function RC_RoadProgressSpeechEvents()

	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture) 
	or Objective_IsFailed(OBJ_RoadCapture) then
		return
	end

	if Player_OwnsEGroup(player1, t_obj_rc.active_point.egroup) == false then
		
		if t_obj_rc.active_point.fg_capturing_speech == false
		and Player_OwnsEGroup(player2, t_obj_rc.active_point.egroup) == false then
			
		elseif Player_OwnsEGroup(player2, t_obj_rc.active_point.egroup) then				
			-- play the associated speech event indicating that a point was capped.
			print("Playing speech - point capped")
			if t_obj_rc.active_point.capped_event ~= false then
				Util_AutoIntel(t_obj_rc.active_point.capped_event)	
			end
		end
		
	end

end


-- orders the particular squad to a safe location back up the road
function RC_Retreat(squads)

	for k,this in pairs(squads) do
		
		if not SGroup_IsEmpty(this.sgroup)
		and not SGroup_IsMoving(this.sgroup, ANY) then	
			local pos = RC_LastSafestPosition()
			local rand_pos = Util_GetRandomPosition(pos, 20)
			
			if Prox_AreSquadsNearMarker(this.sgroup, pos, ANY, 20) == false then
				Cmd_Move(this.sgroup, rand_pos)
			else
				Cmd_Stop(this.sgroup)
			end
			
		end
		
	end

end

---------------------------------------------------------------
-- ROAD CAPTURE BEHAVIOR - RECCE
-- these set of functions control whether or not the enemy 
-- should be scouting the resource point that will next
-- capture and
---------------------------------------------------------------
function RC_RecceCheck()

	if Objective_IsComplete(OBJ_RoadCapture)
	or Objective_IsFailed(OBJ_RoadCapture) then
		StateMachine_RemoveTable(t_obj_rc.state_machine_id) 
		return true
	end
	
	-- if the current point is owned by the Allies, then mark it as captured 
	if Player_OwnsEGroup(player2, t_obj_rc.active_point.egroup) then
		t_obj_rc.active_point.fg_captured = true
	end
	
	-- check which points need to be recce'd and captured
	RC_MonitorPointsToCapture()
	
	if t_obj_rc.active_point.fg_recce == true then
	
		if t_obj_rc.leapfrog_recce_id ~= false then
			Leapfrog_RemovePair(t_obj_rc.leapfrog_recce_id)
			t_obj_rc.leapfrog_recce_id = false
		end
		t_obj_rc.fg_recce_point_timer_started = false
		return false
	end

	return true

end

function RC_RecceEnter()
	
end

function RC_RecceExit()

	if t_obj_rc.threat_id ~= nil then
		ThreatArrow_DestroyGroup(t_obj_rc.threat_id)
	end

end

function RC_RecceExec()

	-- check if the squad has been spawned yet
	local spawned = true
	for k,this in pairs(t_obj_rc.squads_recce) do 
		if SGroup_IsEmpty(this.sgroup) then
			spawned = false
			break
		end
	end
	
	-- spawn the squads, if they are not spawned
	if spawned == false then
		if Timer_Exists(t_obj_rc.timer_recce) == false or Timer_GetRemaining(t_obj_rc.timer_recce) <= 0 then
			
			if t_obj_rc.recce_first_sp == true then
				RC_SpawnGroup(t_obj_rc.squads_recce, true)
				t_obj_rc.recce_first_sp = false
			else
				RC_SpawnGroup(t_obj_rc.squads_recce)
			end
			
			t_obj_rc.threat_id = ThreatArrow_CreateGroup(t_obj_rc.squads_recce[1].sgroup, t_obj_rc.squads_recce[2].sgroup)
			-- ** what happens to the leapfrog managing code here?
			t_obj_rc.leapfrog_recce_id = false
			Timer_Start(t_obj_rc.timer_recce, t_obj_rc.timer_recce_amt)
		else
			-- wait for the timer to process before doing anything else
			return
		end
	end
	
	local pos = EGroup_GetPosition(t_obj_rc.active_point.egroup)
	
	-- add this squad to the leapfrog controller
	if t_obj_rc.leapfrog_recce_id == false then
		t_obj_rc.leapfrog_recce_id = Leapfrog_AddPair(t_obj_rc.squads_recce[1].sgroup, t_obj_rc.squads_recce[2].sgroup, pos, RC_LastSafestPosition())
	end
	
 	if Objective_IsComplete(OBJ_RoadCapture) == false
	and Objective_GetTimerSeconds( OBJ_RoadCapture ) <= t_obj_rc.ua_final_push
	and t_obj_rc.active_point.fg_recce == false then
		t_obj_rc.active_point.fg_recce = true
	end
	
	for k,this in pairs(t_obj_rc.squads_recce) do 
		if SGroup_IsEmpty(this.sgroup) == false then
			if Prox_AreSquadMembersNearMarker(this.sgroup, pos, ANY, 20) then
				
				
				-- wait for some time to pass before confirming that the area is clear
				if t_obj_rc.fg_recce_point_timer_started == false then
					
					Cmd_Stop(this.sgroup)
					t_obj_rc.fg_recce_point_timer_started = true
					Timer_Start(t_obj_rc.timer_recce_point, t_obj_rc.timer_recce_point_amt)
					return
				end
				
				-- mark the area as clear for the capture team to approach
				if Timer_Exists(t_obj_rc.timer_recce_point) and Timer_GetRemaining(t_obj_rc.timer_recce_point) <= 0 then
					t_obj_rc.active_point.fg_recce = true
				end
				
			end
			
		end
	end
	
	-- behavior for the capture squad while recce is running
	for k,this in pairs(t_obj_rc.squads_capture) do 
		if SGroup_IsEmpty(this.sgroup) == false then
			
			local pos = SGroup_GetPosition(this.sgroup)
			
			if not SGroup_IsMoving(this.sgroup, ANY) == false
			and SGroup_IsInCover(this.sgroup) < 0.5 then
--~ 				print(SGroup_GetName(this.sgroup).." is not in cover?  "..SGroup_IsInCover(this.sgroup))
				Cmd_Move(this.sgroup, pos, nil, nil, nil, nil, nil, 40)
			end
			
		end
	end
	
	for k,this in pairs(t_obj_rc.squads_capture2) do 
		if SGroup_IsEmpty(this.sgroup) == false then
			
			local pos = SGroup_GetPosition(this.sgroup)
			
			if not SGroup_IsMoving(this.sgroup, ANY) == false
			and SGroup_IsInCover(this.sgroup) < 0.5 then
--~ 				print(SGroup_GetName(this.sgroup).." is not in cover?  "..SGroup_IsInCover(this.sgroup))
				Cmd_Move(this.sgroup, pos, nil, nil, nil, nil, nil, 40)
			end
			
		end
	end

end


-- returns the last known safest position of the recon elements 
function RC_LastSafestPosition()

	for i=table.getn(teg_road_rp), 1, -1 do
		
		if Player_OwnsEGroup(player2, teg_road_rp[i]) then
			return EGroup_GetPosition(teg_road_rp[i])
		end
		
	end
	
	return Marker_GetPosition(mkr_hunt_convoy_prot1_sp2)

end

---------------------------------------------------------------
-- ROAD CAPTURE BEHAVIOR - CAPTURE
-- these set of functions control whether or not the enemy 
-- should be scouting the resource point that will next
-- capture and
---------------------------------------------------------------
function RC_CaptureCheck()

	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture) then
		return false
	end

	if t_obj_rc.active_point.fg_recce == true 
	and Player_OwnsEGroup(player2, t_obj_rc.active_point.egroup) == false then
		return true
	end

	return false
end

function RC_CaptureExec()

	if Timer_Exists(t_obj_rc.timer_sp_capture) == false or Timer_GetRemaining(t_obj_rc.timer_sp_capture) <= 0 then	
		RC_SpawnCaptureSquads()
	end
	
	RC_SquadCaptureBehavior(t_obj_rc.squads_capture, t_obj_rc.squads_rides, t_obj_rc.active_point)
	
	if t_obj_rc.active_point ~= t_obj_rc.active_point2 then
		RC_SquadCaptureBehavior(t_obj_rc.squads_capture2, t_obj_rc.squads_rides2, t_obj_rc.active_point2)
	end
	
end

function RC_SpawnCaptureSquads()

	-- check if the squad has been spawned yet
	local spawned = true
	for k,this in pairs(t_obj_rc.squads_capture) do 
		if SGroup_IsEmpty(this.sgroup) then
			spawned = false
			break
		end
	end	
	
	-- spawn the squads, if they are not spawned
	if spawned == false then
		if Timer_Exists(t_obj_rc.timer_sp_capture) == false or Timer_GetRemaining(t_obj_rc.timer_sp_capture) <= 0 then
			
			-- forcing the squads to spawn next to their rides
			local force_route = World_GetRand(1, 3)
			
			-- first time spawning they come in on the road.
			if t_obj_rc.capture_first_sp == true then
				RC_SpawnGroup(t_obj_rc.squads_rides, true)
				RC_SpawnGroup(t_obj_rc.squads_capture, true)
				t_obj_rc.capture_first_sp = false
			else
				RC_SpawnGroup(t_obj_rc.squads_rides, nil, force_route)
				RC_SpawnGroup(t_obj_rc.squads_capture, nil, force_route)
			end
			
			if t_obj_rc.events.fg_inf == false then
				Util_AutoIntel(t_obj_rc.events.inf_approaches)
				t_obj_rc.events.fg_inf = true
			end
			
			Timer_Start(t_obj_rc.timer_sp_capture, t_obj_rc.timer_sp_capture_amt)
		else
			-- wait for the timer to process before doing anything else
			return
		end
	end
	
	-- spawn the second group of squads
	if Objective_GetTimerSeconds(OBJ_RoadCapture) <= t_obj_rc.ua_capture2_time then
		
		local spawned = true
		for k,this in pairs(t_obj_rc.squads_capture2) do 
			if SGroup_IsEmpty(this.sgroup) then
				spawned = false
				break
			end
		end
		
		-- forcing the squads to spawn next to their rides
		local force_route = World_GetRand(1, 3)
		
		if spawned == false then
			RC_SpawnGroup(t_obj_rc.squads_rides2, nil, force_route)
			RC_SpawnGroup(t_obj_rc.squads_capture2, nil, force_route)
		end
		
	end
	
end




function RC_CaptureExit()


end

function RC_CaptureEnter()
	
	for k, this in pairs(t_obj_rc.squads_capture) do
		this.fg_can_load = true
	end

end

-- checks what the squads should be doing,
-- and whether or not they are all loaded into vehicles
-- so that they're rides can move out.
function RC_SquadCaptureBehavior(capture_squads, rides, active_point)
	
--~ 	print("RC_SquadCaptureBehavior: Ordering Squads to Capture")
	local pos = EGroup_GetPosition(active_point.egroup)
	local rides_go = true
	local b_capturing = false
	
	-- order the squads to move to the point
	for k, this in pairs(capture_squads) do 
		if SGroup_IsEmpty(this.sgroup) == false then
			
			-- debug flag to try and see which squad should be capturing the point
			this.fg_capturing = false
			
			-- is the squad near the point yet?
			if Prox_AreSquadMembersNearMarker(this.sgroup, pos, ANY, 50) then
				
				-- since they are near the point of capture,
				-- indicate that the soldiers can load vehicles again
				this.fg_can_load = true
				
				if b_capturing == false then
					-- if the player does not own the point and the squad is not capturing, then order them to capture it
					if Player_OwnsEGroup(player2, active_point.egroup) == false
					and not SGroup_IsCapturing( this.sgroup, ANY )
					and not SGroup_IsDoingAbility( this.sgroup, ABILITY.REENABLE_CAPTURE, ANY ) then
						
						if SGroup_IsInHoldEntity(this.sgroup, ANY)
						or SGroup_IsInHoldSquad(this.sgroup, ANY) then
							Cmd_UngarrisonSquad(this.sgroup)
						-- order the squad to re-enable a disabled point	
						elseif Modifier_IsEnabledOnEGroup(active_point.egroup, "modifiers\\enable_capture_entity_modifier.lua", ANY, true) == false then
							Cmd_Ability(this.sgroup, ABILITY.REENABLE_CAPTURE, active_point.egroup)
						-- push really hard at the end to capture the point (even at the expense of the squads life)
						else
							if active_point.fg_capturing_speech == false then
								local rand = World_GetRand(1, table.getn(t_obj_rc.events.inf_capturing))
								Util_AutoIntel(t_obj_rc.events.inf_capturing[rand])
								active_point.fg_capturing_speech = true
							end
								
							if Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_final_push then
								Cmd_AttackMoveThenCapture(this.sgroup, active_point.egroup)
							else
								Cmd_MoveToThenCapture(this.sgroup, active_point.egroup)
							end
						end
						
					end
					b_capturing = true
					this.fg_capturing = true
					
				elseif SGroup_IsInHoldSquad(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup)
				elseif not SGroup_IsInHoldEntity(this.sgroup, ANY)
				and not SGroup_IsMoving(this.sgroup, ANY) then
--~ 					print("RC_SquadCaptureBehavior: Garrison Buildings")
					Util_GarrisonNearbyBuilding(this.sgroup, pos, 40, false)
					
					if eg_garrison == nil 
					and not SGroup_IsInCover(this.sgroup, 0.5) then
--~ 						print("RC_SquadCaptureBehavior: Get into Cover")
						Cmd_Move(this.sgroup, pos, nil, nil, nil, nil, nil, 30)
					end
				elseif SGroup_IsInHoldEntity(this.sgroup, ANY)
				and SGroup_TotalMembersCount(this.sgroup) < Squad_GetMax(SGroup_GetSpawnedSquadAt(this.sgroup, 1)) then
--~ 					print("RC_SquadCaptureBehavior: Attempting to Reinforce")
					local num = Squad_GetMax(SGroup_GetSpawnedSquadAt(this.sgroup, 1)) - SGroup_TotalMembersCount(this.sgroup)
					Cmd_InstantReinforceUnit(this.sgroup, num)
					
				end
			
			-- if not the load them into a vehicle to get moving!
			else
--~ 				print("RC_SquadCaptureBehavior"..k..": Not Near the Point")
				if SGroup_IsInHoldSquad(this.sgroup, ANY) == false
				and this.fg_can_load ~= false then
--~ 					print("RC_SquadCaptureBehavior: Checking Squad Can Occupy Vehicles"..k)
					KR_OccupyVehicles(this, rides)
					rides_go = false
				end
				
				-- next check if they were able to get into the vehicle
				-- if not, then we just need to tell them to move to the point
				if this.fg_can_load == false then
					if SGroup_IsInHoldEntity(this.sgroup, ANY) then
						Cmd_UngarrisonSquad(this.sgroup)
					else
						local pos_offset = Util_GetOffsetPosition(pos, OFFSET_FRONT, 10)
						Cmd_AttackMove(this.sgroup, pos_offset)
					end
				end
				
			end
			
		end
	end
	
	-- order all the carrying vehicles to move out of if all the squads
	-- are loaded that can be loaded.
	for k, this in pairs(rides) do
		
		if not SGroup_IsEmpty(this.sgroup) then
			local rand_pos = Util_GetRandomPosition(pos, 20)
			
			-- check if the vehicle has squads is "full" or everyone has been loaded int a vehicle.
			if Prox_AreSquadsNearMarker(this.sgroup, pos, ANY, 25) == false then
				if KR_IsVehicleFull(this.sgroup, this.capacity_squads, this.capacity_members)
				or rides_go then
					if not SGroup_IsMoving(this.sgroup, ANY) then
						Cmd_Stop(this.sgroup)
						Cmd_Move(this.sgroup, rand_pos)
					end
				end
			end
		end
	end

end

---------------------------------------------------------------
-- ROAD CAPTURE BEHAVIOR - UNDER ATTACk
-- these set of functions control whether or not the enemy 
-- should be scouting the resource point that will next
-- capture and
---------------------------------------------------------------

function RC_UnderAttackCheck()
	
	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture) then
		return false
	end

	-- this may be an expensive call if no one is under attack
	if RC_CheckUnderAttack(t_obj_rc.squads_recce)
	or RC_CheckUnderAttack(t_obj_rc.squads_arty)
	or RC_CheckUnderAttack(t_obj_rc.squads_capture)
	or RC_CheckUnderAttack(t_obj_rc.squads_armor)
	or RC_CheckUnderAttack(t_obj_rc.squads_armor_at) 
	or RC_CheckUnderAttack(t_obj_rc.squads_rides) then
		return true
	end
	
	SGroup_Clear(t_obj_rc.sg_target)
	return false

end

function RC_CheckUnderAttack(t_group)

	for k, this in pairs(t_group) do 
		if SGroup_IsEmpty(this.sgroup) == false 
		and SGroup_IsUnderAttack(this.sgroup, ANY, 5) then
			if SGroup_IsEmpty(t_obj_rc.sg_target) then
				SGroup_GetLastAttacker(this.sgroup, t_obj_rc.sg_target)
			end
			return true
		end
	end
	
	return false

end

function RC_UnderAttackExit()

	if t_obj_rc.threat_id ~= nil then
		ThreatArrow_DestroyGroup(t_obj_rc.threat_id)
	end
	
	if t_obj_rc.threat_at_id ~= nil then
		ThreatArrow_DestroyGroup(t_obj_rc.threat_at_id)
	end

end

function RC_UnderAttackEnter()

	for k, this in pairs(t_obj_rc.squads_capture) do
		this.fg_can_load = true
	end
	
	if t_rc_british.fg_first_contact == false then
		local rand = World_GetRand(1, table.getn(t_rc_british.first_contact))
		Util_AutoAmbient(t_rc_british.first_contact[rand])
		t_rc_british.fg_first_contact = true
	elseif table.getn(t_rc_british.under_attack) > 0 then
		local rand = World_GetRand(1, table.getn(t_rc_british.under_attack))
		Util_AutoAmbient(t_rc_british.under_attack[rand])
		table.remove(t_rc_british.under_attack, rand)
	end

end

function RC_UnderAttackExec()

	RC_UnderAttackArmor()
	RC_UnderAttackArmorAT()
	RC_UnderAttackCapture()
	RC_UnderAttackRecce()
	
end






-- specific function that controls the behavior for the armored squads
function RC_UnderAttackArmor()
		
	if TankCombat_GroupExists(t_obj_rc.tc_armor_id) == false then
		t_obj_rc.tc_armor_id = false
	end	

	-- check if BOTH squads exist, as we always want to spawn them as a pair
	local spawned = true
	for k,this in pairs(t_obj_rc.squads_armor) do 
		if SGroup_IsEmpty(this.sgroup) then
			spawned = false
		end
	end
	
	-- spawn the squads, if they are not spawned
	if spawned == false then
		if Timer_Exists(t_obj_rc.timer_sp_armor) == false or Timer_GetRemaining(t_obj_rc.timer_sp_armor) <= 0 then
			if t_obj_rc.armor_first_sp == true then
				RC_SpawnGroup(t_obj_rc.squads_armor, true)
				t_obj_rc.armor_first_sp = false
			else
				RC_SpawnGroup(t_obj_rc.squads_armor)
			end
			
			if t_obj_rc.events.fg_armor == false then
				local rand = World_GetRand(1,2)
				Util_AutoIntel(t_obj_rc.events.armor_approaches[rand])
				t_obj_rc.events.fg_armor = true
			end
			
			t_obj_rc.threat_id = ThreatArrow_CreateGroup()
			
			for k, this in pairs(t_obj_rc.squads_armor) do 
				ThreatArrow_Add(t_obj_rc.threat_id, this.sgroup)
			end
			
			TankCombat_RemoveGroup(t_obj_rc.tc_armor_id)
			t_obj_rc.tc_armor_id = false
			Timer_Start(t_obj_rc.timer_sp_armor, t_obj_rc.timer_sp_armor_amt)
			
		else
			-- wait for the timer to process before doing anything else
			return
		end
	end
	
	if t_obj_rc.tc_armor_id == false then
		if SGroup_IsEmpty(t_obj_rc.sg_target) == false then
			if EGroup_IsEmpty(teg_ambush_base[1]) == false then
				local pos = EGroup_GetPosition(teg_ambush_base[1])
			end
			t_obj_rc.tc_armor_id = TankCombat_AddGroup(t_obj_rc.tsg_armor, SGroup_GetPosition(t_obj_rc.sg_target), pos)
			TankCombat_EnableFormUp(t_obj_rc.tc_armor_id, false)
		end
	end

end

-- specific function that controls the behavior for the armored AT squads (i.e the squads that deal with heavier attacks)
function RC_UnderAttackArmorAT()

	local armor_threats = {
		SBP.ELITE.HALFTRACK_SNIPER,
		SBP.ELITE.MARDER,
		SBP.ELITE.PANZERGRENADIER,
	}
	
	if Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_armor_at_time then
		return
	end
	
	if TankCombat_GroupExists(t_obj_rc.tc_armor_at_id) == false then
		t_obj_rc.tc_armor_at_id = false
	end
	
	b_attack = false
	SGroup_Clear(sg_temp)
	SGroup_AddGroup(sg_temp, t_obj_rc.sg_target)
	SGroup_Filter(sg_temp, armor_threats, FILTER_KEEP)
	
	if SGroup_IsEmpty(sg_temp) == false then
		b_attack = true
	end

	-- check if all the squads exist, as we always want to spawn them together
	local spawned = true
	for k,this in pairs(t_obj_rc.squads_armor_at) do 
		if SGroup_IsEmpty(this.sgroup) then
			spawned = false
		elseif SGroup_IsUnderAttack(this.sgroup, ANY, 5) then
			b_attack = true
		end
		
	end
	
	-- if any of the squads in the group are under attack, stop processing this funciton 
	-- and let the Tank Combat manager handle it.
	if b_attack == false then
		return
	end
	
	-- spawn the squads, if they are not spawned
	if spawned == false then
		if Timer_Exists(t_obj_rc.timer_sp_armor_at) == false or Timer_GetRemaining(t_obj_rc.timer_sp_armor_at) <= 0 then
			
			if t_obj_rc.armor_at_first_sp == true then
				RC_SpawnGroup(t_obj_rc.squads_armor_at, true)
				t_obj_rc.armor_at_first_sp = false
			else
				RC_SpawnGroup(t_obj_rc.squads_armor_at)
			end
			
			if t_obj_rc.events.fg_armor_at == false then
				local rand = World_GetRand(1,2)
				Util_AutoIntel(t_obj_rc.events.armor_at_approaches[rand])
				t_obj_rc.events.fg_armor_at = true
			end
			
			t_obj_rc.threat_id = ThreatArrow_CreateGroup()
			for k, this in pairs(t_obj_rc.squads_armor_at) do 
				ThreatArrow_Add(t_obj_rc.threat_id, this.sgroup)
			end
			
			TankCombat_RemoveGroup(t_obj_rc.tc_armor_at_id)
			t_obj_rc.tc_armor_at_id = false
			Timer_Start(t_obj_rc.timer_sp_armor_at, t_obj_rc.timer_sp_armor_at_amt)
			
		else
			-- wait for the timer to process before doing anything else
			return
		end
	end
	
	if t_obj_rc.tc_armor_at_id == false then
		
		if SGroup_IsEmpty(t_obj_rc.sg_target) == false then
			if EGroup_IsEmpty(teg_ambush_base[1]) == false then
				local pos = EGroup_GetPosition(teg_ambush_base[1])
			end
			t_obj_rc.tc_armor_at_id = TankCombat_AddGroup(t_obj_rc.tsg_armor_at, SGroup_GetPosition(t_obj_rc.sg_target), pos)
			TankCombat_EnableFormUp(t_obj_rc.tc_armor_id, false)
		end
		
		-- hack that orders the bulldozer to put his blade down.
		for k, this in pairs(t_obj_rc.squads_armor_at) do 
			if this.sbp == SBP.ALLIES.CROCODILE then
				Cmd_Ability(this.sgroup, ABILITY.ALLIES.SHERMAN_BULLDOZER, nil, nil, true)
			end
		end
		
	end

end

-- specific function that controls the behavior for the recce vehicles
function RC_UnderAttackRecce()

	-- order the recce to exit the area and let the armor take over
	for k,this in pairs(t_obj_rc.squads_recce) do 
		if SGroup_IsEmpty(this.sgroup) == false then
			if SGroup_IsMoving(this.sgroup, ANY) == false
			and SGroup_IsUnderAttack(this.sgroup, ANY, 5) then
				
				-- checks to see if the armored tanks are near by, and sends the recce packing back to a "safe location"
				if (not SGroup_IsEmpty(t_obj_rc.squads_armor[1].sgroup) and Prox_SGroupSGroup(this.sgroup, t_obj_rc.squads_armor[1].sgroup, PROX_CENTER) < 20)
				or (not SGroup_IsEmpty(t_obj_rc.squads_armor[2].sgroup) and Prox_SGroupSGroup(this.sgroup, t_obj_rc.squads_armor[2].sgroup, PROX_CENTER) < 20) then
					Cmd_Move(this.sgroup, RC_LastSafestPosition())
				end
				
			end
			
		end
	end

end

function RC_UnderAttackCapture()

	-- ensure that the capture squads only come if it is safe, otherwise
	-- have them attack later on during the mission
	if Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_capture_time then
		return
	end

		if Timer_Exists(t_obj_rc.timer_sp_capture) == false or Timer_GetRemaining(t_obj_rc.timer_sp_capture) <= 0 then
		RC_SpawnCaptureSquads()	
	end

--~ 	print("RC_UnderAttackCapture: Ordering Squads to Capture")
	local b_capturing = false
	local pos = EGroup_GetPosition(t_obj_rc.active_point.egroup)

	RC_RetreatSquads(t_obj_rc.squads_capture)
	RC_RetreatSquads(t_obj_rc.squads_capture2)
	
	RC_SquadCaptureBehavior(t_obj_rc.squads_capture, t_obj_rc.squads_rides, t_obj_rc.active_point)
	
	if t_obj_rc.active_point ~= t_obj_rc.active_point2 then
		RC_SquadCaptureBehavior(t_obj_rc.squads_capture2, t_obj_rc.squads_rides2, t_obj_rc.active_point2)
	end

end

function RC_RetreatSquads(capture_squads)

	for k, this in pairs(capture_squads) do 
		if not SGroup_IsEmpty(this.sgroup) then
			
			if SGroup_TotalMembersCount(this.sgroup) <= 2
			and this.sbp ~= SBP.CW.LIEUTENANT then 
				
				this.fg_can_load = false
				
				if SGroup_IsUnderAttack(this.sgroup, ANY, 5) then
					if SGroup_IsInHoldEntity(this.sgroup, ANY) then
						Cmd_UngarrisonSquad(this.sgroup)
					else
						if table.getn(t_rc_british.retreat) > 0
						and (Timer_Exists( t_rc_british.retreat_timer ) == false or Timer_GetRemaining( t_rc_british.retreat_timer ) <= 0 )then
							local rand = World_GetRand(1, table.getn(t_rc_british.retreat))
							Util_AutoAmbient(t_rc_british.retreat[rand])
							table.remove(t_rc_british.retreat, rand)
							Timer_Start(t_rc_british.retreat_timer, t_rc_british.retreat_amt)
						end
						
						Cmd_Retreat(this.sgroup, Marker_GetPosition(mkr_hunt_convoy_prot1_sp2)	)
					end
				elseif not SGroup_IsMoving(this.sgroup, ANY)
				and SGroup_TotalMembersCount(this.sgroup) < Squad_GetMax(SGroup_GetSpawnedSquadAt(this.sgroup, 1)) then
					local num = Squad_GetMax(SGroup_GetSpawnedSquadAt(this.sgroup, 1)) - SGroup_TotalMembersCount(this.sgroup)
					Cmd_InstantReinforceUnit(this.sgroup, num)
				end				
			end
			
		end
		
	end
	
end










---------------------------------------------------------------
-- ROAD CAPTURE BEHAVIOR - ARTILLERY
-- these set of functions control when
-- the artillery shows up and start bombarding the player's point
-- to improve progress along the road.
---------------------------------------------------------------
function RC_ArtilleryRule()

	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture)
	or Objective_IsComplete(OBJ_DestroyPriests) then
		Rule_RemoveMe()
		return
	end

	if RC_ArtilleryCheck() then
		print("RC_ArtilleryRule: EXECUTING!")
		RC_ArtilleryExec()
	else
		print("RC_ArtilleryRule: No Artillery")
	end

end

function RC_ArtilleryCheck()
		
	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture) 
	or Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_artillery_time then
		return false
	end
	
	-- stop the artillery from respawning if the player completes the secondary objective
	if Objective_IsStarted(OBJ_DestroyPriests)
	and Objective_IsComplete(OBJ_DestroyPriests) then
		return false
	end
	
	if Timer_Exists(t_obj_rc.timer_arty_start)
	and Timer_GetRemaining(t_obj_rc.timer_arty_start) > 0 then
		print("RC_ArtilleryCheck:  "..Timer_GetRemaining(t_obj_rc.timer_arty_start))
		return false
	end
	
	-- check to see if any of the squads are capturing a point at this time
	-- to make sure that we don't interrupt their current activity
	if Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_final_push then
		for k, this in pairs(t_obj_rc.squads_capture) do 
			if SGroup_IsCapturing(this.sgroup, ANY) then
				return false
			end
		end
	end
	
	return true

end

function RC_ArtilleryExit()


end

function RC_ArtilleryEnter()
		
	for k, this in pairs(t_obj_rc.squads_arty) do		
		this.fg_firing = false
		
		if SGroup_IsUsingAbility(this.sgroup, ANY) then
			Cmd_Stop(this.sgroup)
		end
		
	end

end

function RC_ArtilleryExec()

	-- since the artillery is shooting soon, make sure that all squads get the order to evacuate the area.
	if Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_final_push then
		RC_Retreat(t_obj_rc.squads_armor)
		RC_Retreat(t_obj_rc.squads_armor_at)
		RC_Retreat(t_obj_rc.squads_recce)
		RC_Retreat(t_obj_rc.squads_capture)
		RC_Retreat(t_obj_rc.squads_rides)
	end
	
	-- don't start shooting the artillery until the timer counts down to 30
	if Timer_GetRemaining(t_obj_rc.timer_arty_start) > 0 then
		return
	end
	
	if Timer_Exists(t_obj_rc.timer_offmap_arty) == false
	or Timer_GetRemaining(t_obj_rc.timer_offmap_arty) <= 0 then
		-- add a little oompf to the attack depending on where the player is situated
		-- and if he is situation too close to the spawn points on the map
		for i=1, table.getn(tmkr_arty_sectors) do
			Player_GetAllSquadsNearMarker(player1, sg_temp, tmkr_arty_sectors[i])
			if not SGroup_IsEmpty(sg_temp) and SGroup_Count(sg_temp) > 4 then
				local pos = Util_GetPosition(sg_temp)
				Cmd_Ability(player2, ABILITY.SP.SINGLE_HOWITZER, Util_GetRandomPosition(pos, 15), nil, true)
				Cmd_Ability(player2, ABILITY.SP.SINGLE_HOWITZER, Util_GetRandomPosition(pos, 15), nil, true)
				EventCue_Create(CUE.ATTACKED, 1449103, 1449103, pos)
				
				Timer_Start(t_obj_rc.timer_offmap_arty, t_obj_rc.timer_offmap_arty_amt)
			end
		end
		
		
	end
	
	-- ensure that the markers that the priests would move to, exist
	if t_obj_rc.active_point.tmkr_arty == false then
		return
	end
	
	-- spawn any squads that are not spawned
	if t_obj_rc.fg_arty_spawned == false then
		RC_SpawnGroup(t_obj_rc.squads_arty, false, 1)
		t_obj_rc.fg_arty_spawned = true
		
		-- start the associated secondary objective
		if Objective_IsStarted(OBJ_DestroyPriests) == false then
			Objective_Start(OBJ_DestroyPriests)
		end
		
	end
	
	-- a flag used to make sure all available priests are firing
	local restart_timer = true
	local speech = false
	
	-- move the squads to the appropriate locations
	for k, this in pairs(t_obj_rc.squads_arty) do
		
		local pos = t_obj_rc.active_point.tmkr_arty[k]
		
		if not SGroup_IsEmpty(this.sgroup) then
			
			-- make sure the priests have moved to their associated positions
			if Prox_AreSquadMembersNearMarker(this.sgroup, pos, ANY, 10) == false then
				if not SGroup_IsMoving(this.sgroup, ANY) then
					Cmd_Move(this.sgroup, pos, nil, nil, Util_GetPosition(t_obj_rc.active_point.egroup))
					this.fg_firing = false
				end
			else
				
				-- first make sure that we have a target to shoot, this finds the concentration
				-- of the player's units then faces them, picks a position that is a bit short of the
				-- target then starts bombarding that target
				if this.pos_attack == false or this.pos_attack == nil then 
					this.sg_arty_attack = Player_GetSquadConcentration(player1, nil, nil, nil, nil, pos)
					
					-- if we can't find anyone to shoot at then stop trying to artillery the location.
					if this.sg_arty_attack == nil then
						Timer_Start(t_obj_rc.timer_arty_start, t_obj_rc.timer_arty_wait_amt)
						return
					end
					
					this.target_dist = Prox_SGroupSGroup(this.sgroup, this.sg_arty_attack, PROX_CENTER)
					this.pos_attack = Util_GetPosition(this.sg_arty_attack)
					
					-- face the target
					SGroup_FacePosition(this.sgroup, this.pos_attack)
					
					if SGroup_IsUsingAbility(this.sgroup, ANY) then
						Cmd_Stop(this.sgroup)
					end
					this.fg_firing = false
					
				-- orders the priest to start shooting at their targets
				elseif not SGroup_IsMoving(this.sgroup, ANY)
				and not SGroup_IsUsingAbility(this.sgroup, ANY) then
					
					this.target_dist = World_DistancePointToPoint(SGroup_GetPosition(this.sgroup), this.pos_attack)
					local pos_offset = Util_GetOffsetPosition(this.sgroup, OFFSET_FRONT, this.target_dist - this.barrage_offset)
					this.pos_offset = pos_offset
					Cmd_Ability(this.sgroup, ABILITY.CW.PRIEST_BARRAGE, pos_offset, nil, nil, nil, true)
					Cmd_Ability(player2, ABILITY.COMMANDER_TREE.CW.DECOY_ARTILLERY, pos_offset, nil, true)
					EventCue_Create(CUE.ATTACKED, 1449103, 1449103, pos_offset)
					
					FOW_RevealSGroupOnly(this.sgroup, 10)
					UI_CreateMinimapBlip(this.sgroup, 5,  BT_CombatPing)
					this.fg_firing = true
					
					-- an event that plays when artillery is firing
					-- only order this to happen once
					if speech == false then
						local rand = World_GetRand(1, table.getn(t_obj_rc.events.arty_rand))
						Util_AutoAmbient(t_obj_rc.events.arty_rand[rand])
						speech = true
					end
					
				end
			end
			
			if this.fg_firing ~= true then
				restart_timer = false
			else
				this.pos_attack = false
				
				-- shortens the chance to miss by a few meters each time the artillery shoots
				if this.barrage_offset > 0 then
					this.barrage_offset = this.barrage_offset - 5
				else
					this.barrage_offset = 0
				end
			end
		end
	end

	-- a quick check to see if everyone is firing.
	if restart_timer == true then
		print("RC_ArtilleryExec: Restarting the Artillery Timer")
		Timer_Start(t_obj_rc.timer_arty_start, t_obj_rc.timer_arty_wait_amt) -- wait x seconds before firing again
	end

	
end
--------------------------------------------------------------
-- ROAD CAPTURE BEHAVIOR - RETREAT
-- these set of functions control when
-- the artillery shows up and start bombarding the player's point
-- to improve progress along the road.
---------------------------------------------------------------

function RC_RetreatCheck()
		
	if Rule_Exists(RoadCapture_WinCheck2) then
		return true
	end
		
	if (not Objective_IsComplete(OBJ_RoadCapture) and Objective_GetTimerSeconds(OBJ_RoadCapture) > t_obj_rc.ua_retreat_time)
	or Objective_IsFailed(OBJ_RoadCapture) then
		return false
	end

	return true

end

function RC_RetreatExit()


end

function RC_RetreatEnter()
		
	RC_RetreatStop(t_obj_rc.squads_armor)
	RC_RetreatStop(t_obj_rc.squads_armor_at)
	RC_RetreatStop(t_obj_rc.squads_recce)
	RC_RetreatStop(t_obj_rc.squads_capture)
	RC_RetreatStop(t_obj_rc.squads_capture2)
	RC_RetreatStop(t_obj_rc.squads_rides)
	RC_RetreatStop(t_obj_rc.squads_rides2)
	RC_RetreatStop(t_obj_rc.squads_avre)
	RC_RetreatStop(t_obj_rc.squads_town)
	
end

function RC_RetreatExec()

	RC_FinalRetreat(t_obj_rc.squads_armor)
	RC_FinalRetreat(t_obj_rc.squads_armor_at)
	RC_FinalRetreat(t_obj_rc.squads_recce)
	RC_FinalRetreat(t_obj_rc.squads_capture)
	RC_FinalRetreat(t_obj_rc.squads_capture2)
	RC_FinalRetreat(t_obj_rc.squads_rides)
	RC_FinalRetreat(t_obj_rc.squads_rides2)
	RC_FinalRetreat(t_obj_rc.squads_avre)
	RC_FinalRetreat(t_obj_rc.squads_town)
	
	-- hack to get the halftrack to retreat as well
	RC_FinalRetreat(t_obj_rc.squads_town_ride)

end

function RC_RetreatStop( squads)
	for k,this in pairs(squads) do
		
		if not SGroup_IsEmpty(this.sgroup) then
			Cmd_Stop(this.sgroup)
		end
		
	end
end

function RC_FinalRetreat( squads )
	
	for k,this in pairs(squads) do
		
		if not SGroup_IsEmpty(this.sgroup)
		and not SGroup_IsMoving(this.sgroup, ANY) then	
			
			FOW_RevealSGroup(this.sgroup, 30)
			
			if KR_IsSoldier(this.sbp) then
				if SGroup_IsInHoldEntity(this.sgroup, ANY) then
					Cmd_UngarrisonSquad(this.sgroup)
				else
					Cmd_Retreat(this.sgroup, mkr_sp_convoy, mkr_sp_convoy)
				end
			else
				Cmd_Move(this.sgroup, mkr_sp_convoy, nil, mkr_sp_convoy)
			end
			
		end
		
	end

end
---------------------------------------------------------------
-- LEAPFROGGING CODE
-- controls the movement of a pair of vehicles to cover each
-- other as they leapfrom forward towards an obstacle.
---------------------------------------------------------------

function Leapfrog_AddPair(sg1, sg2, destination, retreat_pos)

	if scartype(destination) ~= ST_SCARPOS or scartype(retreat_pos) ~= ST_SCARPOS then
		fatal("Either destination or retreat position is not position type.")
		return
	end
	
	_pairs_current_id = _pairs_current_id + 10

	local group = {
		id 					= _pairs_current_id,
		sgroup1 			= sg1,
		sgroup2 			= sg2,
		sg2_pos				= false, -- the current position to which they are trying to move
		sg1_pos				= false, -- the current position to which this squad is trying to move
		state 				= "caution", -- define state = "caution", "done", "retreat"
		turn 				= 1,
		pos_destination 	= destination,
		timer_wait			= "LEAPFROG TIMER".._pairs_current_id, -- a timer to prevent them from getting stuck trying to get somewhere
		timer_wait_amt		= 8,
	}
	
	-- initialize the timer so that we can check its status later
	Timer_Start(group.timer_wait, group.timer_wait_amt)
	
	if retreat_pos ~= nil then
		group.pos_retreat = retreat_pos
	else
		group.pos_retreat = false
	end
	
	table.insert(_t_pairs, group)
	
	if Rule_Exists(_Pairs_Leapfrog) == false then
		Rule_AddInterval(_Pairs_Leapfrog, 1)
	end
	
	return _pairs_current_id
	
end

function _Leapfrog_Init()

	_t_pairs = {}
	_pairs_current_id = 1002

end

function Leapfrog_RemovePair(id)

	local value = 0
	for k,v in pairs(_t_pairs) do 
		if v.id == id then
			v.fg_remove = true
			return
		end
	end

end

function _Leapfrog_OffsetForwardRand()
	local offset = {OFFSET_FRONT, OFFSET_FRONT_LEFT, OFFSET_FRONT_RIGHT}
	local rand = World_GetRand(1, table.getn(offset))
	
	return offset[rand]
end

function _Leapfrog_OffsetReverseRand()
	local offset = {OFFSET_BACK, OFFSET_BACK_LEFT, OFFSET_BACK_RIGHT}
	local rand = World_GetRand(1, table.getn(offset))
	
	return offset[rand]
end


function _Pairs_Leapfrog()

	if table.getn(_t_pairs) == 0 then
		Rule_RemoveMe()
		return
	end

	for k=table.getn(_t_pairs), 1, -1 do 
		local v = _t_pairs[k]
		if v.fg_remove == true then
			table.remove(_t_pairs, k)
			-- stop processing the loop for this particular run
			break
		end
	
		-- if anyone is dead then RETREAT
		if (SGroup_IsEmpty(v.sgroup1) or SGroup_IsEmpty(v.sgroup2)) then
			
			if v.pos_retreat ~= false then
				-- 'retreat' and clear
				v.state = "retreat"
				if SGroup_IsEmpty(v.sgroup1) == false 
				and SGroup_IsMoving(v.sgroup1, ANY) == false then
					Cmd_Move(v.sgroup1, v.pos_retreat)
				end
				
				if SGroup_IsEmpty(v.sgroup2) == false
				and SGroup_IsMoving(v.sgroup2, ANY) == false then
					Cmd_Move(v.sgroup2, v.pos_retreat)
				end
				
				if Prox_AreSquadsNearMarker(v.sgroup1, v.pos_retreat, ANY, 20)
				or Prox_AreSquadsNearMarker(v.sgroup2, v.pos_retreat, ANY, 20) then
					v.state = "done"
					
					table.remove(_t_pairs, k)
				end
				
			end
			
		-- are we NOT in 'retreat'?
		elseif v.state == "caution" then
			-- are we under attack? then retreat, but leapfrog backwards
			if SGroup_IsUnderAttack(v.sgroup1, false, 5) 
			or SGroup_IsUnderAttack(v.sgroup2, false, 5) then
				
				if v.pos_retreat ~= false then
					if v.turn == 1 then
						if Prox_AreSquadsNearMarker(v.sgroup1, v.pos_retreat, false, 20) then
							if SGroup_IsEmpty(v.sgroup1) or SGroup_IsEmpty(v.sgroup2) then
								v.state = "done"
							else
								v.state = "attack"
							end
						else
							if Prox_SGroupSGroup(v.sgroup1, v.sgroup2, PROX_SHORTEST) > 40
							and Timer_GetRemaining(v.timer_wait) > 0 then
								Cmd_Stop(v.sgroup1)
								SGroup_FacePosition(v.sgroup1, v.pos_destination)
								v.turn = 2
								v.sg2_pos = Util_GetOffsetPosition(v.sgroup1, _Leapfrog_OffsetReverseRand(), 15)
								Cmd_Move(v.sgroup2, v.sg2_pos)
								Timer_Start(v.timer_wait, v.timer_wait_amt)
							else
								if SGroup_IsMoving(v.sgroup1, false) == false then
									Cmd_AttackMove(v.sgroup1, Util_GetPosition(v.pos_retreat))
								end
								Timer_Start(v.timer_wait, v.timer_wait_amt)
							end
						end
					elseif v.turn == 2 then
						if Prox_AreSquadsNearMarker(v.sgroup2, v.pos_retreat, false, 20) then
							if SGroup_IsEmpty(v.sgroup1) or SGroup_IsEmpty(v.sgroup2) then
								v.state = "done"
							else
								v.state = "attack"
							end
							
						else
							if Prox_AreSquadsNearMarker(v.sgroup2, v.sg2_pos, ANY, 15)
							or Timer_GetRemaining(v.timer_wait) == 0 then
								v.turn = 1
								Cmd_Stop(v.sgroup2)
								SGroup_FacePosition(v.sgroup2, v.pos_destination)
							end
						end
					end
				else
					v.state = "attack"
				end
			-- not under attack
			else
				
				-- who's turn is it?
				if v.turn == 1 then
					if Prox_AreSquadsNearMarker(v.sgroup1, v.pos_destination, false, 10) then
						v.state = "done"
						-- remove this group from the list of moving vehicle
						table.remove(_t_pairs, k)
					else
						-- check if they are in enemy territory	
						if Prox_SGroupSGroup(v.sgroup1, v.sgroup2, PROX_SHORTEST) > 40
						and Timer_GetRemaining(v.timer_wait) > 0 then
							Cmd_Stop(v.sgroup1)
							SGroup_FacePosition(v.sgroup1, v.pos_destination)
							v.turn = 2
							v.sg2_pos = Util_GetOffsetPosition(v.sgroup1, _Leapfrog_OffsetForwardRand(), 20)
							Cmd_Move(v.sgroup2, v.sg2_pos)
							Timer_Start(v.timer_wait, v.timer_wait_amt)
						else
							if SGroup_IsMoving(v.sgroup1, false) == false then
								Cmd_AttackMove(v.sgroup1, v.pos_destination)
							end
							Timer_Start(v.timer_wait, v.timer_wait_amt)
						end
					end
				elseif v.turn == 2 then
					if Prox_AreSquadsNearMarker(v.sgroup2, v.pos_destination, false, 20) then
						v.state = "done"
						-- remove this group from the list of moving vehicle
						table.remove(_t_pairs, k)
					else
						if Prox_AreSquadsNearMarker(v.sgroup2, v.sg2_pos, ANY, 15)
						or Timer_GetRemaining(v.timer_wait) == 0 then
							Cmd_Stop(v.sgroup2)
							SGroup_FacePosition(v.sgroup2, v.pos_destination)
							v.turn = 1
						end
					end
				end
				
			end
		elseif v.state == "attack" then
			-- are we under attack?
			if SGroup_IsUnderAttack(v.sgroup1, false, 5) == false
			and SGroup_IsUnderAttack(v.sgroup2, false, 5) == false then
				v.state = "caution" 
			end
		-- else, 'retreat'
		elseif v.state == "retreat" then
			-- need to find a better solution for this.
			v.state = "caution"
		end
	end

end








-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-- REPAIR TEAM (RT)
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
function RepairTeamInit()

	teg_hunt_rt_base = EGroup_GetWBTable("eg_ambush_base%d")
	tsg_repair_team = SGroup_CreateTable("sg_repair_team%d", table.getn(teg_hunt_rt_base))
	tsg_base_inf = SGroup_CreateTable("sg_base_inf%d", table.getn(teg_hunt_rt_base))
	sg_vehicles_to_repair = SGroup_CreateIfNotFound("sg_vehicles_to_repair")

	-- order of the vehicles in this table determines the order
	-- that the infantry will repair the vehicles
	t_rt_vehicle_sbps = {		
		SBP.ALLIES.M10,
		SBP.ALLIES.SHERMAN,
		SBP.ALLIES.PERSHING,
		SBP.ALLIES.CROCODILE,
		SBP.ALLIES.HALFTRACK,
		SBP.CW.STUART,
		SBP.CW.CROMWELL,
		SBP.CW.FIREFLY,
		SBP.CW.COMMAND_CROMWELL,
		SBP.CW.CHURCHILL,
		SBP.CW.CHURCHILL_AVRE,
		SBP.CW.CHURCHILL_CROC,
		SBP.CW.BREN_CARRIER,
	}
	
	t_rt = {
		repair_percent 			= 0.999,
		repair_rate				= Modify_VehicleRepairRate(player2, 2, SBP.CW.SAPPER)
	}
	
	t_repair_team = {}
	for i=1, table.getn(tsg_repair_team) do 
		t_repair_team[i] = {
			sgroup				= tsg_repair_team[i],
			eg_repair 			= teg_hunt_rt_base[i],
			sg_target			= false,
			fg_active			= false,
			sbp 				= SBP.CW.SAPPER,
		}
	end
	
end


function RT_Kickoff()

	-- put squads into ambient buildings and upgrade the buildings, these are the repair, fallback stations
	local all_owned = true
	for i=1, table.getn(teg_hunt_rt_base) do 
		
		if not EGroup_IsEmpty(teg_hunt_rt_base[i]) then
			
			if SGroup_IsEmpty(tsg_base_inf[i]) then
				Util_CreateSquads(player2, tsg_base_inf[i], SBP.ALLIES.HEAVYMG, mkr_hunt_convoy_prot1_sp2)
			elseif not SGroup_IsInHoldEntity(tsg_base_inf[i], ANY) 
			and SGroup_IsIdle(tsg_base_inf[i], ANY) then
				
				Cmd_Garrison(tsg_base_inf[i], teg_hunt_rt_base[i])
			end
			
			if EGroup_HasUpgrade(teg_hunt_rt_base[i], UPG.ALLIES.CONVERT_AMBIENT_BUILDING, ANY) == false then
				all_owned = false
				if Player_OwnsEGroup(player2, teg_hunt_rt_base[i]) then
					Cmd_InstantUpgrade(teg_hunt_rt_base[i], UPG.ALLIES.CONVERT_AMBIENT_BUILDING)
				end
			end	
		end
	end
	
	if Rule_Exists(RT_DetermineRepair) == false then
		Rule_AddInterval(RT_DetermineRepair, 4.5)
	end
	
	if all_owned then
		Rule_RemoveMe()
	end

end

-- this function determines if there are any vehicles near the bases to repair
function RT_DetermineRepair()

	for i=1, table.getn(teg_hunt_rt_base) do 
		-- determine if there are any vehicles nearby that need repair
		if RT_IsBaseValid(teg_hunt_rt_base[i]) then
			
			Player_GetAllSquadsNearMarker(player2, sg_vehicles_to_repair, EGroup_GetPosition(teg_hunt_rt_base[i]), 80)
			SGroup_Filter(sg_vehicles_to_repair, t_rt_vehicle_sbps, FILTER_KEEP)
			if SGroup_IsEmpty(sg_vehicles_to_repair) == false then
			
				-- this checks a squad to see if it falls below the threshold, and if so removes them
				-- from the sgroup of vehicles to repair
				local _FilterHealth = function(gid, idx, sid)
					local currentHealth = 0
					local maxHealth = 0
					
					currentHealth = Squad_GetHealth(sid)
					maxHealth = Squad_GetHealthMax(sid)
					if maxHealth > 0 and currentHealth/maxHealth > t_rt.repair_percent then
						SGroup_Remove(gid, sid)
					end
					
				end
				
				-- loop through the various available vehicles and determine which ones
				-- fall under the threshold
				SGroup_ForEach(sg_vehicles_to_repair, _FilterHealth)
				
				if SGroup_IsEmpty(sg_vehicles_to_repair) == false then
					
					--- *** TODO Fix this hack, right now they are sent back to the first base in the list...
					t_repair_team[i].eg_repair = teg_hunt_rt_base[1]
					RT_RepairTeamActive()
					return
				end
			end
		end
		
	end
	
	-- if the code makes it through without finding any vehicles to repair, then
	-- make sure all the repair engineers are gone.
	RT_RepairTeamInactive()
	
end

-- this function spawns pioneers that are near the bases to move and repair nearby tanks
function RT_RepairTeamActive()
	
	-- spawns, or orders the various 
	local _RepairVehicles = function(gid, idx, sid)
	
		-- if there aren't any team members available for repair,
		-- then don't process the rest of the squads
		if t_repair_team[idx] == nil then
			return
		end
		
		local sgroup = t_repair_team[idx].sgroup
		SGroup_Clear(sg_temp)
		
		if EGroup_IsEmpty(t_repair_team[idx].eg_repair) == false then
			
			-- if the repair team is dead, spawn them.
			if SGroup_IsEmpty(sgroup) then
				Util_CreateSquads(player2, sgroup, t_repair_team[idx].sbp, t_repair_team[idx].eg_repair, EGroup_GetPosition(t_repair_team[idx].eg_repair), nil, 2)
			elseif SGroup_IsInHoldEntity(sgroup, ANY) then
				Cmd_UngarrisonSquad(sgroup, EGroup_GetPosition(t_repair_team[idx].eg_repair))
			elseif Squad_GetActiveCommand(SGroup_GetSpawnedSquadAt(sgroup, 1)) ~= SQUADSTATEID_Ability then
				Cmd_Ability(sgroup, ABILITY.REPAIR, gid)		
			end
		end
	
	end
	
	SGroup_ForEach(sg_vehicles_to_repair, _RepairVehicles)

end

-- loops through the various team members and orders them
-- back into a building to despawn
function RT_RepairTeamInactive()

	for i=1, table.getn(t_repair_team) do 
		local sgroup = t_repair_team[i].sgroup
	
		if SGroup_IsEmpty(sgroup) == false then		
			if SGroup_IsInHoldEntity(sgroup, ALL) then
				SGroup_DestroyAllSquads(sgroup)
			elseif EGroup_IsEmpty(t_repair_team[i].eg_repair) == false then
				-- make the location that they despawn at, better at choosing that location
				Cmd_Garrison(sgroup, t_repair_team[i].eg_repair)
			end
		
		end
	end

end

function RT_IsBaseValid(eg_base)

	if EGroup_IsEmpty(eg_base) then
		return false
	end

	if Player_OwnsEGroup(player2, eg_base) == false then
		return false
	end

	return true

end











-- this is an encounter or a set of encounters that is triggered if the player enters an area
-- and finds some sappers building emplacements at a location
function EngineerBuilding_Init()

	tmkr_eb = Marker_GetTable("mkr_ambush_eb%d")
	tmkr_eb_sp = Marker_GetTable("mkr_ambush_eb%d_sp")
	tmkr_eb_barb = Marker_GetTable("mkr_eb_barb%d_1")
	
	t_eb = {
		prox_dist 		= 40,  -- distance from the player must be to start the squads building
	}
	
	t_eb.squads = {}
	
	for i=1, table.getn(tmkr_eb) do
		t_eb.squads[i] = {
			sgroup 			= SGroup_CreateIfNotFound("sg_engineer_build"..i),
			egroup			= EGroup_CreateIfNotFound("eg_engineer_build"..i),
			sbp 			= SBP.CW.TOMMIES,
			upg 			= {},
			mkr 			= tmkr_eb[i],
			mkr_sp			= tmkr_eb_sp[i],
			ebp 			= EB_ChooseEmplacement(),
			fg_spawned		= false,
			mkr_retreat		= mkr_sp_convoy,
		}
		
		local this = t_eb.squads[i]
		
		if Marker_Exists("mkr_eb_barb"..i.."_1", "") then
			this.mkr_start = Marker_FromName("mkr_eb_barb"..i.."_1", "")
			this.mkr_end = Marker_FromName("mkr_eb_barb"..i.."_2", "")
			this.sbp = SBP.CW.SAPPER
			this.ebp = EBP.CW.BARBED_WIRE
		end
		
		if Marker_Exists("mkr_eb_sandbag"..i.."_1", "") then
			this.mkr_start = Marker_FromName("mkr_eb_sandbag"..i.."_1", "")
			this.mkr_end = Marker_FromName("mkr_eb_sandbag"..i.."_2", "")
			this.sbp = SBP.CW.SAPPER
			this.ebp = EBP.CW.SANDBAG
		end
		
		if Marker_Exists("mkr_eb_mg"..i, "") then
			this.sg_mg			= SGroup_CreateIfNotFound("sg_eb_mg"..i)
			this.mkr_mg			= Marker_FromName("mkr_eb_mg"..i, "")
		end
		
	end
	
	t_eb.squads[1].ebp = false
	
	t_eb.squads[8].ebp = EBP.CW.BOFORS_NEST
	t_eb.squads[8].sbp = SBP.CW.SAPPER

	t_eb.squads[14].ebp = EBP.CW.BOFORS_NEST
	t_eb.squads[14].sbp = SBP.CW.SAPPER
	
	t_eb.squads[9].ebp = EBP.CW.SLITTRENCH_NEST
	
end

function EngineerBuilding_Kickoff()

	Rule_AddInterval(EB_CheckProx, 2.5)

end

function EB_ChooseEmplacement()

	local temp = {EBP.CW.SLITTRENCH_NEST, EBP.CW.MG_NEST, EBP.CW.MORTAR_NEST}
	return temp[World_GetRand(1, table.getn(temp))]

end

function EB_CheckProx()

	if Rule_Exists(RoadCapture_WinCheck2)
	or Objective_IsComplete(OBJ_RoadCapture) then
		Rule_AddInterval(EB_ClearSoldiers, 2)
		Rule_RemoveMe()
	end

	for k, this in pairs(t_eb.squads) do
		
		if EGroup_IsEmpty(this.egroup) then
			EGroup_Clear(eg_temp)
			Player_GetAllEntitiesNearMarker(player2, eg_temp, this.mkr, 15)
			
			-- since slit trenches are not owned until manned, make sure that we include those as well
			World_GetEntitiesNearMarker(player2, eg_temp, this.mkr, OT_Neutral) 
			
			-- filter out for the appropriate building being constructed
			EGroup_Filter(eg_temp, this.ebp, FILTER_KEEP)
			
			if EGroup_IsEmpty(eg_temp) == false then
				-- prevent the squad from attempting to build the structure any more, but pushing
				-- the attempts to build over the threshold
				this.attempts = 5
			end
			
			EGroup_FilterUnderConstruction(eg_temp, FILTER_REMOVE)
			EGroup_Clear(this.egroup)
			EGroup_AddEGroup(this.egroup, eg_temp)
			
		end
		
		if SGroup_IsEmpty(this.sgroup)
		and Objective_IsComplete(OBJ_RoadCapture) == false then
			if this.fg_spawned == false then
				Player_GetAllSquadsNearMarker(player1, sg_temp, Util_GetPosition(this.mkr), t_eb.prox_dist)
				if SGroup_IsEmpty(sg_temp) == false then
					
					print("Attempting to Spawn Squad"..SGroup_GetName(this.sgroup))
					
					local pos = Marker_GetPosition(this.mkr_sp)
					local pos2 = Util_GetOffsetPosition(this.mkr, OFFSET_BACK, 5)
					pos = World_GetHiddenPositionOnPath(player1, pos, pos2, CHECK_OFFCAMERA)
					
					if pos == nil then
						pos = this.mkr_sp
					end
					
					Util_CreateSquads(player2, this.sgroup, this.sbp, pos)
					this.fg_spawned = true
					
				end
				
			elseif this.mkr_mg ~= nil and this.mg_spawned ~= true then
				local pos = Marker_GetPosition(this.mkr_sp)
				local pos2 = Util_GetOffsetPosition(this.mkr, OFFSET_BACK, 5)
				pos = World_GetHiddenPositionOnPath(player1, pos, pos2, CHECK_OFFCAMERA)
				
				if pos == nil then
					pos = this.mkr_sp
				end
				
				Util_CreateSquads(player2, this.sg_mg, SBP.CW.VICKERS_MG_SP, pos, this.mkr_mg, nil, nil, nil, this.mkr)
				ATGun_AddGroup(this.sg_mg, player2)
				this.mg_spawned = true
				
			else
				table.remove(t_eb.squads, k)
			end
			
		elseif SGroup_TotalMembersCount(this.sgroup) <= 1 
		or Objective_IsComplete(OBJ_RoadCapture) then
			Cmd_Retreat(this.sgroup, this.mkr_retreat, this.mkr_retreat)
		elseif this.ebp == false
		and not SGroup_IsMoving(this.sgroup, ANY)
		and not SGroup_IsUnderAttack(this.sgroup, ANY, 10) then
			Cmd_AttackMove(this.sgroup, this.mkr, nil, nil, 20)
		elseif this.ebp ~= false
		and EGroup_IsEmpty(this.egroup) == false 
		and not SGroup_IsConstructingBuilding(this.sgroup, ANY) then
			
			this.fg_built = true
			if this.ebp == EBP.CW.SLITTRENCH_NEST
			and not EGroup_IsEmpty(this.egroup) 
			and not SGroup_IsInHoldEntity(this.sgroup, ANY) then
				Cmd_Garrison(this.sgroup, this.egroup)
			elseif not SGroup_IsInCover(this.sgroup, 0.5) then
				Cmd_AttackMove(this.sgroup, Util_GetPosition(this.egroup), nil, nil, 20)				
			end
			
			if this.mkr_mg ~= nil and this.mg_spawned ~= true then
				local pos = Marker_GetPosition(this.mkr_sp)
				local pos2 = Util_GetOffsetPosition(this.mkr, OFFSET_BACK, 5)
				pos = World_GetHiddenPositionOnPath(player1, pos, pos2, CHECK_OFFCAMERA)
				
				if pos == nil then
					pos = this.mkr_sp
				end
				
				Util_CreateSquads(player2, this.sg_mg, SBP.CW.VICKERS_MG_SP, pos, this.mkr_mg, nil, nil, nil, this.mkr)
				ATGun_AddGroup(this.sg_mg, player2)
				this.mg_spawned = true
				
			end
			
		elseif this.ebp ~= false
		and not SGroup_IsMoving(this.sgroup, ANY)
		and not SGroup_IsConstructingBuilding(this.sgroup, ANY) then
			
			if t_kr.events.fg_tommy_contact == false 
			and this.sbp == SBP.CW.TOMMIES 
			and Player_CanSeeSGroup(player1, this.sgroup, ANY)
			and SGroup_IsOnScreen(player1, this.sgroup, ANY, 0.8) then
				Util_AutoAmbient(t_kr.events.am_tommy_contact)
				t_kr.events.fg_tommy_contact = true
			end
			
			if this.attempts ~= nil and this.attempts > 3 then
				Cmd_Retreat(this.sgroup, mkr_sp_convoy, mkr_sp_convoy)
			elseif this.mkr_end == nil then
				Cmd_Construct(this.sgroup, this.ebp, this.mkr)
				if this.attempts == nil then
					this.attempts = 1
				else
					this.attempts = this.attempts + 1
				end
				
			else
				-- construct a fence or barbed wire
				Command_PlayerSquadConstructFence(player2, this.sgroup, this.ebp, Util_GetPosition(this.mkr_start), Util_GetPosition(this.mkr_end), false)
			end
		end
		
	end


end

function EB_ClearSoldiers()

	local all_dead = true
	for k, this in pairs(t_eb.squads) do
		
		if SGroup_IsEmpty(this.sgroup) == false then
			Cmd_Retreat(this.sgroup, this.mkr_retreat, this.mkr_retreat)
			all_dead = false
		end
		
		if this.sg_mg ~= nil and SGroup_IsEmpty(this.sg_mg) == false then
			Cmd_Retreat(this.sg_mg, this.mkr_retreat, this.mkr_retreat)
			all_dead = false
		end
		
	end
	
	if all_dead then
		Rule_RemoveMe()
	end

end

















-------------------------------------------------------------------------
-- Garrison Church 
-------------------------------------------------------------------------
-- The player must occupy the church and upgrade it to give him the ability 
-- to produce units in the town.
-------------------------------------------------------------------------
function Initialize_OBJ_GarrisonChurch()

	OBJ_GarrisonChurch = {
		
		SetupUI = function() 
			-- mark a point or position
		end,
		
		OnStart = function()
			
			-- announce the goal
			
			
			Sound_PlayMusic("Music/SP/OMG/SitReps/OMG/situation_report_2.bsc",1,0)
			-- win/lose check
			Rule_AddInterval(GarrisonChurch_WinCheck, 1)
			
			-- start related action
			GarrisonChurch_Kickoff()
			-- EncounterName_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			Player_SetPopCapOverride(player1, 90)
			Player_SetAbilityAvailability(player1, ABILITY.SP.HELLS_PANZER_GRENADIERS, ITEM_REMOVED)
			Sound_StopMusic(4,0)
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1449150,
		Description = 1449151,
		TitleEnd = 1449160,
		Type = OT_Primary,
	}
	
	-- Register Objective
	Objective_Register(OBJ_GarrisonChurch)
	-- Initialize Data
	GarrisonChurch_Init()
	
end

-------------------------------------------------------------------------
-- Garrison Church - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function GarrisonChurch_Init()

	sg_gc_hint = SGroup_CreateIfNotFound("sg_gc_hint")
	
	teg_church_territory = { eg_rp11, eg_rp17, eg_rp12, eg_rp13}

	t_gc = {
		-- a table of the supply points that the player needs to have in supply to 
		-- garrison the church
		t_supply_rps 		= {eg_road_rp4, eg_road_rp5, eg_road_rp6},			-- a table of the supply points that the player should capture to ensure that the church is in supply
		supply_rp_ui 		= false,											-- a value store the last resource point that was pinged by the objective.
		fg_garrisoned 		= false,											-- a value to indicate whether or not the church has been garrisoned by the player or not
		fg_barracks			= false,											-- a flag to indicate whether 
		obj_id_squad		= false,											-- a hint point to tell the player to order squads into the church
	}
	
	t_gc.build_squads = {
		{
			ebp 				= EBP.ELITE.KAMPFGRUPPE,
			mkr_build			= mkr_ambush_gc_build2,
		},
		{
			ebp 				= EBP.ELITE.LOGISTIK,
			mkr_build			= mkr_ambush_gc_build4,
		},
	}
	
	for k, this in pairs(t_gc.build_squads) do
		this.sgroup 			= SGroup_CreateIfNotFound("sg_gc_build"..k)
		this.spawn 				= mkr_ambush_gc_sp
		this.sbp 				= SBP.ELITE.PANZERGRENADIER
		this.build_attempts		= 0
	end
	
	GarrisonChurch_InitEvents()
	EGroup_SetInvulnerable(eg_ambush_garrison_church, 0.4)
	Rule_AddInterval(GarrisonChurch_CheckDestruction, 1)
	
	local pos1 = EGroup_GetPosition(eg_ambush_garrison_church)
	local pos2 = Marker_GetPosition(mkr_ambush_gc_build2)
	local pos3 = Marker_GetPosition(mkr_ambush_gc_build4)
	
	nis_build_stuff = {
		{camPos = pos1, waitType = NISLET_TIME, waitValue = 1},
		{camPos = pos1, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Deinhard, 1441355}},
		{camPos = pos1, waitType = NISLET_TIME, waitValue = 1},
		{camPos = pos2, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Deinhard, 1441360}},
		{camPos = pos2, waitType = NISLET_TIME, waitValue = 2},
		{camPos = pos3, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Wolfgang, 1440740}},
		{camPos = pos3, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Deinhard, 1441365}},
	}
	
end

function GarrisonChurch_InitEvents()

	t_gc.events = {
		obj_start = {
			{ACTOR.CXP2.Wolfgang, 1441321},
			{ACTOR.CXP2.Wolfgang, 1441330},
		},
		
		fg_out_of_supply = false,
		out_of_supply = {
			{ACTOR.CXP2.Deinhard, 1441332},
			{ACTOR.CXP2.Deinhard, 1441334},
		},
		
		fg_garrison_out_of_supply = false,
		garrison_out_of_supply = {
			{ACTOR.CXP2.Aldrich, 1441342},
		},
		
		fg_supply_established = false,
		supply_established = {
			{ACTOR.CXP2.Deinhard, 1441336},
		},
		
		church_upgraded = {
			{ACTOR.CXP2.Aldrich, 1441341},
		},
	
		obj_complete = {
			{ACTOR.CXP2.Deinhard, 1441355},
			{ACTOR.CXP2.Deinhard, 1441360},
		},	
	}

end

-- preset any units or events needed before the kickoff, but you do not
-- want them to occur at the outset of the map.
-- Example: Often units are needed to exist before the objective start (because they start the objective)
-- then spawn those units here when they need to be spawned
function GarrisonChurch_Preset()

	-- spawn squads
	
	-- start enemy behavior
	
	-- do other cool things

end

function GarrisonChurch_DelayStart()

	if Event_IsAnyRunning() == false then
		Util_AutoIntel(t_gc.events.obj_start)
		Objective_Start(OBJ_GarrisonChurch)
		Rule_RemoveMe()
	end

end

function GarrisonChurch_Kickoff()

	-- action that starts with the Obj being granted
	EGroup_InstantCaptureStrategicPoint( eg_road_rp6, player1 )
	
	SGroup_Clear(sg_temp)
	Util_CreateSquads(player1, sg_temp, SBP.ELITE.ARMOURCAR_221, mkr_convoy_end)
	Cmd_MoveToThenCapture(sg_temp, eg_road_rp5)

	SGroup_Clear(sg_temp)
	Player_GetAll(player1, sg_temp)
	SGroup_Filter(sg_temp, SBP.ELITE.PANZERGRENADIER, FILTER_KEEP)
	
	if SGroup_IsEmpty(sg_temp) then
		Util_CreateSquads(player1, sg_temp, SBP.ELITE.PANZERGRENADIER, mkr_convoy_end)
		Cmd_MoveToThenCapture(sg_temp, eg_road_rp4)
	end
	
end

-- this function checks to see how damaged the church is and
-- keeps it from getting destroyed if the health reaches a certain point
function GarrisonChurch_CheckDestruction()

	if EGroup_GetAvgHealth(eg_ambush_garrison_church) <= 0.4 then
		EGroup_SetHealthMinCap(eg_ambush_garrison_church, 1)
		Rule_RemoveMe()
	end

end

-- example of how to finish an Obj

function GarrisonChurch_CheckTerritory()

	local all_capped = true
	for i=1, table.getn(teg_church_territory) do
		if not Player_OwnsEGroup(player1, teg_church_territory[i]) then
			all_capped = false
		end
	end
	
	if all_capped then
		Rule_RemoveMe()
		EGroup_InstantCaptureStrategicPoint(eg_town_control, player1)
		EGroup_InstantCaptureStrategicPoint(eg_ambush_rp_control, player2)
		return
	end

end

function GarrisonChurch_WinCheck()
	
	if EGroup_IsEmpty(eg_ambush_garrison_church) then
		Objective_Fail(OBJ_GarrisonChurch, true)
		g_hhambush_win = false
		if Rule_Exists(HHAmbush_EndMission) == false then
			Rule_AddDelayedInterval(HHAmbush_EndMission, 5, 0.5)
		end
		Rule_RemoveMe()
		return
	end
	
	-- this checks if the player has any panzer grenadiers and they have started the next objective,
	-- because if they don't have any PGs, then they will not be able to garrison and upgrade the church,
	-- therefore, fail the mission.
	if Objective_IsStarted(OBJ_RoadCapture) then
		Player_GetAll(player1, sg_temp)
		SGroup_Filter(sg_temp, SBP.ELITE.PANZERGRENADIER, FILTER_KEEP)
		if SGroup_IsEmpty( sg_temp ) then
			Objective_Fail(OBJ_GarrisonChurch, true)
			g_hhambush_win = false
			if Rule_Exists(HHAmbush_EndMission) == false then
				Rule_AddDelayedInterval(HHAmbush_EndMission, 5, 0.5)
			end
			Rule_RemoveMe()
			return
		end
	end
	
	-- check if various points are in supply to tell the player to capture those points
	if World_IsInSupply( player1, Util_GetPosition(eg_ambush_garrison_church)) == false then
		
		if t_gc.events.fg_out_of_supply == false then
			Util_AutoIntel(t_gc.events.out_of_supply)
			t_gc.events.fg_out_of_supply = true
		end
		
		local num = table.getn(t_gc.t_supply_rps)
		for i=1, table.getn(t_gc.t_supply_rps) do
			
			-- check for the last point that is in supply, and if that point is in supply then
			-- tell the player that he needs capture the point before this one to get the church
			-- into supply.
			if World_IsInSupply(player1, Util_GetPosition(t_gc.t_supply_rps[i])) then
				if num > 1 then
					num = i-1
				end
			end
		end
		
		local rp = t_gc.t_supply_rps[num]
		
		if t_gc.supply_rp_ui ~= num then
			if OBJ_GarrisonChurch.mapSupplyID ~= nil then
				Objective_RemoveUIElements(OBJ_GarrisonChurch, OBJ_GarrisonChurch.mapSupplyID)
			end
		
			OBJ_GarrisonChurch.mapSupplyID = Objective_AddUIElements(OBJ_GarrisonChurch, rp, true, 1449158, true, 2)
			t_gc.supply_rp_ui = num
		end
		
		if t_gc.events.fg_garrison_out_of_supply == false then
--~ 			Util_AutoIntel(t_gc.events.garrison_out_of_supply)
			t_gc.events.fg_garrison_out_of_supply = true
			
			if OBJ_GarrisonChurch.mapElementID ~= nil then
				Objective_RemoveUIElements(OBJ_GarrisonChurch, OBJ_GarrisonChurch.mapElementID)
			end
			
			-- tell the playerthat the church is out of supply
			OBJ_GarrisonChurch.mapElementID = Objective_AddUIElements(OBJ_GarrisonChurch, eg_ambush_garrison_church, false, 1449161, false)
			
		end	
		
		return
		
	elseif OBJ_GarrisonChurch.mapSupplyID ~= nil then
		if t_gc.events.fg_supply_established == false then
			Util_AutoIntel(t_gc.events.supply_established)
			t_gc.events.fg_supply_established = true
		end
		
		if OBJ_GarrisonChurch.mapElementID ~= nil then
			Objective_RemoveUIElements(OBJ_GarrisonChurch, OBJ_GarrisonChurch.mapElementID)
			OBJ_GarrisonChurch.mapElementID = nil
		end
		
		Objective_RemoveUIElements(OBJ_GarrisonChurch, OBJ_GarrisonChurch.mapSupplyID)
		OBJ_GarrisonChurch.mapSupplyID = nil
	end
	
	-- update the hint points telling the player to garrison the church and
	-- whether or not the church is out of supply.
	if Player_OwnsEGroup(player1, eg_ambush_garrison_church, ANY) == false
	and t_gc.fg_garrisoned == false then
		
		if OBJ_GarrisonChurch.mapElementID ~= nil then
			Objective_RemoveUIElements(OBJ_GarrisonChurch, OBJ_GarrisonChurch.mapElementID)
		end
		
		if t_gc.obj_id_squad == false then
			Player_GetAll(player1, sg_temp)
			SGroup_Filter(sg_temp, SBP.ELITE.PANZERGRENADIER, FILTER_KEEP)
			
			if SGroup_IsEmpty(sg_temp) == false then
				SGroup_Clear(sg_gc_hint)
				SGroup_Add(sg_gc_hint, SGroup_GetRandomSpawnedSquad(sg_temp))
				if SGroup_IsInHoldEntity(sg_gc_hint, ANY) == false
				and SGroup_IsInHoldSquad(sg_gc_hint, ANY) == false then
					t_gc.obj_id_squad = Objective_AddUIElements(OBJ_GarrisonChurch, sg_gc_hint, false, 1449159, true)
				end
			end
			
		end
		
		-- UI Element
		OBJ_GarrisonChurch.mapElementID = Objective_AddUIElements(OBJ_GarrisonChurch, eg_ambush_garrison_church, true, 1449152, true)
		t_gc.fg_garrisoned = true
		t_gc.fg_barracks = false
		
		return
	end
	
	-- if the player has garrisoned the church, tell him how to upgrade it to a barracks
	-- and ensure that the church is not out of supply.
	if Player_OwnsEGroup(player1, eg_ambush_garrison_church, ANY) then
			
		if t_gc.obj_id_squad ~= false then
			Objective_RemoveUIElements(OBJ_GarrisonChurch, t_gc.obj_id_squad)
			t_gc.obj_id_squad = false
		end		
		
		if EGroup_HasUpgrade(eg_ambush_garrison_church, UPG.SP.HELLS_AMBIENT_BUILDING, ANY) == false then
			
			if World_IsInSupply( player1, Util_GetPosition(eg_ambush_garrison_church)) then
				
				if t_gc.fg_upgrade_barracks == nil then
					if Misc_IsEGroupSelected(eg_ambush_garrison_church, ANY) then
						UI_FlashProductionButton(PITEM_Upgrade, UPG.SP.HELLS_AMBIENT_BUILDING, true, BT_UI_Strong_UpgradeBtn )
						t_gc.fg_upgrade_barracks = HintPoint_AddToProductionButton(PITEM_Upgrade, UPG.SP.HELLS_AMBIENT_BUILDING, 1449155, true)
					end
				end
				
				if t_gc.fg_barracks ~= true then
					
					if OBJ_GarrisonChurch.mapElementID ~= nil then
						Objective_RemoveUIElements(OBJ_GarrisonChurch, OBJ_GarrisonChurch.mapElementID)
					end
					
					OBJ_GarrisonChurch.mapElementID = Objective_AddUIElements(OBJ_GarrisonChurch, eg_ambush_garrison_church, true, 1449153, true)
					Util_AutoIntel(t_gc.events.church_upgraded)
					t_gc.fg_barracks = true
					t_gc.fg_garrisoned = false
					return
				end
				
			end
		end
	end
	
	-- final check if the player has done everything correctly.
	if Player_OwnsEGroup(player1, eg_ambush_garrison_church, ANY)
	and EGroup_HasUpgrade(eg_ambush_garrison_church, UPG.SP.HELLS_AMBIENT_BUILDING, ANY) then
		
		EGroup_SetPlayerOwner(eg_town_retreat, player1)
		EGroup_InstantCaptureStrategicPoint(eg_town_reinforce, player1)
		EGroup_InstantCaptureStrategicPoint(eg_town_control, player1)
		EGroup_InstantCaptureStrategicPoint(eg_ambush_rp_control, player2)
		
		Objective_Complete(OBJ_GarrisonChurch)
		Rule_AddDelayedInterval(GC_BuildTechs, 5, 0.5)
		
		-- give the player the ability to construct buildings again.
		Player_SetConstructionMenuAvailability(player1, TYPE.CONSTRUCT.ELITE.BASIC, ITEM_UNLOCKED)
		Player_SetEntityProductionAvailability( player1, EBP.ELITE.KAMPFGRUPPE, ITEM_UNLOCKED )
		Player_SetEntityProductionAvailability( player1, EBP.ELITE.LOGISTIK, ITEM_UNLOCKED )
		
		Rule_RemoveMe()
	end
	
end

function GC_BuildTechs()

	if Event_IsAnyRunning() == false then
		
		Rule_AddInterval(GC_BuildTechStructure, 0.25)
		
		-- move the camera to the appropriate location
		local nislet_type = NISLET_GAME2LETTER
		if Objective_IsStarted(OBJ_RoadCapture) then
			nislet_type = NISLET_GAME2GAME
		end
		
		Camera_ResetToDefault()
		Util_AutoNISlet(nislet_type, nis_build_stuff)
		
		if Rule_Exists(RoadCapture_DelayObjStart) == false then
			Rule_AddDelayedInterval(RoadCapture_DelayObjStart, 5, 1)
		end
		Rule_RemoveMe()
	end

end

function GC_BuildTechStructure()

	-- check to make sure that everyone is constructing so that we can remove this rule
	local all_building = true
	
	for k, this in pairs(t_gc.build_squads) do
		if this.selected ~= true then
			
			-- need to delay the building of the structure until the squad is not in the building
			if SGroup_IsEmpty(this.sgroup) then
				local spawn = World_GetHiddenPositionOnPath(player1, this.spawn, mkr_kr_sp2_2, CHECK_OFFCAMERA)
				
				-- default, destination is nil
				local dest
				
				if spawn == nil then
					spawn = mkr_ambush_gc_sp
				end
				
				Util_CreateSquads(player1, this.sgroup, this.sbp, this.spawn, dest)
				all_building = false
			elseif Misc_IsSGroupSelected(this.sgroup, ANY) then
				-- check if a squad has been selected and stop it from doing anything else
				this.selected = true
			elseif SGroup_IsInHoldEntity(this.sgroup, ANY) then
				Cmd_Ungarrison(this.sgroup, mkr_ambush_gc_hint)
				all_building = false
			else
				EGroup_Clear(eg_temp)
				Player_GetAllEntitiesNearMarker(player1, eg_temp, this.mkr_build, 5)
				EGroup_Filter(eg_temp, this.ebp, FILTER_KEEP)
				
				if EGroup_IsEmpty(eg_temp) 
				and this.build_attempts < 10 then
					all_building = false
				end
				
				if not SGroup_IsMoving(this.sgroup, ANY)
				and not SGroup_IsConstructingBuilding(this.sgroup, ANY) then
					Cmd_Construct(this.sgroup, this.ebp, this.mkr_build)
					this.build_attempts = this.build_attempts + 1
				end
			end
		end
	end
	
	if all_building then
		if Rule_Exists(GC_HintRecruitment) == false then
			Rule_AddInterval(GC_HintRecruitment, 1)
		end
		Rule_RemoveMe()
	end

end

function GC_BuildHintRemove()

	HintPoint_Remove(t_gc.structure_hint_id)

end

function GC_HintRecruitment()

	if Misc_IsEGroupSelected(eg_ambush_garrison_church, ANY) then
		
		g_recruit = {}
		g_recruit.flash = UI_FlashProductionButton(PITEM_Spawn, SBP.ELITE.PANZERGRENADIER, true, BT_UI_Weak_CommandBtn)
		g_recruit.hint = HintPoint_AddToProductionButton(PITEM_Spawn, SBP.ELITE.PANZERGRENADIER, 1449156, true)
		Rule_AddOneShot(GC_HintRecruitmentRemove, 30)
		Rule_RemoveMe()
		
	end

end

function GC_HintRecruitmentRemove()

	HintPoint_Remove(g_recruit.hint)
	UI_StopFlashing(g_recruit.flash)

end









-------------------------------------------------------------------------
-- Objective Name 
-------------------------------------------------------------------------
-- Short descriptive name of what the player is cht_eventsed to do
-- give a brief description of win conditions and loose conditions if any 
-- also describe the kind of challenges the player will face
-------------------------------------------------------------------------
function Initialize_OBJ_Medal()

	OBJ_Medal = {
		
		SetupUI = function() 
			-- mark a point or position
		end,
		
		OnStart = function()
			
			-- announce the goal
			-- Util_AutoIntel(t_obj_title.EventStart)
			
			-- win/lose check
			Rule_AddInterval(Medal_WinCheck, 3)
			
			-- start related action
			Medal_Kickoff()
			-- EncounterName_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1449200,
		Description = 1449201,
		TitleEnd = 1449202,
		Type = OT_Medal,
		MedalID = MEDALS.CXP2.HELLS_HIGHWAY_AMBUSH,
	}
	
	-- Register Objective
	Objective_Register(OBJ_Medal)
	-- Initialize Data
	Medal_Init()
	
end

-------------------------------------------------------------------------
-- Medal Objective - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Medal_Init()

	-- using teg_road_rp table initialized elsewhere
	t_medal = {
		start_rps 			= {teg_road_rp[1], teg_road_rp[2], teg_road_rp[3]},
		active_point 		= teg_road_rp[1],
		map_id				= {},
	}
	
	for i=table.getn(teg_road_rp), 1, -1 do
		t_medal.map_id[i] = false
	end
	
end

-- preset any units or events needed before the kickoff, but you do not
-- want them to occur at the outset of the map.
-- Example: Often units are needed to exist before the objective start (because they start the objective)
-- then spawn those units here when they need to be spawned
function Medal_Preset()


end

function Medal_DelayStart()

	if Objective_IsComplete(OBJ_GarrisonChurch)
	and Event_IsAnyRunning() == false then
				
		Objective_Start( OBJ_Medal )
		Rule_RemoveMe()
		
	end

end

-- example of how to finish an Obj
function Medal_WinCheck()

	-- update the UI
	for i=table.getn(teg_road_rp), 1, -1 do
		
		if Player_OwnsEGroup(player1, teg_road_rp[i], ANY) == false then
			if t_medal.map_id[i] == false then
				t_medal.map_id[i] = Objective_AddUIElements(OBJ_Medal, teg_road_rp[i], true, 1449203, true, 2)
			end
		elseif t_medal.map_id[i] ~= nil then
			Objective_RemoveUIElements(OBJ_Medal, t_medal.map_id[i]) 
			t_medal.map_id[i] = false			
		end
		
	end

	-- don't bother checking if the player has completed the medal until the final objective is complete
	if Objective_IsComplete(OBJ_RoadCapture) == false then
		return
	end

	for i=1, table.getn(teg_road_rp) do
		
		if Player_OwnsEGroup(player1, teg_road_rp[i], ANY) == false then
			
			Objective_Fail(OBJ_Medal)
			Rule_RemoveMe()
			return
		end
		
	end
	
	Objective_Complete(OBJ_Medal)
	Rule_RemoveMe()
	
end


-- start the related action
function Medal_Kickoff()

	-- action that starts with the Obj being granted
	
end











-------------------------------------------------------------------------
-- Destroy the Priests
-------------------------------------------------------------------------
-- The player is tasked with destroying the Priests that are bombarding his position
-------------------------------------------------------------------------
function Initialize_OBJ_DestroyPriests()

	OBJ_DestroyPriests = {
		
		SetupUI = function() 
			
			OBJ_DestroyPriests.mapElementID = {}
			for k, this in pairs(t_obj_rc.squads_arty) do
				OBJ_DestroyPriests.mapElementID[k] = Objective_AddUIElements(OBJ_DestroyPriests, this.sgroup, true, 1449253, true)
			end
		end,
		
		OnStart = function()
			
			-- announce the goal
			Util_AutoIntel(t_obj_rc.events.arty_start)
			
			-- win/lose check
			Rule_AddInterval(DestroyPriests_WinCheck, 5)
			
			-- start related action
			DestroyPriests_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1449250,
		Description = 1449251,
		TitleEnd = 1449252,
		Type = OT_Secondary,
	}
	
	-- Register Objective
	Objective_Register(OBJ_DestroyPriests)
	-- Initialize Data
	DestroyPriests_Init()
	
end

-------------------------------------------------------------------------
-- Objective Name - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function DestroyPriests_Init()


end

-- preset any units or events needed before the kickoff, but you do not
-- want them to occur at the outset of the map.
-- Example: Often units are needed to exist before the objective start (because they start the objective)
-- then spawn those units here when they need to be spawned
function DestroyPriests_Preset()



end

-- example of how to finish an Obj
function DestroyPriests_WinCheck()

	for k, this in pairs(t_obj_rc.squads_arty) do
		if SGroup_IsEmpty(this.sgroup) == false then
			return
		end
	end
	
	Objective_Complete(OBJ_DestroyPriests)
	
end


-- start the related action
function DestroyPriests_Kickoff()


	
end








-------------------------------------------------------------------------
-- ******************************************************************* --
-- MISCELLANEOUS
-- ******************************************************************* --
-------------------------------------------------------------------------

function HHAmbush_EndMission()

	if Event_IsAnyRunning() == false then
		Rule_RemoveAll()
		
		-- remove the player's resource rate modifier
		Modifier_Remove(t_player1_res_mods[1])
		
		Game_EndSP(g_hhambush_win, nil, true)
	end

end

-- shows the reinforcements button for the player 
function HHAmbush_ShowReinforcements()

	if Objective_IsComplete(OBJ_GarrisonChurch) 
	or Objective_IsStarted(OBJ_RoadCapture) then
		Player_SetAbilityAvailability(player1, ABILITY.SP.HELLS_PANZER_GRENADIERS, ITEM_REMOVED)
		Rule_RemoveMe()
		return
	end

	SGroup_Clear(sg_temp)
	Player_GetAll(player1, sg_temp)
	SGroup_Filter(sg_temp, SBP.ELITE.PANZERGRENADIER, FILTER_KEEP)
	
	if SGroup_IsEmpty(sg_temp) then
		
		Player_SetAbilityAvailability(player1, ABILITY.SP.HELLS_PANZER_GRENADIERS, ITEM_UNLOCKED)
		
		if t_hh_ambush.fg_reinforcements_hint == false then
			Rule_AddOneShot(HHAmbush_ReinforcementsAddHint, 1)
			t_hh_ambush.fg_reinforcements_hint = 0
			Timer_Start(t_hh_ambush.timer_reinforcements_hint, t_hh_ambush.timer_reinforcements_hint_amt)
		end
		
	end
	
	if t_hh_ambush.fg_reinforcements_hint ~= true
	and Timer_Exists(t_hh_ambush.timer_reinforcements_hint)
	and Timer_GetRemaining(t_hh_ambush.timer_reinforcements_hint) <= 0 then
		HintPoint_Remove(t_hh_ambush.reinforcements_hint_id)
		HintPoint_Remove(t_hh_ambush.reinforcements_flash_id)
		
		t_hh_ambush.fg_reinforcements_hint = true
		if Rule_Exists(HHAmbush_ReinforcementsToggle) == false then
			Rule_AddInterval(HHAmbush_ReinforcementsToggle, 1)
		end
		Rule_RemoveMe()
		
	end	
	
	

end

function HHAmbush_ReinforcementsAddHint()

	t_hh_ambush.reinforcements_hint_id = HintPoint_AddToAbilityButton(ABILITY.SP.HELLS_PANZER_GRENADIERS, 1449053, true)
	t_hh_ambush.reinforcements_flash_id = UI_FlashAbilityButton(ABILITY.SP.HELLS_PANZER_GRENADIERS, true, BT_UI_Strong_AbilityBtn)
	
end

function HHAmbush_ReinforcementsToggle()

	if Objective_IsComplete(OBJ_GarrisonChurch)
	or Objective_IsStarted(OBJ_RoadCapture) then
		Player_SetAbilityAvailability(player1, ABILITY.SP.HELLS_PANZER_GRENADIERS, ITEM_REMOVED)
		Rule_RemoveMe()
		return
	end
	
	SGroup_Clear(sg_temp)
	Player_GetAll(player1, sg_temp)
	SGroup_Filter(sg_temp, SBP.ELITE.PANZERGRENADIER, FILTER_KEEP)
	
	-- special case scenario to increase the player's pop cap
	if SGroup_IsEmpty(sg_temp)
	and Player_GetCurrentPopulation(player1, CT_Personnel) >= g_pop_cap_start then
		Player_SetPopCapOverride(player1, g_pop_cap_start + 3)
	else 
		Player_SetPopCapOverride(player1, g_pop_cap_start)
	end
	
	if SGroup_IsEmpty(sg_temp)
	or Player_GetCurrentPopulation(player1, CT_Personnel) < g_pop_cap_start - 6 then
		Player_SetAbilityAvailability(player1, ABILITY.SP.HELLS_PANZER_GRENADIERS, ITEM_UNLOCKED)
	else
		Player_SetAbilityAvailability(player1, ABILITY.SP.HELLS_PANZER_GRENADIERS, ITEM_LOCKED)
	end

end

-- add a hint to tell the player to lock down the Marder when he
-- encounters the command tank
function HHAmbush_MarderHint()

	if g_marder_lockdown_hint == nil then
		if ( SGroup_IsEmpty(t_player_start_squads[1].sgroup) and SGroup_IsEmpty(t_player_start_squads[2].sgroup) )
		or SGroup_IsEmpty(t_kr.primary_targets[1].sgroup) then
			
			Rule_RemoveMe()
			return
		end
		
		if SGroup_IsUnderAttack(t_kr.primary_targets[1].sgroup, ANY, 10) then
			if SGroup_IsEmpty(t_player_start_squads[1].sgroup) == false
			and Prox_SGroupSGroup(t_player_start_squads[1].sgroup, t_kr.primary_targets[1].sgroup, PROX_CENTER) <= 39 then
				g_marder_lockdown_hint = HintPoint_Add(t_player_start_squads[1].sgroup, true, 1449054)
			elseif SGroup_IsEmpty(t_player_start_squads[2].sgroup) == false
			and Prox_SGroupSGroup(t_player_start_squads[2].sgroup, t_kr.primary_targets[1].sgroup, PROX_CENTER) <= 39 then
				g_marder_lockdown_hint = HintPoint_Add(t_player_start_squads[2].sgroup, true, 1449054)
			end
		end
		
		return
	end

	if g_marder_lockdown_hint ~= nil then		
		if Misc_IsSGroupSelected(t_player_start_squads[1].sgroup, ANY)
		or Misc_IsSGroupSelected(t_player_start_squads[2].sgroup, ANY) then
			
			HintPoint_Remove(g_marder_lockdown_hint)
			
			UI_FlashAbilityButton(ABILITY.ELITE.MARDER_LOCKDOWN, true, BT_UI_Weak_AbilityBtn)
			Rule_AddOneShot(HHAmbush_MarderShowHintText, 0.5)
			t_marder_immobile_hint = {}
			Rule_AddDelayedInterval(HHAmbush_MarderImmobileHint, 5, 1)
			Rule_RemoveMe()
		end
	end
	
end

function HHAmbush_MarderLockdownCallback(blueprint, phase)
	

end

function HHAmbush_MarderShowHintText()

	HintPoint_AddToAbilityButton(ABILITY.ELITE.MARDER_LOCKDOWN, 1449055, true)
	
end

-- listens for when the player uses various abilities

function HHAmbush_MarderImmobileHint()
	
	local all_mobile = true
	local all_dead = true
	
	for i=1, 2 do 
		if SGroup_IsEmpty(t_player_start_squads[i].sgroup) == false then
			
			all_dead = false
			
			if  SGroup_IsDoingAbility(t_player_start_squads[i].sgroup, ABILITY.ELITE.MARDER_LOCKDOWN, ANY ) == false then
				
				if t_marder_immobile_hint[i] ~= false
				and t_marder_immobile_hint[i] ~= nil then
					HintPoint_Remove(t_marder_immobile_hint[i])
					t_marder_immobile_hint[i] = false
				end
				
			else
				
				g_lockdown_used = true
				if t_marder_immobile_hint[i] == nil then
					t_marder_immobile_hint[i] = HintPoint_Add(t_player_start_squads[i].sgroup, true, 1449056)
				end
				all_mobile = false
			end
		end
	end
	
	if all_mobile == true
	and (g_lockdown_used ~= nil or all_dead) then
		Rule_RemoveMe()
	end
	
	
end

function HHAmbush_MarderSelected()

	if Event_IsAnyRunning() == false then
		
		sg_marder = SGroup_CreateIfNotFound("sg_marder")
		
		SGroup_Clear(sg_marder)
		Misc_GetSelectedSquads(sg_marder, true)
		SGroup_Filter(sg_marder, SBP.ELITE.MARDER, FILTER_KEEP)
		
		if not SGroup_IsEmpty(sg_marder) 
		and not SGroup_IsUnderAttack(sg_marder, ALL, 10) 
		and not SGroup_IsDoingAttack(sg_marder, ALL, 10) then
			local t_temp = {
				{ACTOR.CXP2.Deinhard, 1440572},
				{ACTOR.CXP2.Deinhard, 1440574},
				{ACTOR.CXP2.Deinhard, 1440576},
			}
			
			g_marder_hint = HintPoint_Add(sg_marder, true, 1449057)
			Rule_AddOneShot(HHAmbush_MarderSelectedHintRemove, 15)
			
			Util_AutoAmbient(t_temp)
			Rule_RemoveMe()
		end
		
	end

end

function HHAmbush_MarderSelectedHintRemove()

	HintPoint_Remove(g_marder_hint)

end

function HHAmbush_ReinforceHint()

	if SGroup_IsEmpty(tsg_player_start[5])
	or Objective_IsComplete(OBJ_KillRecce) then
		Rule_RemoveMe()
		return
	end

	sg_reinforce = SGroup_CreateIfNotFound("sg_reinforce")

	SGroup_Clear(sg_reinforce)
	Player_GetAll(player1, sg_reinforce)
	SGroup_Filter(sg_reinforce, SBP.ELITE.PANZERGRENADIER, FILTER_KEEP)
	
	if SGroup_IsEmpty(sg_reinforce) == false then
	
		local CheckSize = function(gid, idx, sid)
			if Squad_Count(sid) < 3 
			and g_reinforce_hint == nil then
				
				g_reinforce_hint = HintPoint_Add(sid, true, 1449058)
			else
				SGroup_Remove(sg_reinforce, sid)
			end
		end
		
		SGroup_ForEach(sg_reinforce, CheckSize)
	
	end
	
	if g_reinforce_hint ~= nil then
		Rule_AddOneShot(HHAmbush_ReinforceRemoveHint, 20)
		Rule_AddInterval(HHAmbush_ReinforceButtonHint, 2) 
		Rule_RemoveMe()
	end

end

function HHAmbush_ReinforceRemoveHint()
	
	if g_reinforce_hint ~= false then
		HintPoint_Remove(g_reinforce_hint)
		g_reinforce_hint = false
	end
	
end

function HHAmbush_ReinforceButtonHint()

	if SGroup_IsEmpty(tsg_player_start[5])
	or Objective_IsComplete(OBJ_KillRecce) then
		Rule_RemoveMe()
		return
	end

	if SGroup_IsEmpty(sg_reinforce) == false 
	and Misc_IsSGroupSelected(sg_reinforce, ANY)
	and Prox_SGroupSGroup(sg_reinforce, tsg_player_start[5], PROX_CENTER) < 20 then
		if g_reinforce_hint ~= false then
			HintPoint_Remove(g_reinforce_hint)
			g_reinforce_hint = false
		end
		UI_FlashProductionButton( PITEM_SquadReinforce, SBP.ELITE.PANZERGRENADIER, true, BT_UI_Weak_UpgradeBtn )
		HintPoint_AddToProductionButton( PITEM_SquadReinforce, SBP.ELITE.PANZERGRENADIER, 1449059, true )
		Rule_RemoveMe()
	end

end

function HHAmbush_UnlockConstruction()

	if Objective_IsComplete(OBJ_GarrisonChurch) then
		Rule_RemoveMe()
		return
	end

	if Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH_10) then
		Player_SetConstructionMenuAvailability(player1, TYPE.CONSTRUCT.ELITE.BASIC, ITEM_UNLOCKED)
		Rule_RemoveMe()
	end
	
end

-- ***************** BASIC JEEP ENCOUNTER ***************** 
function HHAmbush_JeepInit()
	tsg_mkr_exploit = Marker_GetTable("mkr_ambush_sp_exploit%d")
	
	g_jeeps_retreat = false
	t_jeep_patrol = {}
	for i=1, table.getn(tsg_mkr_exploit) do
		t_jeep_patrol[i] = {}
		t_jeep_patrol[i].sgroup = SGroup_CreateIfNotFound("sg_jeep_patrol"..i)
		t_jeep_patrol[i].sbp = SBP.CW.BREN_CARRIER
		t_jeep_patrol[i].upg = UPG.CW.BREN_CARRIER_MMG
		t_jeep_patrol[i].spawn = tsg_mkr_exploit[i]
		t_jeep_patrol[i].retreat = false
	end
	
end

function HHAmbush_JeepKickoff()
	
	for k, this in pairs(t_jeep_patrol) do
		Util_CreateSquads(player2, this.sgroup, this.sbp, this.spawn)
		Cmd_SquadPath(this.sgroup, "path_ambush_exploit1", true, true, true)
	end
	
	Rule_AddInterval(HHAmbush_JeepPatrol, 3)

end

-- this function has some jeeps following a route and if they 
-- come under attack, it initiates the next objective.
function HHAmbush_JeepPatrol()
	
	local all_dead = true
	
	for k, this in pairs(t_jeep_patrol) do
		if not SGroup_IsEmpty(this.sgroup) then
			
			all_dead = false
			
			if g_jeeps_retreat == false then
				if SGroup_IsUnderAttack(this.sgroup, ANY, 10) 
				or SGroup_IsDoingAttack( this.sgroup, ANY, 10) then
					-- start the objective
					if Objective_IsComplete(OBJ_KillRecce)
					and Rule_Exists(RoadCapture_DelayObjStart) == false then
						Rule_AddDelayedInterval(RoadCapture_DelayObjStart, 10, 1)
						g_jeeps_retreat = true
						Cmd_Move(this.sgroup, mkr_sp_convoy, nil, mkr_sp_convoy)
					end
					
				end
			else
				if SGroup_IsMoving(this.sgroup, ANY) == false then
					Cmd_Move(this.sgroup, mkr_sp_convoy, nil, mkr_sp_convoy)
				end
			end
		elseif g_jeeps_retreat == false then
			
			if Objective_IsComplete(OBJ_KillRecce)
			and Rule_Exists(RoadCapture_DelayObjStart) == false then
				Rule_AddDelayedInterval(RoadCapture_DelayObjStart, 10, 1)
				g_jeeps_retreat = true
			end
			
		end
	end
	
	if all_dead
	and g_jeeps_retreat then
		Rule_RemoveMe()
	end

end
