-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Mission Name

-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")


-------------------------------------------------------------------------

-- [[ SETUP ]]

-------------------------------------------------------------------------

function OnGameSetup()
	-- string numbers should reference dat files
	-- "allies_commonwealth" "allies" "axis" "axis_panzer_elite"
	player1 = Setup_Player(1, 1309230, "axis_panzer_elite", 1)
	player2 = Setup_Player(2, 1309231, "allies_commonwealth", 2)
	--player3 = Setup_Player(3, "$000000", "allies_commonwealth", 1)
	
	-- AI slot (ensure that the AI is on the same team as the other Axis player by setting the second parameter
--~  	player3 = Setup_Player(3, "$000000", "Axis Infantry Company", 2)
end

function OnGameRestore()
	player1 = World_GetPlayerAt(1)
	player2 = World_GetPlayerAt(2)
	--player3 = World_GetPlayerAt(3)
	
	-- function takes care of restoring all global mission parameters after a save/load
	Game_DefaultGameRestore()
end




-------------------------------------------------------------------------

-- [[ ONINIT ]]

-------------------------------------------------------------------------

function OnInit()
	g_MissionSpeechPath="omg\\sp\\Mission8"
	
	g_AIControl_Enable = false
	g_AIControl_Pause = true
	
	--[[ PRESET GAME STATE ]]
	--Util_MissionPreset("Mission Name")
	
	-- a constant that stores the mission number for use with
	-- setting the global speech paths, tech tree setup, and 
	-- the player's starting resources
	-- BRW - don't change this number, as it tells the preset data what to load.
	MISSION_NUMBER = 0208 -- 
	
	Setup_MissionPreset(MISSION_NUMBER)
	
	--[[ PRESET DEBUG CONDITIONS ]]
	Oosterbeek_Debug()
	
	--[[ REGISTER OBJECTIVES ]]
	Oosterbeek_ObjectiveRegister()
	
	--[[ MOD INITIAL STATS ]]
	Oosterbeek_ModifyStats()
	
	--[[ SET RESTRICTIONS ]]
	Oosterbeek_Restrictions()
	
	--[[ SET AI ]]
	Oosterbeek_CpuInit()
	
	--[[ SET DIFFICULTY ]]
	Oosterbeek_Difficulty()
	
	--[[ MISSION PRESETS ]]
	Oosterbeek_MissionPreset()
	
	--[[ GAME START CHECK ]]
	Rule_AddOneShot(PlayerAlpha_Init, 0.1)
	FOW_Enable(false) 
	Rule_AddOneShot(Oosterbeek_NISStart, 1)
	
end

Scar_AddInit(OnInit)

function Oosterbeek_Debug()
	
	-- looks for the command line option [-debug]
	if Misc_IsCommandLineOptionSet("debug") then
		
		g_debug = true
		
		-- BRW - all debug functions should only be set if the -debug is used in the command line.
		Scar_DebugConsoleExecute("bind([[NUMPAD8]], [[Scar_DoString('ToggleUIFOW()')]])")
		-- reveal FOW
		
	end
	
	
		
		-- set up bindings for NISes
			Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('Util_StartNIS(NIS_OPENING)')]])")
			Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS02)')]])")
--~ 		Scar_DebugConsoleExecute("bind([[ALT+3]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS03)')]])")
		


end

function Oosterbeek_ObjectiveRegister()
	numSurrender = 0 
	numHowitzer = 0
	--[[ *** MUST INITIALIZE THE OBJ TABLE BEFORE REGISTERING *** ]]
	Initialize_OBJ_PreventCapture()
	Initialize_OBJ_DestroyLandings()
	Initialize_OBJ_Medal()

	
end

function Oosterbeek_ModifyStats()
	Modify_PlayerResourceRate(player1, RT_Manpower, 1.05)
--~ 	Modify_PlayerResourceRate(player1, RT_Fuel, 1.3)
--~ 	Modify_PlayerResourceRate(player1, RT_Munition, 1.1)
	
end

function Oosterbeek_Restrictions()

	Player_SetPopCapOverride(player1, 100)
	Player_SetResource(player1, RT_Munition, 1000)
	Player_SetResource(player1, RT_Manpower, 3000)
	--Player_SetPopCapOverride(player3, 100)
	
	--[[ UN/RESTRICT UPGRADES 
	Cmd_InstantUpgrade(player1, UPG.ALLIES.STICKY_BOMB, ITEM_UNLOCKED)
	
	]]
	
	--[[ RESOURCES 
	Player_SetResource(player1, RT_Manpower, 600)
	Player_SetResource(player1, RT_Munition, 600)
	Player_SetResource(player1, RT_Fuel, 200)
	]]
	
	--[[ UN/RESTRICT ABILITIES 
	Player_SetAbilityAvailability(player1, ABILITY.ALLIES.GRENADE, ITEM_UNLOCKED)
	Player_SetAbilityAvailability(player1, ABILITY.ALLIES.SATCHEL_CHARGE, ITEM_REMOVED)
	Player_SetAbilityAvailability(player2, ABILITY.AXIS.GRENADE, ITEM_UNLOCKED)
	]]
	
	-- UN/RESTRICT POP CAP

	--[[ UN/RESTRICT UI 
	UI_BindingSetEnabled("company_commander", false)
	UI_BindingSetEnabled("squadcap", false)
	]]
	
	--[[ UN/RESTRICT SBPS 
	local sbps = {SBP.ALLIES_SHERMAN, SBP.ALLIES_CROCODILE, SBP.ALLIES_GREYHOUN, SBP.ALLIES_PERSHING }
	for i = 1, table.getn(sbps) do
		Player_SetSquadProductionAvailability(player1, sbps[i], ITEM_LOCKED)
	end
	]]
end



function Oosterbeek_CpuInit()

	AI_Enable(player2, false)
	--AI_Enable(player3, false)

	--[[ left as an example
	
	-- set up Player3 AI  
	Util_AI_Setup(player3, {Util_DifVar({10, 15, 20, 30}), 5}, player3, Game_GetSPDifficulty(), 7, Util_DifVar({1, 2, 3, 5}), 2, 3)
	
	-- Set up AI's resources
	Player_SetResource(player3, RT_Manpower, 1000)
	Player_SetResource(player3, RT_Munition, 100)
	Player_SetResource(player3, RT_Fuel, 100)
	
	-- tell AI to go after strongest threat instead of the weakest
	AI_DoString( player3, "s_personality.attack_prefer_threat = true" )
	AI_DoString( player3, "s_personality.defend_prefer_threat = true" )

	-- tell AI not to "defend" territories outside of the ring around its base
	AI_EnableComponent(player3, false, COMPONENT_ForwardDefending)
	
	-- disable use of comapny commander menu and abilities
	AI_DoString( player3, "s_commandtree_enabled = false" )
	AI_DoString( player3, "s_playerabilities_enabled = false" )
	
	AI_EnableComponent(player3, false, COMPONENT_Attacking)
	
	]]

end



function Oosterbeek_Difficulty()

	-- get the difficulty
	g_difficulty = Game_GetSPDifficulty()  -- set a global difficulty variable
	print("********* DIFFICULTY: "..g_difficulty)

	-- set health bonus for player 1
--~ 	Setup_Difficulty(player1, g_difficulty) -- pass the player and difficulty global variable into the Set Health function
--~ 	Setup_Difficulty(player2, g_difficulty) -- do it for each player that you have defined

	--[[ left as an example 
	
	t_difficulty = {
		base_def_spawn 			= Util_DifVar( {2*60, 1.5*60, 1*60, 0.75*60} ),			-- amount of time required before spawning base defense soldiers
		base_def_squad_num		= Util_DifVar( {1, 1, 2, 3} ),							-- number of squads to spawn for the base defense
		sniper_vulnerability 	= Util_DifVar( {2.5, 2, 1.5, 1} ),						-- the vulnerability factor on the snipers
		sniper_number			= Util_DifVar( {1, 2, 2, 3} ),							-- number of snipers to spawn
		sniper_wpn_cooldown		= Util_DifVar( {2, 1.5, 1, 1} ),						-- weapon cooldown time for the snipers
		stronghold_attack_num	= Util_DifVar( {1, 1, 2, 2} ),							-- number of squads to spawn from the guard tower to spawn and attack the player on alert
		aa_def_sbps				= Util_DifVar( {SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.GRENADIER, SBP.AXIS.STORMTROOPER, SBP.AXIS.KNIGHTSCROSS} ), -- types of squads to defend the AA Guns
	}

	]]
	mod_boat = 0.2
	mod_xp = 0.3
end


-------------------------------------------------------------------------

-- MISSION Preset 

-------------------------------------------------------------------------

function Oosterbeek_MissionPreset()

 -- 	UI_ForceCommanderTreeChoice(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE)
--~  	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.ELITE.SCORCHED_EARTH, ITEM_UNLOCKED)
--~ 	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.ELITE.TANK_DESTROYER, ITEM_UNLOCKED)
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE, ITEM_LOCKED)
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_00)
 	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_01)
 	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_02)
 	
 	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_10)
 	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_11)
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_12)
	
	--a table for random units
	
	nislet_DestroyBridge = {
		{camPos = eg_blg_Bridge, waitType = NISLET_TIME, waitValue = 40},

	}
	EGroup_Kill(eg_blg_Bridge)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_Heights, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_A1, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_A2, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_A3, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_B1, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_B2, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_B3, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_C1, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_C2, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_C3, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_C4, player2)
	
	EGroup_InstantCaptureStrategicPoint(eg_pnt_D1, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_D2, player1)
	--Entity_SetStrategicPointNeutral(EGroup_GetSpawnedEntityAt(eg_pnt_D2, 1))
	EGroup_InstantCaptureStrategicPoint(eg_pnt_D3, player2)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_D4, player2)
	
	EGroup_InstantCaptureStrategicPoint(eg_pnt_R1, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_R2, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_R3, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_R4, player1)
	EGroup_InstantCaptureStrategicPoint(eg_pnt_Oosterbeek, player2)
	
	FOW_RevealArea(Marker_GetPosition(mkr_Fow1), 50, -1)
	FOW_RevealArea(Marker_GetPosition(mkr_Fow2), 50, -1)
	FOW_RevealArea(Marker_GetPosition(mkr_Fow3), 50, -1)
	FOW_RevealArea(Marker_GetPosition(mkr_Fow4), 50, -1)
	FOW_RevealArea(Marker_GetPosition(mkr_Fow5), 50, -1)
	FOW_RevealArea(Marker_GetPosition(mkr_Fow6), 50, -1)
	FOW_RevealArea(Marker_GetPosition(mkr_Fow7), 50, -1)
	v_Strafing = 1
	EGroup_InstantRevertOccupiedBuilding(eg_blg_Ally1)
	EGroup_InstantRevertOccupiedBuilding(eg_blg_Ally2)
	EGroup_InstantRevertOccupiedBuilding(eg_blg_Ally3)
	EGroup_InstantRevertOccupiedBuilding(eg_blg_Ally4)
	EGroup_InstantRevertOccupiedBuilding(eg_blg_Ally5)
	
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.CANADIAN_ARTILLERY)
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.CANADIAN_ARTILLERY_00)
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.CANADIAN_ARTILLERY_01)
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.CANADIAN_ARTILLERY_10)
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.CANADIAN_ARTILLERY_11)
	Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.CW.CANADIAN_ARTILLERY_12)

	eg_blg_baseAll = EGroup_CreateIfNotFound("eg_blg_baseAll")
	eg_blg_base1 = EGroup_CreateIfNotFound("eg_blg_base1")
	eg_blg_base2 = EGroup_CreateIfNotFound("eg_blg_base2")
	eg_blg_base3 = EGroup_CreateIfNotFound("eg_blg_base3")
	eg_blg_base4 = EGroup_CreateIfNotFound("eg_blg_base4")

	sg_AxisBaseAll = SGroup_CreateIfNotFound("sg_AxisBaseAll")
	
	Player_GetAllEntitiesNearMarker(player1, eg_blg_baseAll, mkr_base3, 50)
	EGroup_Filter(eg_blg_baseAll, {EBP.ELITE.KAMPFGRUPPE, EBP.ELITE.LOGISTIK, EBP.ELITE.PANZER_ARTILLERIE, EBP.ELITE.PANZERJAGER}, FILTER_KEEP)
	EGroup_DestroyAllEntities(eg_blg_baseAll)
	
	Player_GetAllSquadsNearMarker(player1, sg_AxisBaseAll, World_GetTerritorySectorID(EGroup_GetPosition(eg_HQ)))
	SGroup_Filter(sg_AxisBaseAll, {SBP.ELITE.FLAK_38}, FILTER_KEEP) 
	
	SGroup_DestroyAllSquads(sg_AxisBaseAll)
	
	Util_CreateEntities(player1, eg_blg_base1, EBP.ELITE.KAMPFGRUPPE, mkr_base1, 1)
	Util_CreateEntities(player1, eg_blg_base2, EBP.ELITE.LOGISTIK, mkr_base2, 1)
	Util_CreateEntities(player1, eg_blg_base2, EBP.ELITE.PANZER_ARTILLERIE, mkr_base3, 1)
	Util_CreateEntities(player1, eg_blg_base2, EBP.ELITE.PANZERJAGER, mkr_base4, 1)

	
--~ eg_Raft1 = EGroup_CreateIfNotFound("eg_Raft1")
--~ sg_Raft1 = SGroup_CreateIfNotFound("sg_Raft1")


--~ Util_SpawnRaft(player2, eg_Raft1, sg_Raft1, SBP.CW.COMMANDOS, mkr_RaftSpawn1, mkr_RaftLanding1 ) 
--~ Util_SpawnRaft(player2, eg_Raft1, sg_Raft1, SBP.CW.COMMANDOS, mkr_ATGunAlpha1, mkr_ATGunAlpha3) 
end
-------------------------------------------------------------------------

-- MISSION START 

-------------------------------------------------------------------------

function Oosterbeek_NISStart()
--~ 	Player_GetAll(player2)
--~ 	SGroup_DestroyAllSquads(sg_allsquads)
--~ 	Player_GetAll(player1)
--~ 	SGroup_DestroyAllSquads(sg_allsquads)
	eg_SupplyDrops1 = EGroup_CreateIfNotFound("eg_SupplyDrops1")
	eg_SupplyDrops2 = EGroup_CreateIfNotFound("eg_SupplyDrops2")
	eg_SupplyDrops3 = EGroup_CreateIfNotFound("eg_SupplyDrops3")
	Player_GetAllEntitiesNearMarker(player2, eg_SupplyDrops1, mkr_Supply1, 20)
	EGroup_Filter(eg_SupplyDrops1, {EBP.PICKUP.AIRDROP_FUEL, EBP.PICKUP.AIRDROP_MUNITIONS}, FILTER_KEEP) 
	Player_GetAllEntitiesNearMarker(player2, eg_SupplyDrops2, mkr_Supply2, 20)
	EGroup_Filter(eg_SupplyDrops2, {EBP.PICKUP.AIRDROP_FUEL, EBP.PICKUP.AIRDROP_MUNITIONS}, FILTER_KEEP) 
	Player_GetAllEntitiesNearMarker(player2, eg_SupplyDrops3, mkr_Supply3, 20)
	EGroup_Filter(eg_SupplyDrops3, {EBP.PICKUP.AIRDROP_FUEL, EBP.PICKUP.AIRDROP_MUNITIONS}, FILTER_KEEP) 
	
	
	EGroup_DestroyAllEntities(eg_SupplyDrops1)
	EGroup_DestroyAllEntities(eg_SupplyDrops2)
	EGroup_DestroyAllEntities(eg_SupplyDrops3)
	
	eg_Emplacement1 = EGroup_CreateIfNotFound("eg_Emplacement1")
	eg_Emplacement2 = EGroup_CreateIfNotFound("eg_Emplacement2")
	eg_Emplacement3 = EGroup_CreateIfNotFound("eg_Emplacement3")
	eg_Emplacement4 = EGroup_CreateIfNotFound("eg_Emplacement4")
	eg_Emplacement5 = EGroup_CreateIfNotFound("eg_Emplacement5")
	eg_Emplacement6 = EGroup_CreateIfNotFound("eg_Emplacement6")
	Util_CreateEntities(player2, eg_Emplacement1, EBP.CW.BOFORS_NEST, mkr_Emplacement1, 1)
	Util_CreateEntities(player2, eg_Emplacement2, EBP.CW.BOFORS_NEST, mkr_Emplacement2, 1)
	Util_CreateEntities(player2, eg_Emplacement3, EBP.CW.BOFORS_NEST, mkr_Emplacement3, 1)
	Util_CreateEntities(player2, eg_Emplacement4, EBP.CW.MORTAR_NEST, mkr_Emplacement4, 1)
	Util_CreateEntities(player2, eg_Emplacement5, EBP.CW.MORTAR_NEST, mkr_Emplacement5, 1)
	Util_CreateEntities(player2, eg_Emplacement6, EBP.CW.MORTAR_NEST, mkr_Emplacement6, 1)
	
	Util_StartNIS(NIS_OPENING_BLEND, Oosterbeek_MissionStart)
	Rule_AddOneShot(Misc_GrabTerritory, 1)
	Rule_AddInterval(Misc_DestroyAllSquads, 1)
	
	
	Rule_AddOneShot(PlayerGamma_Init, 1)
	--Rule_AddOneShot(PlayerDelta_Init, 1)
	Rule_AddOneShot(BuildingAlpha_Init, 1)
	
	Rule_AddOneShot(DontEnterAlpha_Init, 1)
	Camera_FocusOnPosition(Marker_GetPosition(mkr_Hill), false)
	
	if EGroup_IsEmpty(eg_blg_center) == false then
		sg_AxisBase = SGroup_CreateIfNotFound("sg_AxisBase")
		Util_CreateSquads(player1, sg_AxisBase, SBP.ELITE.FALLSCHIRMJAGER, eg_blg_center)
		Cmd_Garrison(sg_AxisBase, eg_blg_center)
		
		Cmd_InstantUpgrade(eg_blg_center, UPG.ELITE.CONVERT_AMBIENT_BUILDING)
	end
	
	Rule_AddOneShot(StillAlpha_Init, 1)
	Rule_AddOneShot(ATGunAlpha_Init, 1)
	Rule_RemoveMe()

end

function Oosterbeek_MissionStart()

	if Event_IsAnyRunning() == false then
		Camera_Unclamp()
		Misc_RemoveCommandRestriction()
		g_switch = 1
		EGroup_Hide(eg_pnt_Oosterbeek, true)
		eg_pnt_Oosterbeek2 = EGroup_CreateIfNotFound("eg_pnt_Oosterbeek2")
		pointpos = EGroup_GetPosition(eg_pnt_Oosterbeek)
		Util_CreateEntities(player2, eg_pnt_Oosterbeek2, EBP.STRAT_POINT.VICTORY_SP, pointpos, 1)
		EGroup_InstantCaptureStrategicPoint(eg_pnt_Oosterbeek2, player2)
		Rule_AddOneShot(PlayerBeta_Init, 0.1)
		Rule_AddOneShot(BeginRaftAlpha_Init, 0.1)
		--player spawn
		Objective_Start(OBJ_PreventCapture)
		Timer_Start("Timer_Raft", 120)
		Rule_AddInterval(Timer_Raft, 3)
		--enemy spawn
		Rule_RemoveMe()
		Rule_AddOneShot(UnrevealVP, 1)
		Rule_AddInterval(PointSwitch, 1)
		UI_CreateMinimapBlip(eg_blg_center, 10, BT_DefendHerePing)
		Player_SetAbilityAvailability(player1, ABILITY.SP.FALLSHIRMJAGER_BUILDINGONLY, ITEM_REMOVED)
	end
end
function UnrevealVP()
	FOW_UnRevealAll()
end
function PointSwitch()
	if g_switch == 1 and Player_OwnsEGroup(player2, eg_pnt_Oosterbeek2) then 
		EGroup_InstantCaptureStrategicPoint(eg_pnt_Oosterbeek, player2)
		g_switch = 2
	elseif g_switch == 2 and Player_OwnsEGroup(player1, eg_pnt_Oosterbeek2) then 
		EGroup_InstantCaptureStrategicPoint(eg_pnt_Oosterbeek, player1)
		g_switch = 1
	end
end


function Timer_Raft()
	if Timer_GetRemaining("Timer_Raft") == 0 and g_ready == 1 then 
		Rule_AddInterval(PreventCapture_WinCheck, 1)
		Rule_AddInterval(PreventCapture_WinCheck2, 30)
		Objective_StartTimer(OBJ_PreventCapture, COUNT_DOWN, g_GameTime, 60) 
		Rule_RemoveMe()
	end
end
-------------------------------------------------------------------------
-- Objective Prevent the Allies from conneting their territory
-------------------------------------------------------------------------
--The player will need to prevent the allies from connecting to oosterbeek for  X amount of minutes
--The Panther will back away if its health hits below a certain threashold
-------------------------------------------------------------------------

function Initialize_OBJ_PreventCapture()

	OBJ_PreventCapture = {
		
		SetupUI = function() 
			
		end,
		
		OnStart = function()
		Sound_PlayMusic("Music/SP/OMG/preparation/OMG/They're_out_there.bsc",2,0)
			
			g_vis_A1 = 1
			g_vis_B1 = 1
			g_vis_C1 = 1
			eg_Vis1 = EGroup_CreateIfNotFound("eg_Vis1")
			eg_Vis2 = EGroup_CreateIfNotFound("eg_Vis2")
			eg_Vis3 = EGroup_CreateIfNotFound("eg_Vis3")
		end,
		
		OnComplete = function()
			-- tell the player they did good
			
		end,

		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1489100,
		Description = 1489110,
		Type = OT_Primary,
		TitleEnd = 1489104,
		
	}
	
	-- Register Objective
	Objective_Register(OBJ_PreventCapture)
	-- Initialize Data
	g_GameTime = 1200
	PreventCapture_Init()
	
end

function PreventCapture_Init()
	-- the timer of the counterdown	

	-- the threshold is the current time left on the PreventCapture timer.  
	-- functions will fire in a given time		
	

	timertable1 =
	{
		{
			threshold = g_GameTime, --15:00 --------------------------------------------------------------------------start time------------------------------------
			exec = function()
				
				RaftAlpha_Init()
				Util_AutoAmbient(t_raftwaveA1)
				Util_AutoIntel(t_Prevent_Objective1)
				--UI_CreateMinimapBlip(mkr_Threat1, 10, BT_DefendHerePing )
				Objective_UpdateText(OBJ_PreventCapture, 1489101, nil)
				OBJ_PreventCapture.Threat1 = Objective_AddUIElements(OBJ_PreventCapture, eg_pnt_C1, true, 1489121, true, 2.3)
				
			end
		},
		{
			threshold = g_GameTime - 80, --14:40
			exec = function()
				WaveRaftAlpha_Init()
				Util_AutoAmbient(t_raftwaveA2)
				
			end
		},
		{
			threshold = g_GameTime - 120, --14:40
			exec = function()
				Util_AutoIntel(t_Prevent_Reminder1)
			end
		},
		{
			threshold = g_GameTime - 200, --14:40
			exec = function()
				Rule_Remove(RaftAlpha_Respawn)
				
			end
		},
		{
			threshold = g_GameTime - 230, --14:40
			exec = function()
				Objective_RemoveUIElements(OBJ_PreventCapture, OBJ_PreventCapture.Threat1)
			end
		},
		{
			threshold = g_GameTime - 240, -------------------------------------------------------------Coming from B Oosterbeek------------------------------
			exec = function()
				Rule_AddInterval(Rule_Chatter_Oosterbeek, 30)
				BrenAlpha_Init()
				GarrisonBeta_Init()
				BazookaAlpha_Init()
				UI_CreateMinimapBlip(mkr_Threat2, 10, BT_DefendHerePing )
			end
		},
		{
			threshold = g_GameTime - 250, --14:40
			exec = function()
				Util_AutoIntel(t_Prevent_Objective2)
				OBJ_PreventCapture.Threat2 = Objective_AddUIElements(OBJ_PreventCapture, mkr_Threat2, true, false, false)
			end
		},
		{
			threshold = g_GameTime - 280, --14:40
			exec = function()
				AirborneAlpha_Init()
				GarrisonAlpha_Init()
			end
		},
		{
			threshold = g_GameTime - 420, 
			exec = function()				
				Sound_PlayMusic("Music/SP/OMG/trepidation/OMG/dusk_of_the_fatherland.bsc",2,0)
				Rule_Remove(Rule_Chatter_Oosterbeek)
				Rule_Remove(BazookaAlpha_Respawn)
				Rule_Remove(BrenAlpha_Respawn)
				--Rule_Remove(AirborneAlpha_Respawn)
				Rule_Remove(GarrisonAlpha_Respawn)
				Rule_Remove(GarrisonBeta_Respawn)
			end
		},
		{	
			threshold = g_GameTime - 470, 
			exec = function()
				Objective_RemoveUIElements(OBJ_PreventCapture, OBJ_PreventCapture.Threat2)
			end
		},
		{
			threshold = g_GameTime - 480, -------------------------------------------------------------Coming from C Beachhead------------------------------
			exec = function()
				
				CrossingAlpha_Init()
				--UI_CreateMinimapBlip(mkr_Threat1, 5, BT_DefendHerePing )
				
			end
		},
		{
			threshold = g_GameTime - 540, 
			exec = function()
				RaftBeta_Init()
				UI_CreateMinimapBlip(mkr_Threat3, 5, BT_DefendHerePing )
				Util_AutoAmbient(t_raftwaveB1)
			end
		},
		{	
			threshold = g_GameTime - 550, 
			exec = function()
				Util_AutoIntel(t_Prevent_Objective3)
				OBJ_PreventCapture.Threat3 = Objective_AddUIElements(OBJ_PreventCapture, eg_pnt_B1, true, 1489123, true, 2.3)
			end
		},
		{
			threshold = g_GameTime - 580, 
			exec = function()
				WaveRaftBeta_Init()
				Util_AutoAmbient(t_raftwaveB2)
				EngineerBuilding_Init()
			end
		},
		{
			threshold = g_GameTime - 595, 
			exec = function()
				Rule_AddInterval(Medal_DelayGrant, 1)
				Util_AutoAmbient(t_howitzer)
			end
		},
		{
			threshold = g_GameTime - 660, 
			exec = function()
				Rule_Remove(RaftBeta_Respawn)
			end
		},
		{	
			threshold = g_GameTime - 670, 
			exec = function()
				Objective_RemoveUIElements(OBJ_PreventCapture, OBJ_PreventCapture.Threat3)
			end
		},
		{
			threshold = g_GameTime - 720, -------------------------------------------------------------Coming from D OOsterbeek------------------------------
			exec = function()
				
				
				--BrenAlpha_Init()				
				GarrisonGamma_Init()
				TetrarchAlpha_Init()
				Rule_AddInterval(Rule_Chatter_Oosterbeek, 30)
				UI_CreateMinimapBlip(mkr_Threat4, 10, BT_DefendHerePing )
			end
		},
		{	
			threshold = g_GameTime - 730, 
			exec = function()
				Util_AutoIntel(t_Prevent_Objective4)
				OBJ_PreventCapture.Threat4 = Objective_AddUIElements(OBJ_PreventCapture, mkr_Threat4, true, false, false)
			end
		},
		{
			threshold = g_GameTime - 760, 
			exec = function()
				--AirborneBeta_Init()
				MortarAlpha_Init()
				CrocAlpha_Init()

			end
		},
		{
			threshold = g_GameTime - 860, 
			exec = function()
				GrenadeAlpha_Init()
			end
		},
		
		{
			threshold = g_GameTime - 900, 
			exec = function()
				Loc_FormatText(1489127, Loc_FormatTime(300, false, true))
				EventCue_Create(CUE.ATTACKED, Loc_FormatText(1489127, Loc_FormatTime(300, false, true)), 1489127, nil)
				
				Rule_Remove(Rule_Chatter_Oosterbeek)
				
				
				

				
				
				Rule_Remove(BazookaAlpha_Respawn)
				Rule_Remove(TetrarchAlpha_Respawn)
				Rule_Remove(CrocAlpha_Respawn)
				Rule_Remove(MortarAlpha_Respawn)
				Rule_Remove(AirborneAlpha_Respawn)
				Rule_Remove(GarrisonAlpha_Respawn)
				Rule_Remove(GarrisonBeta_Respawn)
				Rule_Remove(GarrisonGamma_Respawn)
				Rule_Remove(GrenadeAlpha_Respawn)
				Rule_Remove(BrenAlpha_Respawn)
				
				
				Rule_Remove(BrenAlpha_Kickoff)
				Rule_Remove(AirborneAlpha_Kickoff)
				Rule_Remove(MortarAlpha_Kickoff)
				Rule_Remove(BazookaAlpha_Kickoff)
				Rule_Remove(GarrisonAlpha_Kickoff)
				Rule_Remove(GarrisonBeta_Kickoff)
				Rule_Remove(GarrisonGamma_Kickoff)				
				Rule_Remove(GrenadeAlpha_Kickoff)
			end
		},
		{	
			threshold = g_GameTime - 950, 
			exec = function()
				Sound_PlayMusic("Music/SP/OMG/motivation/OMG/the_blitz_.bsc",2,0)
				Objective_RemoveUIElements(OBJ_PreventCapture, OBJ_PreventCapture.Threat4)
			end
		},
		{
			threshold = g_GameTime - 960, -------------------------------------------------------------Coming from E Beachhead------------------------------
			exec = function()
					
				RaftGamma_Init()
				Util_AutoAmbient(t_raftwaveC1)
				--PropertyAlpha_Init()	
				UI_CreateMinimapBlip(mkr_Threat5, 10, BT_CombatPing)				
			end
		},
		{	
			threshold = g_GameTime - 970, 
			exec = function()
				Util_AutoIntel(t_Prevent_Objective5)
				OBJ_PreventCapture.Threat5 = Objective_AddUIElements(OBJ_PreventCapture, eg_pnt_A1, true, 1489125, true, 2.3)
			end
		},
		
		{
			threshold = g_GameTime - 990, 
			exec = function()
				WaveRaftGamma_Init()
				Util_AutoAmbient(t_raftwaveC2)
				
			end
		},
		{
			threshold = g_GameTime - 1020, 
			exec = function()
				Rule_AddInterval(RaftBeta_Respawn, 1)
				WaveRaftBeta_Init()
				UI_CreateMinimapBlip(mkr_Threat3, 10, BT_CombatPing)
				Objective_RemoveUIElements(OBJ_PreventCapture, OBJ_PreventCapture.Threat5)
				Game_LoadAtmosphere("data:art/scenarios/presets/atmosphere/CXP2_OOSTERBEEK_PREDAWN_00.aps", 120)
			end
		},
		{
			threshold = g_GameTime - 1050, 
			exec = function()	
				
				Rule_AddInterval(RaftAlpha_Respawn, 1)
				WaveRaftAlpha_Init()
				UI_CreateMinimapBlip(mkr_Threat1, 10, BT_CombatPing)
				Util_AutoIntel(t_Prevent_Reminder5)
			end
		},
		{
			threshold = g_GameTime - 1140, 
			exec = function()	
				EventCue_Create(CUE.ATTACKED, Loc_FormatText(1489126, Loc_FormatTime(60, false, true)), 1489126, nil)
				
			end
		},
		

		{
			threshold = g_GameTime - 1200, -------------------------------------------------------------COMPLETE------------------------------
			exec = function()
--~ 				Rule_Remove(RaftAlpha_Kickoff)
--~ 				Rule_Remove(RaftBeta_Kickoff)
--~ 				Rule_Remove(RaftGamma_Kickoff)
				--Rule_Remove(PropertyAlpha_Kickoff)
				PlayerZeta_Init()
				Rule_Remove(RaftAlpha_Respawn)
				Rule_Remove(RaftBeta_Respawn)
				Rule_Remove(RaftGamma_Respawn)
				Rule_Remove(PropertyAlpha_Respawn)
				
--~ 				Rule_Remove(WaveRaftAlpha_Kickoff)
--~ 				Rule_Remove(WaveRaftBeta_Kickoff)
--~ 				Rule_Remove(WaveRaftGamma_Kickoff)
--~ 				Rule_Remove(CrossingAlpha_Kickoff)
--~ 				Rule_Remove(DontEnterAlpha_Kickoff)
				
				FOW_RevealArea(Marker_GetPosition(mkr_Fow8), 60, -1)
				FOW_RevealArea(Marker_GetPosition(mkr_Fow9), 60, -1)
				FOW_RevealArea(Marker_GetPosition(mkr_Fow10), 60, -1)	
				Rule_AddOneShot(Return_ToOosterbeek, 1)
				Rule_AddOneShot(Return_ToHill, 1)
				Rule_Remove(PreventCapture_WinCheck2)
				Sound_StopMusic(7,0)
				
			end
		},
	}

end
function Return_ToHill()
	for k, this in pairs(t_RaftAlpha) do
		this.phase = 6
	end
	for k, this in pairs(t_WaveRaftAlpha) do
		this.phase = 6	
	end
	for k, this in pairs(t_RaftBeta) do
		this.phase = 6
	end
	for k, this in pairs(t_WaveRaftBeta) do
		this.phase = 6
	end
	for k, this in pairs(t_RaftGamma) do
		this.phase = 6
	end
	for k, this in pairs(t_WaveRaftGamma) do
		this.phase = 6
	end
end
function Return_ToOosterbeek()
	for k, this in pairs(t_BrenAlpha) do
		if SGroup_Count(this.inf) >  0 then 
			Cmd_Move(this.inf, mkr_StillAlphaLast4, nil, nil, mkr_RaftLaunch10)
		end
	end
	for k, this in pairs(t_AirborneAlpha) do
		if SGroup_Count(this.sgroup) >  0 then 
			Cmd_Move(this.sgroup, mkr_StillAlphaLast3, nil, nil, mkr_RaftLaunch10)
		end
	end
	for k, this in pairs(t_BazookaAlpha) do
		if SGroup_Count(this.sgroup) >  0 then 
			Cmd_Move(this.sgroup, mkr_StillAlphaLast3, nil, nil, mkr_RaftLaunch10)
		end
	end
	for k, this in pairs(t_MortarAlpha) do
		if SGroup_Count(this.sgroup) >  0 then 
			Cmd_Move(this.sgroup, mkr_StillAlphaLast2, nil, nil, mkr_RaftLaunch10)
		end
	end
	for k, this in pairs(t_GarrisonAlpha) do
		if SGroup_Count(this.sgroup) >  0 then 
			Cmd_Move(this.sgroup, mkr_StillAlphaLast4, nil, nil, mkr_RaftLaunch10)
		end
	end
	for k, this in pairs(t_GarrisonBeta) do
		if SGroup_Count(this.sgroup) >  0 then 
			Cmd_Move(this.sgroup, mkr_StillAlphaLast2, nil, nil, mkr_RaftLaunch10)
		end
	end
	for k, this in pairs(t_GarrisonGamma) do
		if SGroup_Count(this.sgroup) >  0 then 
			Cmd_Move(this.sgroup, mkr_StillAlphaLast5, nil, nil, mkr_RaftLaunch10)
		end
	end
	for k, this in pairs(t_GrenadeAlpha) do
		if SGroup_Count(this.sgroup) >  0 then 
			Cmd_Move(this.sgroup, mkr_StillAlpha1, nil, nil, mkr_RaftLaunch10)
		end
	end
end

function Rule_Chatter_Oosterbeek()
	if table.getn(t_groundattack) >  0 and Event_IsAnyRunning() == false then
		if SGroup_IsEmpty( sg_AllyAll ) == false and SGroup_IsDoingAttack(sg_AllyAll, ANY, 1) then
			i = World_GetRand(1, table.getn(t_groundattack))
			Util_AutoAmbient(t_groundattack[i])
			table.remove(t_groundattack, i)
		end

	elseif table.getn(t_groundattack) <=  0 then
		Rule_RemoveMe()
	end
end

function PreventCapture_Preset()
	

end

-- example of how to finish an Obj
function PreventCapture_WinCheck()

		
	local timeleft = Objective_GetTimerSeconds(OBJ_PreventCapture)
	for k, v in pairs(timertable1) do
		if v.executed == nil and v.threshold >= timeleft then
			v.executed = true
			v.exec()
			break
		end
	end	

	if Objective_GetTimerSeconds(OBJ_PreventCapture) > 0 then 
		if Player_OwnsEGroup(player2, eg_pnt_A1) and g_vis_A1 == 1 then 
			Util_CreateEntities(player2, eg_Vis1, EBP.STRAT_POINT.CONTROL_STRUCTURE_SP, mkr_Vis1, 1)
			World_SetDesignerSupply(Marker_GetPosition(mkr_Vis1), true)
			g_vis_A1 = 2
		elseif Player_OwnsEGroup(player2, eg_pnt_A1) == false and g_vis_A1 == 2 then 
			EGroup_DestroyAllEntities(eg_Vis1)
			World_SetDesignerSupply(Marker_GetPosition(mkr_Vis1), false)
			g_vis_A1 = 1
		end
		if Player_OwnsEGroup(player2, eg_pnt_B1) and g_vis_B1 == 1 then 
			Util_CreateEntities(player2, eg_Vis2, EBP.STRAT_POINT.CONTROL_STRUCTURE_SP, mkr_Vis2, 1)
			World_SetDesignerSupply(Marker_GetPosition(mkr_Vis2), true)
			g_vis_B1 = 2
		elseif Player_OwnsEGroup(player2, eg_pnt_B1) == false and g_vis_B1 == 2 then 
			EGroup_DestroyAllEntities(eg_Vis2)
			World_SetDesignerSupply(Marker_GetPosition(mkr_Vis2), false)
			g_vis_B1 = 1
		end
		
		if Player_OwnsEGroup(player2, eg_pnt_C1) and g_vis_C1 == 1 then 
			Util_CreateEntities(player2, eg_Vis3, EBP.STRAT_POINT.CONTROL_STRUCTURE_SP, mkr_Vis3, 1)
			World_SetDesignerSupply(Marker_GetPosition(mkr_Vis3), true)
			g_vis_C1 = 2
		elseif Player_OwnsEGroup(player2, eg_pnt_C1) == false and g_vis_C1 == 2 then 
			EGroup_DestroyAllEntities(eg_Vis3)
			World_SetDesignerSupply(Marker_GetPosition(mkr_Vis3), false)
			g_vis_C1 = 1
		end
		
		
		if EGroup_Count(eg_Vis1) > 0 then  
			if World_TeamTerritoryPointsConnected(Player_GetTeam(player2), EGroup_GetPosition(eg_pnt_Ally),  EGroup_GetPosition(eg_Vis1)) == true then 
				Objective_Fail(OBJ_PreventCapture)
				Game_EndSP(false)
			end

		end
				
		if EGroup_Count(eg_Vis2) > 0 then  
			if World_TeamTerritoryPointsConnected(Player_GetTeam(player2), EGroup_GetPosition(eg_pnt_Ally),  EGroup_GetPosition(eg_Vis2)) == true then 
				Objective_Fail(OBJ_PreventCapture)
				Game_EndSP(false)
			end

		end
				
		if EGroup_Count(eg_Vis3) > 0 then  
			if World_TeamTerritoryPointsConnected(Player_GetTeam(player2), EGroup_GetPosition(eg_pnt_Ally),  EGroup_GetPosition(eg_Vis3)) == true then 
				Objective_Fail(OBJ_PreventCapture)
				Game_EndSP(false)
			end
		end

	
	
	elseif Objective_GetTimerSeconds(OBJ_PreventCapture) == 0 then 
		if World_TeamTerritoryPointsConnected(Player_GetTeam(player2), EGroup_GetPosition(eg_pnt_Ally),  EGroup_GetPosition(eg_pnt_StrongHold1)) == false then 
			Objective_Complete(OBJ_PreventCapture)
			Rule_RemoveMe()
			Rule_AddOneShot(DestroyLandings_DelayGrant, 3)
		elseif World_TeamTerritoryPointsConnected(Player_GetTeam(player2), EGroup_GetPosition(eg_pnt_Ally),  EGroup_GetPosition(eg_pnt_StrongHold1)) == true then
			Objective_Fail(OBJ_PreventCapture)
			Rule_RemoveMe()
			Game_EndSP(false)
		end
	end
end
function PreventCapture_WinCheck2()
	if EGroup_Count(eg_Vis1) > 0 then  
		local pos1 = Util_GetPosition(eg_pnt_Ally)
		local pos2 = Util_GetPosition(eg_Vis1)
		local sector1 = World_GetTerritorySectorID(pos1)
		local sector2 = World_GetTerritorySectorID(pos2)
		
		if not World_TeamTerritoryPointsConnected(Player_GetTeam(player1), pos1, pos2) then
			local tgap = {}
			if World_GetTeamTerritoryGaps(sector1, sector2, tgap) then
				for i=1, table.getn(tgap) do

					for j=1, table.getn(tgap[i]) do

						local sectorid = tgap[i][j]

						local blipid = UI_CreateMinimapBlip(World_GetTerritorySectorPosition(sectorid), 30, BT_ObjectivePrimary )
						EventCue_Create(CUE.ATTACKED, 1489128, 1489128, World_GetTerritorySectorPosition(sectorid))

						Util_StartIntel(EVENTS.CapturePoint)
					end

				end
			end
		end

	end
			
	if EGroup_Count(eg_Vis2) > 0 then  
		local pos1 = Util_GetPosition(eg_pnt_Ally)
		local pos2 = Util_GetPosition(eg_Vis2)
		local sector1 = World_GetTerritorySectorID(pos1)
		local sector2 = World_GetTerritorySectorID(pos2)
		
		if not World_TeamTerritoryPointsConnected(Player_GetTeam(player1), pos1, pos2) then
			local tgap = {}
			if World_GetTeamTerritoryGaps(sector1, sector2, tgap) then
				for i=1, table.getn(tgap) do

					for j=1, table.getn(tgap[i]) do

						local sectorid = tgap[i][j]

						local blipid = UI_CreateMinimapBlip(World_GetTerritorySectorPosition(sectorid), 30, BT_ObjectivePrimary )
						EventCue_Create(CUE.ATTACKED, 1489128, 1489128, World_GetTerritorySectorPosition(sectorid))
						

					end

				end
			end
		end

	end
			
	if EGroup_Count(eg_Vis3) > 0 then  
		local pos1 = Util_GetPosition(eg_pnt_Ally)
		local pos2 = Util_GetPosition(eg_Vis3)
		local sector1 = World_GetTerritorySectorID(pos1)
		local sector2 = World_GetTerritorySectorID(pos2)
		
		if not World_TeamTerritoryPointsConnected(Player_GetTeam(player1), pos1, pos2) then
			local tgap = {}
			if World_GetTeamTerritoryGaps(sector1, sector2, tgap) then
				for i=1, table.getn(tgap) do

					for j=1, table.getn(tgap[i]) do

						local sectorid = tgap[i][j]

						local blipid = UI_CreateMinimapBlip(World_GetTerritorySectorPosition(sectorid), 30, BT_ObjectivePrimary )
						EventCue_Create(CUE.ATTACKED, 1489128, 1489128, World_GetTerritorySectorPosition(sectorid))
						

					end

				end
			end
		end

	end

end
function Delay_PreventCapture()
	Objective_Start(OBJ_PreventCapture)

end


-------------------------------------------------------------------------
-- Destroy the Commonwealth landing zones
-------------------------------------------------------------------------

-------------------------------------------------------------------------
function Initialize_OBJ_DestroyLandings()
	OBJ_DestroyLandings = {
		
		SetupUI = function() 
			
			OBJ_DestroyLandings.mapElementID = Objective_AddUIElements(OBJ_DestroyLandings, mkr_AllyOosterbeek2, true, 1489102, true)
			--Objective_SetAlwaysShowDetails(OBJ_DestroyLandings, false, true, true)
			
		end,
		
		OnStart = function()
			Sound_PlayMusic("Music/SP/OMG/trepidation/OMG/Death_from_above.bsc",2,0)
			Util_AutoIntel(t_Destroy_Objective)
			-- win/lose check
			Rule_AddOneShot(AldricDeath, 1)
			Rule_AddInterval(DestroyLandings_WinCheck, 1)
			Rule_AddInterval(DestroyLandings_WinCheck2, 1)
			sg_AllyAttacker = SGroup_CreateIfNotFound("sg_AllyAttacker")
			Rule_Remove(Misc_GatherEgroup)
			DestroyLandings_Kickoff()
			g_LandingsStarted = 1 
		end,
		OnComplete = function()
			Sound_PlayMusic("Music/SP/OMG/sitreps/OMG/situation_report_1.bsc",2,0)
			-- tell the player they did good
		end,
		
		IsComplete = function()
			
			
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1489102,
		Description = 1489112,
		Type = OT_Primary,
		
		SitRep = {
			Movie = "CXP2_SR_08-02",
			Force = true,
			SpeechTiming =
			{
				{ 1,	ACTOR.CXP2.Aldrich, 1481280},
				{ 3.4,	ACTOR.CXP2.Wolfgang, 1481282},
				{ 9,	ACTOR.CXP2.Wolfgang, 1481284 },
				{ 12,	ACTOR.CXP2.Wolfgang, 1481286 },
				{ 18.6,	ACTOR.CXP2.Voss, 1481288},
				{ 22,	ACTOR.CXP2.Voss, 1481290 },
				{ 28,	ACTOR.CXP2.Voss, 1481292 },
				{ 35,	ACTOR.CXP2.Voss, 1481293 },
			},
		},
	}
	
	-- Register Objective
	Objective_Register(OBJ_DestroyLandings)
	-- Initialize Data
	DestroyLandings_Init()
	
end

function DestroyLandings_Init()
	
	

end

function AldricDeath()
	sg_aldricdeathall = SGroup_CreateIfNotFound("sg_aldricdeathall")
	
	Rule_AddInterval(AldricDeathRepeat, 5)
end
function AldricDeathRepeat()

	-- find any NEW squads not already accounted for...
	Player_GetAll(player1)
	SGroup_RemoveGroup(sg_allsquads, sg_aldricdeathall)
	
	-- add the event rule to the new squads
	Rule_AddSGroupEvent(Rule_SquadKilled, sg_allsquads, GE_SquadKilled)
	
	-- add the new squads to the group so that they don't get counted again
	SGroup_AddGroup(sg_aldricdeathall, sg_allsquads)
	Rule_RemoveMe()
	
end
function Rule_SquadKilled(squad)
	if Event_IsAnyRunning() == false then
		local sbp = Squad_GetBlueprint(squad)
		if sbp == SBP.ELITE.HETZER then 
			Util_AutoIntel(t_endhetzer)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.JAGDPANTHER then 
			Util_AutoIntel(t_endjagdpanther)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.HUMMEL then 
			Util_AutoIntel(t_endhummel)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.WIRBLEWIND then 
			Util_AutoIntel(t_endwirblewind)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.BERGETIGER then	
			Util_AutoIntel(t_endbergtiger)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.PANZER_SUPPORT then 
			Util_AutoIntel(t_endpanzer)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.MARDER then 
			Util_AutoIntel(t_endmarder)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.ARMOURCAR_223 or sbp == SBP.ELITE.ARMOURCAR_221 then 
			Util_AutoIntel(t_endarmorcar)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.HALFTRACK_250 or sbp == SBP.ELITE.HALFTRACK_251 or sbp == SBP.ELITE.HALFTRACK_MORTAR or sbp == SBP.ELITE.HALFTRACK_SNIPER or sbp == SBP.ELITE.HALFTRACK_VAMPIRE then 
			Util_AutoIntel(t_endhalftrack)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)
			Rule_Remove(AldricDeathRepeat)
		elseif sbp == SBP.ELITE.FALLSCHIRMJAGER or sbp == SBP.ELITE.LUFTWAFFE or sbp == SBP.ELITE.PANZERGRENADIER then 
			Util_AutoIntel(t_endinfantry)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)	
			Rule_Remove(AldricDeathRepeat)
		else
			Util_AutoIntel(t_AldricDeath)
			Rule_RemoveSGroupEvent(Rule_SquadKilled, sg_aldricdeathall)	
			Rule_Remove(AldricDeathRepeat)
		end
	end
end


function DestroyLandings_Preset()
	

end

-- Complete when the allied HQ reaches the location. 
function DestroyLandings_FirstIntel()

end

function DestroyLandings_WinCheck()
	--local numSurrender = Stats_UnitSoldierKills(player2, SBP.CW.COMMANDOS)
	
	print(numSurrender)
	if g_oosterbeeksurrender == 1 then 
		Rule_AddOneShot(DestroyLandings_StartNIS, 15)
		Rule_AddOneShot(Alternate_Speech, 1)
 		Rule_RemoveMe()
	else
		--Objective_SetCounter(OBJ_DestroyLandings, numSurrender)
		lastcount = numSurrender
	end
	
	
	if SGroup_Count(t_ATGunAlpha[3].sgroup) == 0 and SGroup_Count(t_ATGunAlpha[4].sgroup) == 0 and SGroup_Count(t_ATGunAlpha[5].sgroup) == 0 and retreat_MG == nil then
		for k, this in pairs(t_StillAlpha) do
			Cmd_Move(this.sgroup, this.depart)
			retreat_MG = 1
		end
	end
	if retreat_MG == 1 then 
		if g_speech1 == nil then 
			Util_AutoIntel(t_CityRetreat)
			g_speech1 = 1
		end
		SGroup_GetLastAttacker(sg_AllyOosterbeek2, sg_AllyAttacker)
		if ((SGroup_ContainsSGroup(sg_AllyAttacker, sg_AxisHeavyTank, ANY) and SGroup_TotalMembersCount(sg_AllyAttacker) > 2) or (Player_OwnsEGroup(player1, eg_pnt_Oosterbeek2) == true)) and g_oosterbeeksurrender == nil then 
			numSurrender = numSurrender + SGroup_TotalMembersCount(sg_AllyOosterbeek2) 
			Cmd_Surrender(sg_AllyOosterbeek2)
			g_oosterbeeksurrender = 1
			retreat_MG = 2
		end
	end
	
end
function Alternate_Speech()
	if numSurrender > 70  then 
		Objective_Complete(OBJ_DestroyLandings)
		Util_AutoNISlet(NISLET_GAME2LETTER,t_Nislet_OosterbeekEnd3) 
		if SGroup_Count(sg_AxisAll) > 0 then 
			Cmd_Stop(sg_AxisAll)
			SGroup_SetAutoTargetting(sg_AxisAll, "hardpoint_01", false)
		end
		Rule_RemoveMe()
	elseif numSurrender  > 29 and numSurrender < 71 then
		Objective_Complete(OBJ_DestroyLandings)
		Util_AutoNISlet(NISLET_GAME2LETTER,t_Nislet_OosterbeekEnd2) 
		if SGroup_Count(sg_AxisAll) > 0 then 
			Cmd_Stop(sg_AxisAll)
			SGroup_SetAutoTargetting(sg_AxisAll, "hardpoint_01", false)
		end
		Rule_RemoveMe()
	elseif numSurrender  < 30 then
		Objective_Complete(OBJ_DestroyLandings)
		Util_AutoNISlet(NISLET_GAME2LETTER,t_Nislet_OosterbeekEnd1) 
		if SGroup_Count(sg_AxisAll) > 0 then 
			Cmd_Stop(sg_AxisAll)
			SGroup_SetAutoTargetting(sg_AxisAll, "hardpoint_01", false)
		end
		Rule_RemoveMe()
	end
end
function DestroyLandings_StartNIS()
	SGroup_DestroyAllSquads(sg_AllyAll)
	SGroup_DestroyAllSquads(sg_AxisAll)
	Util_StartNIS(EVENTS.NIS02)
end




-- Complete when the allied HQ reaches the location. 
function DestroyLandings_WinCheck2()
	for k, this in pairs(t_CrossingAlpha) do
		if SGroup_Count(this.sgroup) > 0 then
			if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 2) == false and retreat_CrossingAlpha == nil then 
				Cmd_Move(this.sgroup, this.last) 
			else
				retreat_CrossingAlpha = 1
			end
		else 
			retreat_CrossingAlpha = 1
		end
	end
--~ 	for k, this in pairs(t_PropertyAlpha) do
--~ 		if SGroup_Count(this.sgroup) > 0 then
--~ 			if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 2) == false and retreat_PropertyAlpha == nil then 
--~ 				Cmd_Move(this.sgroup, this.last) 
--~ 			else
--~ 				retreat_PropertyAlpha = 1
--~ 			end
--~ 		else
--~ 			retreat_PropertyAlpha = 1
--~ 		end
--~ 	end
--~ 	
	local raftalpha = true
	for k, this in pairs(t_RaftAlpha) do
		if this.phase ~= 7 then 
			raftalpha = false
			break
		end
	end
	if raftalpha == true then 
		retreat_RaftAlpha = 1
	end
	local waveraftalpha = true
	for k, this in pairs(t_WaveRaftAlpha) do
		if this.phase ~= 7 then 
			waveraftalpha = false
			break
		end
	end
	if waveraftalpha == true then 
		retreat_WaveRaftAlpha = 1
	end

	-------------------------------------------------------------------------------
	local raftbeta = true
	for k, this in pairs(t_RaftBeta) do
		if this.phase ~= 7 then 
			raftbeta = false
			break
		end
	end
	if raftbeta == true then 
		retreat_RaftBeta = 1
	end
	local waveraftbeta = true
	for k, this in pairs(t_WaveRaftBeta) do
		if this.phase ~= 7 then 
			waveraftbeta = false
			break
		end
	end
	if waveraftbeta == true then 
		retreat_WaveRaftBeta = 1
	end
---------------------------------------------------------------------------------------	
	local raftgamma = true
	for k, this in pairs(t_RaftGamma) do
		if this.phase ~= 7 then 
			raftgamma = false
			break
		end
	end
	if raftgamma == true then 
		retreat_RaftGamma = 1
	end
	local waveraftgamma = true
	for k, this in pairs(t_WaveRaftGamma) do
		if this.phase ~= 7 then 
			waveraftgamma = false
			break
		end
	end
	if waveraftgamma == true then 
		retreat_WaveRaftGamma = 1
	end
	
	if retreat_RaftAlpha == 1 and retreat_WaveRaftAlpha == 1 then
--~ 		if g_speechretreat == nil then 
--~ 			Util_AutoIntel(t_regrouphill)
--~ 			g_speechretreat = 1
--~ 		end
		SGroup_GetLastAttacker(sg_LastStand1, sg_LastStandAttacker1)
		if Player_OwnsEGroup(player2, eg_Emplacement2) == false then 
			if ((SGroup_TotalMembersCount(sg_LastStand1) < SGroup_TotalMembersCount(sg_LastStandAttacker1)) or (SGroup_ContainsSGroup(sg_LastStandAttacker1, sg_AxisHeavyTank, ANY))) and g_surrender1 == nil  then 
				numSurrender = numSurrender + SGroup_TotalMembersCount(sg_LastStand1) 
				Cmd_Surrender(sg_LastStand1)
				g_surrender1 = 1 
			end
		end
	end
	
	if retreat_RaftBeta == 1 and retreat_WaveRaftBeta == 1 then
		SGroup_GetLastAttacker(sg_LastStand2, sg_LastStandAttacker2)
		if Player_OwnsEGroup(player2, eg_Emplacement3) == false then 
			if ((SGroup_TotalMembersCount(sg_LastStand2) < SGroup_TotalMembersCount(sg_LastStandAttacker2)) or (SGroup_ContainsSGroup(sg_LastStandAttacker2, sg_AxisHeavyTank, ANY))) and g_surrender2 == nil  then 
				numSurrender = numSurrender + SGroup_TotalMembersCount(sg_LastStand2) 
				Cmd_Surrender(sg_LastStand2)
				g_surrender2 = 1 
			end
		end
	end
	
		
	if 	retreat_RaftGamma == 1 and retreat_WaveRaftGamma == 1 then					
		SGroup_GetLastAttacker(sg_LastStand3, sg_LastStandAttacker3)
		if Player_OwnsEGroup(player2, eg_Emplacement1) == false then 
			if ((SGroup_TotalMembersCount(sg_LastStand3) < SGroup_TotalMembersCount(sg_LastStandAttacker3)) or (SGroup_ContainsSGroup(sg_LastStandAttacker3, sg_AxisHeavyTank, ANY)))  and g_surrender3 == nil then 
				numSurrender = numSurrender + SGroup_TotalMembersCount(sg_LastStand3) 
				Cmd_Surrender(sg_LastStand3)
				g_surrender3 = 1 
			end
		end
	end	
	if g_surrender1 == 1 and g_surrender2 == 1 and g_surrender3 == 1 then 
		if g_speechretreat2 == nil then 
			Util_AutoIntel(t_hillsurrender)
			
			g_speechretreat2 = 1
		end
	end
end




-- start the related action
function DestroyLandings_Kickoff()

	Rule_AddInterval(DestroyLandings_FirstIntel, 5)
	
end


-- start the related action
function DestroyLandings_DelayGrant()
	Objective_Start(OBJ_DestroyLandings)
	lastcount = 0
	
end




-------------------------------------------------------------------------
-- Medal Objective( kill as many commandos as possible)
-------------------------------------------------------------------------

-------------------------------------------------------------------------
function Initialize_OBJ_Medal()
	OBJ_Medal = {
		
		SetupUI = function() 
			
			
		end,
		
		OnStart = function()
			
			-- win/lose check
			Rule_AddInterval(Medal_WinCheck, 1)
			-- action
			Medal_Kickoff()
			lastcount = 0
			numKills = 0 
			
		end,
		OnComplete = function()
			
		end,
		
		IsComplete = function()
			
			
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1489103,
		Description = 1489113,
		Type = OT_Medal,
		MedalID = MEDALS.CXP2.OOSTERBEEK_CROSSING,

	}
	
	-- Register Objective
	Objective_Register(OBJ_Medal)
	-- Initialize Data
	Medal_Init()
	
end

function Medal_Init()
	

end

function Medal_Preset()	

end

-- Complete when the allied HQ reaches the location. 
function Medal_FirstIntel()

end

-- Complete when the allied HQ reaches the location. 
function Medal_WinCheck()
	Objective_SetCounter(OBJ_Medal, numHowitzer, 3)
	if EGroup_Count(t_Priest.squads[1].egroup) == 0 and g_howiztzerdestroyed1 == nil then
		numHowitzer = numHowitzer + 1
		g_howiztzerdestroyed1 = 1
	end
	if EGroup_Count(t_Priest.squads[2].egroup) == 0 and g_howiztzerdestroyed2 == nil then
		numHowitzer = numHowitzer + 1
		g_howiztzerdestroyed2 = 1
	end
	if EGroup_Count(t_Priest.squads[3].egroup) == 0 and g_howiztzerdestroyed3 == nil then
		numHowitzer = numHowitzer + 1
		g_howiztzerdestroyed3 = 1
	end
	if EGroup_Count(t_Priest.squads[1].egroup) == 0 and 
	EGroup_Count(t_Priest.squads[2].egroup) == 0  and 
	EGroup_Count(t_Priest.squads[3].egroup) == 0 and 
	g_HowitzerBuilt == 1 then 
		g_HowitzerBuilt = 2
		Objective_Complete(OBJ_Medal)
		Util_AutoIntel(t_artillerycomplete)
	end
	if Objective_IsComplete(OBJ_PreventCapture) then 	
		if EGroup_Count(t_Priest.squads[1].egroup) == 1 and g_howping1 == nil then
			OBJ_Medal.ID1 = Objective_AddUIElements(OBJ_Medal, t_Priest.squads[1].egroup, true, 1489103, true)
			g_howping1 = 1
		end
		if EGroup_Count(t_Priest.squads[1].egroup) == 0 and g_howping1 == 1 then 
			Objective_RemoveUIElements(OBJ_Medal, OBJ_Medal.ID1)
			g_howping1 = 2
		end
		if EGroup_Count(t_Priest.squads[2].egroup) == 1 and g_howping2 == nil then
			OBJ_Medal.ID2 = Objective_AddUIElements(OBJ_Medal, t_Priest.squads[2].egroup, true, 1489103, true)
			g_howping2 = 1
		end
		if EGroup_Count(t_Priest.squads[2].egroup) == 0 and g_howping2 == 1 then 
			Objective_RemoveUIElements(OBJ_Medal, OBJ_Medal.ID2)
			g_howping2 = 2
		end
		if EGroup_Count(t_Priest.squads[3].egroup) == 1 and g_howping3 == nil then
			OBJ_Medal.ID1 = Objective_AddUIElements(OBJ_Medal, t_Priest.squads[3].egroup, true, 1489103, true)
			g_howping3 = 1
		end
		if EGroup_Count(t_Priest.squads[3].egroup) == 0 and g_howping3 == 1 then 
			Objective_RemoveUIElements(OBJ_Medal, OBJ_Medal.ID3)
			g_howping3 = 2
		end
	end
end

-- start the related action
function Medal_Kickoff()

	Rule_AddInterval(Medal_FirstIntel, 5)
	
end


-- start the related action
function Medal_DelayGrant()
	if EGroup_Count(t_Priest.squads[1].egroup) > 0 and 
	EGroup_Count(t_Priest.squads[2].egroup) > 0 and
	EGroup_Count(t_Priest.squads[3].egroup) > 0 and g_HowitzerBuilt == nil then 
		g_HowitzerBuilt = 1
		Util_AutoIntel(t_artillerystart)
		Objective_Start(OBJ_Medal)
		Objective_SetCounter(OBJ_Medal, numHowitzer, 3)
		Rule_RemoveMe()
	end
end


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--END OF OBJECTIVE SCRIPT
--START OF SPAWNING SCRIPT

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Allied spawned units

-------------------------------------------------------------------------

function PlayerAlpha_Init()
--Spawning allied infantry at the beginning for NIS purposes perhaps.

	tmkr_PlayerAlpha = Marker_GetTable("mkr_2PlayerAlpha%d")
	tsg_PlayerAlpha = SGroup_CreateTable("sg_PlayerAlpha%d", table.getn(tmkr_PlayerAlpha))

	

	t_PlayerAlpha = {
		{
			upgrade = false,
			unit = SBP.ELITE.HALFTRACK_251, 
		},
		{
			upgrade = false,
			unit = SBP.ELITE.PANZERGRENADIER, 

		},
		{
			upgrade = false,
			unit = SBP.ELITE.PANZERGRENADIER, 
		},
		{
			upgrade = false,
			unit = SBP.ELITE.PANZERGRENADIER, 
		},
		{
			upgrade = false,
			unit = SBP.ELITE.HALFTRACK_MORTAR, 
		},
		{
			upgrade = false,
			unit = SBP.ELITE.HEAVYMG, 
		},
		{
			upgrade = false,
			unit = SBP.ELITE.PANZERGRENADIER, 
		},
		{
			upgrade = false,
			unit = SBP.ELITE.PANZERGRENADIER, 
		},

	}
	for i = 1, table.getn(t_PlayerAlpha) do
		t_PlayerAlpha[i].sgroup = tsg_PlayerAlpha[i]
		t_PlayerAlpha[i].spawn = tmkr_PlayerAlpha[i]
	end
	PlayerAlpha_Preset()
	--Timer_Start("tmr_PlayerAlpha", 20)
end

function PlayerAlpha_Preset()
--Spawn the squads when the function is called 
	for k, this in pairs(t_PlayerAlpha) do
		if SGroup_Count(this.sgroup) == 0 then 
			Util_CreateSquads(player1, this.sgroup, this.unit, this.spawn)
			Cmd_InstantSetupTeamWeapon(this.sgroup)
			--Modify_WeaponAccuracy(this.sgroup, "hardpoint_01", 2)
			this.phase = 2
			if this.upgrade ~= nil and this.upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, this.upgrade)
				Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			end
		end
	end	

end


function PlayerBeta_Init()
-- axis spawned weapons
	tmkr_PlayerBeta = Marker_GetTable("mkr_2PlayerBeta%d")
	tsg_PlayerBeta = SGroup_CreateTable("sg_PlayerBeta%d", table.getn(tmkr_PlayerBeta))
	t_PlayerBeta = {
		{
			phase = 2, 
			unit = SBP.ELITE.HEAVYMG, 
		},

	}
	for i = 1, table.getn(t_PlayerBeta) do
		t_PlayerBeta[i].sgroup = tsg_PlayerBeta[i]
		t_PlayerBeta[i].spawn = tmkr_PlayerBeta[i]
	end
	PlayerBeta_Preset()
end


function PlayerBeta_Preset()
	for k, this in pairs(t_PlayerBeta) do
		Util_CreateSquads(player1, this.sgroup, this.unit, this.spawn)
		Cmd_InstantSetupTeamWeapon(this.sgroup)
		this.phase = 2
	end
end


function PlayerGamma_Init()
-- Axis spawned vehicles for the player
	tmkr_PlayerGamma = Marker_GetTable("mkr_2PlayerGamma%d")
	tsg_PlayerGamma = SGroup_CreateTable("sg_2PlayerGamma%d", table.getn(tmkr_PlayerGamma))
	t_PlayerGamma = {
		{
			phase = 2, 
		},
		{
			phase = 2, 
		},
	}
	for i = 1, table.getn(t_PlayerGamma) do
		t_PlayerGamma[i].sgroup = tsg_PlayerGamma[i]
		t_PlayerGamma[i].spawn = tmkr_PlayerGamma[i]
	end
	PlayerGamma_Preset()
end


function PlayerGamma_Preset()
	for k, this in pairs(t_PlayerGamma) do
		Util_CreateSquads(player1, this.sgroup, SBP.ELITE.HALFTRACK_250, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
end

function PlayerDelta_Init()
-- Axis spawned vehicles for the player
	--tmkr_PlayerDelta = Marker_GetTable("mkr_2PlayerDelta%d")
	--tsg_PlayerDelta = SGroup_CreateTable("sg_2PlayerDelta%d", table.getn(tmkr_PlayerDelta))
	sg_PlayerDelta1 = SGroup_CreateIfNotFound("sg_PlayerDelta1")
	sg_PlayerDelta2 = SGroup_CreateIfNotFound("sg_PlayerDelta2")
	sg_PlayerDelta3 = SGroup_CreateIfNotFound("sg_PlayerDelta3")
	
	
	t_PlayerDelta = {
		{
			phase = 2, 
			unit = SBP.ELITE.PANZERGRENADIER, 
			egroup = eg_blg_Sniper1, 
		},
		{
			phase = 2, 
			unit = SBP.ELITE.HEAVYMG, 
			egroup = eg_blg_Sniper2, 
		},
		{
			phase = 2, 
			unit = SBP.ELITE.PANZERGRENADIER, 
			egroup = eg_blg_Sniper3, 
		},
	}
	for i = 1, table.getn(t_PlayerDelta) do
		--t_PlayerDelta[i].sgroup = tsg_PlayerDelta[i]
		--t_PlayerDelta[i].spawn = tmkr_PlayerDelta[i]
	end
	PlayerDelta_Preset()
end


function PlayerDelta_Preset()
	for k, this in pairs(t_PlayerDelta) do
		if EGroup_Count(this.egroup) > 0 then 
			Util_CreateSquads(player1, this.sgroup, this.unit, this.egroup)
			this.phase = 2
		end
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
end
function PlayerZeta_Init()
--Spawning allied infantry at the beginning for NIS purposes perhaps.
	sg_PlayerZeta1 = SGroup_CreateIfNotFound("sg_PlayerZeta1")
	sg_PlayerZeta2 = SGroup_CreateIfNotFound("sg_PlayerZeta2")
	sg_PlayerZeta3 = SGroup_CreateIfNotFound("sg_PlayerZeta3")
	sg_PlayerZeta4 = SGroup_CreateIfNotFound("sg_PlayerZeta4")
	sg_PlayerZeta5 = SGroup_CreateIfNotFound("sg_PlayerZeta5")
	sg_PlayerZeta6 = SGroup_CreateIfNotFound("sg_PlayerZeta6")
	
	sg_PlayerZetaHalftrack1 = SGroup_CreateIfNotFound("sg_PlayerZetaHalftrack1")
	sg_PlayerZetaHalftrack2 = SGroup_CreateIfNotFound("sg_PlayerZetaHalftrack2")
	sg_PlayerZetaHalftrack3 = SGroup_CreateIfNotFound("sg_PlayerZetaHalftrack3")
	sg_PlayerZetaHalftrack4 = SGroup_CreateIfNotFound("sg_PlayerZetaHalftrack4")
	sg_PlayerZetaHalftrack5 = SGroup_CreateIfNotFound("sg_PlayerZetaHalftrack5")
	sg_PlayerZetaHalftrack6 = SGroup_CreateIfNotFound("sg_PlayerZetaHalftrack6")
	
	t_PlayerZeta = {
		{
			sgroup = sg_PlayerZeta1, 
			upgrade = UPG.ELITE.G43,
			timername = "tmr_PlayerZeta", 
			timer = 14, 
			count = 4, 
			phase = 1,
			marker = mkr_PlayerAlpha2,
			marker2  = mkr_PlayerZeta1a, 
			unit1 = SBP.ELITE.PANZERGRENADIER, 
			unit2 = false,

		},
		{
			sgroup = sg_PlayerZeta2, 
			upgrade = UPG.ELITE.G43,
			timername = "tmr_PlayerZeta", 
			timer = 12, 
			count = 4, 
			phase = 1,
			marker = mkr_PlayerAlpha2a,
			marker2  = mkr_PlayerZeta2a, 
			unit1 = SBP.ELITE.PANZERGRENADIER, 
			unit2 = false, 

		},
		{
			sgroup = sg_PlayerZeta3, 
			upgrade = UPG.ELITE.PANZERSCHRECK,
			timername = "tmr_PlayerZeta", 
			timer = 10, 
			count = 4, 
			phase = 1, 
			marker = mkr_PlayerGamma1,
			marker2  = mkr_PlayerZeta3a, 
			unit1 = SBP.ELITE.PANZERGRENADIER,  
			unit2 = false, 
		},
		{
			sgroup = sg_PlayerZeta4, 
			upgrade = false,
			timername = "tmr_PlayerZeta", 
			timer = 6, 
			count = 1, 
			phase = 1, 
			marker = mkr_PlayerAlpha3,
			marker2  = mkr_PlayerZeta4a, 
			unit1 = SBP.ELITE.HUMMEL, 
			unit2 = false,
		},
		{
			sgroup = sg_PlayerZeta5, 
			upgrade = false,
			timername = "tmr_PlayerZeta", 
			timer = 1, 
			count = 1, 
			phase = 1,
			marker = mkr_PlayerAlpha4,
			marker2  = mkr_PlayerZeta1a, 
			unit1 = SBP.ELITE.JAGDPANTHER,			
			unit2 = false,

		},
	}

	Rule_AddInterval(PlayerZeta_Preset, 1)
	Timer_Start("tmr_PlayerZeta", 15)
end

function PlayerZeta_Preset()
--Spawn the squads when the function is called 
	for k, this in pairs(t_PlayerZeta) do
		if Timer_GetRemaining("tmr_PlayerZeta") < this.timer and SGroup_Count(this.sgroup) == 0 and this.phase == 1 then 
			Util_CreateSquads(player1, this.sgroup, this.unit1, mkr_PlayerEntry, this.marker, 1, this.count )
			Cmd_Move(this.sgroup, this.marker)
			this.phase = 2
			if this.upgrade ~= nil and this.upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, this.upgrade)
				Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			end
		end
		if Timer_GetRemaining("tmr_PlayerZeta") == 0 then 
			Rule_RemoveMe()
		end
	end	

end
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--END OF ALLIED SPAWN SCRIPT
--BEGINNING OF AXIS SPAWN SCRIPT
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



function BuildingAlpha_Init()
-- Axis spawned vehicles for the player
	--tmkr_BuildingAlpha = Marker_GetTable("mkr_2BuildingAlpha%d")
	--tsg_BuildingAlpha = SGroup_CreateTable("sg_2BuildingAlpha%d", table.getn(tmkr_BuildingAlpha))
	sg_BuildingAlpha1 = SGroup_CreateIfNotFound("sg_BuildingAlpha1")
	sg_BuildingAlpha2 = SGroup_CreateIfNotFound("sg_BuildingAlpha2")
	sg_BuildingAlpha3 = SGroup_CreateIfNotFound("sg_BuildingAlpha3")
	sg_BuildingAlpha4 = SGroup_CreateIfNotFound("sg_BuildingAlpha4")
	sg_BuildingAlpha5 = SGroup_CreateIfNotFound("sg_BuildingAlpha5")
	sg_BuildingAlpha6 = SGroup_CreateIfNotFound("sg_BuildingAlpha6")
	sg_BuildingAlpha7 = SGroup_CreateIfNotFound("sg_BuildingAlpha7")
	sg_BuildingAlpha8 = SGroup_CreateIfNotFound("sg_BuildingAlpha8")
	
	t_BuildingAlpha = {
		{
			sgroup = sg_BuildingAlpha1,
			phase = 2, 
			unit = SBP.CW.COMMANDOS_MG,
			egroup = eg_blg_Ally1, 
		},
		{
			sgroup = sg_BuildingAlpha2,
			phase = 2, 
			unit = SBP.CW.COMMANDOS_MG,
			egroup = eg_blg_Ally2, 
		},
		{
			sgroup = sg_BuildingAlpha3,
			phase = 2, 
			unit = SBP.CW.COMMANDOS_MG,
			egroup = eg_blg_Ally3, 
		},
		{
			sgroup = sg_BuildingAlpha4,
			phase = 2, 
			unit = SBP.CW.COMMANDOS_MG,
			egroup = eg_blg_Ally4, 
		},
		{
			sgroup = sg_BuildingAlpha5,
			phase = 2, 
			unit = SBP.CW.COMMANDOS_MG,
			egroup = eg_blg_Ally5, 
		},
		{
			sgroup = sg_BuildingAlpha6,
			phase = 2, 
			unit = SBP.CW.COMMANDOS_MG,
			egroup = eg_blg_Ally6, 
		},
		{
			sgroup = sg_BuildingAlpha7,
			phase = 2, 
			unit = SBP.CW.COMMANDOS_MG,
			egroup = eg_blg_Ally7, 
		},
		{
			sgroup = sg_BuildingAlpha8,
			phase = 2, 
			unit = SBP.CW.COMMANDOS_MG,
			egroup = eg_blg_Ally8, 
		},
	}
	for i = 1, table.getn(t_BuildingAlpha) do
		--t_BuildingAlpha[i].sgroup = tsg_BuildingAlpha[i]
		--t_BuildingAlpha[i].spawn = tmkr_BuildingAlpha[i]
	end
	BuildingAlpha_Preset()
end


function BuildingAlpha_Preset()
	for k, this in pairs(t_BuildingAlpha) do
		if EGroup_Count(this.egroup) > 0 then 
			Util_CreateSquads(player2, this.sgroup, this.unit, this.egroup)
			this.phase = 2
			if this.upgrade ~= nil and this.upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, this.upgrade)
				Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			end
		end
	end
	if Rule_Exists(BuildingAlpha_Kickoff) == false then 
		Rule_AddInterval(BuildingAlpha_Kickoff, 1)
	end
end

function BuildingAlpha_Kickoff()
	for k, this in pairs(t_BuildingAlpha) do
		if this.phase == 2 then 
			if SGroup_TotalMembersCount(this.sgroup) < 2 and EGroup_Count(this.egroup) > 0  then 
				Cmd_UngarrisonSquad(this.sgroup)
			end
			if SGroup_IsInHoldEntity(this.sgroup, ANY) == false then 
				Cmd_Retreat(this.sgroup, mkr_Final1)
			end
		end
	end
end


function BeginRaftAlpha_Init()

	tmkr_BeginRaftAlpha = Marker_GetTable("mkr_BeginRaftAlpha%d")
	--tsg_BeginRaftAlpha = SGroup_CreateTable("sg_BeginRaftAlpha%d", table.getn(tmkr_BeginRaftAlpha))
	
	sg_BeginRaftAlpha1 = SGroup_CreateIfNotFound("sg_BeginRaftAlpha1")
	sg_BeginRaftAlpha2 = SGroup_CreateIfNotFound("sg_BeginRaftAlpha2")
	sg_BeginRaftAlpha3 = SGroup_CreateIfNotFound("sg_BeginRaftAlpha3")

	eg_BeginRaftAlpha1 = EGroup_CreateIfNotFound("eg_BeginRaftAlpha1")
	eg_BeginRaftAlpha2 = EGroup_CreateIfNotFound("eg_BeginRaftAlpha2")
	eg_BeginRaftAlpha3 = EGroup_CreateIfNotFound("eg_BeginRaftAlpha3")
	
	sg_BeginRaftAlphaAttacker1 = SGroup_CreateIfNotFound("sg_BeginRaftAlphaAttacker1")
	sg_BeginRaftAlphaAttacker2 = SGroup_CreateIfNotFound("sg_BeginRaftAlphaAttacker2")
	sg_BeginRaftAlphaAttacker3 = SGroup_CreateIfNotFound("sg_BeginRaftAlphaAttacker3")
	
	
	t_BeginRaftAlpha = {
		{
			sgroup = sg_BeginRaftAlpha1, 
			egroup = eg_BeginRaftAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_BeginRaftAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_BeginRaftAlpha1,
			landing = mkr_WaveRaftAlpha1a, 
			attacker = sg_BeginRaftAlphaAttacker1, 

		},
		{
			sgroup = sg_BeginRaftAlpha2, 
			egroup = eg_BeginRaftAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_BeginRaftAlpha2", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_BeginRaftAlpha2,
			landing = mkr_WaveRaftAlpha2a,
			attacker = sg_BeginRaftAlphaAttacker2, 

		},

		{
			sgroup = sg_BeginRaftAlpha3, 
			egroup = eg_BeginRaftAlpha3, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_BeginRaftAlpha3", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_BeginRaftAlpha3,
			landing = mkr_WaveRaftAlpha3a,
			attacker = sg_BeginRaftAlphaAttacker3, 

		},
	}
	BeginRaftAlpha_Preset()
	
end


function BeginRaftAlpha_Preset()
--Spawns the units
	for k, this in pairs(t_BeginRaftAlpha) do
		if EGroup_Count(this.egroup) == 0 then 
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , this.landing, 1, 4) 
			-- this two actions make the units on the boats visible when they are seeing from really far away 
			-- (close to the top of the screen after the NIS)
			SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			
			Modify_ReceivedDamage(this.egroup, mod_boat)
			this.phase = 2
		end
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(BeginRaftAlpha_Kickoff) == false then 
		Rule_AddInterval(BeginRaftAlpha_Kickoff, 3)
	end

end

function BeginRaftAlpha_Kickoff()
--checks what they need to do after being spawned
	local g_destroyed = true
	
	for k, this in pairs(t_BeginRaftAlpha) do
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing, ANY, 1) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and g_LandingsStarted == nil then 
			EGroup_Kill(this.egroup)
		end
		
		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)
			if SGroup_IsCapturing(this.sgroup, ANY) == false and Player_OwnsEGroup(player2, eg_pnt_C1) == false then 
				Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_C1)
			elseif Player_OwnsEGroup(player2, eg_pnt_C1) == true and SGroup_Count(sg_AxisAll) > 0 then
				Cmd_AttackMove(this.sgroup, sg_AxisAll) 
			end
		end
		
		if SGroup_Count(this.sgroup) > 0 then 
			g_destroyed = false
		end
	end
	
	if g_destroyed == true then 
		Util_AutoIntel(t_Prepare_Objective)
		Rule_AddOneShot(Delay_PreventCapture, 1)
		--Objective_ForceSitRep(OBJ_PreventCapture)
		
		Rule_AddInterval(KR_ForceSitRep, 1)
		g_ready = 1
		Rule_RemoveMe()
	end
end




function KR_ForceSitRep()

	if Objective_IsComplete(OBJ_PreventCapture) then
		Rule_RemoveMe()
		return
	end
	
	if Event_IsAnyRunning() == false then
	
		-- surreptitiously add in the sitrep and pretend it was always there
		OBJ_PreventCapture.OnStart = function() end
		
		
		OBJ_PreventCapture.SitRep = {
			Movie = "CXP2_SR_08-01",
			Force = false,
			SpeechTiming =
			{
				{ 0.5,	ACTOR.CXP2.Aldrich, 1480520},
				{ 5,	ACTOR.CXP2.Aldrich, 1480530},
				{ 10.6,	ACTOR.CXP2.Aldrich, 1480550 },
				{ 14.8,	ACTOR.CXP2.Wolfgang, 1480560 },
				{ 20.5,	ACTOR.CXP2.Wolfgang, 1480570 },
				{ 24.5,	ACTOR.CXP2.Wolfgang, 1480580 },
				{ 31.4,	ACTOR.CXP2.Wolfgang, 1480590 },
				{ 41.5,	ACTOR.CXP2.Wolfgang, 1480595 },
			},
		},
		
		-- and force the sitrep to play

		Obj_SetObjectiveFunction(OBJ_PreventCapture.ID, FN_OnActivate, __ObjectiveOnActivateCallback)
		Objective_ForceSitRep(OBJ_PreventCapture)
		Rule_AddInterval(Speech_AfterSitrep, 1)
		Rule_RemoveMe()
	end

end


function Speech_AfterSitrep()
	if Event_IsAnyRunning() == false then
		Util_AutoIntel(t_Prepare_AfterSitrep)
		Rule_RemoveMe()
	end
end
function BeginRaftAlpha_GiveXP()
	Player_AddResource(player1, RT_Action, mod_xp)
end


-- Wave Data
-- Axis Units sent in waves but do not spawn again.  
-- Each squad is monitored by total members in the squad
-- Alpha send to the Heights, Beta to the middle 
-------------------------------------------------------------------------

function WaveRaftAlpha_Init()

	tmkr_WaveRaftAlpha = Marker_GetTable("mkr_WaveRaftAlpha%d")
	--tsg_WaveRaftAlpha = SGroup_CreateTable("sg_WaveRaftAlpha%d", table.getn(tmkr_WaveRaftAlpha))
	
	sg_WaveRaftAlpha1 = SGroup_CreateIfNotFound("sg_WaveRaftAlpha1")
	sg_WaveRaftAlpha2 = SGroup_CreateIfNotFound("sg_WaveRaftAlpha2")
	sg_WaveRaftAlpha3 = SGroup_CreateIfNotFound("sg_WaveRaftAlpha3")

	eg_WaveRaftAlpha1 = EGroup_CreateIfNotFound("eg_WaveRaftAlpha1")
	eg_WaveRaftAlpha2 = EGroup_CreateIfNotFound("eg_WaveRaftAlpha2")
	eg_WaveRaftAlpha3 = EGroup_CreateIfNotFound("eg_WaveRaftAlpha3")
	
	sg_WaveRaftAlphaAttacker1 = SGroup_CreateIfNotFound("sg_WaveRaftAlphaAttacker1")
	sg_WaveRaftAlphaAttacker2 = SGroup_CreateIfNotFound("sg_WaveRaftAlphaAttacker2")
	sg_WaveRaftAlphaAttacker3 = SGroup_CreateIfNotFound("sg_WaveRaftAlphaAttacker3")
	
	
	t_WaveRaftAlpha = {
		{
			sgroup = sg_WaveRaftAlpha1, 
			egroup = eg_WaveRaftAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_WaveRaftAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch1,
			landing = {mkr_WaveRaftAlpha1a, mkr_WaveRaftAlpha1b, mkr_WaveRaftAlpha1c},
			landing2 = mkr_WaveRaftAlpha1b,
			attacker = sg_WaveRaftAlphaAttacker1, 
			last = mkr_WaveRaftAlphaLast1,

		},
--~ 		{
--~ 			sgroup = sg_WaveRaftAlpha2, 
--~ 			egroup = eg_WaveRaftAlpha2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_WaveRaftAlpha2", 
--~ 			timer = 10, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = mkr_RaftLaunch3,
--~ 			landing = {mkr_WaveRaftAlpha2a, mkr_WaveRaftAlpha2b, mkr_WaveRaftAlpha2c},
--~ 			landing2 = mkr_WaveRaftAlpha2b,
--~ 			attacker = sg_WaveRaftAlphaAttacker2, 
--~ 			last = mkr_WaveRaftAlphaLast2,

--~ 		},

		{
			sgroup = sg_WaveRaftAlpha3, 
			egroup = eg_WaveRaftAlpha3, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_WaveRaftAlpha3", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch4,
			landing = {mkr_WaveRaftAlpha3a, mkr_WaveRaftAlpha3b, mkr_WaveRaftAlpha3c},
			landing2 = mkr_WaveRaftAlpha3b,
			attacker = sg_WaveRaftAlphaAttacker3, 
			last = mkr_WaveRaftAlphaLast3,
		
		},
	}
	WaveRaftAlpha_Preset()
	
end


function WaveRaftAlpha_Preset()
--Spawns the units
	for k, this in pairs(t_WaveRaftAlpha) do
		if EGroup_Count(this.egroup) == 0 and SGroup_Count(this.sgroup) == 0  then 
			
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing), 1, 3) 
			SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			Rule_AddSGroupEvent(WaveRaftAlpha_GiveXP, this.sgroup, GE_SquadKilled)
			Cmd_InstantUpgrade(this.sgroup, UPG.CW.PIAT)
			Modify_ReceivedDamage(this.egroup, mod_boat)
			this.phase = 2
		end
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveRaftAlpha_Kickoff) == false then 
		Rule_AddInterval(WaveRaftAlpha_Kickoff, 1)
	end
end

function WaveRaftAlpha_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveRaftAlpha) do
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing2, ANY, 15) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and g_LandingsStarted == nil then 
			EGroup_Kill(this.egroup)
		end
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					Cmd_AttackMove(this.sgroup, this.attacker) 
				elseif SGroup_Count(sg_AxisAll) > 0 then
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, SGroup_GetPosition(this.sgroup)))
				end
			end
		end
		
		if this.phase == 6 then 
			
			if SGroup_Count(this.sgroup) > 0 then
				if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 15) == false then 
					Cmd_Move(this.sgroup, this.last) 
				else
					this.phase = 7
				end
			elseif SGroup_Count(this.sgroup) == 0 then
				this.phase = 7
			end
		end
	end
end

function WaveRaftAlpha_GiveXP()
	Player_AddResource(player1, RT_Action, mod_xp)
end


function WaveRaftBeta_Init()

	tmkr_WaveRaftBeta = Marker_GetTable("mkr_WaveRaftBeta%d")
	--tsg_WaveRaftBeta = SGroup_CreateTable("sg_WaveRaftBeta%d", table.getn(tmkr_WaveRaftBeta))
	
	sg_WaveRaftBeta1 = SGroup_CreateIfNotFound("sg_WaveRaftBeta1")
	sg_WaveRaftBeta2 = SGroup_CreateIfNotFound("sg_WaveRaftBeta2")
	sg_WaveRaftBeta3 = SGroup_CreateIfNotFound("sg_WaveRaftBeta3")

	sg_WaveRaftBetaHelper1 = SGroup_CreateIfNotFound("sg_WaveRaftBetaHelper1")
	sg_WaveRaftBetaHelper2 = SGroup_CreateIfNotFound("sg_WaveRaftBetaHelper2")
	sg_WaveRaftBetaHelper3 = SGroup_CreateIfNotFound("sg_WaveRaftBetaHelper3")
	
	eg_WaveRaftBeta1 = EGroup_CreateIfNotFound("eg_WaveRaftBeta1")
	eg_WaveRaftBeta2 = EGroup_CreateIfNotFound("eg_WaveRaftBeta2")
	eg_WaveRaftBeta3 = EGroup_CreateIfNotFound("eg_WaveRaftBeta3")
	
	sg_WaveRaftBetaAttacker1 = SGroup_CreateIfNotFound("sg_WaveRaftBetaAttacker1")
	sg_WaveRaftBetaAttacker2 = SGroup_CreateIfNotFound("sg_WaveRaftBetaAttacker2")
	sg_WaveRaftBetaAttacker3 = SGroup_CreateIfNotFound("sg_WaveRaftBetaAttacker3")
	
	eg_blg_House1 = EGroup_CreateIfNotFound("eg_blg_House1")
	eg_blg_House2 = EGroup_CreateIfNotFound("eg_blg_House2")
	eg_blg_House3 = EGroup_CreateIfNotFound("eg_blg_House3")
	
	eg_blg_Home1 = EGroup_CreateIfNotFound("eg_blg_Home1")
	eg_blg_Home2 = EGroup_CreateIfNotFound("eg_blg_Home2")
	eg_blg_Home3 = EGroup_CreateIfNotFound("eg_blg_Home3")
	
	eg_blg_Raft1 = EGroup_CreateIfNotFound("eg_blg_Raft1")
	eg_blg_Raft2 = EGroup_CreateIfNotFound("eg_blg_Raft2")
	eg_blg_Raft3 = EGroup_CreateIfNotFound("eg_blg_Raft3")
	
	t_WaveRaftBeta = {
		{
			sgroup = sg_WaveRaftBeta1, 
			sgroup2 = sg_WaveRaftBetaHelper1,
			egroup = eg_WaveRaftBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_WaveRaftBeta1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch6,
			landing = {mkr_WaveRaftBeta1a, mkr_WaveRaftBeta1b, mkr_WaveRaftBeta1c}, 
			landing2 = mkr_WaveRaftBeta1b,
			attacker = sg_WaveRaftBetaAttacker1, 
			last = mkr_WaveRaftBetaLast1,
			house1 = eg_blg_House2, 
			house2 = eg_blg_House5, 
			house3 = eg_blg_House6, 
			house4 = eg_blg_House4, 
			home = eg_blg_Home1, 
			current = eg_blg_Raft1, 
		},
		{
			sgroup = sg_WaveRaftBeta2, 
			sgroup2 = sg_WaveRaftBetaHelper2,
			egroup = eg_WaveRaftBeta2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_WaveRaftBeta2", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch7,
			landing = {mkr_WaveRaftBeta2a, mkr_WaveRaftBeta2b, mkr_WaveRaftBeta2c}, 
			landing2 = mkr_WaveRaftBeta2b,
			attacker = sg_WaveRaftBetaAttacker2, 
			last = mkr_WaveRaftBetaLast2,				
			house1 = eg_blg_House1, 
			house2 = eg_blg_House4, 			
			house3 = eg_blg_House3, 
			house4 = eg_blg_House2,  
			home = eg_blg_Home2,
			current = eg_blg_Raft2, 
		},

		{
			sgroup = sg_WaveRaftBeta3, 
			sgroup2 = sg_WaveRaftBetaHelper3,
			egroup = eg_WaveRaftBeta3, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_WaveRaftBeta3", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch8,
			landing = {mkr_WaveRaftBeta3a, mkr_WaveRaftBeta3b, mkr_WaveRaftBeta3c}, 
			landing2 = mkr_WaveRaftBeta3b,
			attacker = sg_WaveRaftBetaAttacker3, 
			last = mkr_WaveRaftBetaLast3,
			house1 = eg_blg_House3, 
			house2 = eg_blg_House2, 
			house3 = eg_blg_House1, 
			house4 = eg_blg_House4,  
			home = eg_blg_Home3,
			current = eg_blg_Raft3, 
		},
	}
	WaveRaftBeta_Preset()
	
end


function WaveRaftBeta_Preset()
--Spawns the units
	for k, this in pairs(t_WaveRaftBeta) do
		if EGroup_Count(this.egroup) == 0 and SGroup_Count(this.sgroup) == 0 then 
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing), 1, 3) 
			SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			Rule_AddSGroupEvent(WaveRaftBeta_GiveXP, this.sgroup, GE_SquadKilled)
			Cmd_InstantUpgrade(this.sgroup, UPG.CW.RIFLE_GRENADE)
			Modify_ReceivedDamage(this.egroup, mod_boat)
			this.phase = 2
		end
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveRaftBeta_Kickoff) == false then 
		Rule_AddInterval(WaveRaftBeta_Kickoff, 1)
	end

end

function WaveRaftBeta_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveRaftBeta) do
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing2, ANY, 15) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and g_LandingsStarted == nil then 
			EGroup_Kill(this.egroup)
		end
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				
				if SGroup_IsInHoldEntity(this.sgroup, ANY) == false  then 	
					if EGroup_Count(this.house1) > 0 and Player_OwnsEGroup(player2, this.house1) == false and Player_OwnsEGroup(player1, this.house1) == false  then
						Cmd_Garrison(this.sgroup, this.house1)
						
					elseif EGroup_Count(this.house2) > 0 and Player_OwnsEGroup(player2, this.house2) == false and Player_OwnsEGroup(player1, this.house2) == false then 
						Cmd_Garrison(this.sgroup, this.house2)
					elseif EGroup_Count(this.house3) > 0 and Player_OwnsEGroup(player2, this.house3) == false and Player_OwnsEGroup(player1, this.house3) == false then 
						Cmd_Garrison(this.sgroup, this.house3)
					elseif EGroup_Count(this.house4) > 0 and Player_OwnsEGroup(player2, this.house4) == false and Player_OwnsEGroup(player1, this.house4) == false  then 
						Cmd_Garrison(this.sgroup, this.house4)
					end
				elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == true then 
					SGroup_GetHoldEGroup(this.sgroup, this.current)
					if EGroup_ContainsEGroup(this.house1, this.current, ANY) then
						if Player_OwnsEGroup(player2, this.house1) and EGroup_Count(this.house1) > 0 and  SGroup_Count(this.sgroup2) == 0 then 
							Cmd_InstantUpgrade(this.house1, UPG.ALLIES.CONVERT_AMBIENT_BUILDING)
							Util_CreateSquads(player2, this.sgroup2, SBP.CW.COMMANDOS_MG, this.house1)
							Cmd_UngarrisonSquad(this.sgroup)
						end
						this.phase = 3
					elseif  EGroup_ContainsEGroup(this.house2, this.current, ANY)  then
						if Player_OwnsEGroup(player2, this.house2) and EGroup_Count(this.house2) > 0 and SGroup_Count(this.sgroup2) == 0 then 
							Cmd_InstantUpgrade(this.house2, UPG.ALLIES.CONVERT_AMBIENT_BUILDING)
							Util_CreateSquads(player2, this.sgroup2, SBP.CW.COMMANDOS_MG, this.house2)
							Cmd_UngarrisonSquad(this.sgroup)
						end
						this.phase = 3
					elseif Player_OwnsEGroup(player2, this.house3) and EGroup_Count(this.house3) > 0 and EGroup_ContainsEGroup(this.house3, this.current, ANY) then
						if SGroup_Count(this.sgroup2) == 0 then 
							Cmd_InstantUpgrade(this.house3, UPG.ALLIES.CONVERT_AMBIENT_BUILDING)
							Util_CreateSquads(player2, this.sgroup2, SBP.CW.COMMANDOS_MG, this.house3)
							Cmd_UngarrisonSquad(this.sgroup)
						end
						this.phase = 3
					elseif EGroup_ContainsEGroup(this.house4, this.current, ANY)  then
						if Player_OwnsEGroup(player2, this.house4) and EGroup_Count(this.house4) > 0 and SGroup_Count(this.sgroup2) == 0 then 
							Cmd_InstantUpgrade(this.house4, UPG.ALLIES.CONVERT_AMBIENT_BUILDING)
							Util_CreateSquads(player2, this.sgroup2, SBP.CW.COMMANDOS_MG, this.house4)
							Cmd_UngarrisonSquad(this.sgroup)
						end
						this.phase = 3
					end
				end
			end
		end
		if this.phase == 3 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_IsInHoldEntity(this.sgroup, ANY) == false and EGroup_Count(eg_blg_AllBuildings) > 0 then 	
					EGroup_Single(this.home, Util_GetClosestFreeEntity(eg_blg_AllBuildings, SGroup_GetPosition(this.sgroup)))
					Cmd_Garrison(this.sgroup, this.home)
				end
			end
--~ 				if EGroup_Count(this.house1) > 0 and Player_OwnsEGroup(player2, this.house1) == false and Player_OwnsEGroup(player1, this.house1) == false  then
--~ 					Cmd_Garrison(this.sgroup, this.house1)
--~ 					
--~ 				elseif EGroup_Count(this.house2) > 0 and Player_OwnsEGroup(player2, this.house2) == false and Player_OwnsEGroup(player1, this.house2) == false then 
--~ 					Cmd_Garrison(this.sgroup, this.house2)
--~ 				elseif EGroup_Count(this.house3) > 0 and Player_OwnsEGroup(player2, this.house3) == false and Player_OwnsEGroup(player1, this.house3) == false then 
--~ 					Cmd_Garrison(this.sgroup, this.house3)
--~ 				elseif EGroup_Count(this.house4) > 0 and Player_OwnsEGroup(player2, this.house4) == false and Player_OwnsEGroup(player1, this.house4) == false  then 
--~ 					Cmd_Garrison(this.sgroup, this.house4)
--~ 				end
		end
		if this.phase == 6 then 
			
			if SGroup_Count(this.sgroup) > 0 then
				if SGroup_IsInHoldEntity(this.sgroup, ANY) == true then
					Cmd_UngarrisonSquad(this.sgroup)
				elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == false then
					if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 15) == false then 
							Cmd_Move(this.sgroup, this.last) 
					else
							this.phase = 7
					end
				end
			elseif SGroup_Count(this.sgroup) == 0 then
				this.phase = 7
			end
		end
	end
end

function WaveRaftBeta_GiveXP()
	Player_AddResource(player1, RT_Action, mod_xp)
end

function WaveRaftGamma_Init()

	tmkr_WaveRaftGamma = Marker_GetTable("mkr_WaveRaftGamma%d")
	--tsg_WaveRaftGamma = SGroup_CreateTable("sg_WaveRaftGamma%d", table.getn(tmkr_WaveRaftGamma))
	
	sg_WaveRaftGamma1 = SGroup_CreateIfNotFound("sg_WaveRaftGamma1")
	sg_WaveRaftGamma2 = SGroup_CreateIfNotFound("sg_WaveRaftGamma2")
	sg_WaveRaftGamma3 = SGroup_CreateIfNotFound("sg_WaveRaftGamma3")

	eg_WaveRaftGamma1 = EGroup_CreateIfNotFound("eg_WaveRaftGamma1")
	eg_WaveRaftGamma2 = EGroup_CreateIfNotFound("eg_WaveRaftGamma2")
	eg_WaveRaftGamma3 = EGroup_CreateIfNotFound("eg_WaveRaftGamma3")
	
	sg_WaveRaftGammaAttacker1 = SGroup_CreateIfNotFound("sg_WaveRaftGammaAttacker1")
	sg_WaveRaftGammaAttacker2 = SGroup_CreateIfNotFound("sg_WaveRaftGammaAttacker2")
	sg_WaveRaftGammaAttacker3 = SGroup_CreateIfNotFound("sg_WaveRaftGammaAttacker3")
	
	
	t_WaveRaftGamma = {
		{
			sgroup = sg_WaveRaftGamma1, 
			egroup = eg_WaveRaftGamma1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_WaveRaftGamma1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch8,
			landing = {mkr_WaveRaftGamma1a, mkr_WaveRaftGamma1b, mkr_WaveRaftGamma1c}, 
			landing2 = mkr_WaveRaftGamma1b,
			attacker = sg_WaveRaftGammaAttacker1, 
			last = mkr_WaveRaftGammaLast1,
		},
--~ 		{
--~ 			sgroup = sg_WaveRaftGamma2, 
--~ 			egroup = eg_WaveRaftGamma2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_WaveRaftGamma2", 
--~ 			timer = 10, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = mkr_RaftLaunch9,
--~ 			landing = {mkr_WaveRaftGamma2a, mkr_WaveRaftGamma2b, mkr_WaveRaftGamma2c}, 
--~ 			attacker = sg_WaveRaftGammaAttacker2, 
--~ 			landing2 = mkr_WaveRaftGamma2b,
--~ 			last = mkr_WaveRaftGammaLast2,
--~ 		},

		{
			sgroup = sg_WaveRaftGamma3, 
			egroup = eg_WaveRaftGamma3, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_WaveRaftGamma3", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch10,
			landing = {mkr_WaveRaftGamma3a, mkr_WaveRaftGamma3b, mkr_WaveRaftGamma3c}, 
			landing2 = mkr_WaveRaftGamma3b,
			attacker = sg_WaveRaftGammaAttacker3, 
			last = mkr_WaveRaftGammaLast3,
		},
	}
	WaveRaftGamma_Preset()
	
end


function WaveRaftGamma_Preset()
--Spawns the units
	for k, this in pairs(t_WaveRaftGamma) do
		if EGroup_Count(this.egroup) == 0 and SGroup_Count(this.sgroup) == 0 then 
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing), 1, 3) 
			SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			Rule_AddSGroupEvent(WaveRaftGamma_GiveXP, this.sgroup, GE_SquadKilled)
			Modify_ReceivedDamage(this.egroup, mod_boat)
			Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
			this.phase = 2
		end
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveRaftGamma_Kickoff) == false then 
		Rule_AddInterval(WaveRaftGamma_Kickoff, 1)
	end

end

function WaveRaftGamma_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveRaftGamma) do
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing2, ANY, 10) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and g_LandingsStarted == nil then 
			EGroup_Kill(this.egroup)
		end
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_IsCapturing(this.sgroup, ANY) == false then
					if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
						SGroup_GetLastAttacker(this.sgroup, this.attacker)
						if SGroup_Count(this.attacker) > 0 then 
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
				
						Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_BACK, 10, true)
						--Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)
						end
					elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
						if SGroup_Count(sg_AxisTank) > 0 then 
						--SGroup_Single(this.tank, Util_GetClosestSquadPosition(sg_AxisTank, this.sgroup))
						Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisTank, SGroup_GetPosition(this.sgroup)))
						elseif SGroup_Count(sg_AxisTank) == 0  then
							if SGroup_Count(sg_AxisAll) > 0 then							
								Cmd_AttackMove(this.sgroup,  sg_AxisAll)
							end
						end
					end
				end
			end
		end
		if this.phase == 6 then 
			
			if SGroup_Count(this.sgroup) > 0 then
				if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 15) == false then 
					Cmd_Move(this.sgroup, this.last) 
				else
					this.phase = 7
				end
			elseif SGroup_Count(this.sgroup) == 0 then
				this.phase = 7
			end
		end
	end
end
function WaveRaftGamma_GiveXP()
	Player_AddResource(player1, RT_Action, mod_xp)
end

-----------------------------------------------------------------------------------------------------
--wave Data for ground troops from oosterbeek


function WaveAlpha_Init()

	tmkr_WaveAlpha = Marker_GetTable("mkr_WaveAlpha%d")
	tsg_WaveAlpha = SGroup_CreateTable("sg_WaveAlpha%d", table.getn(tmkr_WaveAlpha))
	sg_WaveAlpha1 = SGroup_CreateIfNotFound("sg_WaveAlpha1")
	sg_WaveAlpha2 = SGroup_CreateIfNotFound("sg_WaveAlpha2")

	t_WaveAlpha = {
		{
			sgroup = sg_WaveAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,
			upgrade = false,
			phase = 2,
			path = "pth_R1a", 	
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
		},
		{
			sgroup = sg_WaveAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			upgrade = false, 
			phase = 2,
			path = "pth_R1b", 
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
		},
	}
	
	for i = 1, table.getn(t_WaveAlpha) do
		--t_WaveAlpha[i].sgroup = tsg_WaveAlpha[i]
		--t_WaveAlpha[i].spawn = tmkr_WaveAlpha[i]
	end
	
	WaveAlpha_Preset()
	
end


function WaveAlpha_Preset()
--Spawns the units
	for k, this in pairs(t_WaveAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, 1, 4)
		--Util_CreateSquads(player2, this.sgroup, this.unit2, this.spawn)
		Modify_Vulnerability(this.sgroup, 1.4)
		Cmd_SquadPath(this.sgroup, this.path, true, false, true, 0)
		Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_R1, true)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveAlpha_Kickoff) == false then 
		Rule_AddInterval(WaveAlpha_Kickoff, 1)
	end

end

function WaveAlpha_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then 
			this.phase = 5
		end
		if Prox_AreSquadsNearMarker(this.sgroup, EGroup_GetPosition(eg_pnt_R1), ANY, 15) and Player_OwnsEGroup(player2, eg_pnt_R1) == false then 
			Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_R1, true)
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, this.depart)	
			this.phase = 0
			Modifier_RemoveAllFromSGroup(this.sgroup)
		end
	end
end

function WaveBeta_Init()

	tmkr_WaveBeta = Marker_GetTable("mkr_WaveBeta%d")
	tsg_WaveBeta = SGroup_CreateTable("sg_WaveBeta%d", table.getn(tmkr_WaveBeta))
	sg_WaveBeta1 = SGroup_CreateIfNotFound("sg_WaveBeta1")
	sg_WaveBeta2 = SGroup_CreateIfNotFound("sg_WaveBeta2")

	t_WaveBeta = {
		{
			sgroup = sg_WaveBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,
			upgrade = false,
			phase = 2,
			path = "pth_R2a", 	
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
		},
		{
			sgroup = sg_WaveBeta2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			upgrade = false, 
			phase = 2,
			path = "pth_R2b", 
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
		},
	}
	
	for i = 1, table.getn(t_WaveBeta) do
		--t_WaveBeta[i].sgroup = tsg_WaveBeta[i]
		--t_WaveBeta[i].spawn = tmkr_WaveBeta[i]
	end
	
	WaveBeta_Preset()
	
end


function WaveBeta_Preset()
--Spawns the units
	for k, this in pairs(t_WaveBeta) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, 1, 4)
		--Util_CreateSquads(player2, this.sgroup, this.unit2, this.spawn)
		Modify_Vulnerability(this.sgroup, 1.4)
		Cmd_SquadPath(this.sgroup, this.path, true, false, true, 0)
		Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_R2, true)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveBeta_Kickoff) == false then 
		Rule_AddInterval(WaveBeta_Kickoff, 1)
	end

end

function WaveBeta_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveBeta) do
		if SGroup_TotalMembersCount(this.sgroup) < 3 then 
			this.phase = 5
		end
		if Prox_AreSquadsNearMarker(this.sgroup, EGroup_GetPosition(eg_pnt_R2), ANY, 15) and Player_OwnsEGroup(player2, eg_pnt_R2) == false then 
			Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_R2, true)
		end
		
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, this.depart)	
			this.phase = 0
			Modifier_RemoveAllFromSGroup(this.sgroup)			
		end
	end
end

function WaveGamma_Init()

	tmkr_WaveGamma = Marker_GetTable("mkr_WaveGamma%d")
	tsg_WaveGamma = SGroup_CreateTable("sg_WaveGamma%d", table.getn(tmkr_WaveGamma))
	sg_WaveGamma1 = SGroup_CreateIfNotFound("sg_WaveGamma1")
	sg_WaveGamma2 = SGroup_CreateIfNotFound("sg_WaveGamma2")

	t_WaveGamma = {
		{
			sgroup = sg_WaveGamma1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,
			upgrade = false,
			phase = 2,
			path = "pth_R3a", 	
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
		},
		{
			sgroup = sg_WaveGamma2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			upgrade = false, 
			phase = 2,
			path = "pth_R3b", 
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
		},
	}
	
	for i = 1, table.getn(t_WaveGamma) do
		--t_WaveGamma[i].sgroup = tsg_WaveGamma[i]
		--t_WaveGamma[i].spawn = tmkr_WaveGamma[i]
	end
	
	WaveGamma_Preset()
	
end


function WaveGamma_Preset()
--Spawns the units
	for k, this in pairs(t_WaveGamma) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, 1, 4)
		--Util_CreateSquads(player2, this.sgroup, this.unit2, this.spawn)
		Modify_Vulnerability(this.sgroup, 1.4)
		Cmd_SquadPath(this.sgroup, this.path, true, false, true, 0)
		Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_R3, true)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveGamma_Kickoff) == false then 
		Rule_AddInterval(WaveGamma_Kickoff, 1)
	end

end

function WaveGamma_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveGamma) do
		if Prox_AreSquadsNearMarker(this.sgroup, EGroup_GetPosition(eg_pnt_R3), ANY, 15) and Player_OwnsEGroup(player2, eg_pnt_R3) == false then 
			Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_R3, true)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 3 then 
			this.phase = 5
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, this.depart)	
			this.phase = 0
			Modifier_RemoveAllFromSGroup(this.sgroup)				
		end
	end
end


function WaveDelta_Init()

	tmkr_WaveDelta = Marker_GetTable("mkr_WaveDelta%d")
	tsg_WaveDelta = SGroup_CreateTable("sg_WaveDelta%d", table.getn(tmkr_WaveDelta))
	sg_WaveDelta1 = SGroup_CreateIfNotFound("sg_WaveDelta1")
	sg_WaveDelta2 = SGroup_CreateIfNotFound("sg_WaveDelta2")

	t_WaveDelta = {
		{
			sgroup = sg_WaveDelta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,
			upgrade = false,
			phase = 2,
			path = "pth_R4a", 	
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
		},
		{
			sgroup = sg_WaveDelta2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			upgrade = false, 
			phase = 2,
			path = "pth_R4b", 
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
		},
	}
	
	for i = 1, table.getn(t_WaveDelta) do
		--t_WaveDelta[i].sgroup = tsg_WaveDelta[i]
		--t_WaveDelta[i].spawn = tmkr_WaveDelta[i]
	end
	
	WaveDelta_Preset()
	
end


function WaveDelta_Preset()
--Spawns the units
	for k, this in pairs(t_WaveDelta) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, 1, 4)
		--Util_CreateSquads(player2, this.sgroup, this.unit2, this.spawn)
		Modify_Vulnerability(this.sgroup, 1.4)
		Cmd_SquadPath(this.sgroup, this.path, true, false, true, 0)
		Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_R4, true)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveDelta_Kickoff) == false then 
		Rule_AddInterval(WaveDelta_Kickoff, 1)
	end

end

function WaveDelta_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveDelta) do
		if SGroup_TotalMembersCount(this.sgroup) < 3 then 
			this.phase = 5
		end
		if Prox_AreSquadsNearMarker(this.sgroup, EGroup_GetPosition(eg_pnt_R4), ANY, 15) and Player_OwnsEGroup(player2, eg_pnt_R4) == false then 
			Cmd_AttackMoveThenCapture(this.sgroup, eg_pnt_R4, true)
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, this.depart)	
			this.phase = 0
			Modifier_RemoveAllFromSGroup(this.sgroup)				
		end
	end
end







-------------------------------------------------------------------------

-- Interval Units
-- This units once called will recreate themselves over and over until the rule is stopped.  
-- A timer allows the to recreate rate to be slower and slower
-------------------------------------------------------------------------
-- Creates the raft and on its destination, spawns units and tells the units to capture.
function RaftAlpha_Init()
	tmkr_RaftAlpha = Marker_GetTable("mkr_RaftAlpha%d")
	--tsg_RaftAlpha = SGroup_CreateTable("sg_RaftAlpha%d", table.getn(tmkr_RaftAlpha))
	sg_RaftAlpha1 = SGroup_CreateIfNotFound("sg_RaftAlpha1")
	sg_RaftAlpha2 = SGroup_CreateIfNotFound("sg_RaftAlpha2")
	sg_RaftAlpha3 = SGroup_CreateIfNotFound("sg_RaftAlpha3")
	
	eg_RaftAlpha1 = EGroup_CreateIfNotFound("eg_RaftAlpha1")
	eg_RaftAlpha2 = EGroup_CreateIfNotFound("eg_RaftAlpha2")
	eg_RaftAlpha3 = EGroup_CreateIfNotFound("eg_RaftAlpha3")
	
	sg_RaftAlphaAttacker1 = SGroup_CreateIfNotFound("sg_RaftAlphaAttacker1")
	sg_RaftAlphaAttacker2 = SGroup_CreateIfNotFound("sg_RaftAlphaAttacker2")
	sg_RaftAlphaAttacker3 = SGroup_CreateIfNotFound("sg_RaftAlphaAttacker3")
	
	
	t_RaftAlpha = {
		{
			sgroup = sg_RaftAlpha1, 
			egroup = eg_RaftAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch2,
			landing = {mkr_RaftAlpha1a, mkr_RaftAlpha1b, mkr_RaftAlpha1c},
			landing2 = mkr_RaftAlpha1b,
			capture1 = eg_pnt_C1, 
			capture2 = eg_pnt_B2, 
			capture3 = eg_pnt_B1, 
			capture4 = eg_pnt_D2, 
			attacker = sg_RaftAlphaAttacker1, 
			last = mkr_RaftAlphaLast1,

		},
		{
			sgroup = sg_RaftAlpha2, 
			egroup = eg_RaftAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftAlpha2", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch4,
			landing = {mkr_RaftAlpha2a, mkr_RaftAlpha2b, mkr_RaftAlpha2c}, 
			landing2 = mkr_RaftAlpha2b,			
			capture1 = eg_pnt_B1, 
			capture2 = eg_pnt_A1, 
			capture3 = eg_pnt_Heights, 
			capture4 = eg_pnt_D2, 
			attacker = sg_RaftAlphaAttacker2, 
			last = mkr_RaftAlphaLast2,

		},
		
		{
			sgroup = sg_RaftAlpha3, 
			egroup = eg_RaftAlpha3, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftAlpha3", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch5,
			landing = {mkr_RaftAlpha3a, mkr_RaftAlpha3b, mkr_RaftAlpha3c}, 
			landing2 = mkr_RaftAlpha3b,
			capture1 = eg_pnt_C1, 
			capture2 = eg_pnt_B1, 
			capture3 = eg_pnt_B2, 
			capture4 = eg_pnt_A1, 
			attacker = sg_RaftAlphaAttacker3, 
			last = mkr_RaftAlphaLast3,

		},
	}
	RaftAlpha_Preset()
end

function RaftAlpha_Preset()
	for k, this in pairs(t_RaftAlpha) do
	
		Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing),1, 4) 
		SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
		EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")
		Rule_AddSGroupEvent(RaftAlpha_GiveXP, this.sgroup, GE_SquadKilled)
		Modify_ReceivedDamage(this.egroup, mod_boat)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(RaftAlpha_Kickoff) == false then 
		Rule_AddInterval(RaftAlpha_Kickoff, 1)
	end
	if Rule_Exists(RaftAlpha_Respawn) == false then 
		Rule_AddInterval(RaftAlpha_Respawn, 1)
	end
	
end

function RaftAlpha_Respawn()
	for k, this in pairs(t_RaftAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if EGroup_Count(this.egroup) == 0 and SGroup_Count(this.sgroup) == 0  and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing),1, 4) 
			SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			Rule_AddSGroupEvent(RaftAlpha_GiveXP, this.sgroup, GE_SquadKilled)
			Modify_ReceivedDamage(this.egroup, mod_boat)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing2, ANY, 15) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and  g_LandingsStarted == nil  then 
			EGroup_Kill(this.egroup)
		end
	end
end

function RaftAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	for k, this in pairs(t_RaftAlpha) do
		--SGroup_GetLastAttacker(this.sgroup, this.attacker)
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end
		
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_IsCapturing(this.sgroup, ANY) == false then
					if Player_OwnsEGroup(player2, this.capture1) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)				
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
					elseif Player_OwnsEGroup(player2, this.capture2) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
					elseif Player_OwnsEGroup(player2, this.capture3) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
					elseif Player_OwnsEGroup(player2, this.capture4) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
					elseif SGroup_Count(sg_AxisAll) > 0 then
						Cmd_AttackMove(this.sgroup, sg_AxisAll)
					end
				end
			end
		end
		if this.phase == 6 then 
			

			if SGroup_Count(this.sgroup) > 0 then 	
				if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 15) == false then 
					Cmd_Move(this.sgroup, this.last) 
				else
					this.phase = 7
				end
			elseif SGroup_Count(this.sgroup) == 0 then
				this.phase = 7
			end
		end
	end
end

function RaftAlpha_GiveXP()
	Player_AddResource(player1, RT_Action, mod_xp)
end

function RaftBeta_Init()
--units from rafts on the lower side away from the Heights
	tmkr_RaftBeta = Marker_GetTable("mkr_RaftBeta%d")
	--tsg_RaftBeta = SGroup_CreateTable("sg_RaftBeta%d", table.getn(tmkr_RaftBeta))
	sg_RaftBeta1 = SGroup_CreateIfNotFound("sg_RaftBeta1")
	sg_RaftBeta2 = SGroup_CreateIfNotFound("sg_RaftBeta2")
	sg_RaftBeta3 = SGroup_CreateIfNotFound("sg_RaftBeta3")
	
	eg_RaftBeta1 = EGroup_CreateIfNotFound("eg_RaftBeta1")
	eg_RaftBeta2 = EGroup_CreateIfNotFound("eg_RaftBeta2")
	eg_RaftBeta3 = EGroup_CreateIfNotFound("eg_RaftBeta3")
	
	sg_RaftBetaAttacker1 = SGroup_CreateIfNotFound("sg_RaftBetaAttacker1")
	sg_RaftBetaAttacker2 = SGroup_CreateIfNotFound("sg_RaftBetaAttacker2")
	sg_RaftBetaAttacker3 = SGroup_CreateIfNotFound("sg_RaftBetaAttacker3")
	
	
	t_RaftBeta = {
		{
			sgroup = sg_RaftBeta1, 
			egroup = eg_RaftBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftBeta1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch6,
			landing = {mkr_RaftBeta1a, mkr_RaftBeta1b, mkr_RaftBeta1c},
			landing2 = mkr_RaftBeta1b,
			capture1 = eg_pnt_B1, 
			capture2 = eg_pnt_B2, 
			capture3 = eg_pnt_B3, 
			capture4 = eg_pnt_C3, 
			attacker = sg_RaftBetaAttacker1, 
			last = mkr_RaftBetaLast1,

		},
		{
			sgroup = sg_RaftBeta2, 
			egroup = eg_RaftBeta2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftBeta2", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch7,
			landing = {mkr_RaftBeta2a, mkr_RaftBeta2b, mkr_RaftBeta2c}, 
			landing2 = mkr_RaftBeta2b,
			capture1 = eg_pnt_C1, 
			capture2 = eg_pnt_A1, 
			capture3 = eg_pnt_C2, 
			capture4 = eg_pnt_C3, 
			attacker = sg_RaftBetaAttacker2, 
			last = mkr_RaftBetaLast2,
		},
		
		{
			sgroup = sg_RaftBeta3, 
			egroup = eg_RaftBeta3, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftBeta3", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch8,
			landing = {mkr_RaftBeta3a, mkr_RaftBeta3b, mkr_RaftBeta3c},
			landing2 = mkr_RaftBeta3b,
			capture1 = eg_pnt_B1, 
			capture2 = eg_pnt_C2, 
			capture3 = eg_pnt_C3, 
			capture4 = eg_pnt_R1, 
			attacker = sg_RaftBetaAttacker3, 
			last = mkr_RaftBetaLast3,

		},
	}
	RaftBeta_Preset()
end

function RaftBeta_Preset()
	for k, this in pairs(t_RaftBeta) do
		if EGroup_Count(this.egroup) == 0 then 
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing),1, 4) 
			SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")	
			Rule_AddSGroupEvent(RaftBeta_GiveXP, this.sgroup, GE_SquadKilled)
			Modify_ReceivedDamage(this.egroup, mod_boat)
			this.phase = 2
		end

	end
	if Rule_Exists(RaftBeta_Kickoff) == false then 
		Rule_AddInterval(RaftBeta_Kickoff, 1)
	end

	if Rule_Exists(RaftBeta_Respawn) == false then 
		Rule_AddInterval(RaftBeta_Respawn, 1)
	end
end
function RaftBeta_Respawn()
	for k, this in pairs(t_RaftBeta) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if EGroup_Count(this.egroup) == 0 and SGroup_Count(this.sgroup) == 0  and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing),1, 4) 
			SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")	
			Rule_AddSGroupEvent(RaftBeta_GiveXP, this.sgroup, GE_SquadKilled)
			Cmd_InstantUpgrade(this.sgroup, UPG.CW.PIAT)
			Modify_ReceivedDamage(this.egroup, mod_boat)
			Modify_ReceivedDamage(this.egroup, 1)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing2, ANY, 15) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and g_LandingsStarted == nil  then 
			EGroup_Kill(this.egroup)
		end
	end
end

function RaftBeta_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_RaftBeta) do
		--SGroup_GetLastAttacker(this.sgroup, this.attacker)
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end

		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_IsCapturing(this.sgroup, ANY) == false then
					if Player_OwnsEGroup(player2, this.capture1) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)				
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
					elseif Player_OwnsEGroup(player2, this.capture2) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
					elseif Player_OwnsEGroup(player2, this.capture3) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
					elseif Player_OwnsEGroup(player2, this.capture4) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
					elseif SGroup_Count(sg_AxisAll) > 0 then
						Cmd_AttackMove(this.sgroup, sg_AxisAll)
					end
				end
			end
		end
		if this.phase == 6 then 
			

			if SGroup_Count(this.sgroup) > 0 then 	
				if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 15) == false then 
					Cmd_Move(this.sgroup, this.last) 
				else
					this.phase = 7
				end
			elseif SGroup_Count(this.sgroup) == 0 then
				this.phase = 7
			end
		end
	end
end

function RaftBeta_GiveXP()
	Player_AddResource(player1, RT_Action, mod_xp)
end

function RaftGamma_Init()
--units from rafts on the lower side away from the Heights
	tmkr_RaftGamma = Marker_GetTable("mkr_RaftGamma%d")
	--tsg_RaftGamma = SGroup_CreateTable("sg_RaftGamma%d", table.getn(tmkr_RaftGamma))
	sg_RaftGamma1 = SGroup_CreateIfNotFound("sg_RaftGamma1")
	sg_RaftGamma2 = SGroup_CreateIfNotFound("sg_RaftGamma2")
	sg_RaftGamma3 = SGroup_CreateIfNotFound("sg_RaftGamma3")
	
	eg_RaftGamma1 = EGroup_CreateIfNotFound("eg_RaftGamma1")
	eg_RaftGamma2 = EGroup_CreateIfNotFound("eg_RaftGamma2")
	eg_RaftGamma3 = EGroup_CreateIfNotFound("eg_RaftGamma3")
	
	sg_RaftGammaAttacker1 = SGroup_CreateIfNotFound("sg_RaftGammaAttacker1")
	sg_RaftGammaAttacker2 = SGroup_CreateIfNotFound("sg_RaftGammaAttacker2")
	sg_RaftGammaAttacker3 = SGroup_CreateIfNotFound("sg_RaftGammaAttacker3")
	
	
	t_RaftGamma = {
		{
			sgroup = sg_RaftGamma1, 
			egroup = eg_RaftGamma1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftGamma1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch8,
			landing = {mkr_RaftGamma1a, mkr_RaftGamma1b, mkr_RaftGamma1c},
			landing2 = mkr_RaftGamma1b,
			capture1 = eg_pnt_A1, 
			capture2 = eg_pnt_B1, 
			capture3 = eg_pnt_C1, 
			capture4 = eg_pnt_Heights, 
			attacker = sg_RaftGammaAttacker1, 
			last = mkr_RaftGammaLast1,

		},
		{
			sgroup = sg_RaftGamma2, 
			egroup = eg_RaftGamma2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftGamma2", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch9,
			landing = {mkr_RaftGamma2a, mkr_RaftGamma2b, mkr_RaftGamma2c},  
			landing2 = mkr_RaftGamma2b,
			capture1 = eg_pnt_A1, 
			capture2 = eg_pnt_B2, 
			capture3 = eg_pnt_C3, 
			capture4 = eg_pnt_R1, 
			attacker = sg_RaftGammaAttacker2, 
			last = mkr_RaftGammaLast2,

		},
		
		{
			sgroup = sg_RaftGamma3, 
			egroup = eg_RaftGamma3, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_RaftGamma3", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch9,
			landing = {mkr_RaftGamma3a, mkr_RaftGamma3b, mkr_RaftGamma3c},
			landing2 = mkr_RaftGamma3b,
			capture1 = eg_pnt_A1, 
			capture2 = eg_pnt_A2, 
			capture3 = eg_pnt_B3, 
			capture4 = eg_pnt_D2, 
			attacker = sg_RaftGammaAttacker3, 
			last = mkr_RaftGammaLast3,

		},
	}
	RaftGamma_Preset()
end

function RaftGamma_Preset()
	for k, this in pairs(t_RaftGamma) do
		Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing), 1, 4) 
		SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
		EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")	
		Rule_AddSGroupEvent(RaftGamma_GiveXP, this.sgroup, GE_SquadKilled)
		Modify_ReceivedDamage(this.egroup, mod_boat)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(RaftGamma_Kickoff) == false then 
		Rule_AddInterval(RaftGamma_Kickoff, 1)
	end
	if Rule_Exists(RaftGamma_Respawn) == false then 
		Rule_AddInterval(RaftGamma_Respawn, 1)
	end
	
end
function RaftGamma_Respawn()
	for k, this in pairs(t_RaftGamma) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if EGroup_Count(this.egroup) == 0 and SGroup_Count(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , Table_GetRandomItem(this.landing), 1, 4) 
			SGroup_CallEntityFunction(this.sgroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			EGroup_CallEntityFunction(this.egroup, Entity_SetAnimatorAction, "area_cull_override_attach")
			Rule_AddSGroupEvent(RaftGamma_GiveXP, this.sgroup, GE_SquadKilled)
			Modify_ReceivedDamage(this.egroup, mod_boat)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing2, ANY, 15) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and g_LandingsStarted == nil  then 
			EGroup_Kill(this.egroup)
		end

	end
end

function RaftGamma_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_RaftGamma) do
		--SGroup_GetLastAttacker(this.sgroup, this.attacker)
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_IsCapturing(this.sgroup, ANY) == false then
					if Player_OwnsEGroup(player2, this.capture1) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)				
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
					elseif Player_OwnsEGroup(player2, this.capture2) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
					elseif Player_OwnsEGroup(player2, this.capture3) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
					elseif Player_OwnsEGroup(player2, this.capture4) == false then
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
					elseif SGroup_Count(sg_AxisAll) > 0 then
						Cmd_AttackMove(this.sgroup, sg_AxisAll)
					end
				end
			end
		end
		if this.phase == 6 then 
			

			if SGroup_Count(this.sgroup) > 0 then 	
				if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 15) == false then 
					Cmd_Move(this.sgroup, this.last) 
				else
					this.phase = 7
				end
			elseif SGroup_Count(this.sgroup) == 0 then
				this.phase = 7
			end
		end
	end
end


function RaftGamma_GiveXP()
	Player_AddResource(player1, RT_Action, mod_xp)
end


function CrossingAlpha_Init()
--crosses over the river to help the player adjust their site to the other side.  All rafts must be stopped because they will overlap each other if the cross paths.  
	tmkr_CrossingAlpha = Marker_GetTable("mkr_CrossingAlpha%d")
	--tsg_CrossingAlpha = SGroup_CreateTable("sg_CrossingAlpha%d", table.getn(tmkr_CrossingAlpha))
	sg_CrossingAlpha1 = SGroup_CreateIfNotFound("sg_CrossingAlpha1")
	sg_CrossingAlpha2 = SGroup_CreateIfNotFound("sg_CrossingAlpha2")
	sg_CrossingAlpha3 = SGroup_CreateIfNotFound("sg_CrossingAlpha3")
	
	eg_CrossingAlpha1 = EGroup_CreateIfNotFound("eg_CrossingAlpha1")
	eg_CrossingAlpha2 = EGroup_CreateIfNotFound("eg_CrossingAlpha2")
	eg_CrossingAlpha3 = EGroup_CreateIfNotFound("eg_CrossingAlpha3")
	
	sg_CrossingAlphaAttacker1 = SGroup_CreateIfNotFound("sg_CrossingAlphaAttacker1")
	sg_CrossingAlphaAttacker2 = SGroup_CreateIfNotFound("sg_CrossingAlphaAttacker2")
	sg_CrossingAlphaAttacker3 = SGroup_CreateIfNotFound("sg_CrossingAlphaAttacker3")
	
	
	t_CrossingAlpha = {
		{
			sgroup = sg_CrossingAlpha1, 
			egroup = eg_CrossingAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_CrossingAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunchCross1,
			landing = mkr_CrossingAlpha1a, 
			capture1 = eg_pnt_B1, 
			capture2 = eg_pnt_B2, 
			capture3 = eg_pnt_B3, 
			capture4 = eg_pnt_R3, 
			attacker = sg_CrossingAlphaAttacker1, 
			last = mkr_CrossingAlphaLast1,
		},
		{
			sgroup = sg_CrossingAlpha2, 
			egroup = eg_CrossingAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_CrossingAlpha2", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunchCross2,
			landing = mkr_CrossingAlpha2a,   
			capture1 = eg_pnt_B1, 
			capture2 = eg_pnt_B2, 
			capture3 = eg_pnt_C2, 
			capture4 = eg_pnt_Heights, 
			attacker = sg_CrossingAlphaAttacker2, 
			last = mkr_CrossingAlphaLast2,

		},
	}
	CrossingAlpha_Preset()
end

function CrossingAlpha_Preset()
	for k, this in pairs(t_CrossingAlpha) do
		Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , this.landing, 1, 3) 
		Rule_AddSGroupEvent(CrossingAlpha_GiveXP, this.sgroup, GE_SquadKilled)
		Cmd_InstantUpgrade(this.sgroup, UPG.CW.PIAT)
		Modify_ReceivedDamage(this.egroup, mod_boat)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(CrossingAlpha_Kickoff) == false then 
		Rule_AddInterval(CrossingAlpha_Kickoff, 10)
	end

	
end
  

function CrossingAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_CrossingAlpha) do
		--SGroup_GetLastAttacker(this.sgroup, this.attacker)
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
--~ 		if EGroup_Count(this.egroup) == 0  and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
--~ 			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS, this.spawn , this.landing) 
--~ 			Modify_ReceivedDamage(this.egroup, 1)
--~ 			if upgrade ~= nil and upgrade ~= false then
--~ 				Cmd_InstantUpgrade(this.sgroup, upgrade)
--~ 			end
--~ 			this.timer = this.timer 
--~ 			this.phase = 2
--~ 		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing, ANY, 10) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and g_LandingsStarted == nil then 
			EGroup_Kill(this.egroup)
		end
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_Count(sg_AxisTank) > 0 then 
					--SGroup_Single(this.tank, Util_GetClosestSquadPosition(sg_AxisTank, this.sgroup))
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisTank, SGroup_GetPosition(this.sgroup)))
				elseif SGroup_Count(sg_AxisTank) == 0 and SGroup_Count(sg_AxisAll) > 0  then
					Cmd_AttackMove(this.sgroup,  Util_GetClosestSquadPosition(sg_AxisAll, SGroup_GetPosition(this.sgroup)))
				end
			end
		end
		if this.phase == 6 then 
			
			if SGroup_Count(this.sgroup) > 0 then
				if Prox_AreSquadsNearMarker(this.sgroup, this.last, ANY, 15) == false then 
					Cmd_Move(this.sgroup, this.last) 
				else
					this.phase = 7
				end
			elseif SGroup_Count(this.sgroup) == 0 then
				this.phase = 7
			end
		end
	end
end


function CrossingAlpha_GiveXP()
	Player_AddResource(player1, RT_Action, mod_xp)
end




function PropertyAlpha_Init()
--picks the closest territory and tries to capture it.  
	--tmkr_PropertyAlpha = Marker_GetTable("mkr_PropertyAlpha%d")
	--tsg_PropertyAlpha = SGroup_CreateTable("sg_PropertyAlpha%d", table.getn(tmkr_PropertyAlpha))
	sg_PropertyAlpha1 = SGroup_CreateIfNotFound("sg_PropertyAlpha1")
	sg_PropertyAlpha2 = SGroup_CreateIfNotFound("sg_PropertyAlpha2")
	sg_PropertyAlpha3 = SGroup_CreateIfNotFound("sg_PropertyAlpha3")
	
	sg_PropertyAlphaAttacker1 = SGroup_CreateIfNotFound("sg_PropertyAlphaAttacker1")
	sg_PropertyAlphaAttacker2 = SGroup_CreateIfNotFound("sg_PropertyAlphaAttacker2")
	sg_PropertyAlphaAttacker3 = SGroup_CreateIfNotFound("sg_PropertyAlphaAttacker3")
	
	eg_PropertyAlpha1 = EGroup_CreateIfNotFound("eg_PropertyAlpha1")

	eg_PropertyAlphaPoint1 = EGroup_CreateIfNotFound("eg_PropertyAlphaPoint1")
	
	t_PropertyAlpha = {
		{
			sgroup = sg_PropertyAlpha1, 
			egroup = eg_PropertyAlpha1,
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_PropertyAlpha1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_RaftLaunch10,
			point = eg_PropertyAlphaPoint1, 
			landing = mkr_Property1a,
			attacker = sg_PropertyAlphaAttacker1, 
			last = mkr_PropertyAlphaLast1,

		},
	}
	PropertyAlpha_Preset()
end

function PropertyAlpha_Preset()
	for k, this in pairs(t_PropertyAlpha) do
		Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , this.landing, 1, 4) 
		Modify_ReceivedDamage(this.egroup, mod_boat)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(PropertyAlpha_Kickoff) == false then 
		Rule_AddInterval(PropertyAlpha_Kickoff, 5)
	end
	if Rule_Exists(PropertyAlpha_Respawn) == false then 
		Rule_AddInterval(PropertyAlpha_Respawn, 5)
	end
	
	
end

function PropertyAlpha_Respawn()
	for k, this in pairs(t_PropertyAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and EGroup_Count(this.egroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_SpawnRaft(player2, this.egroup, this.sgroup, SBP.CW.COMMANDOS_NOVETRANCY_SP, this.spawn , this.landing, 1, 4) 
			Modify_ReceivedDamage(this.egroup, mod_boat)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if Prox_AreEntitiesNearMarker(this.egroup, this.landing, ANY, 1) and EGroup_IsOnScreen(player1, this.egroup, ANY) == false and EGroup_IsHoldingAny(this.egroup) == false and SGroup_Count(this.sgroup) == 0 and g_LandingsStarted == nil  then 
			EGroup_Kill(this.egroup)
		end
		
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end

function PropertyAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_PropertyAlpha) do
		
		SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 60) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
					SGroup_GetLastAttacker(this.sgroup, this.attacker)
					if SGroup_Count(this.attacker) > 0 then 
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
					
						Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_BACK, 60, true)
						--Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)
					end
				elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
					if Player_OwnsEGroup(player1, eg_AllPoints) == true then 
						EGroup_Single(this.point, Util_GetClosestStrategicPointCapturableByPlayer(eg_AllPoints, this.sgroup, player2))
						if SGroup_IsCapturing(this.sgroup, ANY) == false then 
							Cmd_AttackMoveThenCapture(this.sgroup, this.point)
						end
					end
				end
			end
		end
	end
end 
  
  
  
  
  
  
function AirborneAlpha_Init()
	tmkr_AirborneAlpha = Marker_GetTable("mkr_AirborneAlpha%d")
	--tsg_AirborneAlpha = SGroup_CreateTable("sg_AirborneAlpha%d", table.getn(tmkr_AirborneAlpha))
	sg_AirborneAlpha1 = SGroup_CreateIfNotFound("sg_AirborneAlpha1")
	sg_AirborneAlpha2 = SGroup_CreateIfNotFound("sg_AirborneAlpha2")
	sg_AirborneAlpha3 = SGroup_CreateIfNotFound("sg_AirborneAlpha3")
	
	sg_AirborneAlphaAttacker1 = SGroup_CreateIfNotFound("sg_AirborneAlphaAttacker1")
	sg_AirborneAlphaAttacker2 = SGroup_CreateIfNotFound("sg_AirborneAlphaAttacker2")
	sg_AirborneAlphaAttacker3 = SGroup_CreateIfNotFound("sg_AirborneAlphaAttacker3")
	
	
	t_AirborneAlpha = {
		{
			sgroup = sg_AirborneAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = UPG.CW.BREN,
			timername = "tmr_AirborneAlpha1", 
			timer = 20, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			capture1 = eg_pnt_Oosterbeek2, 
			capture2 = eg_pnt_D3, 
			capture3 = eg_pnt_D4, 
			capture4 = eg_pnt_C4, 
			attacker = sg_AirborneAlphaAttacker1, 

		},
--~ 		{
--~ 			sgroup = sg_AirborneAlpha2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = UPG.CW.RIFLE_GRENADE,
--~ 			timername = "tmr_AirborneAlpha1", 
--~ 			timer = 20, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn1,
--~ 			capture1 = eg_pnt_D2, 
--~ 			capture2 = eg_pnt_D3, 
--~ 			capture3 = eg_pnt_Heights, 
--~ 			capture4 = eg_pnt_D1, 
--~ 			attacker = sg_AirborneAlphaAttacker1, 

--~ 		},
	}
	AirborneAlpha_Preset()
end

function AirborneAlpha_Preset()
	for k, this in pairs(t_AirborneAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 3)
		--Modify_Vulnerability(this.sgroup, 2.2)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(AirborneAlpha_Respawn) == false then 
		Rule_AddInterval(AirborneAlpha_Respawn, 1)
	end

	if Rule_Exists(AirborneAlpha_Kickoff) == false then 
		Rule_AddInterval(AirborneAlpha_Kickoff, 1)
	end

	
end
  
function AirborneAlpha_Respawn()
  	for k, this in pairs(t_AirborneAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 3)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end	
  
end
function AirborneAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_AirborneAlpha) do
		if SGroup_Count(this.sgroup) > 0 then
			--SGroup_GetLastAttacker(this.sgroup, this.attacker)
			
			if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
				SGroup_Clear(this.attacker)
				
			end
			
			if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
				--this.phase = 5
			end
	
			if this.phase == 2 then 
			
				if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
					
					SGroup_GetLastAttacker(this.sgroup, this.attacker)
					if SGroup_Count(this.attacker) > 0 then 
						if SGroup_TotalMembersCount(this.sgroup) > SGroup_TotalMembersCount(this.attacker) then 
							Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)					
						else
							Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
							Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_FRONT_RIGHT, 120, true)
						end
					end
				elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_IsCapturing(this.sgroup, ANY) == false then
					if Player_OwnsEGroup(player2, this.capture1) == false then 
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
					elseif Player_OwnsEGroup(player2, this.capture2) == false then
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
					elseif Player_OwnsEGroup(player2, this.capture3) == false then
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
					elseif Player_OwnsEGroup(player2, this.capture4) == false then
						Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
					else
						Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
					end
				end
			end
			if this.phase == 5 then 
				Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
				Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
			end
		end
	end
end

-------------------------------------------------------------------------

-- Interval Units
-- This units once called will recreate themselves over and over until the rule is stopped.  
-- A timer allows the to recreate rate to be slower and slower
-------------------------------------------------------------------------
function AirborneBeta_Init()
	tmkr_AirborneBeta = Marker_GetTable("mkr_AirborneBeta%d")
	--tsg_AirborneBeta = SGroup_CreateTable("sg_AirborneBeta%d", table.getn(tmkr_AirborneBeta))
	sg_AirborneBeta1 = SGroup_CreateIfNotFound("sg_AirborneBeta1")
	sg_AirborneBeta2 = SGroup_CreateIfNotFound("sg_AirborneBeta2")
	sg_AirborneBeta3 = SGroup_CreateIfNotFound("sg_AirborneBeta3")
	
	sg_AirborneBetaAttacker1 = SGroup_CreateIfNotFound("sg_AirborneBetaAttacker1")

	t_AirborneBeta = {
		{
			sgroup = sg_AirborneBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = UPG.CW.RIFLE_GRENADE,
			timername = "tmr_AirborneBeta1", 
			timer = 20, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			capture1 = eg_pnt_C4, 
			capture2 = eg_pnt_D4, 
			capture3 = eg_pnt_R2, 
			capture4 = eg_pnt_R1, 
			attacker = sg_AirborneBetaAttacker1, 

		},
		{
			sgroup = sg_AirborneBeta2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = UPG.CW.RIFLE_GRENADE,
			timername = "tmr_AirborneBeta2", 
			timer = 20, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			capture1 = eg_pnt_D4, 
			capture2 = eg_pnt_C4, 
			capture3 = eg_pnt_R2, 
			capture4 = eg_pnt_R1, 
			attacker = sg_AirborneBetaAttacker1, 

		},

	}
	AirborneBeta_Preset()
end

function AirborneBeta_Preset()
	for k, this in pairs(t_AirborneBeta) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.TOMMIES, this.spawn, nil, 1, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(AirborneBeta_Respawn) == false then 
		Rule_AddInterval(AirborneBeta_Respawn, 10)
	end
	
	if Rule_Exists(AirborneBeta_Kickoff) == false then 
		Rule_AddInterval(AirborneBeta_Kickoff, 10)
	end
	
end

function AirborneBeta_Respawn()
	for k, this in pairs(t_AirborneBeta) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.TOMMIES, this.spawn, nil, 1, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end
		

function AirborneBeta_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_AirborneBeta) do
		
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end
		
--~ 		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
--~ 			this.phase = 5
--~ 		end

		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					if SGroup_TotalMembersCount(this.sgroup) > SGroup_TotalMembersCount(this.attacker) then 
						Cmd_AttackMove(this.sgroup, this.attacker)						
					else
						Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_FRONT_RIGHT, 120, true)
					end
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0 and SGroup_IsCapturing(this.sgroup, ANY) == false then
				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				else
					Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
				end
			end
		end
		if this.phase == 5 then
			Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))
		end
	end
end

function AirborneGamma_Init()
	tmkr_AirborneGamma = Marker_GetTable("mkr_AirborneGamma%d")
	--tsg_AirborneGamma = SGroup_CreateTable("sg_AirborneGamma%d", table.getn(tmkr_AirborneGamma))
	sg_AirborneGamma1 = SGroup_CreateIfNotFound("sg_AirborneGamma1")
	sg_AirborneGamma2 = SGroup_CreateIfNotFound("sg_AirborneGamma2")
	sg_AirborneGamma3 = SGroup_CreateIfNotFound("sg_AirborneGamma3")
	
	eg_AirborneGamma1 = EGroup_CreateIfNotFound("eg_AirborneGamma1")
	
	sg_AirborneGammaAttacker1 = SGroup_CreateIfNotFound("sg_AirborneGammaAttacker1")

	t_AirborneGamma = {
		{
			sgroup = sg_AirborneGamma1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_AirborneGamma1", 
			timer = 20, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			egroup = eg_AirborneGamma1,
			attacker = sg_AirborneGammaAttacker1, 

		},

	}
	AirborneGamma_Preset()
end

function AirborneGamma_Preset()
	for k, this in pairs(t_AirborneGamma) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(AirborneGamma_Kickoff) == false then 
		Rule_AddInterval(AirborneGamma_Kickoff, 5)
	end
	
end



function AirborneGamma_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_AirborneGamma) do
		
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
			this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 and SGroup_Count(sg_AllyFlak) < 3 and SGroup_Count(sg_AllyFlak) > 0  then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if EGroup_Count(eg_AllFlak) > 0 then 
				EGroup_Single(this.egroup, Util_GetClosestFreeEntity(eg_AllFlak, this.sgroup))
				Cmd_CaptureTeamWeapon(this.sgroup, this.egroup) 
			elseif EGroup_Count(eg_AllFlak) == 0  and SGroup_Count(sg_AxisAll) > 0 then
				Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)		
				Cmd_AttackMove(this.sgroup,  Util_GetClosestSquadPosition(sg_AxisAll, SGroup_GetPosition(this.sgroup)))
			end	
		end
		if this.phase == 5 then
			Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))
		end
	end
end






function BazookaAlpha_Init()
	tmkr_BazookaAlpha = Marker_GetTable("mkr_BazookaAlpha%d")
	--tsg_BazookaAlpha = SGroup_CreateTable("sg_BazookaAlpha%d", table.getn(tmkr_BazookaAlpha))
	sg_BazookaAlpha1 = SGroup_CreateIfNotFound("sg_BazookaAlpha1")
	sg_BazookaAlpha2 = SGroup_CreateIfNotFound("sg_BazookaAlpha2")
	sg_BazookaAlpha3 = SGroup_CreateIfNotFound("sg_BazookaAlpha3")
	
	sg_BazookaAlphaAttacker1 = SGroup_CreateIfNotFound("sg_BazookaAlphaAttacker1")
	sg_BazookaAlphaAttacker2 = SGroup_CreateIfNotFound("sg_BazookaAlphaAttacker2")
	sg_BazookaAlphaAttacker3 = SGroup_CreateIfNotFound("sg_BazookaAlphaAttacker3")
	
	eg_BazookaAlphaAttacker1 = EGroup_CreateIfNotFound("eg_BazookaAlphaAttacker1")
	eg_BazookaAlphaAttacker2 = EGroup_CreateIfNotFound("eg_BazookaAlphaAttacker2")
	eg_BazookaAlphaAttacker3 = EGroup_CreateIfNotFound("eg_BazookaAlphaAttacker3")
	
	t_BazookaAlpha = {
		{
			sgroup = sg_BazookaAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_BazookaAlpha1", 
			timer = 20, 
			count = 4, 
			phase = 2,
			spawn = mkr_SpawnBuilding1,
			egroup = eg_AxisAll, 
			egroupattack = eg_BazookaAlphaAttacker1, 
			attacker = sg_BazookaAlphaAttacker1, 

		},
--~ 		{
--~ 			sgroup = sg_BazookaAlpha2,
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,			
--~ 			timername = "tmr_BazookaAlpha2", 
--~ 			timer = 60, 
--~ 			upgrade = false, 
--~ 			count = 4,
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn2,
--~ 			capture1 = eg_pnt_R1, 
--~ 			capture2 = eg_pnt_R2, 
--~ 			capture3 = eg_pnt_R3, 
--~ 			capture4 = eg_pnt_R4, 
--~ 			attacker = sg_BazookaAlphaAttacker2, 
--~ 		},
	}
	BazookaAlpha_Preset()
end

function BazookaAlpha_Preset()
	for k, this in pairs(t_BazookaAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
		Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
		this.phase = 2

	end
	if Rule_Exists(BazookaAlpha_Respawn) == false then 
		Rule_AddInterval(BazookaAlpha_Respawn, 5)
	end
	
	if Rule_Exists(BazookaAlpha_Kickoff) == false then 
		Rule_AddInterval(BazookaAlpha_Kickoff, 5)
	end
	
	
end
 function BazookaAlpha_Respawn()
	for k, this in pairs(t_BazookaAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
			Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end
function BazookaAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_BazookaAlpha) do
		if SGroup_Count(this.sgroup) > 0 then 
		--SGroup_GetLastAttacker(this.sgroup, this.attacker) 
			if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
				SGroup_Clear(this.attacker)
			end
			
			if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
				--this.phase = 5
			end
	
			
			if this.phase == 2 then 
				if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
					SGroup_GetLastAttacker(this.sgroup, this.attacker)
					if SGroup_Count(this.attacker) > 0 then 
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
					
						
						--Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)
					end
				elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
					
					if EGroup_Count(this.egroup) > 0 then 
						EGroup_Single(eg_BazookaAlphaAttacker1, Util_GetClosestAllyEntity(this.egroup, SGroup_GetPosition(this.sgroup)))
						Cmd_AttackMove(this.sgroup, eg_BazookaAlphaAttacker1)
						
					elseif EGroup_Count(this.egroup) == 0 and SGroup_Count(sg_AxisAll) > 0  then
						Cmd_AttackMove(this.sgroup,  Util_GetClosestSquadPosition(sg_AxisAll, SGroup_GetPosition(this.sgroup)))
					end
				end
			end
			if this.phase == 5 then 
				Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
			end
		end
	end
end


function BazookaBeta_Init()
	tmkr_BazookaBeta = Marker_GetTable("mkr_BazookaBeta%d")
	--tsg_BazookaBeta = SGroup_CreateTable("sg_BazookaBeta%d", table.getn(tmkr_BazookaBeta))
	sg_BazookaBeta1 = SGroup_CreateIfNotFound("sg_BazookaBeta1")
	sg_BazookaBeta2 = SGroup_CreateIfNotFound("sg_BazookaBeta2")
	sg_BazookaBeta3 = SGroup_CreateIfNotFound("sg_BazookaBeta3")
	
	sg_BazookaBetaAttacker1 = SGroup_CreateIfNotFound("sg_BazookaBetaAttacker1")
	sg_BazookaBetaAttacker2 = SGroup_CreateIfNotFound("sg_BazookaBetaAttacker2")
	sg_BazookaBetaAttacker3 = SGroup_CreateIfNotFound("sg_BazookaBetaAttacker3")

	sg_BazookaBetaTank1 = SGroup_CreateIfNotFound("sg_BazookaBetaTank1 ")

	
	t_BazookaBeta = {
		{
			sgroup = sg_BazookaBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_BazookaBeta1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			egroup = eg_AxisAll, 
			attacker = sg_BazookaBetaAttacker1, 
			tank = sg_BazookaBetaTank1, 
		},
	}
	BazookaBeta_Preset()
end

function BazookaBeta_Preset()
	for k, this in pairs(t_BazookaBeta) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
		Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
		this.phase = 2

	end
	if Rule_Exists(BazookaBeta_Kickoff) == false then 
		Rule_AddInterval(BazookaBeta_Kickoff, 5)
	end
	
	
end
  

function BazookaBeta_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_BazookaBeta) do
		
		--SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
			--this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
			Cmd_InstantUpgrade(this.sgroup, UPG.CW.RIFLE_GRENADE)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
				
					Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_BACK, 10, true)
					--Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
				if SGroup_Count(sg_AxisTank) > 0 then 
					--SGroup_Single(this.tank, Util_GetClosestSquadPosition(sg_AxisTank, this.sgroup))
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisTank, SGroup_GetPosition(this.sgroup)))
				elseif SGroup_Count(sg_AxisTank) == 0 and SGroup_Count(sg_AxisAll) > 0  then
					Cmd_AttackMove(this.sgroup,  Util_GetClosestSquadPosition(sg_AxisAll, SGroup_GetPosition(his.sgroup)))
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end














function MortarAlpha_Init()
	tmkr_MortarAlpha = Marker_GetTable("mkr_MortarAlpha%d")
	--tsg_MortarAlpha = SGroup_CreateTable("sg_MortarAlpha%d", table.getn(tmkr_MortarAlpha))
	sg_MortarAlpha1 = SGroup_CreateIfNotFound("sg_MortarAlpha1")
	sg_MortarAlpha2 = SGroup_CreateIfNotFound("sg_MortarAlpha2")
	sg_MortarAlpha3 = SGroup_CreateIfNotFound("sg_MortarAlpha3")
	
	sg_MortarAlphaAttacker1 = SGroup_CreateIfNotFound("sg_MortarAlphaAttacker1")
	sg_MortarAlphaAttacker2 = SGroup_CreateIfNotFound("sg_MortarAlphaAttacker2")
	sg_MortarAlphaAttacker3 = SGroup_CreateIfNotFound("sg_MortarAlphaAttacker3")
	
	
	t_MortarAlpha = {
		{
			sgroup = sg_MortarAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MortarAlpha1", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			egroup = eg_AxisAll, 
			attacker = sg_MortarAlphaAttacker1, 
			ability = ABILITY.ALLIES.MORTAR_BARRAGE, 
			sgroupenemy = sg_AxisAll, 

		},
--~ 		{
--~ 			sgroup = sg_MortarAlpha2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_MortarAlpha2", 
--~ 			timer = 60, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn1,
--~ 			egroup = eg_AxisAll, 
--~ 			attacker = sg_MortarAlphaAttacker2, 
--~ 			ability = ABILITY.ALLIES.MORTAR_SMOKE,
--~ 			sgroupenemy = sg_AxisAll, 
--~ 		},
	}
	MortarAlpha_Preset()
end

function MortarAlpha_Preset()
	for k, this in pairs(t_MortarAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MORTAR, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(MortarAlpha_Respawn) == false then 
		Rule_AddInterval(MortarAlpha_Respawn, 1)
	end
	if Rule_Exists(MortarAlpha_Kickoff) == false then 
		Rule_AddInterval(MortarAlpha_Kickoff, 1)
	end
	
	
end
function MortarAlpha_Respawn()
	for k, this in pairs(t_MortarAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MORTAR, this.spawn)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end

function MortarAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_MortarAlpha) do
		if SGroup_Count(this.sgroup) > 0 then 
			if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
				SGroup_Clear(this.attacker)
			end
	
			if this.phase == 2 then 
				if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
					SGroup_GetLastAttacker(this.sgroup, this.attacker)
					if SGroup_Count(this.attacker) > 0 then 
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
					
						Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
					end
--~ 				elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
--~ 					if EGroup_Count(this.egroup) > 0 then 
--~ 						Cmd_Ability(this.sgroup, this.ability, Util_GetClosestEntityPosition(this.egroup, SGroup_GetPosition(this.sgroup)), nil, true)
--~ 					elseif SGroup_Count(this.sgroupenemy) > 0 then 
--~ 						Cmd_Ability(this.sgroup, this.ability, Util_GetClosestSquadPosition(this.sgroupenemy, SGroup_GetPosition(this.sgroup)), nil, true)
--~ 					end
				end
			end
		end

	end
end






function MGAlpha_Init()
	tmkr_MGAlpha = Marker_GetTable("mkr_MGAlpha%d")
	--tsg_MGAlpha = SGroup_CreateTable("sg_MGAlpha%d", table.getn(tmkr_MGAlpha))
	sg_MGAlpha1 = SGroup_CreateIfNotFound("sg_MGAlpha1")
	sg_MGAlpha2 = SGroup_CreateIfNotFound("sg_MGAlpha2")
	sg_MGAlpha3 = SGroup_CreateIfNotFound("sg_MGAlpha3")
	
	sg_MGAlphaAttacker1 = SGroup_CreateIfNotFound("sg_MGAlphaAttacker1")
	sg_MGAlphaAttacker2 = SGroup_CreateIfNotFound("sg_MGAlphaAttacker2")
	sg_MGAlphaAttacker3 = SGroup_CreateIfNotFound("sg_MGAlphaAttacker3")
	
	t_MGAlpha = {
		{
			sgroup = sg_MGAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MGAlpha1", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			sgroupenemy = sg_AxisAll, 
			attacker = sg_MGAlphaAttacker1, 

		},
--~ 		{
--~ 			sgroup = sg_MGAlpha2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_MGAlpha2", 
--~ 			timer = 60, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn1,
--~ 			sgroupenemy = sg_AxisAll, 
--~ 			attacker = sg_MGAlphaAttacker2, 
--~ 		},
	}
	MGAlpha_Preset()
end

function MGAlpha_Preset()
	for k, this in pairs(t_MGAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MG, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(MGAlpha_Kickoff) == false then 
		Rule_AddInterval(MGAlpha_Kickoff, 1)
	end
	
	
end
  

function MGAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_MGAlpha) do
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MG, this.spawn)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_CanSeeSGroup(this.sgroup, this.sgroupenemy, ANY) == false then
				if SGroup_Count(this.sgroupenemy) > 0 then 
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(this.sgroupenemy, SGroup_GetPosition(this.sgroup)))
				else
					Cmd_Stop(this.sgroup)
				end
			else
				if SGroup_IsUnderAttackFromDirection(this.sgroup, ANY, OFFSET_DIRECTION_BACK, 1) then 
					SGroup_GetLastAttacker(this.sgroup, this.attacker)
					if SGroup_Count(this.attacker) > 0 then 
						Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
						Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
					end
				else		
					Cmd_InstantSetupTeamWeapon(this.sgroup)
					
				end
			end
		end
	end
end










function GarrisonAlpha_Init()
	tmkr_GarrisonAlpha = Marker_GetTable("mkr_GarrisonAlpha%d")
	--tsg_GarrisonAlpha = SGroup_CreateTable("sg_GarrisonAlpha%d", table.getn(tmkr_GarrisonAlpha))
	sg_GarrisonAlpha1 = SGroup_CreateIfNotFound("sg_GarrisonAlpha1")
	sg_GarrisonAlpha2 = SGroup_CreateIfNotFound("sg_GarrisonAlpha2")
	sg_GarrisonAlpha3 = SGroup_CreateIfNotFound("sg_GarrisonAlpha3")
	
	sg_GarrisonAlphaAttacker1 = SGroup_CreateIfNotFound("sg_GarrisonAlphaAttacker1")
	sg_GarrisonAlphaAttacker2 = SGroup_CreateIfNotFound("sg_GarrisonAlphaAttacker2")
	sg_GarrisonAlphaAttacker3 = SGroup_CreateIfNotFound("sg_GarrisonAlphaAttacker3")
	
	eg_GarrisonAlpha1 = EGroup_CreateIfNotFound("eg_GarrisonAlpha1")
	
	eg_GarrisonAlphaRemove = EGroup_CreateIfNotFound("eg_GarrisonAlphaRemove")
	
	t_GarrisonAlpha = {
		{
			sgroup = sg_GarrisonAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GarrisonAlpha1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			attacker = sg_GarrisonAlphaAttacker1, 
			egroup = eg_blg_AllBuildings,  
			holdegroup = eg_GarrisonAlpha1,


		},
	}
	GarrisonAlpha_Preset()
end

function GarrisonAlpha_Preset()
	for k, this in pairs(t_GarrisonAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(GarrisonAlpha_Respawn) == false then 
		Rule_AddInterval(GarrisonAlpha_Respawn, 5)
	end
	if Rule_Exists(GarrisonAlpha_Kickoff) == false then 
		Rule_AddInterval(GarrisonAlpha_Kickoff, 5)
	end
	
end
function GarrisonAlpha_Respawn()
	for k, this in pairs(t_GarrisonAlpha) do	
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end  

function GarrisonAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_GarrisonAlpha) do
		if SGroup_Count(this.sgroup) > 0 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker) 
			
			if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 150) == false then 
				SGroup_Clear(this.attacker)
			end
			if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
				--this.phase = 5
			end
	
			if this.phase == 2 then 
				if SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false  then 
					if SGroup_Count(sg_AxisAll) > 0 then 
						Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, SGroup_GetPosition(this.sgroup)))
					else
						
					end
				elseif SGroup_IsUnderAttack(this.sgroup, ANY, 5) == true and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_Count(this.attacker) > 0 then 	
					StripWeakBuildings(this.egroup)
					EGroup_Single(eg_GarrisonAlphaRemove, Util_GetClosestFreeEntity(this.egroup, SGroup_GetPosition(this.sgroup)))
					Cmd_Garrison(this.sgroup, eg_GarrisonAlphaRemove)
						
					
				elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == true then 
					SGroup_GetHoldEGroup(this.sgroup, this.holdegroup)
					if	EGroup_GetAvgHealth(eg_GarrisonAlphaRemove) < 0.8 or SGroup_IsDoingAttack(this.sgroup, ANY, 10) == false then 
						Cmd_UngarrisonSquad(this.sgroup)
						--Cmd_Ungarrison((this.sgroup, mkr_BeaconAlpha2) 
						
						StripWeakBuildings(this.egroup)
					end
				end
			end
			if this.phase == 5 then 
				Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
			end
		end
	end
end



function GarrisonBeta_Init()
	tmkr_GarrisonBeta = Marker_GetTable("mkr_GarrisonBeta%d")
	--tsg_GarrisonBeta = SGroup_CreateTable("sg_GarrisonBeta%d", table.getn(tmkr_GarrisonBeta))
	sg_GarrisonBeta1 = SGroup_CreateIfNotFound("sg_GarrisonBeta1")
	sg_GarrisonBeta2 = SGroup_CreateIfNotFound("sg_GarrisonBeta2")
	sg_GarrisonBeta3 = SGroup_CreateIfNotFound("sg_GarrisonBeta3")
	
	sg_GarrisonBetaAttacker1 = SGroup_CreateIfNotFound("sg_GarrisonBetaAttacker1")
	sg_GarrisonBetaAttacker2 = SGroup_CreateIfNotFound("sg_GarrisonBetaAttacker2")
	sg_GarrisonBetaAttacker3 = SGroup_CreateIfNotFound("sg_GarrisonBetaAttacker3")
	
	eg_GarrisonBeta1 = EGroup_CreateIfNotFound("eg_GarrisonBeta1")
	
	eg_GarrisonBetaRemove = EGroup_CreateIfNotFound("eg_GarrisonBetaRemove")
	
	t_GarrisonBeta = {
		{
			sgroup = sg_GarrisonBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GarrisonBeta1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			attacker = sg_GarrisonBetaAttacker1, 
			egroup = eg_blg_AllBuildings,   
			holdegroup = eg_GarrisonBeta1,


		},
	}
	GarrisonBeta_Preset()
end

function GarrisonBeta_Preset()
	for k, this in pairs(t_GarrisonBeta) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MG, this.spawn, nil, 1, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(GarrisonBeta_Respawn) == false then 
		Rule_AddInterval(GarrisonBeta_Respawn, 5)
	end
	if Rule_Exists(GarrisonBeta_Kickoff) == false then 
		Rule_AddInterval(GarrisonBeta_Kickoff, 5)
	end
	
end
  

function GarrisonBeta_Respawn()
	for k, this in pairs(t_GarrisonBeta) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MG, this.spawn, nil, 1, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end
function GarrisonBeta_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_GarrisonBeta) do
		if SGroup_Count(this.sgroup) > 0  then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker) 
			
			if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 150) == false then 
				SGroup_Clear(this.attacker)
			end
			if SGroup_TotalMembersCount(this.sgroup) < 2 and SGroup_Count(this.sgroup) > 0 then
				--this.phase = 5
			end
	
			if this.phase == 2 then 
				if SGroup_IsUnderAttack(this.sgroup, ANY, 10) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false  then 
					if SGroup_Count(sg_AxisAll) > 0 then 
						Cmd_Move(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					
					end
				elseif SGroup_IsUnderAttack(this.sgroup, ANY, 10) == true and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_Count(this.attacker) > 0 then 	
					StripWeakBuildings2(this.egroup)
					EGroup_Single(eg_GarrisonBetaRemove, Util_GetClosestFreeEntity(this.egroup, this.sgroup))
						
					Cmd_Garrison(this.sgroup, eg_GarrisonBetaRemove)
					
				elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == true  then 
					SGroup_GetHoldEGroup(this.sgroup, this.holdegroup)
					if	EGroup_GetAvgHealth(eg_GarrisonBetaRemove) < 0.95 or SGroup_IsUnderAttack(this.sgroup, ANY, 10) == false then 
						
						Cmd_UngarrisonSquad(this.sgroup)
						--Cmd_Ungarrison((this.sgroup, mkr_BeaconBeta2) 
						
						StripWeakBuildings2(this.egroup)
					end
				end
			end
			if this.phase == 5 then 
				Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
			end
		end
	end
end

function StripWeakBuildings2(egroup)
	local _CheckBuilding  = function(gid, idx, eid)
		local health = Entity_GetHealth(eid) / Entity_GetHealthMax(eid)
		
		if health < 0.95 then 
			EGroup_Remove(gid, eid)
		end
	end
	EGroup_ForEach(egroup, _CheckBuilding)
end

 function GarrisonGamma_Init()
	tmkr_GarrisonGamma = Marker_GetTable("mkr_GarrisonGamma%d")
	--tsg_GarrisonGamma = SGroup_CreateTable("sg_GarrisonGamma%d", table.getn(tmkr_GarrisonGamma))
	sg_GarrisonGamma1 = SGroup_CreateIfNotFound("sg_GarrisonGamma1")
	sg_GarrisonGamma2 = SGroup_CreateIfNotFound("sg_GarrisonGamma2")
	sg_GarrisonGamma3 = SGroup_CreateIfNotFound("sg_GarrisonGamma3")
	
	sg_GarrisonGammaAttacker1 = SGroup_CreateIfNotFound("sg_GarrisonGammaAttacker1")
	sg_GarrisonGammaAttacker2 = SGroup_CreateIfNotFound("sg_GarrisonGammaAttacker2")
	sg_GarrisonGammaAttacker3 = SGroup_CreateIfNotFound("sg_GarrisonGammaAttacker3")
	
	eg_GarrisonGamma1 = EGroup_CreateIfNotFound("eg_GarrisonGamma1")
	
	eg_GarrisonGammaRemove = EGroup_CreateIfNotFound("eg_GarrisonGammaRemove")
	
	t_GarrisonGamma = {
		{
			sgroup = sg_GarrisonGamma1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GarrisonGamma1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			attacker = sg_GarrisonGammaAttacker1, 
			egroup = eg_blg_AllBuildings,  
			holdegroup = eg_GarrisonGamma1,


		},

	}
	GarrisonGamma_Preset()
end

function GarrisonGamma_Preset()
	for k, this in pairs(t_GarrisonGamma) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MG, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(GarrisonGamma_Respawn) == false then 
		Rule_AddInterval(GarrisonGamma_Respawn, 10)
	end
	if Rule_Exists(GarrisonGamma_Kickoff) == false then 
		Rule_AddInterval(GarrisonGamma_Kickoff, 10)
	end
	
end
  
function GarrisonGamma_Respawn()
	
	for k, this in pairs(t_GarrisonGamma) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MG, this.spawn)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end

function GarrisonGamma_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_GarrisonGamma) do
		SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 150) == false then 
			SGroup_Clear(this.attacker)
		end

		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 10) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false  then 
				if SGroup_Count(sg_AxisAll) > 0 then 
					Cmd_Move(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, SGroup_GetPosition(this.sgroup)), false, nil, nil, OFFSET_FRONT, 20)
				else
					
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 10) == true and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_Count(this.attacker) > 0 then 	
				StripWeakBuildings(this.egroup)
				EGroup_Single(eg_GarrisonGammaRemove, Util_GetClosestFreeEntity(this.egroup, SGroup_GetPosition(this.sgroup)))
				Cmd_Garrison(this.sgroup, eg_GarrisonGammaRemove)
					
				
			elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == true then 
				SGroup_GetHoldEGroup(this.sgroup, this.holdegroup)
				if	EGroup_GetAvgHealth(eg_GarrisonGammaRemove) < 0.60 or SGroup_IsDoingAttack(this.sgroup, ANY, 10) == false then 
					Cmd_UngarrisonSquad(this.sgroup)
					--Cmd_Ungarrison((this.sgroup, mkr_BeaconGamma2) 
					
					StripWeakBuildings(this.egroup)
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end
 
function BrenAlpha_Init()
	tmkr_BrenAlpha = Marker_GetTable("mkr_BrenAlpha%d")
	tsg_BrenAlpha = SGroup_CreateTable("sg_BrenAlpha%d", table.getn(tmkr_BrenAlpha))
	sg_BrenAlpha1 = SGroup_CreateIfNotFound("sg_BrenAlpha1")
	sg_BrenAlpha2 = SGroup_CreateIfNotFound("sg_BrenAlpha2")
	sg_BrenAlpha3 = SGroup_CreateIfNotFound("sg_BrenAlpha3")
	sg_BrenInfantryAlpha1 = SGroup_CreateIfNotFound("sg_BrenInfantryAlpha1")
	sg_BrenInfantryAlpha2 = SGroup_CreateIfNotFound("sg_BrenInfantryAlpha2")
	sg_BrenInfantryAlpha3 = SGroup_CreateIfNotFound("sg_BrenInfantryAlpha3")
	sg_BrenFollowAlpha1 = SGroup_CreateIfNotFound("sg_BrenFollowAlpha1")
	sg_BrenFollowAlpha2 = SGroup_CreateIfNotFound("sg_BrenFollowAlpha2")
	sg_BrenFollowAlpha3 = SGroup_CreateIfNotFound("sg_BrenFollowAlpha3")

	sg_BrenAlphaAttacker1 = SGroup_CreateIfNotFound("sg_BrenAlphaAttacker1")
	sg_BrenAlphaAttacker2 = SGroup_CreateIfNotFound("sg_BrenAlphaAttacker2")
	sg_BrenAlphaAttacker3 = SGroup_CreateIfNotFound("sg_BrenAlphaAttacker3")

	
	t_BrenAlpha = {
		{
			sgroup = sg_BrenAlpha1,
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			timername = "tmr_BrenAlpha1", 
			timer = 10, 
			phase = 2,
			spawn = mkr_Spawn1,
			inf = sg_BrenInfantryAlpha1,
			attacker = sg_BrenAlphaAttacker1, 
			egroup1 = eg_pnt_R1, 
			egroup2 = eg_pnt_R2, 
		},
--~ 		{
--~ 			sgroup = sg_BrenAlpha2,
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_StrongHold1,
--~ 			depart = mkr_Final1,			
--~ 			timername = "tmr_BrenAlpha2", 
--~ 			timer = 10, 
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn3, 
--~ 			inf = sg_BrenInfantryAlpha2,
--~ 			follow = sg_BrenFollowAlpha2, 
--~ 			attacker = sg_BrenAlphaAttacker2, 
--~ 		},
	}
	
	for i = 1, table.getn(t_BrenAlpha) do
		--t_BrenAlpha[i].sgroup = tsg_BrenAlpha[i]
		--t_BrenAlpha[i].spawn = tmkr_BrenAlpha[i]
	end
	BrenAlpha_Preset()
end

function BrenAlpha_Preset()
	for k, this in pairs(t_BrenAlpha) do
			Util_CreateSquads(player2, this.sgroup, SBP.CW.BREN_CARRIER, this.spawn)
			Util_CreateSquads(player2, this.inf, SBP.CW.COMMANDOS_PIAT, this.sgroup)		
			--Util_CreateSquads(player2, this.follow, SBP.CW.COMMANDOS, this.spawn)		
		this.phase = 2
	end	
	if Rule_Exists(BrenAlpha_Respawn) == false then 
		Rule_AddInterval(BrenAlpha_Respawn, 5)
	end
	if Rule_Exists(BrenAlpha_Kickoff) == false then 
		Rule_AddInterval(BrenAlpha_Kickoff, 5)
	end
	
end

function BrenAlpha_Respawn()
	for k, this in pairs(t_BrenAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and SGroup_TotalMembersCount(this.inf) == 0 and  Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 and EGroup_Count(eg_blg_Bridge) > 0 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.BREN_CARRIER, this.spawn)
			Util_CreateSquads(player2, this.inf, SBP.CW.COMMANDOS_PIAT, this.sgroup)	
			--Util_CreateSquads(player2, this.follow, SBP.CW.COMMANDOS, this.spawn)	
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end

function BrenAlpha_Kickoff()
	for k, this in pairs(t_BrenAlpha) do
		if SGroup_Count(this.sgroup) > 0 or SGroup_Count(this.inf) > 0  then 
			SGroup_GetLastAttacker(this.inf, this.attacker) 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)
			
			if this.phase == 2 then 
				if SGroup_Count(this.sgroup) > 0 then 
					if SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and SGroup_Count(sg_AxisAll) > 0 then 	
						Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					elseif SGroup_IsUnderAttack(this.sgroup, ANY, 5) == true then
						Cmd_UngarrisonSquad(this.sgroup)				
						this.phase = 3
					elseif Prox_AreSquadsNearMarker(this.sgroup, EGroup_GetPosition(this.egroup1), ANY, 10) or Prox_AreSquadsNearMarker(this.sgroup, EGroup_GetPosition(this.egroup2), ANY, 10) then 
						Cmd_UngarrisonSquad(this.sgroup)
						this.phase = 3
					end
				end
			end
			if this.phase == 3 then 
				if SGroup_IsHoldingAny(this.sgroup) == false then 
					if Prox_AreSquadsNearMarker(this.sgroup, this.depart, ANY) == false then
						Cmd_Move(this.sgroup, this.depart)
					end
					if SGroup_Count(this.inf) > 0 and SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and SGroup_Count(this.attacker) > 0 then 
	
						Cmd_AttackMove(this.inf, this.attacker) 
					end
				else
					Cmd_UngarrisonSquad(this.sgroup)
				end
			end
			if SGroup_IsHoldingAny(this.sgroup) == true and SGroup_GetAvgHealth(this.sgroup) < 0.40 then 
				SGroup_Kill(this.sgroup)
				SGroup_Kill(this.inf)
			end
		end
	end
end
 
 

function GrenadeAlpha_Init()
	tmkr_GrenadeAlpha = Marker_GetTable("mkr_GrenadeAlpha%d")
	--tsg_GrenadeAlpha = SGroup_CreateTable("sg_GrenadeAlpha%d", table.getn(tmkr_GrenadeAlpha))
	sg_GrenadeAlpha1 = SGroup_CreateIfNotFound("sg_GrenadeAlpha1")
	sg_GrenadeAlpha2 = SGroup_CreateIfNotFound("sg_GrenadeAlpha2")
	sg_GrenadeAlpha3 = SGroup_CreateIfNotFound("sg_GrenadeAlpha3")
	
	sg_GrenadeAlphaAttacker1 = SGroup_CreateIfNotFound("sg_GrenadeAlphaAttacker1")

	t_GrenadeAlpha = {
		{
			sgroup = sg_GrenadeAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GrenadeAlpha1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			attacker = sg_GrenadeAlphaAttacker1, 

		},

	}
	GrenadeAlpha_Preset()
end

function GrenadeAlpha_Preset()
	for k, this in pairs(t_GrenadeAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(GrenadeAlpha_Respawn) == false then 
		Rule_AddInterval(GrenadeAlpha_Respawn, 1)
	end
	if Rule_Exists(GrenadeAlpha_Kickoff) == false then 
		Rule_AddInterval(GrenadeAlpha_Kickoff, 1)
	end
	
end

function GrenadeAlpha_Respawn()
	for k, this in pairs(t_GrenadeAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end

function GrenadeAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_GrenadeAlpha) do
		
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 2 and SGroup_Count(this.sgroup) > 0 then
			this.phase = 5
		end

		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)
			if SGroup_Count(this.attacker) > 0 then 
				if Prox_SGroupSGroup(this.sgroup, this.attacker, PROX_SHORTEST) < 15 then 					
					Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)					
				end
			elseif SGroup_Count(sg_AxisAll) > 0 then 
				Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, SGroup_GetPosition(this.sgroup)))
			end
		end
		if this.phase == 5 then
			Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))
		end
	end
end


function TetrarchAlpha_Init()
	tmkr_TetrarchAlpha = Marker_GetTable("mkr_TetrarchAlpha%d")
	--tsg_TetrarchAlpha = SGroup_CreateTable("sg_TetrarchAlpha%d", table.getn(tmkr_TetrarchAlpha))
	sg_TetrarchAlpha1 = SGroup_CreateIfNotFound("sg_TetrarchAlpha1")
	sg_TetrarchAlpha2 = SGroup_CreateIfNotFound("sg_TetrarchAlpha2")
	sg_TetrarchAlpha3 = SGroup_CreateIfNotFound("sg_TetrarchAlpha3")
	
	sg_TetrarchAlphaAttacker1 = SGroup_CreateIfNotFound("sg_TetrarchAlphaAttacker1")
	sg_TetrarchAlphaAttacker2 = SGroup_CreateIfNotFound("sg_TetrarchAlphaAttacker2")
	sg_TetrarchAlphaAttacker3 = SGroup_CreateIfNotFound("sg_TetrarchAlphaAttacker3")

	sg_TetrarchAlphaTank1 = SGroup_CreateIfNotFound("sg_TetrarchAlphaTank1 ")

	
	t_TetrarchAlpha = {
		{
			sgroup = sg_TetrarchAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_TetrarchAlpha1", 
			timer = 90, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			egroup = eg_AxisAll, 
			attacker = sg_TetrarchAlphaAttacker1, 
			tank = sg_TetrarchAlphaTank1, 
		},
	}
	TetrarchAlpha_Preset()
end

function TetrarchAlpha_Preset()
	for k, this in pairs(t_TetrarchAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.CHURCHILL, this.spawn)
		this.phase = 2

	end
	if Rule_Exists(TetrarchAlpha_Kickoff) == false then 
		Rule_AddInterval(TetrarchAlpha_Kickoff, 5)
	end
	if Rule_Exists(TetrarchAlpha_Respawn) == false then 
		Rule_AddInterval(TetrarchAlpha_Respawn, 5)
	end
	
	
end
  
function TetrarchAlpha_Respawn()
	for k, this in pairs(t_TetrarchAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.CHURCHILL, this.spawn)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end

function TetrarchAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_TetrarchAlpha) do
		
		--SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		
--~ 		if SGroup_GetAvgHealth(this.sgroup) < 0.2  then
--~ 			this.phase = 5
--~ 		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_IsUnderAttack(this.sgroup, ANY, 5) == true then 
					SGroup_GetLastAttacker(this.sgroup, this.attacker)
					if SGroup_Count(this.attacker) > 0 then 
						Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_BACK, 10, true)
					end
				elseif SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and SGroup_Count(this.attacker) == 0  then
					if SGroup_Count(sg_AxisTank) > 0 then 
						Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisTank, this.sgroup))
					elseif SGroup_Count(sg_AxisTank) == 0 and SGroup_Count(sg_AxisAll) > 0  then
						Cmd_AttackMove(this.sgroup,  Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					end
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Move(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end


function CrocAlpha_Init()
	tmkr_CrocAlpha = Marker_GetTable("mkr_CrocAlpha%d")
	--tsg_CrocAlpha = SGroup_CreateTable("sg_CrocAlpha%d", table.getn(tmkr_CrocAlpha))
	sg_CrocAlpha1 = SGroup_CreateIfNotFound("sg_CrocAlpha1")
	sg_CrocAlpha2 = SGroup_CreateIfNotFound("sg_CrocAlpha2")
	sg_CrocAlpha3 = SGroup_CreateIfNotFound("sg_CrocAlpha3")
	
	sg_CrocAlphaAttacker1 = SGroup_CreateIfNotFound("sg_CrocAlphaAttacker1")
	sg_CrocAlphaAttacker2 = SGroup_CreateIfNotFound("sg_CrocAlphaAttacker2")
	sg_CrocAlphaAttacker3 = SGroup_CreateIfNotFound("sg_CrocAlphaAttacker3")

	sg_CrocAlphaTank1 = SGroup_CreateIfNotFound("sg_CrocAlphaTank1 ")

	
	t_CrocAlpha = {
		{
			sgroup = sg_CrocAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_CrocAlpha1", 
			timer = 90, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			egroup = eg_AxisAll, 
			attacker = sg_CrocAlphaAttacker1, 
			tank = sg_CrocAlphaTank1, 
		},
	}
	CrocAlpha_Preset()
end

function CrocAlpha_Preset()
	for k, this in pairs(t_CrocAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.CHURCHILL_CROC, this.spawn)
		this.phase = 2

	end
	if Rule_Exists(CrocAlpha_Kickoff) == false then 
		Rule_AddInterval(CrocAlpha_Kickoff, 5)
	end
	if Rule_Exists(CrocAlpha_Respawn) == false then 
		Rule_AddInterval(CrocAlpha_Respawn, 5)
	end
	
	
end
  
function CrocAlpha_Respawn()
	for k, this in pairs(t_CrocAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.CHURCHILL_CROC, this.spawn)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
	end
end

function CrocAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_CrocAlpha) do
		
		--SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 70) == false then 
			SGroup_Clear(this.attacker)
		end
		
--~ 		if SGroup_GetAvgHealth(this.sgroup) < 0.2  then
--~ 			this.phase = 5
--~ 		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_IsUnderAttack(this.sgroup, ANY, 5) == true then 
					SGroup_GetLastAttacker(this.sgroup, this.attacker)
					if SGroup_Count(this.attacker) > 0 then 
						Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_FRONT, 70, true)
					end
				elseif SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false then
					if SGroup_Count(sg_AxisAll) > 0  then
						Cmd_AttackMove(this.sgroup,  Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					end
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Move(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end


function ATGunAlpha_Init()
	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_ATGunAlpha = Marker_GetTable("mkr_ATGun2Alpha%d")
	tsg_ATGunAlpha = SGroup_CreateTable("sg_ATGunAlpha%d", table.getn(tmkr_ATGunAlpha))
	tsg_ATGunAlphaAttacker = SGroup_CreateTable("sg_ATGunAlpha%dAttacker", table.getn(tmkr_ATGunAlpha))
--~ 	sg_ATGunAlpha1Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha1Attacker")
--~ 	sg_ATGunAlpha2Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha2Attacker")
--~ 	sg_ATGunAlpha3Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha3Attacker")
--~ 	sg_ATGunAlpha4Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha4Attacker")
--~ 	sg_ATGunAlpha5Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha5Attacker")
	
	
	t_ATGunAlpha = {
		{
			phase = 2,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			depart = mkr_Final1, 
		},
	}
	
	for i = 1, table.getn(t_ATGunAlpha) do
		t_ATGunAlpha[i].sgroup = tsg_ATGunAlpha[i]
		t_ATGunAlpha[i].spawn = tmkr_ATGunAlpha[i]
		t_ATGunAlpha[i].attacker = tsg_ATGunAlphaAttacker[i]
	end
	
	ATGunAlpha_Preset()


end

-- preset any units or events needed before the kickoff
function ATGunAlpha_Preset()
	-- spawn squads
	-- start enemy behavior
	-- do other cool things
	for k, this in pairs(t_ATGunAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_PAK38_SP, this.spawn)
		this.phase = 2
	end
	
	Rule_AddInterval(ATGunAlpha_Kickoff, 1)

end

-- start the related action
function ATGunAlpha_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_ATGunAlpha) do
		--print(SGroup_GetAvgHealth(this.sgroup))
		if SGroup_TotalMembersCount(this.sgroup) < 4 then
			--this.phase = 5
		end
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_IsUnderAttackFromDirection(this.sgroup, ANY, OFFSET_DIRECTION_BACK, 1) and SGroup_Count(this.attacker) > 0 then 
					Cmd_AttackMove(this.sgroup, this.attacker)
				end
			end
		end	
	end
end

function StillAlpha_Init()
	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_StillAlpha = Marker_GetTable("mkr_StillAlpha%d")
	tsg_StillAlpha = SGroup_CreateTable("sg_StillAlpha%d", table.getn(tmkr_StillAlpha))
	tsg_StillAlphaAttacker = SGroup_CreateTable("sg_StillAlpha%dAttacker", table.getn(tmkr_StillAlpha))
--~ 	sg_StillAlpha1Attacker = SGroup_CreateIfNotFound("sg_StillAlpha1Attacker")
--~ 	sg_StillAlpha2Attacker = SGroup_CreateIfNotFound("sg_StillAlpha2Attacker")
--~ 	sg_StillAlpha3Attacker = SGroup_CreateIfNotFound("sg_StillAlpha3Attacker")
--~ 	sg_StillAlpha4Attacker = SGroup_CreateIfNotFound("sg_StillAlpha4Attacker")
--~ 	sg_StillAlpha5Attacker = SGroup_CreateIfNotFound("sg_StillAlpha5Attacker")
	
	
	t_StillAlpha = {
		{
			phase = 2,
			unit = SBP.CW.TOMMIES,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			unit = SBP.CW.COMMANDOS,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			unit = SBP.CW.TOMMIES,
			depart = mkr_StillAlphaLast3, 
		},
		{
			phase = 2,
			unit = SBP.CW.COMMANDOS,
			depart = mkr_StillAlphaLast4, 
		},
		{
			phase = 2,
			unit = SBP.CW.TOMMIES,
			depart = mkr_StillAlphaLast5, 
		},

	}
	
	for i = 1, table.getn(t_StillAlpha) do
		t_StillAlpha[i].sgroup = tsg_StillAlpha[i]
		t_StillAlpha[i].spawn = tmkr_StillAlpha[i]
		t_StillAlpha[i].attacker = tsg_StillAlphaAttacker[i]
	end
	
	StillAlpha_Preset()


end

-- preset any units or events needed before the kickoff
function StillAlpha_Preset()
	-- spawn squads
	-- start enemy behavior
	-- do other cool things
	for k, this in pairs(t_StillAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn)
		this.phase = 2
	end
	
	Rule_AddInterval(StillAlpha_Kickoff, 1)

end

-- start the related action
function StillAlpha_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_StillAlpha) do
		--print(SGroup_GetAvgHealth(this.sgroup))
		if SGroup_TotalMembersCount(this.sgroup) < 4 then
			--this.phase = 5
		end
		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)
			if SGroup_Count(this.sgroup) > 0 and SGroup_Count(this.attacker) > 0 then
				if SGroup_IsUnderAttackFromDirection(this.sgroup, ANY, OFFSET_DIRECTION_BACK, 1) then 
					Cmd_AttackMove(this.sgroup, this.attacker)
				end
			end
		end	
	end
end



function DontEnterAlpha_Init()
	tmkr_DontEnterAlpha = Marker_GetTable("mkr_DontEnterAlpha%d")
	--tsg_DontEnterAlpha = SGroup_CreateTable("sg_DontEnterAlpha%d", table.getn(tmkr_DontEnterAlpha))
	sg_DontEnterAlpha1 = SGroup_CreateIfNotFound("sg_DontEnterAlpha1")
	sg_DontEnterAlpha2 = SGroup_CreateIfNotFound("sg_DontEnterAlpha2")
	sg_DontEnterAlpha3 = SGroup_CreateIfNotFound("sg_DontEnterAlpha3")
	
	sg_DontEnterAlphaAttacker1 = SGroup_CreateIfNotFound("sg_DontEnterAlphaAttacker1")
	sg_DontEnterAlphaAttacker2 = SGroup_CreateIfNotFound("sg_DontEnterAlphaAttacker2")
	sg_DontEnterAlphaAttacker3 = SGroup_CreateIfNotFound("sg_DontEnterAlphaAttacker3")
	
	
	t_DontEnterAlpha = {
		{
			sgroup = sg_DontEnterAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_DontEnterAlpha1", 
			timer = 4, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			attacker = sg_DontEnterAlphaAttacker1, 

		},
	}
	DontEnterAlpha_Preset()
end

function DontEnterAlpha_Preset()
	for k, this in pairs(t_DontEnterAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
		Modify_ReceivedAccuracy(this.sgroup, 0.5)
		Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
		this.phase = 2
	end
	if Rule_Exists(DontEnterAlpha_Kickoff) == false then 
		Rule_AddInterval(DontEnterAlpha_Kickoff, 1)
	end
	
	
end
  

function DontEnterAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_DontEnterAlpha) do
		
		--SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 4)
			Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
			Modify_ReceivedAccuracy(this.sgroup, 0.5)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			sectorOosterbeek = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_Oosterbeek))
			Player_GetAllSquadsNearMarker(player1, sg_DontEnterAlphaAttacker1, sectorOosterbeek)
			if SGroup_Count(sg_DontEnterAlphaAttacker1) > 0 then 
				Cmd_AttackMove(this.sgroup,	sg_DontEnterAlphaAttacker1)
			else	
				Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))
			end
		end
	end
end


-- this is an encounter or a set of encounters that is triggered if the player enters an area
-- and finds some sappers building emplacements at a location
function EngineerBuilding_Init()
	tmkr_PriestAlpha = Marker_GetTable("mkr_PriestAlpha%d")
	
	
	t_Priest = {
		idx = 1
	}
	t_Priest.squads = {}
	
	for i=1, table.getn(tmkr_PriestAlpha) do
		t_Priest.squads[i] = {
			sgroup 			= SGroup_CreateIfNotFound("sg_Priest_build"..i),
			egroup			= EGroup_CreateIfNotFound("eg_Priest_build"..i),
			sbp 			= SBP.CW.TOMMIES,
			upg 			= {},
			mkr 			= tmkr_PriestAlpha[i],
			ebp 			= EBP.CW.HOWITZER_NEST,
			fg_spawned		= false,
			ability         = ABILITY.CW.SUPERCHARGE_BARRAGE,
			mkr_retreat		= mkr_Final1,
			egroup2  		= EGroup_CreateIfNotFound("eg_Priest_temp"..i),
			sgroup2			= SGroup_CreateIfNotFound("sg_Priest_temp"..i),
		}
		if Marker_Exists("mkr_PriestAlphaPos"..i, "") then
			this = t_Priest.squads[i]
			this.mkr_start = Marker_FromName("mkr_PriestAlphaPos"..i, "")
			--this.mkr_end = Marker_FromName("mkr_eb_barb"..i.."_2", "")
			this.sbp = SBP.CW.SAPPER
			this.ebp = EBP.CW.BARBED_WIRE
	
		end
		EngineerBuilding_Kickoff()
		 
	end 

end

function EngineerBuilding_Kickoff()
	if Rule_Exists(EB_CheckProx) == false then 
		Rule_AddInterval(EB_CheckProx, 2.5)
	end

end


function EB_CheckProx()


	for k, this in pairs(t_Priest.squads) do
		
		if EGroup_IsEmpty(this.egroup) then

			EGroup_Clear(this.egroup2)
			Player_GetAllEntitiesNearMarker(player2, this.egroup2, this.mkr, 15)
			
			-- since slit trenches are not owned until manned, make sure that we include those as well
			World_GetEntitiesNearMarker(player2, this.egroup2, this.mkr, OT_Neutral) 
			
			-- filter out for the appropriate building being constructed
			EGroup_Filter(this.egroup2, EBP.CW.HOWITZER_NEST, FILTER_KEEP)
			EGroup_FilterUnderConstruction(this.egroup2, FILTER_REMOVE)
			EGroup_Clear(this.egroup)
			EGroup_AddEGroup(this.egroup, this.egroup2)
			Modify_Vulnerability(this.egroup, 5)
			
		end
		if Player_OwnsEGroup(player2, this.egroup) == true then 
			local panzerrand = World_GetRand(1, 2)
			if  panzerrand== 1 then 
				if SGroup_Count(sg_AxisAll) > 0 then 
					Cmd_Ability(this.egroup, this.ability, Util_GetClosestSquadPosition(sg_AxisAll, this.egroup), nil, true)
				end
			end
			if  panzerrand== 2 then 
				if SGroup_Count(sg_AxisAll) > 0 then 
					Cmd_Ability(this.egroup, ABILITY.CW.PDR_25_BARRAGE, Util_GetClosestSquadPosition(sg_AxisAll, this.egroup), nil, true)
				end
			end	
		end
		if SGroup_IsEmpty(this.sgroup) then
			if this.fg_spawned == false then
	
				Player_GetAllSquadsNearMarker(player1, this.sgroup2, this.mkr_start, 200)
			--	Player_GetAllSquadsNearMarker(player1, this.sgroup3, this.mkr_start, 5)
				if SGroup_IsEmpty(this.sgroup2) == false then
					
					local pos = Util_GetOffsetPosition(this.mkr, OFFSET_BACK, 40)
					pos = World_GetHiddenPositionOnPath(player1, pos, Util_GetPosition(this.mkr), CHECK_OFFCAMERA)
					
					if pos == nil then
						pos = this.mkr
					end
					Util_CreateSquads(player2, this.sgroup, this.sbp, pos)
					this.fg_spawned = true
				end
			end
			
		elseif EGroup_IsEmpty(this.egroup) == false and SGroup_IsConstructingBuilding(this.sgroup, ANY) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_TotalMembersCount(this.sgroup) > 0 and SGroup_IsMoving(this.sgroup, ANY) == false then 
			Cmd_Retreat(this.sgroup, mkr_Final3)
	
			
		elseif not SGroup_IsMoving(this.sgroup, ANY)
		and not SGroup_IsConstructingBuilding(this.sgroup, ANY) then
			
			if this.mkr_end == nil then
				Cmd_Construct(this.sgroup, EBP.CW.HOWITZER_NEST, this.mkr)
			else
				-- construct a fence or barbed wire
				--Command_PlayerSquadConstructFence(player2, this.sgroup, this.ebp, Util_GetPosition(this.mkr_start), Util_GetPosition(this.mkr_end), false)
			end
		end
		
	end

end


---------------------------------------------------------------------------------------------------------------------------
-- Misc functions
-- functions that do have anything to do with spawning units
---------------------------------------------------------------------------------------------------------------------------
--this function gathers the units and puts them into sgroup names for reference. 
--this creates the ability to create a tanks specifically or a sniper etc.. 

-- puts sgroup names to guys being in the sectors
function Misc_GrabTerritory()
	sectorIDR1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_R1))
	sectorIDR2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_R2))
	sectorIDR3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_R3))
	sectorIDR4 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_R4))
	sectorIDHeights = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_Heights))
	
	
	sectorIDA1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_A1))
	sectorIDA2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_A2))
	sectorIDA3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_A3))

	sectorIDB1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_B1))
	sectorIDB2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_B2))
	sectorIDB3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_B3))
	
	sectorIDC1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_C1))
	sectorIDC2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_C2))
	sectorIDC3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_C3))
	sectorIDC4 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_C4))
	
	sectorIDD1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_D1))
	sectorIDD2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_D2))
	sectorIDD3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_D3))
	sectorIDD4 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_D4))
	
	sectorIDOosterbeek = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_Oosterbeek))
	
	sg_AllyR1 = SGroup_CreateIfNotFound("sg_AllyR1")
	sg_AllyR2 = SGroup_CreateIfNotFound("sg_AllyR2")
	sg_AllyR3 = SGroup_CreateIfNotFound("sg_AllyR3")
	sg_AllyR4 = SGroup_CreateIfNotFound("sg_AllyR4")
	sg_AllyHeights = SGroup_CreateIfNotFound("sg_AllyHeights")
	
	sg_AllyA1 = SGroup_CreateIfNotFound("sg_AllyA1")
	sg_AllyA2 = SGroup_CreateIfNotFound("sg_AllyA2")
	sg_AllyA3 = SGroup_CreateIfNotFound("sg_AllyA3")
	
	sg_AllyB1 = SGroup_CreateIfNotFound("sg_AllyB1")
	sg_AllyB2 = SGroup_CreateIfNotFound("sg_AllyB2")
	sg_AllyB3 = SGroup_CreateIfNotFound("sg_AllyB3")
	
	sg_AllyC1 = SGroup_CreateIfNotFound("sg_AllyC1")
	sg_AllyC2 = SGroup_CreateIfNotFound("sg_AllyC2")
	sg_AllyC3 = SGroup_CreateIfNotFound("sg_AllyC3")
	sg_AllyC4 = SGroup_CreateIfNotFound("sg_AllyC4")
	
	sg_AllyD1 = SGroup_CreateIfNotFound("sg_AllyD1")
	sg_AllyD2 = SGroup_CreateIfNotFound("sg_AllyD2")
	sg_AllyD3 = SGroup_CreateIfNotFound("sg_AllyD3")
	sg_AllyD4 = SGroup_CreateIfNotFound("sg_AllyD4")

	sg_AllyAll = SGroup_CreateIfNotFound("sg_AllyAll")
	sg_AllyFlak = SGroup_CreateIfNotFound("sg_AllyFlak")

	
	sg_AxisR1 = SGroup_CreateIfNotFound("sg_AxisR1")
	sg_AxisR2 = SGroup_CreateIfNotFound("sg_AxisR2")
	sg_AxisR3 = SGroup_CreateIfNotFound("sg_AxisR3")
	sg_AxisR4 = SGroup_CreateIfNotFound("sg_AxisR4")
	sg_AxisHeights = SGroup_CreateIfNotFound("sg_AxisHeights")
	
	sg_AxisA1 = SGroup_CreateIfNotFound("sg_AxisA1")
	sg_AxisA2 = SGroup_CreateIfNotFound("sg_AxisA2")
	sg_AxisA3 = SGroup_CreateIfNotFound("sg_AxisA3")
	
	sg_AxisB1 = SGroup_CreateIfNotFound("sg_AxisB1")
	sg_AxisB2 = SGroup_CreateIfNotFound("sg_AxisB2")
	sg_AxisB3 = SGroup_CreateIfNotFound("sg_AxisB3")
	
	sg_AxisC1 = SGroup_CreateIfNotFound("sg_AxisC1")
	sg_AxisC2 = SGroup_CreateIfNotFound("sg_AxisC2")
	sg_AxisC3 = SGroup_CreateIfNotFound("sg_AxisC3")
	sg_AxisC4 = SGroup_CreateIfNotFound("sg_AxisC4")
	
	sg_AxisD1 = SGroup_CreateIfNotFound("sg_AxisD1")
	sg_AxisD2 = SGroup_CreateIfNotFound("sg_AxisD2")
	sg_AxisD3 = SGroup_CreateIfNotFound("sg_AxisD3")
	sg_AxisD4 = SGroup_CreateIfNotFound("sg_AxisD4")
	
	sg_AxisAll = SGroup_CreateIfNotFound("sg_AxisAll")
	
	
	sg_LastStand1 = SGroup_CreateIfNotFound("sg_LastStand1")
	sg_LastStand2 = SGroup_CreateIfNotFound("sg_LastStand2")
	sg_LastStand3 = SGroup_CreateIfNotFound("sg_LastStand3")

	sg_LastStandAttacker1 = SGroup_CreateIfNotFound("sg_LastStandAttacker1")
	sg_LastStandAttacker2 = SGroup_CreateIfNotFound("sg_LastStandAttacker2")
	sg_LastStandAttacker3 = SGroup_CreateIfNotFound("sg_LastStandAttacker3")

	sg_AllyOosterbeek1 = SGroup_CreateIfNotFound("sg_AllyOosterbeek1")
	sg_AllyOosterbeek2 = SGroup_CreateIfNotFound("sg_AllyOosterbeek2")
	sg_AxisOosterbeek2 = SGroup_CreateIfNotFound("sg_AxisOosterbeek2")
	
	
	
	sg_AxisInfantry = SGroup_CreateIfNotFound("sg_AxisInfantry")
	sg_AxisTank = SGroup_CreateIfNotFound("sg_AxisTank")
	sg_AxisHeavyTank = SGroup_CreateIfNotFound("sg_AxisHeavyTank")
	
	

	eg_AxisAll = EGroup_CreateIfNotFound("eg_AxisAll")
	eg_AllFlak = EGroup_CreateIfNotFound("eg_AllFlak")
	
	
	
	
	Rule_AddInterval(Misc_GatherUnit, 1)
	Rule_AddInterval(Misc_GatherEgroup, 10)
end
function Misc_GatherUnit()

	Player_GetAll(player1, sg_AxisAll)
	Player_GetAll(player2, sg_AllyAll)
	
	Player_GetAll(player1, sg_AxisInfantry)		
	SGroup_Filter(sg_AxisInfantry, {SBP.ELITE.FALLSCHIRMJAGER, SBP.ELITE.LUFTWAFFE}, FILTER_KEEP) 
	
	Player_GetAll(player1, sg_AxisTank)
	--SGroup_FilterUnderConstruction(sg_AxisTank, FILTER_REMOVE)
	SGroup_Filter(sg_AxisTank, {SBP.ELITE.WIRBLEWIND, SBP.ELITE.FLAK_38, SBP.ELITE.ARMOURCAR_221, SBP.ELITE.ARMOURCAR_223, SBP.ELITE.BERGETIGER, SBP.ELITE.HUMMEL, SBP.ELITE.HETZER, SBP.ELITE.JAGDPANTHER, SBP.ELITE.HALFTRACK_250, SBP.ELITE.HALFTRACK_251, SBP.ELITE.HALFTRACK_MORTAR, SBP.ELITE.HALFTRACK_MORTAR, SBP.ELITE.HALFTRACK_SNIPER, SBP.ELITE.HALFTRACK_VAMPIRE}, FILTER_KEEP) 
	
	Player_GetAll(player1, sg_AxisHeavyTank)
	--SGroup_FilterUnderConstruction(sg_AxisTank, FILTER_REMOVE)
	SGroup_Filter(sg_AxisHeavyTank, {SBP.ELITE.WIRBLEWIND, SBP.ELITE.HETZER, SBP.ELITE.JAGDPANTHER, SBP.ELITE.PANTHER, SBP.ELITE.MARDER, SBP.ELITE.PANZER_SUPPORT}, FILTER_KEEP) 
	

	
	Player_GetAll(player2, sg_AllyFlak)
	SGroup_Filter(sg_AllyFlak, {SBP.ELITE.FLAK_38_CAPTURED}, FILTER_KEEP) 

	Player_GetAllSquadsNearMarker(player2, sg_LastStand1, mkr_LastStand1)
	Player_GetAllSquadsNearMarker(player2, sg_LastStand2, mkr_LastStand2)
	Player_GetAllSquadsNearMarker(player2, sg_LastStand3, mkr_LastStand3)

	Player_GetAllSquadsNearMarker(player2, sg_AllyOosterbeek1, mkr_AllyOosterbeek1)
	Player_GetAllSquadsNearMarker(player2, sg_AllyOosterbeek2, sectorIDOosterbeek)
	Player_GetAllSquadsNearMarker(player1, sg_AxisOosterbeek2, mkr_AllyOosterbeek2)
	
	Player_GetAllSquadsNearMarker(player1, sg_AxisR1, sectorIDR1)
	Player_GetAllSquadsNearMarker(player1, sg_AxisR2, sectorIDR2)
	Player_GetAllSquadsNearMarker(player1, sg_AxisR3, sectorIDR3)
	Player_GetAllSquadsNearMarker(player1, sg_AxisR4, sectorIDR4)
	Player_GetAllSquadsNearMarker(player1, sg_AxisHeights, sectorIDHeights)
	
	Player_GetAllSquadsNearMarker(player1, sg_AxisA1, sectorIDA1)
	Player_GetAllSquadsNearMarker(player1, sg_AxisA2, sectorIDA2)
	Player_GetAllSquadsNearMarker(player1, sg_AxisA3, sectorIDA3)

	Player_GetAllSquadsNearMarker(player1, sg_AxisB1, sectorIDB1)
	Player_GetAllSquadsNearMarker(player1, sg_AxisB2, sectorIDB2)
	Player_GetAllSquadsNearMarker(player1, sg_AxisB3, sectorIDB3)
	
	Player_GetAllSquadsNearMarker(player2, sg_AxisC1, sectorIDC1)
	Player_GetAllSquadsNearMarker(player2, sg_AxisC2, sectorIDC2)
	Player_GetAllSquadsNearMarker(player2, sg_AxisC3, sectorIDC3)
	Player_GetAllSquadsNearMarker(player2, sg_AxisC4, sectorIDC4)
	
	Player_GetAllSquadsNearMarker(player2, sg_AxisD1, sectorIDD1)
	Player_GetAllSquadsNearMarker(player2, sg_AxisD2, sectorIDD2)
	Player_GetAllSquadsNearMarker(player2, sg_AxisD3, sectorIDD3)
	Player_GetAllSquadsNearMarker(player2, sg_AxisD4, sectorIDD4)
	
	Player_GetAllSquadsNearMarker(player2, sg_AllyR1, sectorIDR1)
	Player_GetAllSquadsNearMarker(player2, sg_AllyR2, sectorIDR2)
	Player_GetAllSquadsNearMarker(player2, sg_AllyR3, sectorIDR3)
	Player_GetAllSquadsNearMarker(player2, sg_AllyR4, sectorIDR4)
	Player_GetAllSquadsNearMarker(player2, sg_AllyHeights, sectorIDHeights)
	
	Player_GetAllSquadsNearMarker(player1, sg_AllyA1, sectorIDA1)
	Player_GetAllSquadsNearMarker(player1, sg_AllyA2, sectorIDA2)
	Player_GetAllSquadsNearMarker(player1, sg_AllyA3, sectorIDA3)

	Player_GetAllSquadsNearMarker(player1, sg_AllyB1, sectorIDB1)
	Player_GetAllSquadsNearMarker(player1, sg_AllyB2, sectorIDB2)
	Player_GetAllSquadsNearMarker(player1, sg_AllyB3, sectorIDB3)
	
	Player_GetAllSquadsNearMarker(player2, sg_AllyC1, sectorIDC1)
	Player_GetAllSquadsNearMarker(player2, sg_AllyC2, sectorIDC2)
	Player_GetAllSquadsNearMarker(player2, sg_AllyC3, sectorIDC3)
	Player_GetAllSquadsNearMarker(player2, sg_AllyC4, sectorIDC4)
	
	Player_GetAllSquadsNearMarker(player2, sg_AllyD1, sectorIDD1)
	Player_GetAllSquadsNearMarker(player2, sg_AllyD2, sectorIDD2)
	Player_GetAllSquadsNearMarker(player2, sg_AllyD3, sectorIDD3)
	Player_GetAllSquadsNearMarker(player2, sg_AllyD4, sectorIDD4)

	
	
end

function Misc_GatherEgroup()
	
	Player_GetAll(player1, eg_AxisAll)
	
	
--~ 	World_GetNeutralEntitiesNearMarker(eg_AllFlak, mkr_AllMap)
--~ 	EGroup_Filter(eg_AllFlak, {EBP.PICKUP.ELITE.FLAKVIERLING38}, FILTER_KEEP) 
--~ 	
	
end	

--Destroys everybody that enters the exit
function Misc_DestroyAllSquads()
	sg_tempDestroy1 = SGroup_CreateIfNotFound("sg_tempDestroy1")
	Player_GetAllSquadsNearMarker(player2, sg_tempDestroy1, mkr_Final1)
	if SGroup_Count(sg_tempDestroy1) > 0 then
		SGroup_DestroyAllSquads(sg_tempDestroy1)
	end
	sg_tempDestroy3 = SGroup_CreateIfNotFound("sg_tempDestroy3")
	Player_GetAllSquadsNearMarker(player2, sg_tempDestroy3, mkr_Final3)
	if SGroup_Count(sg_tempDestroy3) > 0 then
		SGroup_DestroyAllSquads(sg_tempDestroy3)
	end
end



function ToggleUIFOW()
	if g_FowUI == 0 then 
		print("reveal")
		--FOW_RevealAll()
		Game_SetMode(UI_Fullscreen)
		g_FowUI = 1
	elseif g_FowUI == 1 then 
		--FOW_UnRevealAll()
		print("hide")
		Game_SetMode(UI_Normal)
		g_FowUI = 0
	end
end

function Util_GetClosestFreeEntity(egroup, source)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local result = nil
	
	local _CheckEntity = function(gid, idx, eid)
		if World_OwnsEntity(eid) then
			local thispos = Entity_GetPosition(eid)
			local thisdist = World_DistancePointToPoint(source, thispos)
			if  thisdist < dist then
				result = eid
				dist = thisdist
			end
		end
	end
	EGroup_ForEach(egroup, _CheckEntity)
	
	return result
	
end

function Util_GetClosestAllyEntity(egroup, source)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local result = nil
	
	local _CheckEntity = function(gid, idx, eid)
		if Player_OwnsEntity(player1, eid) then
			local thispos = Entity_GetPosition(eid)
			local thisdist = World_DistancePointToPoint(source, thispos)
			if  thisdist < dist then
				result = eid
				dist = thisdist
			end
		end
	end
	EGroup_ForEach(egroup, _CheckEntity)
	
	return result
	
end




function Util_GetClosestEntityPosition(egroup, source)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local pos = nil
	
	local _CheckEntity = function(gid, idx, eid)
		local thispos = Entity_GetPosition(eid)
		local thisdist = World_DistancePointToPoint(source, thispos)
		if  thisdist < dist then
			pos = thispos
			dist = thisdist
		end
	end
	EGroup_ForEach(egroup, _CheckEntity)
	
	return pos
	
end

function Util_GetClosestSquadPosition(sgroup, source)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local pos = nil
	
	local _CheckSquad = function(gid, idx, sid)
		local thispos = Squad_GetPosition(sid)
		local thisdist = World_DistancePointToPoint(source, thispos)
		if  thisdist < dist then
			pos = thispos
			dist = thisdist
		end
	end
	SGroup_ForEach(sgroup, _CheckSquad)
	
	return pos
	
end


function Util_GetClosestStrategicPointCapturableByPlayer(egroup, source, player)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local flag = nil
	local team = Player_GetTeam(player)
	

	local _CheckEntity = function(gid, idx, eid)
		if World_OwnsEntity(eid) or Player_GetTeam(Entity_GetPlayerOwner(eid)) ~= team then
			local thispos = Entity_GetPosition(eid)
			local thisdist = World_DistancePointToPoint(source, thispos)
			if  thisdist < dist then
				flag = eid
				dist = thisdist
			end
		end
	end
	EGroup_ForEach(egroup, _CheckEntity)
	
	return flag
	
end

function StripWeakBuildings(egroup)
	local _CheckBuilding  = function(gid, idx, eid)
		local health = Entity_GetHealth(eid) / Entity_GetHealthMax(eid)
		
		if health < 0.95 then 
			EGroup_Remove(gid, eid)
		end
	end
	EGroup_ForEach(egroup, _CheckBuilding)
end

