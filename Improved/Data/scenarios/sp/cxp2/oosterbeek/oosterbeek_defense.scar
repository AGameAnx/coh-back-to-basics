-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Mission Name

-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")


-------------------------------------------------------------------------

-- [[ SETUP ]]

-------------------------------------------------------------------------

function OnGameSetup()
	-- string numbers should reference dat files
	-- "allies_commonwealth" "allies" "axis" "axis_panzer_elite"
	player1 = Setup_Player(1, 1309230, "axis_panzer_elite", 1)
	player2 = Setup_Player(2, 1309231, "allies_commonwealth", 2)
	--player3 = Setup_Player(3, "$000000", "allies_commonwealth", 1)
	
	-- AI slot (ensure that the AI is on the same team as the other Axis player by setting the second parameter
--~  	player3 = Setup_Player(3, "$000000", "Axis Infantry Company", 2)
end

function OnGameRestore()
	player1 = World_GetPlayerAt(1)
	player2 = World_GetPlayerAt(2)
	--player3 = World_GetPlayerAt(3)
	
	-- function takes care of restoring all global mission parameters after a save/load
	Game_DefaultGameRestore()
end


-------------------------------------------------------------------------

-- [[ ONINIT ]]

-------------------------------------------------------------------------

function OnInit()
	g_MissionSpeechPath="omg\\sp\\Mission3"
	
	g_AIControl_Enable = false
	g_AIControl_Pause = true
	
	--[[ PRESET GAME STATE ]]
	--Util_MissionPreset("Mission Name")
	
	-- a constant that stores the mission number for use with
	-- setting the global speech paths, tech tree setup, and 
	-- the player's starting resources
	MISSION_NUMBER = 0203
	
	Setup_MissionPreset(MISSION_NUMBER)
	
	--[[ PRESET DEBUG CONDITIONS ]]
	Oosterbeek_Debug()
	
	--[[ REGISTER OBJECTIVES ]]
	Oosterbeek_ObjectiveRegister()
	
	--[[ MOD INITIAL STATS ]]
	Oosterbeek_ModifyStats()
	
	--[[ SET RESTRICTIONS ]]
	Oosterbeek_Restrictions()
	
	--[[ SET AI ]]
	Oosterbeek_CpuInit()
	
	--[[ SET DIFFICULTY ]]
	Oosterbeek_Difficulty()
	
	--[[ MISSION PRESETS ]]
	Oosterbeek_MissionPreset()
	

	--[[ GAME START CHECK ]]
	Rule_AddOneShot(Oosterbeek_NISStart, 1)
	
end

Scar_AddInit(OnInit)

function Oosterbeek_Debug()
	
	-- looks for the command line option [-debug]
	if Misc_IsCommandLineOptionSet("debug") then
		
		g_debug = true
		
		-- reveal FOW
		
	end
	
	
		
		-- set up bindings for NISes
	 		Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('Util_StartNIS(NIS_OPENING_BLEND)')]])")
--~ 		Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS02)')]])")
--~ 		Scar_DebugConsoleExecute("bind([[ALT+3]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS03)')]])")

	Scar_DebugConsoleExecute("bind([[NUMPAD8]], [[Scar_DoString('ToggleUIFOW()')]])")
end

function Oosterbeek_ObjectiveRegister()

	--[[ *** MUST INITIALIZE THE OBJ TABLE BEFORE REGISTERING *** ]]
	Initialize_OBJ_DestroyBridge()
	Initialize_OBJ_CapturePoints()
	Initialize_OBJ_DefendPoints()
	Initialize_OBJ_CaptureHeights()
	Initialize_OBJ_Medal()
	Initialize_OBJ_DestroyHowitzer()

end

function Oosterbeek_ModifyStats()
	Modify_PlayerResourceRate(player1, RT_Manpower, 1.05)
--~ 	Modify_PlayerResourceRate(player1, RT_Fuel, 1.3)
--~ 	Modify_PlayerResourceRate(player1, RT_Munition, 1.1)
			

	Modify_EntityBuildTime(player2, EBP.CW.HOWITZER_NEST, 0.1)

	--Cmd_InstantUpgrade(player1, UPG.SP.FALLSCHIRMJAGER_BUILDING)
	Modify_AbilityMaxCastRange(player1, ABILITY.CW.PDR_25_BARRAGE, 2)
	Modify_AbilityMaxCastRange(player1, ABILITY.CW.PDR_25_OVERWATCH, 1.5)
	Misc_RestrictCommandsToMarker(mkr_Clamp1)
	Camera_ClampToMarker(mkr_Clamp1)
end

function Oosterbeek_Restrictions()
	Player_SetResource(player2, RT_Manpower, 10000)
	Player_SetResource(player2, RT_Fuel, 10000)
	Player_SetPopCapOverride(player1, 100)
	Player_SetPopCapOverride(player2, 200)
	--Player_SetUpgradeAvailability( player1, UPG.ELITE.CONVERT_AMBIENT_BUILDING, ITEM_REMOVED )
	Player_SetResource(player1, RT_Munition, 1000)
	--Player_SetPopCapOverride(player3, 100)
	
	--[[ UN/RESTRICT UPGRADES 
	Cmd_InstantUpgrade(player1, UPG.ALLIES.STICKY_BOMB, ITEM_UNLOCKED)
	
	]]
	
	--[[ RESOURCES 
	Player_SetResource(player1, RT_Manpower, 600)
	Player_SetResource(player1, RT_Munition, 600)
	Player_SetResource(player1, RT_Fuel, 200)
	]]
	
	--[[ UN/RESTRICT ABILITIES 
	Player_SetAbilityAvailability(player1, ABILITY.ALLIES.GRENADE, ITEM_UNLOCKED)
	Player_SetAbilityAvailability(player1, ABILITY.ALLIES.SATCHEL_CHARGE, ITEM_REMOVED)
	Player_SetAbilityAvailability(player2, ABILITY.AXIS.GRENADE, ITEM_UNLOCKED)
	]]
	
	-- UN/RESTRICT POP CAP

	--[[ UN/RESTRICT UI 
	UI_BindingSetEnabled("company_commander", false)
	UI_BindingSetEnabled("squadcap", false)
	]]
	
	--[[ UN/RESTRICT SBPS 
	local sbps = {SBP.ALLIES_SHERMAN, SBP.ALLIES_CROCODILE, SBP.ALLIES_GREYHOUN, SBP.ALLIES_PERSHING }
	for i = 1, table.getn(sbps) do
		Player_SetSquadProductionAvailability(player1, sbps[i], ITEM_LOCKED)
	end
	]]
end



function Oosterbeek_CpuInit()

	AI_Enable(player2, false)
	--AI_Enable(player3, false)

	--[[ left as an example
	
	-- set up Player3 AI  
	Util_AI_Setup(player3, {Util_DifVar({10, 15, 20, 30}), 5}, player3, Game_GetSPDifficulty(), 7, Util_DifVar({1, 2, 3, 5}), 2, 3)
	
	-- Set up AI's resources
	Player_SetResource(player3, RT_Manpower, 1000)
	Player_SetResource(player3, RT_Munition, 100)
	Player_SetResource(player3, RT_Fuel, 100)
	
	-- tell AI to go after strongest threat instead of the weakest
	AI_DoString( player3, "s_personality.attack_prefer_threat = true" )
	AI_DoString( player3, "s_personality.defend_prefer_threat = true" )

	-- tell AI not to "defend" territories outside of the ring around its base
	AI_EnableComponent(player3, false, COMPONENT_ForwardDefending)
	
	-- disable use of comapny commander menu and abilities
	AI_DoString( player3, "s_commandtree_enabled = false" )
	AI_DoString( player3, "s_playerabilities_enabled = false" )
	
	AI_EnableComponent(player3, false, COMPONENT_Attacking)
	
	]]

end



function Oosterbeek_Difficulty()

	-- get the difficulty
	g_difficulty = Game_GetSPDifficulty()  -- set a global difficulty variable
	print("********* DIFFICULTY: "..g_difficulty)

	-- set health bonus for player 1
	Setup_Difficulty(player1, g_difficulty) -- pass the player and difficulty global variable into the Set Health function
	Setup_Difficulty(player2, g_difficulty) -- do it for each player that you have defined

	--[[ left as an example 
	
	t_difficulty = {
		base_def_spawn 			= Util_DifVar( {2*60, 1.5*60, 1*60, 0.75*60} ),			-- amount of time required before spawning base defense soldiers
		base_def_squad_num		= Util_DifVar( {1, 1, 2, 3} ),							-- number of squads to spawn for the base defense
		sniper_vulnerability 	= Util_DifVar( {2.5, 2, 1.5, 1} ),						-- the vulnerability factor on the snipers
		sniper_number			= Util_DifVar( {1, 2, 2, 3} ),							-- number of snipers to spawn
		sniper_wpn_cooldown		= Util_DifVar( {2, 1.5, 1, 1} ),						-- weapon cooldown time for the snipers
		stronghold_attack_num	= Util_DifVar( {1, 1, 2, 2} ),							-- number of squads to spawn from the guard tower to spawn and attack the player on alert
		aa_def_sbps				= Util_DifVar( {SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.GRENADIER, SBP.AXIS.STORMTROOPER, SBP.AXIS.KNIGHTSCROSS} ), -- types of squads to defend the AA Guns
	}
	
	]]
	
end


-------------------------------------------------------------------------

-- MISSION Preset 

-------------------------------------------------------------------------

function Oosterbeek_MissionPreset()

	UI_ForceCommanderTreeChoice(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE)

	
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_11, ITEM_LOCKED)
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_12, ITEM_LOCKED)
	Player_SetUpgradeAvailability(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_02, ITEM_LOCKED)
	
	--a table for random units

	
	nislet_DestroyBridge = {
		{camPos = eg_blg_Bridge, waitType = NISLET_TIME, waitValue = 40},

	}

	v_Strafing = 0
	v_form1 = 0 
	v_form2 = 0 
	v_form3 = 0 
	v_form4 = 0 
	v_form5 = 0 
	Modify_AbilityRechargeTime(player1, ABILITY.ELITE.MUNITIONPANZER_GOLIATH, 0.3)
	
	sg_PlayerAlphaHalftrack7 = SGroup_CreateIfNotFound("sg_PlayerAlphaHalftrack7")
	sg_PlayerAlphaHalftrack8 = SGroup_CreateIfNotFound("sg_PlayerAlphaHalftrack8")
	
	eg_SupplyDrops1 = EGroup_CreateIfNotFound("eg_SupplyDrops1")
	eg_SupplyDrops1a = EGroup_CreateIfNotFound("eg_SupplyDrops1a")
	eg_SupplyDrops2 = EGroup_CreateIfNotFound("eg_SupplyDrops2")
	eg_SupplyDrops2a = EGroup_CreateIfNotFound("eg_SupplyDrops2a")
	eg_SupplyDrops3 = EGroup_CreateIfNotFound("eg_SupplyDrops3")
	eg_SupplyDrops3a = EGroup_CreateIfNotFound("eg_SupplyDrops3a")
	eg_blg_base1 = EGroup_CreateIfNotFound("eg_blg_base1")
	eg_blg_base2 = EGroup_CreateIfNotFound("eg_blg_base2")
	eg_blg_base3 = EGroup_CreateIfNotFound("eg_blg_base3")
	eg_blg_base4 = EGroup_CreateIfNotFound("eg_blg_base4")
	Util_CreateEntities(player1, eg_blg_base1, EBP.ELITE.KAMPFGRUPPE, mkr_base1, 1)
	Util_CreateEntities(player1, eg_blg_base2, EBP.ELITE.LOGISTIK, mkr_base2, 1)
	
end





-------------------------------------------------------------------------

-- MISSION START 

-------------------------------------------------------------------------

function Oosterbeek_NISStart()
	Util_StartNIS(NIS_OPENING_BLEND, Oosterbeek_MissionStart)

end

function JennyKim()
	if g_Timerstart == nil then 
		Timer_Start("TooLong", 900)
		g_Timerstart = 1
	end
	if Timer_GetRemaining("TooLong") == 500 and g_Timerstart == 1 and EGroup_Count(eg_blg_Bridge) > 0 then 
		InterfereAlpha_Init()
	end
	if Timer_GetRemaining("TooLong") == 0 and g_Timerstart == 1 and EGroup_Count(eg_blg_Bridge) > 0 then 
		EventCue_Create(CUE.ATTACKED, 1439306, 1439306, nil)
		if Rule_Exists(DefendPoints_DelayGrant) == false then 
			--EGroup_InstantCaptureStrategicPoint(eg_pnt_R1, player1)
			--EGroup_InstantCaptureStrategicPoint(eg_pnt_C3, player1)
			Objective_Complete(OBJ_CapturePoints)
		end
		Util_AutoIntel(t_tooclose3)
		g_tooclose3 = 1
		Rule_RemoveMe()
	end


	if g_tooclose1 == nil and Prox_ArePlayersNearMarker(player1, mkr_Oosterbeek, ANY, 130) then 
		Util_AutoIntel(t_tooclose1)
		EventCue_Create(CUE.ATTACKED, 1439306, 1439306, nil)
		g_tooclose1 = 1
	end
	if g_tooclose2 == nil and Prox_ArePlayersNearMarker(player1, mkr_Oosterbeek, ANY, 70) then 
		Util_AutoIntel(t_tooclose2)
		EventCue_Create(CUE.ATTACKED, 1439306, 1439306, nil)
		g_tooclose2 = 1
	end
	if g_tooclose3 == nil and Prox_ArePlayersNearMarker(player1, mkr_Oosterbeek, ANY, 30) then 
		if Objective_IsComplete(OBJ_DestroyBridge) == true then 
			--EGroup_InstantCaptureStrategicPoint(eg_pnt_R1, player1)
			--EGroup_InstantCaptureStrategicPoint(eg_pnt_C3, player1)
			Objective_Complete(OBJ_CapturePoints)
			
			if Rule_Exists(DefendPoints_DelayGrant) == false then 
				Rule_AddOneShot(DefendPoints_DelayGrant, 5)
			end
			Util_AutoIntel(t_tooclose3)
			EventCue_Create(CUE.ATTACKED, 1439306, 1439306, nil)
			g_tooclose3 = 1
			Rule_RemoveMe()
		elseif Objective_IsComplete(OBJ_DestroyBridge) == false then 
			--EGroup_InstantCaptureStrategicPoint(eg_pnt_R1, player1)
			--EGroup_InstantCaptureStrategicPoint(eg_pnt_C3, player1)
			Objective_Complete(OBJ_CapturePoints)
			EventCue_Create(CUE.ATTACKED, 1439306, 1439306, nil)
			Util_AutoIntel(t_tooclose3)

			g_tooclose3 = 1
			Rule_RemoveMe()
		end	
	end
	if Objective_IsComplete(OBJ_CapturePoints) then 
		Rule_RemoveMe()
	end
end
function Fail_Game()
	Modifier_RemoveAllFromSGroup(sg_AxisAll)	
	Modifier_RemoveAllFromSGroup(sg_AllyAll)
	Camera_Unclamp()
	Misc_RemoveCommandRestriction()
	Game_EndSP(false)
end
function Osterbeek_NISAction()
	Cmd_Move(sg_PlayerAlpha1, eg_blg_Bridge)
	Camera_FollowSGroup(sg_PlayerAlpha1) 
end
function Oosterbeek_MissionStart()

	if Event_IsAnyRunning() == false then
		Rule_AddOneShot(Misc_GrabTerritory, 1)
		Rule_AddInterval(Misc_DestroyAllSquads, 1)	
		Rule_AddOneShot(PlayerBeta_Init, 1)
		--Rule_AddOneShot(PlayerGamma_Init, 1)
		ATGunAlpha_Init()
		--MortarBeta_Init()
		MGBeta_Init()
		StillAlpha_Init()
		AttackAlpha_Init()
		RetreatAlpha_Init()
		CounterAlpha_Init()
		EngineerBuilding_Init()
		
	
	
		-- depends on previous rule to run

		--Rule_AddOneShot(Osterbeek_NISAction, 10)

		Rule_AddInterval(JennyKim, 1)
		DontEnterAlpha_Init()
		
		
		Rule_AddOneShot(PlayerAlpha_Init, 1)
		UI_BindingSetEnabled( "company_commander", false )	
		__DisableCompanyCommanderTree()
		Rule_AddOneShot(HalftrackAlpha_Init, 1)
		Rule_AddOneShot(MGGamma_Init, 1)
		Rule_AddOneShot(Delay_DestroyBridge, 1)
		--player spawn

		Rule_AddInterval(Check_InitilizeHeights, 1)
		Rule_AddInterval(DestroyHowitzer_DelayGrant, 1)
		Rule_AddOneShot(PlayerDelta_Init, 1)
		--enemy spawn
		Rule_RemoveMe()
		
	end
end

function Delay_DestroyBridge()
	Objective_Start(OBJ_DestroyBridge)

end


-------------------------------------------------------------------------
-- Objective Destroy Bridge
-------------------------------------------------------------------------
--The player must destroy the Panther to get the next objective.  
--The Panther will back away if its health hits below a certain threashold
-------------------------------------------------------------------------


function Initialize_OBJ_DestroyBridge()
-- objective to destroy the panther
	OBJ_DestroyBridge = {
		
		SetupUI = function() 
			OBJ_DestroyBridge.ID1 = Objective_AddUIElements(OBJ_DestroyBridge, mkr_ian, true, 1439050, true)
			
			--Objective_SetAlwaysShowDetails(OBJ_DestroyBridge, false, true, false)

		end,
		
		OnStart = function()
			Sound_PlayMusic("Music/SP/OMG/Trepidation/OMG/CONVOY.bsc",2,0)
			Util_AutoIntel(t_Destroy_Objective)
			-- win/lose check
			Rule_AddInterval(DestroyBridge_WinCheck, 1)
			TrenchAlpha_Init()
			-- action
			DestroyBridge_KickOff()
			sg_DropParatroop = SGroup_CreateIfNotFound("sg_DropParatroop")
			sg_DropParatroop2 = SGroup_CreateIfNotFound("sg_DropParatroop2")
			FOW_RevealArea(Marker_GetPosition(mkr_Fow1a), 30, -1)
			FOW_RevealArea(Marker_GetPosition(mkr_Fow2a), 30, -1)
			FOW_RevealArea(Marker_GetPosition(mkr_Fow3a), 30, -1)	
			Rule_AddInterval(Rule_Chatter_Defense, 30)
		end,
		
		OnComplete = function()
			if Objective_IsComplete(OBJ_CapturePoints) == false then 
				Sound_StopMusic(20,10)
				
				if g_flashstart == 1 then 	
					UI_StopFlashing(flashID2)
				end

				Rule_Remove(HalftrackAlpha_Kickoff)
				-- setup next obj
				-- trigger next obj
				if g_DefendPointStarted == nil then 
					Rule_AddOneShot(CapturePoints_DelayGrant, 1)	
				end
			end
			FOW_UnRevealArea(Marker_GetPosition(mkr_Fow1a), 30)
			FOW_UnRevealArea(Marker_GetPosition(mkr_Fow2a), 30)
			FOW_UnRevealArea(Marker_GetPosition(mkr_Fow3a), 30)	
			
			sg_DeleteLeft = SGroup_CreateIfNotFound("sg_DeleteLeft")
			Player_GetAllSquadsNearMarker(player1, sg_DeleteLeft, mkr_spawngoliath, 20)
			SGroup_Kill(sg_DeleteLeft)
		end,
		
		IsComplete = function()
			
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1439050,
		Description = 1439051,
		Type = OT_Primary,
		TitleEnd = 1439053,
	}
	
	-- Register Objective
	Objective_Register(OBJ_DestroyBridge)
	-- Initialize Data
	DestroyBridge_Init()
	
end

function Rule_Chatter_Defense()
	if table.getn(t_ambientDefense) >  0 and Event_IsAnyRunning() == false then
		if SGroup_IsEmpty( sg_AllyAll ) == false and SGroup_IsDoingAttack(sg_AllyAll, ANY, 1) then
			i = World_GetRand(1, table.getn(t_ambientDefense))
			Util_AutoAmbient(t_ambientDefense[i])
			table.remove(t_ambientDefense, i)
		end

	elseif table.getn(t_ambientDefense) <=  0 then
		Rule_RemoveMe()
	end
end

-------------------------------------------------------------------------
-- Objective Name - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function DestroyBridge_Init()

	
	
end

-- preset any units or events needed before the kickoff, but you do not
-- want them to occur at the outset of the map.
-- Example: Often units are needed to exist before the objective start (because they start the objective)
-- then spawn those units here when they need to be spawned
function DestroyBridge_Preset()
	
	
	-- spawn squads
	
	-- start enemy behavior
	
	-- do other cool things

end

function DestroyBridge_KickOff()
		
	-- Intel lines about the tank
	Rule_AddInterval(DestroyBridge_FirstIntel, 1)

end

function DestroyBridge_FirstIntel()
--speech related to this encounter	
end
function RemoveLetterBox()

	Game_Letterbox(false, 1)
end
-- win condition - once the player kills the Panther
-- the next obj is triggered
function RuleEvent_GoliathDestroyed(squad)
	if World_DistancePointToPoint(Squad_GetPosition(squad), Marker_GetPosition(mkr_Bridge)) < 20 then
		EGroup_Kill(eg_blg_Bridge)
	end
end
function DestroyBridge_WinCheck()
	if EGroup_Count(eg_blg_Bridge) == 0 then 
		Rule_Remove(Rule_Chatter_Defense)
		Util_AutoNISlet(NISLET_GAME2LETTER, t_Nislet_Bridge) 
		FOW_RevealMarker(mkr_CamBridge, 15)
		Objective_Complete(OBJ_DestroyBridge)
		Rule_AddOneShot(RemoveUI, 1)
		
		if g_tooclose3 == 1 then
			Rule_AddOneShot(RemoveLetterBox, 10)
		end
		Rule_RemoveMe()
		return
	end
	if Prox_ArePlayersNearMarker(player1, mkr_Bridge, ANY, 40) and g_manning == nil then 
		ManningAlpha_Init()
		g_manning = 1
	end
	if Prox_AreSquadsNearMarker(sg_AxisGoliath, mkr_Bridge_Detonate, ANY, 20) then
		if event_detonate == nil then
			Util_AutoIntel(t_Destroy_FlashGoliath)
			UI_FlashAbilityButton(ABILITY.AXIS.GOLIATH_DETONATE, true, BT_UI_Weak_CommandBtn )
			event_detonate = 1
		end
		for i=1,SGroup_CountSpawned(sg_AxisGoliath) do
			local squad = SGroup_GetSpawnedSquadAt(sg_AxisGoliath, i)
			Rule_RemoveSquadEvent(RuleEvent_GoliathDestroyed, squad)
			Rule_AddSquadEvent(RuleEvent_GoliathDestroyed, squad, GE_SquadKilled)
		end
	end	
	if SGroup_Count(sg_AxisBridge) > 0 and SGroup_Count(sg_AllyBridge) == 0 and event_bridge == nil and EGroup_Count(eg_blg_Bridge) > 0 then 
		Util_AutoIntel(t_Destroy_AreaClear)
		event_bridge = 1
	end
	
	if Prox_AreSquadsNearMarker(sg_AxisAll, mkr_Bridge, ANY) and speech_halftrack == nil then
		speech_halftrack = 1 
		Util_AutoIntel(t_Destroy_FirstBridge)
	end
	if Misc_IsSGroupSelected(sg_AxisAll, ANY) and speech_select == nil then 
		speech_select = 1
		-- brw 07/31/07, removing this speech because it's redundant.
--~ 		Util_AutoAmbient(t_firstmoveorder)
		Cmd_Ability(sg_PlayerAlphaHalftrack4, ABILITY.ELITE.MUNITIONPANZER_FOLLOW, sg_PlayerAlphaHalftrack1)
	end
	if Prox_AreSquadsNearMarker(sg_AxisMunitionHalftrack, mkr_Bridge, ANY, 80) and ping_halftrack == nil then
		OBJ_DestroyBridge.ID2 = Objective_AddUIElements(OBJ_DestroyBridge, sg_AxisMunitionHalftrack, true, 1439052, true)
		ping_halftrack = 1
	elseif Prox_AreSquadsNearMarker(sg_AxisGoliath, mkr_Bridge, ANY, 80) and ping_halftrack == nil then 
		OBJ_DestroyBridge.ID3 = Objective_AddUIElements(OBJ_DestroyBridge, sg_AxisGoliath, true, 1439204, true)
		ping_halftrack = 1
	end		
	if Prox_AreSquadsNearMarker(sg_AxisMunitionHalftrack, mkr_Bridge, ANY) and event_flash == nil and SGroup_Count(sg_AxisGoliath) == 0 then
		
		flashID = UI_FlashAbilityButton(ABILITY.ELITE.MUNITIONPANZER_GOLIATH, true, BT_UI_Weak_CommandBtn )
		
		UI_SetModalAbilityPhaseCallback(Goliath_Callback)
		event_flash = 1 
		event_halftrack	= 1	
	end
	
-----------------------------------------------------------------------------------------------------------------------------------------------------
	
	if SGroup_Count(sg_AxisGoliath) > 0 and event_halftrack == 1 then 
		Objective_RemoveUIElements(OBJ_DestroyBridge, OBJ_DestroyBridge.ID2)
		OBJ_DestroyBridge.ID3 = Objective_AddUIElements(OBJ_DestroyBridge, sg_AxisGoliath, true, 1439204, true)
		event_halftrack = 2
	end
	if SGroup_Count(sg_AxisGoliath) == 0 and event_halftrack == 2 and SGroup_Count(sg_AxisMunitionHalftrack) > 0 then 
		OBJ_DestroyBridge.ID2 = Objective_AddUIElements(OBJ_DestroyBridge, sg_AxisMunitionHalftrack, true, 1439052, true)
		event_halftrack = 1
	end
	if SGroup_Count(sg_AxisGoliath) == 0 and SGroup_Count(sg_AxisMunitionHalftrack) == 0 and (event_halftrack == 1 or event_halftrack == 2) then
		OBJ_DestroyBridge.ID4 = Objective_AddUIElements(OBJ_DestroyBridge, eg_blg_base2, true, 1439205, true)
		flashID2 = UI_FlashProductionButton(PITEM_Spawn, SBP.ELITE.HALFTRACK_251, true, BT_UI_Weak_UpgradeBtn )
		g_flashstart = 1
		event_halftrack = 3
	end
	if event_halftrack == 3 and SGroup_Count(sg_AxisMunitionHalftrack) > 0 then 
		event_halftrack = 2 
		Objective_RemoveUIElements(OBJ_DestroyBridge, OBJ_DestroyBridge.ID4)
	end
	if Prox_AreSquadsNearMarker(sg_AxisGoliath, mkr_Bridge, ANY) and g_goliath == nil then 
		g_goliath = 1
--~ 		Util_Paradrop(player2, sg_DropParatroop, SBP.CW.COMMANDOS_PARATROOPER_SP, mkr_Bridge, 1)
--~ 		Cmd_AttackMove(sg_DropParatroop, sg_AxisGoliath)
		Util_CreateSquads(player2, sg_DropParatroop2, SBP.CW.COMMANDOS_PARATROOPER_SP, mkr_spawngoliath, nil, 2, 2)
		if SGroup_Count(sg_AxisGoliath) > 0 and SGroup_Count(sg_DropParatroop2) > 0 then
			Cmd_AttackMove(sg_DropParatroop2, sg_AxisGoliath)
		elseif SGroup_Count(sg_AxisAll) > 0 and SGroup_Count(sg_DropParatroop2) > 0 then
			Cmd_AttackMove(sg_DropParatroop2, sg_AxisAll)
		end
		
	end
	if Prox_AreSquadsNearMarker(sg_DropParatroop, mkr_Bridge, ANY) and g_goliath == 1 then 
		Util_AutoIntel(t_Destroy_Paratrooper)
		g_goliath = 2
	end
	
	
	
--~ 	if SGroup_Count(sg_DropParatroop) > 0 then 
--~ 		if SGroup_Count(sg_AxisGoliath) > 0 then 
--~ 			Cmd_AttackMove(sg_DropParatroop, sg_AxisGoliath)		
--~ 		elseif SGroup_Count(sg_AxisAll) > 0 then 
--~ 			Cmd_AttackMove(sg_DropParatroop, sg_AxisAll)
--~ 		end
--~ 	end
	if SGroup_Count(sg_DropParatroop2) > 0 then 
		if SGroup_CountSpawned(sg_AxisGoliath) > 0 then 
			Cmd_AttackMove(sg_DropParatroop2, sg_AxisGoliath)	
		elseif SGroup_Count(sg_AxisAll) > 0 then 
			Cmd_AttackMove(sg_DropParatroop2, sg_AxisAll)
		end
	end
end

function RemoveUI()
	Objective_RemoveUIElements(OBJ_DestroyBridge, OBJ_DestroyBridge.ID1)
	Objective_RemoveUIElements(OBJ_DestroyBridge, OBJ_DestroyBridge.ID2)
	Objective_RemoveUIElements(OBJ_DestroyBridge, OBJ_DestroyBridge.ID3)
	Objective_RemoveUIElements(OBJ_DestroyBridge, OBJ_DestroyBridge.ID4)
end

function Goliath_Callback(ability, phase)
	if ability == ABILITY.ELITE.MUNITIONPANZER_GOLIATH then 
		if phase == MAP_Placing then 
			Util_AutoIntel(t_firstgoliath)
			UI_ClearModalAbilityPhaseCallback()
		end
	end
end


function Check_InitilizeHeights()
	if Prox_ArePlayersNearMarker(player1, mkr_Hill, ANY, 60) then 
		if g_OBJ_CaptureHeights == nil then 
			Objective_Start(OBJ_CaptureHeights)
			g_OBJ_CaptureHeights = 1
			Rule_RemoveMe()
		end
	end
end

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



-------------------------------------------------------------------------
-- Capture 3 points
-------------------------------------------------------------------------

-------------------------------------------------------------------------
function Initialize_OBJ_CapturePoints()
	OBJ_CapturePoints = {
		
		SetupUI = function() 
			
			OBJ_CapturePoints.C3 = Objective_AddUIElements(OBJ_CapturePoints, eg_pnt_C3, true, 1439093, true, 2)
			OBJ_CapturePoints.R1= Objective_AddUIElements(OBJ_CapturePoints, eg_pnt_R1, true, 1439093, true, 2)
			--Objective_SetAlwaysShowDetails(OBJ_CapturePoints, false, true, true)
			
		end,
		
		OnStart = function()
			-- win/lose check
			Sound_PlayMusic("Music/SP/OMG/preparation/OMG/omg_m01_cue3.bsc",2,0)
			Rule_AddInterval(CapturePoints_WinCheck, 1)
			-- action
			CapturePoints_Kickoff()
			Util_AutoIntel(t_CapturePoint_Objective)
			--Util_AutoAmbient(t_respondtobridge)

			if Player_OwnsEGroup(player1, eg_pnt_C3) == true or  Player_OwnsEGroup(player1, eg_pnt_R1) == true then 
				speech_point = 1 
			end
		end,
		OnComplete = function()
		Sound_PlayMusic("Music/SP/OMG/Sitreps/OMG/Situation_report_1.bsc",2,0)
			if g_DefendPointStarted == nil then 
				if Rule_Exists(DefendPoints_DelayGrant) == false then 
					Rule_AddOneShot(DefendPoints_DelayGrant, 1)
					g_DefendPointStarted = 1
					Rule_Remove(JennyKim)
				end
			end
			
			-- tell the player they did good
		end,
		
		IsComplete = function()
			
			
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1439090,
		Description = 1439091,
		Type = OT_Primary,
		TitleEnd = 1439092, 
		SitRep = {
			Movie = "CXP2_SR_03-01",
			Force = true,
			SpeechTiming =
			{
				{ 1,	ACTOR.CXP2.Voss, 1435691 },
				{ 5.5,	ACTOR.CXP2.Voss, 1435692 },
				{ 10.5,	ACTOR.CXP2.Voss, 1435694 },
				{ 18,	ACTOR.CXP2.Voss, 1435693 },
				{ 25,	ACTOR.CXP2.Wolfgang, 1435695 },
				{ 31.9,	ACTOR.CXP2.Wolfgang, 1435696 },
			--	{ 25,	ACTOR.CXP2.Wolfgang, 1435697 }, -- No longer used, July 18, 2007 -cmartin
				{ 37.8,	ACTOR.CXP2.Aldrich, 1435698 },
				{ 40,	ACTOR.CXP2.Aldrich, 1435699 },
			},
			PrologueEvent = function()

				Camera_MoveToPosition(Marker_GetPosition(mkr_PlayerBeta2))
		
			end,

		
		},
	}
	
	-- Register Objective
	Objective_Register(OBJ_CapturePoints)
	-- Initialize Data
	CapturePoints_Init()
	
end

function CapturePoints_Init()


end

function CapturePoints_Preset()
	

end


-- Complete when the allied HQ reaches the location. 
function CapturePoints_WinCheck()
	if Player_OwnsEGroup(player1, eg_pnt_C3) and g_pntc3 == nil then 
		Objective_RemoveUIElements(OBJ_CapturePoints, OBJ_CapturePoints.C3)		
		g_pntc3 = 1
	end
	if Player_OwnsEGroup(player1, eg_pnt_R1) and g_pntr1 == nil then 
		Objective_RemoveUIElements(OBJ_CapturePoints, OBJ_CapturePoints.R1)
		g_pntr1 = 1
	end
	if Player_OwnsEGroup(player1, eg_pnt_C3) and Player_OwnsEGroup(player1, eg_pnt_R1)  then 
		Objective_Complete(OBJ_CapturePoints)
		Rule_RemoveMe() 
	end
	
	if (Player_OwnsEGroup(player1, eg_pnt_C3) or Player_OwnsEGroup(player1, eg_pnt_R1)) and speech_point == nil  then 
		Util_AutoIntel(t_CapturePoint_Firstcaptured)	
		speech_point = 1 
	end

		
end

-- start the related action
function CapturePoints_Kickoff()

	
	
end


-- start the related action
function CapturePoints_DelayGrant()
	if g_OBJ_CapturePoints == nil then 
		Objective_Start(OBJ_CapturePoints)
		g_OBJ_CapturePoints = 1
		Rule_RemoveMe()
	end
end

-------------------------------------------------------------------------
-- Capture Westerbouwing Heights
-------------------------------------------------------------------------

-------------------------------------------------------------------------
function Initialize_OBJ_CaptureHeights()
	OBJ_CaptureHeights = {
		
		SetupUI = function() 
			
			OBJ_CaptureHeights.mapElementID = Objective_AddUIElements(OBJ_CaptureHeights, eg_pnt_Heights, true, 1439060, true, 2)
			--Objective_SetAlwaysShowDetails(OBJ_CaptureHeights, false, true, true)
			
		end,
		
		OnStart = function()
			-- win/lose check
			Rule_AddInterval(CaptureHeights_WinCheck, 5)
			-- action
			CaptureHeights_Kickoff()
			
			Util_AutoIntel(t_CaptureHeights_Objective)
			
		end,
		OnComplete = function()
			
			-- tell the player they did good
			
			
			
			Util_AutoIntel(t_heightscomplete)
		end,
		
		IsComplete = function()
			
			
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1439060,
		Description = 1439061,
		Type = OT_Secondary,
		TitleEnd = 1439062,
	}
	
	-- Register Objective
	Objective_Register(OBJ_CaptureHeights)
	-- Initialize Data
	CaptureHeights_Init()
	
end

function CaptureHeights_Init()
	eg_blg_recruit2 = EGroup_CreateIfNotFound("eg_blg_recruit2")
	

end

function CaptureHeights_Preset()
	

end


-- Complete when the allied HQ reaches the location. 
function CaptureHeights_WinCheck()
	
	if Player_OwnsEGroup(player1, eg_pnt_Heights) then 
		Objective_Complete(OBJ_CaptureHeights)
		Rule_RemoveMe() 
	end
end

-- start the related action
function CaptureHeights_Kickoff()

	
	
end


-- start the related action
function CaptureHeights_DelayGrant()
	if g_OBJ_CaptureHeights == nil then 
		Objective_Start(OBJ_CaptureHeights)
		
		g_OBJ_CaptureHeights = 1
		Rule_RemoveMe()
	end
end

function Recruit_LuftwaffeSquad()
	if g_epilogue == 1 then 
		Rule_AddInterval(Check_CommandPoints, 1)
		Objective_StartTimer(OBJ_DefendPoints, COUNT_DOWN, 900, 60) 
		Rule_AddInterval(DefendPoints_WinCheck, 1)
		Rule_RemoveMe()
	end
end
function Move_Luftwaffe()
	if SGroup_IsHoldingAny(sg_OpelAlpha1) == false then 
		Cmd_Move(sg_OpelAlphaInf1, mkr_PlaceFlak)
		Cmd_Move(sg_OpelAlpha1, mkr_PlayerDelta1)
		Rule_AddInterval(Opel_Disappear, 1)
		Rule_AddInterval(Select_Luftwaffe, 1)
		Rule_RemoveMe()
	end
end
function Opel_Disappear()
	if SGroup_IsOnScreen(player1, sg_OpelAlpha1, ANY) == false then 
		SGroup_DestroyAllSquads(sg_OpelAlpha1)
		Rule_RemoveMe()
	end
end

function Recruit_LuftwaffeSquad2()

	if Prox_AreSquadsNearMarker(sg_OpelAlpha1, mkr_OpelAlphaInf1, ANY, 3)  then		
		Cmd_Ungarrison(sg_OpelAlpha1)
		Rule_AddInterval(Move_Luftwaffe, 1)		
		Rule_RemoveMe()
	end
end
function Select_Luftwaffe()
	sg_Luftwaffesquad = SGroup_CreateIfNotFound("sg_Luftwaffesquad")
	Player_GetAll(player1, sg_Luftwaffesquad)
	SGroup_Filter(sg_Luftwaffesquad, {SBP.ELITE.LUFTWAFFE}, FILTER_KEEP) 
	if SGroup_Count(sg_Luftwaffesquad) > 0 and g_luftspawn == nil then 
		
		hintpointLuftwaffe = HintPoint_Add(sg_Luftwaffesquad, true, 1439203)
		g_luftspawn = 1
		Cmd_Move(sg_Luftwaffesquad, mkr_PlaceFlak)
	end
	if Misc_IsSGroupSelected(sg_Luftwaffesquad, ANY) then 
		HintPoint_Remove(hintpointLuftwaffe)
		flashid_building_op1 = UI_FlashConstructionMenu("tp_construction_panzer_elite_luftwaffe", true, BT_UI_Weak_CommandBtn)
		hpid_building_op1 = HintPoint_AddToConstructionMenu("p_construction_panzer_elite_luftwaffe", 1439201, true)
		UI_SetConstructionMenuCallback(Building_Secure_ClickedBuildMenu)
		Rule_RemoveMe()
		Rule_AddOneShot(Remove_op1, 60)
	end
end
function Remove_op1()
	HintPoint_Remove(hintpointLuftwaffe)
	UI_StopFlashing(flashid_building_op1)
	UI_ClearConstructionMenuCallback()
end
function Check_Luftwaffe()
	
	sg_Luftwaffesquad = SGroup_CreateIfNotFound("sg_Luftwaffesquad")
	Player_GetAll(player1, sg_Luftwaffesquad)
	SGroup_Filter(sg_Luftwaffesquad, {SBP.ELITE.LUFTWAFFE}, FILTER_KEEP) 
	if Misc_IsSGroupSelected(sg_Luftwaffesquad, ANY) then 
		Util_AutoIntel(t_RecruitLuft) 
		flashid_building_op1 = UI_FlashConstructionMenu("tp_construction_panzer_elite_luftwaffe", true, BT_UI_Weak_CommandBtn)
		hpid_building_op1 = HintPoint_AddToConstructionMenu("p_construction_panzer_elite_luftwaffe", 1439201, true)
		UI_SetConstructionMenuCallback(Building_Secure_ClickedBuildMenu)
		Rule_RemoveMe()
		
	end
	
end

function Building_Secure_ClickedBuildMenu(menuname, activated)

	if menuname == "tp_construction_panzer_elite_luftwaffe" then
		if activated == true then
			UI_ClearConstructionMenuCallback()
			UI_StopFlashing(flashid_building_op1)
			UI_FlashConstructionButton(EBP.SYNC_WEAPON.FLAK_38, true, BT_UI_Weak_UpgradeBtn)
			UI_SetBuildingPlacementCallback(SetUpBase_Flak)
			Player_AddResource(player1, RT_Fuel, 20)
			
		end
	end
end


-- callback function deals with stages for building the howitzer
function SetUpBase_Flak(ebp, phase)
	
	if ebp == EBP.SYNC_WEAPON.FLAK_38 then
		if speech_flak == nil then 
			Util_AutoIntel(t_RecruitLuft2) 
			speech_flak = 1
			
		end
		-- placing
		if phase == CP_Selected then
			
			if g_hint == nil then 
				hntpnt_flak = HintPoint_Add(mkr_PlaceFlak, true, 1439202)
				Rule_AddOneShot(Remove_HntFlak, 60)
				g_hint = 1
			end
		-- rotating
		elseif phase == CP_StartedPlacing then
			HintPoint_Remove(hntpnt_flak)
			UI_ClearBuildingPlacementCallback()
		-- placed
		elseif phase == CP_FinishedPlacing then
			
			--UI_FlashAbilityButton(ABILITY.COMMANDER_TREE.ELITE.RECRUIT_LUFTWAFFE, true, BT_UI_Weak_AbilityBtn)		
			
			
		end
		
	end		
	
end

function Remove_HntFlak()
	HintPoint_Remove(hntpnt_flak)
end 


function Check_CommandPoints()
	if Player_GetResource(player1, RT_Command) > 0 and g_commandpoint == nil then 
		EventCue_Create(CUE.ATTACKED, 1439303, 1439303, nil)
		g_commandpoint = 1
	end
	if Player_GetResource(player1, RT_Command) > 1 then 
		flashid_building_cc = UI_FlashBinding("company_commander", true, BT_UI_Weak_CommanderBtn)
		hpid_building_cc = HintPoint_AddToTaskbarBinding("company_commander", 1439200, true)
		Rule_AddInterval(Check_CommandPoints_ClearHint, 0.5)
		Rule_AddInterval(Recruit_Fallshirmajager, 1)
		Rule_RemoveMe()
	end
end

function Check_CommandPoints_ClearHint()
	if UI_IsCommanderTreeBranchShown() then
		flashcommand = UI_FlashCommanderBranchUpgrade(UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_00, BT_UI_Strong_UpgradeBtn)	
		UI_StopFlashing(flashid_building_cc)		
		HintPoint_Remove(hpid_building_cc)
		Rule_RemoveMe()
	end
end



function Recruit_Fallshirmajager()
	if Player_HasUpgrade(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_00) then 
--~ 		if jen == 1 then 
--~ 			UI_StopFlashing(flashcommand)
--~ 			jen = 2
--~ 		end
		if g_recruit == nil then 	
			Util_AutoIntel(t_RecruitFall)
			eg_tempfall = EGroup_CreateIfNotFound("eg_tempfall")
			g_recruit = 1
			--Player_SetUpgradeAvailability(player1, UPG.SP.FALLSCHIRMJAGER_BUILDING, ITEM_UNLOCKED)
			--Player_SetAbilityAvailability(player1, ABILITY.SP.FALLSHIRMJAGER_BUILDINGONLY, ITEM_UNLOCKED)
			
			--Player_SetAbilityAvailability(player1, ABILITY.SP.FALLSHIRMJAGER_FOWONLY, ITEM_REMOVED)
		end
		if g_playerevent == nil then 
			Rule_AddPlayerEvent(AbilityListenerFallshirmajager, player1, GE_AbilityExecuted)
			UI_SetModalAbilityPhaseCallback(AbilityListenerFallshirmajager2)
			flashfall = UI_FlashAbilityButton(ABILITY.SP.FALLSHIRMJAGER_BUILDINGONLY, true, BT_UI_Weak_AbilityBtn)
			g_playerevent = 1
		end
		
		--Rule_AddInterval(Check_SeeBuilding, 1)
		
	end
end
function UI_RemoveTemp()
	HintPoint_Remove(hintpointID2)
end

function AbilityListenerFallshirmajager2(ability, phase)
       print("TESTING!")     
	if ability == ABILITY.SP.FALLSHIRMJAGER_BUILDINGONLY then
		
		if phase == MAP_Placing then
     		EGroup_Clear(eg_tempfall)
			local _CheckEntity = function(gid, idx, eid)
				if Misc_IsEntityOnScreen(eid, 0.5) and Player_OwnsEntity(player2, eid) == false then
					EGroup_Add(eg_tempfall, eid)
					hintpointID2 = HintPoint_Add(eg_tempfall, true, 1439210, -3)
					Camera_MoveToEGroup(eg_tempfall, true, 5)
					Rule_AddOneShot(UI_RemoveTemp, 60)
					Rule_RemoveMe()
					return true
				end
			end
			EGroup_ForEach(eg_blg_AllBuildings, _CheckEntity)
            UI_ClearModalAbilityPhaseCallback()    
		elseif phase == MAP_Confirmed then
            
            
                            
 
            
		end
	end
            
end


function AbilityListenerFallshirmajager(squad, abilityID, target)
	
	
	
	if abilityID == ABILITY.SP.FALLSHIRMJAGER_BUILDINGONLY then	
		--if scartype(target) == ST_ENTITY then
			HintPoint_Remove(hintpointID2)	
			Rule_AddOneShot(Give_Ability, 40)
			UI_StopFlashing(flashfall)
			--Player_SetAbilityAvailability(player1, ABILITY.SP.FALLSHIRMJAGER_FOWONLY, ITEM_UNLOCKED)
			
			
			Rule_RemoveMe()
		--end
	end
end
function Give_Ability()
	Player_SetAbilityAvailability(player1, ABILITY.COMMANDER_TREE.ELITE.RECRUIT_FALLSHIRMAJAGER, ITEM_REMOVED)
	Player_SetAbilityAvailability(player1, ABILITY.SP.FALLSHIRMJAGER_BUILDINGONLY, ITEM_REMOVED)
	Cmd_InstantUpgrade(player1, UPG.SP.FALLSCHIRMJAGER_NO_FOW)
end

-------------------------------------------------------------------------
-- Counter Attack 
-------------------------------------------------------------------------
-- The player has to fend off the Axis DefendPoints for X minutes.  
-------------------------------------------------------------------------
function Initialize_OBJ_DefendPoints()

	OBJ_DefendPoints = {
		
		SetupUI = function() 

--~ 			if Player_OwnsEGroup(player1, eg_pnt_R2) then 
--~ 				OBJ_DefendPoints.R2 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R2, true, 1439070, true, 2)
--~ 			end
--~ 			if Player_OwnsEGroup(player1, eg_pnt_C3) then 
--~ 				OBJ_DefendPoints.C3 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_C3, true, 1439070, true, 2)
--~ 			end
			-- mark a point or position
		end,
		
		OnStart = function()
			Sound_PlayMusic("Music/SP/OMG/Preparation/OMG/BUILD_OR_FAIL.bsc",2,0)
			ping_R1 = 1
			ping_R2 = 1
			ping_R3 = 1
			ping_R4 = 1
			ping_C3 = 1
			g_DefendPoints = 1
			Rule_AddInterval(Recruit_LuftwaffeSquad2, 1)
			
			Rule_AddInterval(Recruit_LuftwaffeSquad, 1)
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,

		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1439070,
		Description = 1439071,
		Type = OT_Primary,
		TitleEnd = 1439075,
		SitRep = {
			Movie = "CXP2_SR_03-02",
			Force = true,
			SpeechTiming =
			{
				{ 1,	ACTOR.CXP2.Wolfgang, 1435900},
				{ 4.3,	ACTOR.CXP2.Wolfgang, 1435901},
				{ 8.9,	ACTOR.CXP2.Voss, 1435910 },
				{ 13,	ACTOR.CXP2.Voss, 1435920},
				{ 15.6,	ACTOR.CXP2.Voss, 1435930},
				{ 20,	ACTOR.CXP2.Voss, 1435940 },
				{ 27,	ACTOR.CXP2.Voss, 1435941 },
			},
			EpilogueEvent = function()
				g_epilogue = 1
				Cmd_InstantUpgrade(player1, UPG.COMMANDER_TREE.ELITE.LUFTWAFFE_10)	
				Camera_MoveToPosition(mkr_Camera1)
				sg_OpelAlpha1 = SGroup_CreateIfNotFound("sg_OpelAlpha1")
				Util_CreateSquads(player1, sg_OpelAlpha1, SBP.AXIS.OPELBLITZ, mkr_OpelAlpha1)
				Modify_UnitSpeed(sg_OpelAlpha1, 0.5)
				sg_OpelAlphaInf1 = SGroup_CreateIfNotFound("sg_OpelAlphaInf1")
				Util_CreateSquads(player1, sg_OpelAlphaInf1, SBP.ELITE.LUFTWAFFE, sg_OpelAlpha1)
				UI_BindingSetEnabled("company_commander", true )
				Player_SetResource(player1, RT_Command, 0)
				Cmd_Move(sg_OpelAlpha1, mkr_OpelAlphaInf1)	
				SGroup_SetSelectable(sg_OpelAlpha1, false)				
				CTRL.Actor_PlaySpeech(ACTOR.CXP2.Voss, 1435759)
				CTRL.WAIT()
				CTRL.Actor_PlaySpeech(ACTOR.CXP2.Voss, 1435765)
				CTRL.WAIT()
				CTRL.Actor_PlaySpeech(ACTOR.CXP2.Voss, 1435766)
				CTRL.WAIT()
				CTRL.Actor_PlaySpeech(ACTOR.CXP2.Voss, 1435770)
				CTRL.WAIT()
            end,

		},
	}
	
	-- Register Objective
	Objective_Register(OBJ_DefendPoints)
	-- Initialize Data
	DefendPoints_Init()
	
end

function DefendPoints_Init()
	-- the timer of the counterdown	

	-- the threshold is the current time left on the DefendPoints timer.  
	-- functions will fire in a given time		
	
	t_points = 
	{
		{
			egroup = eg_pnt_R2, 
		},
		{
			egroup = eg_pnt_R3, 
		},
		{
			egroup = eg_pnt_R4, 
		},
	}
	
	t_nislet3 = {
		{camPos = mkr_Bridge, waitType = NISLET_TIME, waitValue = 1},
	}
	
	timertable1 =
	{
		{
			threshold = 900,
			exec = function()
				EngineerBuilding_Init2()
				UI_BindingSetEnabled("company_commander", true )
				__EnableCompanyCommanderTree()
				Rule_AddInterval(Rule_Chatter1, 20)
				
			end
		},
		{
			threshold = 850,
			exec = function()
				if Player_OwnsEGroup(player1, eg_pnt_R1) then 
					OBJ_DefendPoints.R1 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R1, true, 1439070, true, 2)
				end
				WaveAlpha_Init()
				GarrisonGamma_Init()	
			end
		},
		{
			threshold = 820,
			exec = function()
				AirborneBeta_Init()
				Rule_AddOneShot(CaptureHeights_DelayGrant, 1)	
			end
		},
		{
			threshold = 710,
			exec = function()
				WaveBeta_Init()
				MortarAlpha_Init()
			end
		},
		{
			threshold = 700,
			exec = function()
				if Player_OwnsEGroup(player1, eg_pnt_R2) then 
					OBJ_DefendPoints.R2 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R2, true, 1439070, true, 2)
				end
				
			end
		},
		{
			threshold = 680,
			exec = function()
				Rule_AddInterval(Supply_Drop, 1)
			end
		},
		{
			threshold = 650,
			exec = function()
				g_artystart = 1
				Game_LoadAtmosphere("data:art/scenarios/presets/atmosphere/CXP2_OOSTERBEEK_DAYBREAK_RAIN_00.aps", 300)
			end
		},
		{
			threshold = 600,
			exec = function()
				WaveGamma_Init()
				GarrisonAlpha_Init()
				MGAlpha_Init()
				
				--PiatAlpha_Init()
			end
		},
		{
			threshold = 590,
			exec = function()
				if Player_OwnsEGroup(player1, eg_pnt_C3) then 
					OBJ_DefendPoints.C3 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_C3, true, 1439070, true, 2)
				end
				Rule_AddInterval(DefendPoints_UpdateObjective, 1)
			end
		},
		
		
		{
			threshold = 520,
			exec = function()
				Rule_AddInterval(Bombing_Form1, 1)
				Sound_PlayStreamed("Ambiences/Ambiences_Streamed/CXP2/HenschelCircling/plane_distant_circle_oosterbeek")				
				EventCue_Create(CUE.ATTACKED, 1439301, 1439301, nil)
				Util_AutoIntel(t_plane1)
				

				Rule_Remove(Rule_Chatter1)
				Rule_AddInterval(Rule_Chatter2, 20)
			end
		},
		{
			threshold = 510,
			exec = function()
				
				Modify_EntityRecievedDamage(player2, EBP.AIRCRAFT.ALLIES.TYPHOON_ROCKET, 10)
				Modify_EntityRecievedDamage(player2, EBP.AIRCRAFT.ALLIES.TYPHOON_RECON, 10)
				Modify_EntityRecievedAccuracy(player2, EBP.AIRCRAFT.ALLIES.TYPHOON_ROCKET, 2)
				Modify_EntityRecievedAccuracy(player2, EBP.AIRCRAFT.ALLIES.TYPHOON_RECON, 2)
				--EventCue_Create(CUE.ATTACKED, 1439301, 1439301, nil)
				--Util_AutoIntel(t_plane2)				
				
				--Rule_AddInterval(Bombing_Form3, 1)
				--EventCue_Create(CUE.ATTACKED, 1439301, 1439301, nil)
				--Util_AutoIntel(t_plane3)
			end
		},
		{
			threshold = 500,
			exec = function()
				BrenAlpha_Init()
			end
		},

		{
			threshold = 400,
			exec = function()
				Rule_AddInterval(Bombing_Form2, 1)	
				EventCue_Create(CUE.ATTACKED, 1439301, 1439301, nil)
				Util_AutoIntel(t_plane4)
				
				
			end
		},
		{
			threshold = 300,
			exec = function()
				
				Loc_FormatText(1439305, Loc_FormatTime(300, false, true))
				EventCue_Create(CUE.ATTACKED, Loc_FormatText(1439305, Loc_FormatTime(300, false, true)), 1439305, nil)
			end
		},
		{
			threshold = 280,
			exec = function()
				Rule_AddInterval(Bombing_Form5, 1)
				EventCue_Create(CUE.ATTACKED, 1439301, 1439301, nil)
				BazookaAlpha_Init()
			end
		},
		{
			threshold = 250,
			exec = function()
				Util_AutoIntel(t_weather1)
				Util_AutoAmbient(t_weather2)
			end
		},
		{
			threshold = 230,
			exec = function()
				Util_AutoIntel(t_Glidercoming)
				FlyerAlpha_Init()
			end
		},
		{
			threshold = 200,
			exec = function()	
				GliderAlpha_Init()
				Rule_Remove(Rule_Chatter2)
			end
		},
		{
			threshold = 190,
			exec = function()	
				Game_LoadAtmosphere("data:art/scenarios/presets/atmosphere/CXP2_OOSTERBEEK_DAYBREAK_STORMYRAIN_00.aps", 150)
				EventCue_Create(CUE.ATTACKED, 1439300, 1439300, mkr_GliderAlpha2)
				Game_TriggerLightning( )
				Sound_StopMusic(15,0)
				Util_AutoIntel(t_Gliderprepare)
				
			end
		},

		{
			threshold = 120,
			exec = function()
				WaveAlpha_Init()
				WaveBeta_Init()
				WaveGamma_Init()
				Rule_AddInterval(Rule_Chatter3, 15)
			end
		},
		{
			threshold = 60,
			exec = function()
				Game_TriggerLightning( )

				--EventCue_Create(CUE.ATTACKED, Loc_FormatText(1439304, Loc_FormatTime(60, false, true)), 1439304, nil)
			end
		},
		{
			threshold = 20,
			exec = function()
				Game_TriggerLightning( )
			end
		},
		{
			threshold = 10,
			exec = function()
				Game_TriggerLightning( )
			end
		},
		{
			threshold = 5,
			exec = function()
				Game_TriggerLightning( )
			end
		},
		{
			threshold = 2,
			exec = function()
				Game_TriggerLightning( )
			end
		},
		{
			threshold = 1,
			exec = function()
				Game_TriggerLightning( )
			end
		},
		{
			threshold = 0,
			exec = function()
				Rule_Remove(Rule_Chatter3)
				Rule_Remove(BrenAlpha_Kickoff)
				Rule_Remove(GarrisonAlpha_Kickoff)
				Rule_Remove(SupplyAlpha_Kickoff)
				Rule_Remove(WaveAlpha_Kickoff)
				Rule_Remove(WaveBeta_Kickoff)
				Rule_Remove(WaveGamma_Kickoff)
				--Rule_Remove(PiatAlpha_Kickoff)
				Rule_Remove(GarrisonBeta_Kickoff)
				Rule_Remove(BazookaBeta_Kickoff)
				Rule_Remove(GliderAlpha_Kickoff)
				Rule_Remove(GarrisonGamma_Kickoff)
				Rule_Remove(AirborneBeta_Kickoff)
				Rule_Remove(MortarAlpha_Kickoff)
				Rule_Remove(BazookaAlpha_Kickoff)
				Rule_Remove(GrenadeAlpha_Kickoff)
				Rule_Remove(TravelAlpha_Kickoff)
				Rule_Remove(DefendPoints_UpdateObjective)
			end
		},
	}

end

function Rule_Chatter1()
	if table.getn(t_ambientFight1) >  0 and Event_IsAnyRunning() == false then
		if SGroup_IsEmpty( sg_AllyAll ) == false and SGroup_IsDoingAttack(sg_AllyAll, ANY, 1) then
			i = World_GetRand(1, table.getn(t_ambientFight1))
			Util_AutoAmbient(t_ambientFight1[i])
			table.remove(t_ambientFight1, i)
		end

	elseif table.getn(t_ambientFight1) <=  0 then
		Rule_RemoveMe()
	end
end
function Rule_Chatter2()
	if table.getn(t_ambientFight2) >  0 and Event_IsAnyRunning() == false then
		if SGroup_IsEmpty( sg_AllyAll ) == false and SGroup_IsDoingAttack(sg_AllyAll, ANY, 1) then
			i = World_GetRand(1, table.getn(t_ambientFight2))
			Util_AutoAmbient(t_ambientFight2[i])
			table.remove(t_ambientFight2, i)
		end

	elseif table.getn(t_ambientFight2) <=  0 then
		Rule_RemoveMe()
	end
end
function Rule_Chatter3()
	if table.getn(t_ambientFight3) >  0 and Event_IsAnyRunning() == false then
		if SGroup_IsEmpty( sg_AllyAll ) == false and SGroup_IsDoingAttack(sg_AllyAll, ANY, 1) then
			i = World_GetRand(1, table.getn(t_ambientFight3))
			Util_AutoAmbient(t_ambientFight3[i])
			table.remove(t_ambientFight3, i)
		end

	elseif table.getn(t_ambientFight3) <=  0 then
		Rule_RemoveMe()
	end
end


function DefendPoints_Preset()


end
function CrashPlane()
	Cmd_Ability(player2,  ABILITY.SP.CAEN_BOMBING_RUN, Marker_GetPosition(mkr_Crash1), Marker_GetDirection(mkr_Crash1), true)
	Cmd_Ability(player2,  ABILITY.SP.CAEN_BOMBING_RUN, Marker_GetPosition(mkr_Crash2), Marker_GetDirection(mkr_Crash2), true)
end
-- example of how to finish an Obj
function DefendPoints_WinCheck()

	if Event_IsAnyRunning() == false then
		local timeleft = Objective_GetTimerSeconds(OBJ_DefendPoints)
		for k, v in pairs(timertable1) do
			if v.executed == nil and v.threshold >= timeleft then
				v.executed = true
				v.exec()
				break
			end
		end	
	end
--~ 	for k, v in pairs(t_points) do
	if Objective_GetTimerSeconds(OBJ_DefendPoints) == 0 then 
		if Objective_IsComplete(OBJ_DestroyBridge) then 
			if Player_OwnsEGroup(player1, eg_pnt_R3) or Player_OwnsEGroup(player1, eg_pnt_R4) then 
				Objective_Complete(OBJ_DefendPoints)
				Rule_RemoveMe()
				Util_AutoNISlet(NISLET_GAME2LETTER, t_Nislet_Ending) 

				Modifier_RemoveAllFromSGroup(sg_AxisAll)	
				Modifier_RemoveAllFromSGroup(sg_AllyAll)
				Rule_AddOneShot(DefendPoints_Final, 20)
				Rule_AddInterval(DefendPoints_Retreat, 5)
			else
				Objective_Fail(OBJ_DefendPoints)
				Modifier_RemoveAllFromSGroup(sg_AxisAll)	
				Modifier_RemoveAllFromSGroup(sg_AllyAll)
				Rule_RemoveMe()
				Game_EndSP(false)
				Camera_Unclamp()
				Misc_RemoveCommandRestriction()
			end
		else
			Objective_Fail(OBJ_DestroyBridge)
			Objective_Fail(OBJ_DefendPoints)
			Modifier_RemoveAllFromSGroup(sg_AxisAll)	
			Modifier_RemoveAllFromSGroup(sg_AllyAll)
			Game_EndSP(false)
			Camera_Unclamp()
			Misc_RemoveCommandRestriction()
		end
	end
end

function DefendPoints_Retreat()
	if SGroup_Count(sg_AllyInfantry) > 0 then 
		Cmd_Retreat(sg_AllyInfantry, mkr_Final1)
	end
	if SGroup_Count(sg_AllyTanks) > 0 then 
		Cmd_Move(sg_AllyTanks, mkr_Final1)
	end
end
function DefendPoints_Final()


	Modifier_RemoveAllFromSGroup(sg_AxisAll)	
	Modifier_RemoveAllFromSGroup(sg_AllyAll)
	Game_EndSP(true, nil, true)
	Camera_Unclamp()
	Misc_RemoveCommandRestriction()
	SGroup_DestroyAllSquads(sg_AllyAll)
	SGroup_DestroyAllSquads(sg_AxisAll)
end

function DefendPoints_DelayGrant()
	if Objective_IsStarted(OBJ_DefendPoints) == false then 
		Objective_Start(OBJ_DefendPoints)
		
	end
end

function DefendPoints_UpdateObjective()
	if Event_IsAnyRunning() == false then
		if Player_OwnsEGroup(player1, eg_pnt_R1) == false and ping_R1 == 1 then 
			Objective_RemoveUIElements(OBJ_DefendPoints, OBJ_DefendPoints.R1)
			UI_CreateMinimapBlip(eg_pnt_R1, 5, BT_DefendHerePing)
			Util_StartIntel(EVENTS.CapturePoint)
			ping_R1 = 2
		elseif Player_OwnsEGroup(player1, eg_pnt_R1) == true and ping_R1 == 2 then 
			OBJ_DefendPoints.R1 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R1, true, 1439070, true, 2)
			ping_R1 = 1
		end
		if Player_OwnsEGroup(player1, eg_pnt_R2) == false and ping_R2 == 1 then 
			Objective_RemoveUIElements(OBJ_DefendPoints, OBJ_DefendPoints.R2)
			UI_CreateMinimapBlip(eg_pnt_R2, 5, BT_DefendHerePing)
			Util_StartIntel(EVENTS.CapturePoint)
			ping_R2 = 2
		elseif Player_OwnsEGroup(player1, eg_pnt_R2) == true and ping_R2 == 2 then 
			OBJ_DefendPoints.R2 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R2, true, 1439070, true, 2)
			ping_R2 = 1
		end
		if Player_OwnsEGroup(player1, eg_pnt_C3) == false and ping_C3 == 1 then 
			Objective_RemoveUIElements(OBJ_DefendPoints, OBJ_DefendPoints.C3)
			UI_CreateMinimapBlip(eg_pnt_C3, 5, BT_DefendHerePing)
			Util_StartIntel(EVENTS.CapturePoint)
			ping_C3 = 2
		elseif Player_OwnsEGroup(player1, eg_pnt_C3) == true and ping_C3 == 2 then 
			OBJ_DefendPoints.C3 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_C3, true, 1439070, true, 2)
			ping_C3 = 1
		end
		
		
		if Player_OwnsEGroup(player1, eg_pnt_R3) == false and ping_R3 == 1 then 
			Objective_RemoveUIElements(OBJ_DefendPoints, OBJ_DefendPoints.R3)
			UI_CreateMinimapBlip(eg_pnt_R3, 5, BT_DefendHerePing)
			Util_StartIntel(EVENTS.CapturePoint)
			ping_R3 = 2
		elseif Player_OwnsEGroup(player1, eg_pnt_R3) == true and ping_R3 == 2 then 
			OBJ_DefendPoints.R3 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R3, true, 1439070, true, 2)
			ping_R3 = 1
		end
			
		if Player_OwnsEGroup(player1, eg_pnt_R4) == false and ping_R4 == 1 then 
			Objective_RemoveUIElements(OBJ_DefendPoints, OBJ_DefendPoints.R4)
			UI_CreateMinimapBlip(eg_pnt_R4, 5, BT_DefendHerePing)
			Util_StartIntel(EVENTS.CapturePoint)
			ping_R4 = 2
		elseif Player_OwnsEGroup(player1, eg_pnt_R4) == true and ping_R4 == 2 then 
			OBJ_DefendPoints.R4 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R4, true, 1439070, true, 2)
			ping_R4 = 1
		end
		if Player_OwnsEGroup(player1, eg_pnt_R1) == false and Player_OwnsEGroup(player1, eg_pnt_R2) == false and Player_OwnsEGroup(player1, eg_pnt_R3) == false and Player_OwnsEGroup(player1, eg_pnt_R4) == false and Player_OwnsEGroup(player1, eg_pnt_C3) == false then 
			Modifier_RemoveAllFromSGroup(sg_AxisAll)	
			Modifier_RemoveAllFromSGroup(sg_AllyAll)
			Game_EndSP(false)
			Camera_Unclamp()
			Misc_RemoveCommandRestriction()
		end
		if ((Player_OwnsEGroup(player1, eg_pnt_R1) == false and Player_OwnsEGroup(player1, eg_pnt_R2) == false) or  
			(Player_OwnsEGroup(player1, eg_pnt_R1) == false and Player_OwnsEGroup(player1, eg_pnt_C3) == false) or  
			(Player_OwnsEGroup(player1, eg_pnt_R2) == false and Player_OwnsEGroup(player1, eg_pnt_C3) == false)) and g_DefendPoints == 1 then 
			Objective_UpdateText(OBJ_DefendPoints, 1439073, nil)
			g_DefendPoints = 2
			OBJ_DefendPoints.R3 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R3, true, 1439073, true, 2)
			OBJ_DefendPoints.R4 = Objective_AddUIElements(OBJ_DefendPoints, eg_pnt_R4, true, 1439073, true, 2)
		end
	end
end

-------------------------------------------------------------------------
-- Destroy Howitzers
-------------------------------------------------------------------------

-------------------------------------------------------------------------
function Initialize_OBJ_DestroyHowitzer()
	OBJ_DestroyHowitzer = {
		
		SetupUI = function() 
			
			
			
		end,
		
		OnStart = function()
			-- win/lose check
			Rule_AddInterval(DestroyHowitzer_WinCheck, 5)
			-- action
			DestroyHowitzer_Kickoff()
			
		end,
		OnComplete = function()
			
			-- tell the player they did good

		end,
		
		IsComplete = function()
			
			
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1439110,
		Description = 1439112,
		Type = OT_Secondary,
		TitleEnd = 1439111,
	}
	
	-- Register Objective
	Objective_Register(OBJ_DestroyHowitzer)
	-- Initialize Data
	DestroyHowitzer_Init()
	
end

function DestroyHowitzer_Init()

	

end

function DestroyHowitzer_Preset()
	

end


-- Complete when the allied HQ reaches the location. 
function DestroyHowitzer_WinCheck()
		

	if g_howiedestroyed == 1 and Player_OwnsEGroup(player2, t_Priest.squads[1].egroup) == false then
		Objective_Complete(OBJ_DestroyHowitzer)
		Rule_RemoveMe() 
	end
end

-- start the related action
function DestroyHowitzer_Kickoff()

	
	
end


-- start the related action
function DestroyHowitzer_DelayGrant()
	if g_howiebuilt == 1 then 
		Objective_Start(OBJ_DestroyHowitzer)
		OBJ_DestroyHowitzer.mapElementID = Objective_AddUIElements(OBJ_DestroyHowitzer, t_Priest.squads[1].egroup, true, 1439110, true, 2)
		g_howiedestroyed = 1
		Rule_RemoveMe()
	end
end



-------------------------------------------------------------------------
-- Medal Objective( kill as many commandos as possible)
-------------------------------------------------------------------------

-------------------------------------------------------------------------
function Initialize_OBJ_Medal()
	OBJ_Medal = {
		
		SetupUI = function() 
			
			
		end,
		
		OnStart = function()
			
			-- win/lose check
			Rule_AddInterval(Medal_WinCheck, 1)
			-- action
			Medal_Kickoff()
			lastcount = 0
			numCaught = 0
			Objective_SetCounter(OBJ_Medal, 0, 3)
			
		end,
		OnComplete = function()
			
		end,
		
		IsComplete = function()
			
			
		end,
		
		OnFail = function()
			Rule_Remove(Supply_Drop)
			-- tell the player they lost
			
		end,
		
		Title = 1439080,
		Description = 1439081,
		Type = OT_Medal,
		TitleEnd = 1439083,
		MedalID = MEDALS.CXP2.OOSTERBEEK_DEFENSE,

	}
	
	-- Register Objective
	Objective_Register(OBJ_Medal)
	-- Initialize Data
	Medal_Init()
	
end

function Medal_Init()
	

end

function Medal_Preset()	

end

-- Complete when the allied HQ reaches the location. 
function Medal_FirstIntel()

end

-- Complete when the allied HQ reaches the location. 
function Medal_WinCheck()
	Objective_SetCounter(OBJ_Medal, numCaught, 3)
	if g_drop1 == 1 then 
		if EGroup_Count(eg_SupplyDrops1) == 0 then 
			numCaught = numCaught + 1
			g_drop1 = 2
			Objective_SetCounter(OBJ_Medal, numCaught, 3)
			--Objective_RemoveUIElements(OBJ_Medal, OBJ_Medal.ID1)
		end
	end
	if g_drop2 == 1 then 
		if EGroup_Count(eg_SupplyDrops2) == 0 then 
			numCaught = numCaught + 1
			g_drop2 = 2
			Objective_SetCounter(OBJ_Medal, numCaught, 3)
			--Objective_RemoveUIElements(OBJ_Medal, OBJ_Medal.ID2)
		end
	end		
	if g_drop3 == 1 then 
		if EGroup_Count(eg_SupplyDrops3) == 0 then 
			numCaught = numCaught + 1
			g_drop3 = 2
			Objective_SetCounter(OBJ_Medal, numCaught, 3)
			--Objective_RemoveUIElements(OBJ_Medal, OBJ_Medal.ID3)
		end
	end
	if numCaught == 3 and g_medalfail == nil then 
		Objective_Complete(OBJ_Medal)	
 		Rule_RemoveMe()
	elseif g_medalfail == 1 then 
		Rule_RemoveMe()
	end
	
end
	

-- start the related action
function Medal_Kickoff()

	Rule_AddInterval(Medal_FirstIntel, 5)
	
end


-- start the related action
function Medal_DelayGrant()
	if g_OBJ_Medal == nil then 
		Objective_Start(OBJ_Medal)
		g_OBJ_Medal = 1
		Rule_RemoveMe()
	end
end

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Allied spawned units

-------------------------------------------------------------------------

function PlayerAlpha_Init()
--Spawning allied infantry at the beginning for NIS purposes perhaps.
	sg_PlayerAlpha1 = SGroup_CreateIfNotFound("sg_PlayerAlpha1")
	sg_PlayerAlpha2 = SGroup_CreateIfNotFound("sg_PlayerAlpha2")
	sg_PlayerAlpha3 = SGroup_CreateIfNotFound("sg_PlayerAlpha3")
	sg_PlayerAlpha4 = SGroup_CreateIfNotFound("sg_PlayerAlpha4")
	sg_PlayerAlpha5 = SGroup_CreateIfNotFound("sg_PlayerAlpha5")
	sg_PlayerAlpha6 = SGroup_CreateIfNotFound("sg_PlayerAlpha6")
	sg_PlayerAlpha7 = SGroup_CreateIfNotFound("sg_PlayerAlpha7")
	sg_PlayerAlpha8 = SGroup_CreateIfNotFound("sg_PlayerAlpha8")
	
	sg_PlayerAlphaHalftrack1 = SGroup_CreateIfNotFound("sg_PlayerAlphaHalftrack1")
	sg_PlayerAlphaHalftrack2 = SGroup_CreateIfNotFound("sg_PlayerAlphaHalftrack2")
	sg_PlayerAlphaHalftrack3 = SGroup_CreateIfNotFound("sg_PlayerAlphaHalftrack3")
	sg_PlayerAlphaHalftrack4 = SGroup_CreateIfNotFound("sg_PlayerAlphaHalftrack4")
	sg_PlayerAlphaHalftrack5 = SGroup_CreateIfNotFound("sg_PlayerAlphaHalftrack5")
	sg_PlayerAlphaHalftrack6 = SGroup_CreateIfNotFound("sg_PlayerAlphaHalftrack6")
	
	t_PlayerAlpha = {
		{
			sgroup = sg_PlayerAlpha1, 
			sgroup2 = sg_PlayerAlphaHalftrack1, 
			upgrade = false,
			timername = "tmr_PlayerAlpha", 
			timer = 9, 
			count = 4, 
			phase = 1,
			marker = mkr_PlayerAlpha1,
			marker2  = mkr_PlayerAlpha1a, 
			unit1 = SBP.ELITE.HALFTRACK_SNIPER, 
			unit2 = false,
			ctrl_group = 2,

		},
		{
			sgroup = sg_PlayerAlpha2, 
			sgroup2 = sg_PlayerAlphaHalftrack2, 
			upgrade = false,
			timername = "tmr_PlayerAlpha", 
			timer = 8, 
			count = 4, 
			phase = 1,
			marker = mkr_PlayerAlpha2,
			marker2  = mkr_PlayerAlpha2a, 
			unit1 = SBP.ELITE.HALFTRACK_250, 
			unit2 = SBP.ELITE.PANZERGRENADIER, 
			ctrl_group = 2,

		},
		{
			sgroup = sg_PlayerAlpha3, 
			sgroup2 = sg_PlayerAlphaHalftrack3, 
			upgrade = false,
			timername = "tmr_PlayerAlpha", 
			timer = 7, 
			count = 4, 
			phase = 1, 
			marker = mkr_PlayerAlpha3,
			marker2  = mkr_PlayerAlpha3a, 
			unit1 = SBP.ELITE.HALFTRACK_MORTAR, 
			unit2 = false,
			ctrl_group = 2,

		},
		{
			sgroup = sg_PlayerAlpha4, 
			sgroup2 = sg_PlayerAlphaHalftrack4, 
			upgrade = false,
			timername = "tmr_PlayerAlpha", 
			timer = 6, 
			count = 4, 
			phase = 1, 
			marker = mkr_PlayerAlpha4,
			marker2  = mkr_PlayerAlpha4a, 
			unit1 = SBP.ELITE.HALFTRACK_251, 
			unit2 = false,
			ctrl_group = 3,

		},
	}

	PlayerAlpha_Preset()
	Timer_Start("tmr_PlayerAlpha", 10)
end

function PlayerAlpha_Preset()
--Spawn the squads when the function is called 
	for k, this in pairs(t_PlayerAlpha) do
		--if Timer_GetRemaining("tmr_PlayerAlpha") < this.timer and SGroup_Count(this.sgroup) == 0 and this.phase == 1 then 
			Util_CreateSquads(player1, this.sgroup2, this.unit1, this.marker2)
			if this.unit2 ~= nil and this.unit2 ~= false then
				Util_CreateSquads(player1, this.sgroup, this.unit2, this.sgroup2)
				Cmd_InstantUpgrade(this.sgroup, UPG.ELITE.PANZERSCHRECK)
				Util_CreateSquads(player1, this.sgroup, this.unit2, this.sgroup2)
				Cmd_InstantUpgrade(this.sgroup, UPG.ELITE.G43)
				UI_CreateMinimapBlip(this.sgroup, 5, BT_GeneralPing)	
			end
			Misc_SetSquadControlGroup(SGroup_GetSpawnedSquadAt(this.sgroup2, 1), this.ctrl_group)

			Cmd_Move(this.sgroup2, this.marker)
			this.phase = 2
			if this.upgrade ~= nil and this.upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			end
		--end
		
	end	

	Misc_SetSquadControlGroup(SGroup_GetSpawnedSquadAt(sg_PlayerAlpha7, 1), 1)
	Misc_SetSquadControlGroup(SGroup_GetSpawnedSquadAt(sg_PlayerAlpha8, 1), 1)

	
	

end


function PlayerBeta_Init()

	tmkr_PlayerBeta = Marker_GetTable("mkr_PlayerBeta%d")
	tsg_PlayerBeta = SGroup_CreateTable("sg_PlayerBeta%d", table.getn(tmkr_PlayerBeta))
	t_PlayerBeta = {
		{
			phase = 2, 
		},
		{
			phase = 2, 
		},



	}
	for i = 1, table.getn(t_PlayerBeta) do
		t_PlayerBeta[i].sgroup = tsg_PlayerBeta[i]
		t_PlayerBeta[i].spawn = tmkr_PlayerBeta[i]
	end
	PlayerBeta_Preset()
end


function PlayerBeta_Preset()
	for k, this in pairs(t_PlayerBeta) do
		Util_CreateSquads(player1, this.sgroup, SBP.ELITE.PANZERGRENADIER, this.spawn)
		this.phase = 2
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
end


function PlayerGamma_Init()

	tmkr_PlayerGamma = Marker_GetTable("mkr_PlayerGamma%d")
	tsg_PlayerGamma = SGroup_CreateTable("sg_PlayerGamma%d", table.getn(tmkr_PlayerGamma))
	t_PlayerGamma = {
		{
			phase = 2, 
		},
		{
			phase = 2, 
		},


	}
	for i = 1, table.getn(t_PlayerGamma) do
		t_PlayerGamma[i].sgroup = tsg_PlayerGamma[i]
		t_PlayerGamma[i].spawn = tmkr_PlayerGamma[i]
	end
	PlayerGamma_Preset()
end


function PlayerGamma_Preset()
	for k, this in pairs(t_PlayerGamma) do
		Util_CreateSquads(player1, this.sgroup, SBP.ELITE.FALLSCHIRMJAGER, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
end

function PlayerDelta_Init()
-- axis spawned weapons
	tmkr_PlayerDelta = Marker_GetTable("mkr_PlayerDelta%d")
	tsg_PlayerDelta = EGroup_CreateTable("eg_PlayerDelta%d", table.getn(tmkr_PlayerDelta))
	t_PlayerDelta = {
		{
			phase = 2, 
			weapon = EBP.PICKUP.AXIS.HMG, 
		},
		{
			phase = 2, 
			weapon = EBP.PICKUP.AXIS.HMG, 
		},
	}
	for i = 1, table.getn(t_PlayerDelta) do
		t_PlayerDelta[i].egroup = tsg_PlayerDelta[i]
		t_PlayerDelta[i].spawn = tmkr_PlayerDelta[i]
	end
	PlayerDelta_Preset()
end


function PlayerDelta_Preset()
	for k, this in pairs(t_PlayerDelta) do
		Util_CreateEntities(nil, this.egroup, this.weapon, this.spawn, 1)
		this.phase = 2
	end
end


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--END OF ALLIED SPAWN SCRIPT
--BEGINNING OF AXIS SPAWN SCRIPT
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- Wave Data
-- Axis Units sent in waves but do not spawn again.  
-- Each squad is monitored by total members in the squad
-- Alpha send to the Left, Beta to the middle and Gamma to the right
-------------------------------------------------------------------------
function WaveAlpha_Init()

	tmkr_WaveAlpha = Marker_GetTable("mkr_WaveAlpha%d")
	tsg_WaveAlpha = SGroup_CreateTable("sg_WaveAlpha%d", table.getn(tmkr_WaveAlpha))
	sg_WaveAlpha1 = SGroup_CreateIfNotFound("sg_WaveAlpha1")
	sg_WaveAlpha2 = SGroup_CreateIfNotFound("sg_WaveAlpha2")

	sg_WaveAlphaAttacker1 = SGroup_CreateIfNotFound("sg_WaveAlphaAttacker1")
	sg_WaveAlphaAttacker2 = SGroup_CreateIfNotFound("sg_WaveAlphaAttacker2")

	t_WaveAlpha = {
		{
			sgroup = sg_WaveAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,
			upgrade = false,
			phase = 2,
			path = "pth_R1a", 
			capture1 = eg_pnt_R1, 
			capture2= eg_pnt_R2, 
			capture3= eg_pnt_C3, 
			capture4= eg_pnt_R3,
			enemy1 = sg_AxisR1,
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
			attacker = sg_WaveAlphaAttacker1, 
		},
--~ 		{
--~ 			sgroup = sg_WaveAlpha2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_StrongHold1,
--~ 			depart = mkr_Final1,			
--~ 			upgrade = false, 
--~ 			phase = 2,
--~ 			path = "pth_R1b",
--~ 			capture1 = eg_pnt_R1, 
--~ 			capture2= eg_pnt_R2, 
--~ 			capture3= eg_pnt_R3, 
--~ 			capture4= eg_pnt_R4, 			
--~ 			unit = SBP.CW.COMMANDOS, 
--~ 			unit2 = SBP.CW.COMMANDOS,  
--~ 			spawn = mkr_Spawn1, 
--~ 			attacker = sg_WaveAlphaAttacker2, 
--~ 		},
	}
	
	for i = 1, table.getn(t_WaveAlpha) do
		--t_WaveAlpha[i].sgroup = tsg_WaveAlpha[i]
		--t_WaveAlpha[i].spawn = tmkr_WaveAlpha[i]
	end
	
	WaveAlpha_Preset()
	
end


function WaveAlpha_Preset()
--Spawns the units
	for k, this in pairs(t_WaveAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, 3)
		--Util_CreateSquads(player2, this.sgroup, this.unit2, this.spawn)
		Cmd_SquadPath(this.sgroup, this.path, true, false, true, 0)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveAlpha_Kickoff) == false then 
		Rule_AddInterval(WaveAlpha_Kickoff, 1)
	end

end

function WaveAlpha_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveAlpha) do	
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 50) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)

				if SGroup_Count(this.attacker) > 0 then 
					
					if SGroup_TotalMembersCount(this.sgroup) < SGroup_TotalMembersCount(this.attacker) then 
						Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)					
					elseif SGroup_Count(this.enemy1) > 0 then 
						Cmd_AttackMove(this.sgroup, SGroup_GetPosition(this.enemy1), false, nil, 30)
					end
				end
			end
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_IsCapturing(this.sgroup, ANY) == false then
				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				else
					Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, this.depart)	
			this.phase = 0
			Modifier_RemoveAllFromSGroup(this.sgroup)
		end
	end
end

function WaveBeta_Init()

	tmkr_WaveBeta = Marker_GetTable("mkr_WaveBeta%d")
	tsg_WaveBeta = SGroup_CreateTable("sg_WaveBeta%d", table.getn(tmkr_WaveBeta))
	sg_WaveBeta1 = SGroup_CreateIfNotFound("sg_WaveBeta1")
	sg_WaveBeta2 = SGroup_CreateIfNotFound("sg_WaveBeta2")

	sg_WaveBetaAttacker1 = SGroup_CreateIfNotFound("sg_WaveBetaAttacker1")
	sg_WaveBetaAttacker2 = SGroup_CreateIfNotFound("sg_WaveBetaAttacker2")
	t_WaveBeta = {
		{
			sgroup = sg_WaveBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,
			upgrade = false,
			phase = 2,
			path = "pth_R2a", 	
			capture1 = eg_pnt_R2, 
			capture2= eg_pnt_R1, 
			capture3= eg_pnt_C3, 
			capture4= eg_pnt_R4, 
			enemy1 = sg_AxisR2,
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
			attacker = sg_WaveBetaAttacker1, 
		},
--~ 		{
--~ 			sgroup = sg_WaveBeta2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_StrongHold1,
--~ 			depart = mkr_Final1,			
--~ 			upgrade = false, 
--~ 			phase = 2,
--~ 			path = "pth_R2b", 
--~ 			capture1 = eg_pnt_R2, 
--~ 			capture2= eg_pnt_R1, 
--~ 			capture3= eg_pnt_R4, 
--~ 			capture4= eg_pnt_R3, 
--~ 			unit = SBP.CW.COMMANDOS, 
--~ 			unit2 = SBP.CW.COMMANDOS,  
--~ 			spawn = mkr_Spawn1, 
--~ 			attacker = sg_WaveAlphaAttacker1, 
--~ 		},
	}
	
	for i = 1, table.getn(t_WaveBeta) do
		--t_WaveBeta[i].sgroup = tsg_WaveBeta[i]
		--t_WaveBeta[i].spawn = tmkr_WaveBeta[i]
	end
	
	WaveBeta_Preset()
	
end


function WaveBeta_Preset()
--Spawns the units
	for k, this in pairs(t_WaveBeta) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, 4)
		--Util_CreateSquads(player2, this.sgroup, this.unit2, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveBeta_Kickoff) == false then 
		Rule_AddInterval(WaveBeta_Kickoff, 1)
	end

end

function WaveBeta_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveBeta) do
		if SGroup_TotalMembersCount(this.sgroup) < 3 then 
			--this.phase = 5
		end
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 60) == false then 
			SGroup_Clear(this.attacker)
		end
		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)

			if SGroup_Count(this.attacker) > 0 then 
				if Prox_SGroupSGroup(this.sgroup, this.attacker, PROX_SHORTEST) < 10 then 
					
					Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)					
				elseif SGroup_Count(this.enemy1) > 0 then 
					Cmd_AttackMove(this.sgroup, SGroup_GetPosition(this.enemy1), false, nil, 30)
				end
			end
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_IsCapturing(this.sgroup, ANY) == false then
				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				else
					Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, this.depart)	
			this.phase = 0
			Modifier_RemoveAllFromSGroup(this.sgroup)			
		end
	end
end

function WaveGamma_Init()

	tmkr_WaveGamma = Marker_GetTable("mkr_WaveGamma%d")
	tsg_WaveGamma = SGroup_CreateTable("sg_WaveGamma%d", table.getn(tmkr_WaveGamma))
	sg_WaveGamma1 = SGroup_CreateIfNotFound("sg_WaveGamma1")
	sg_WaveGamma2 = SGroup_CreateIfNotFound("sg_WaveGamma2")

	sg_WaveGammaAttacker1 = SGroup_CreateIfNotFound("sg_WaveGammaAttacker1")
	sg_WaveGammaAttacker2 = SGroup_CreateIfNotFound("sg_WaveGammaAttacker2")
	t_WaveGamma = {
		{
			sgroup = sg_WaveGamma1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,
			upgrade = false,
			phase = 2,
			path = "pth_C3a", 	
			capture1 = eg_pnt_C3, 
			capture2= eg_pnt_R1, 
			capture3= eg_pnt_R4, 
			capture4= eg_pnt_R3, 
			enemy1 = sg_AxisC3,
			unit = SBP.CW.COMMANDOS, 
			unit2 = SBP.CW.COMMANDOS,  
			spawn = mkr_Spawn1, 
			attacker = sg_WaveGammaAttacker1, 
		},
--~ 		{
--~ 			sgroup = sg_WaveGamma2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_StrongHold1,
--~ 			depart = mkr_Final1,			
--~ 			upgrade = false, 
--~ 			phase = 2,
--~ 			path = "pth_R2b", 
--~ 			capture1 = eg_pnt_R2, 
--~ 			capture2= eg_pnt_R1, 
--~ 			capture3= eg_pnt_R4, 
--~ 			capture4= eg_pnt_R3, 
--~ 			unit = SBP.CW.COMMANDOS, 
--~ 			unit2 = SBP.CW.COMMANDOS,  
--~ 			spawn = mkr_Spawn1, 
--~ 			attacker = sg_WaveAlphaAttacker1, 
--~ 		},
	}
	
	for i = 1, table.getn(t_WaveGamma) do
		--t_WaveGamma[i].sgroup = tsg_WaveGamma[i]
		--t_WaveGamma[i].spawn = tmkr_WaveGamma[i]
	end
	
	WaveGamma_Preset()
	
end


function WaveGamma_Preset()
--Spawns the units
	for k, this in pairs(t_WaveGamma) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, 4)
		--Util_CreateSquads(player2, this.sgroup, this.unit2, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(WaveGamma_Kickoff) == false then 
		Rule_AddInterval(WaveGamma_Kickoff, 1)
	end

end

function WaveGamma_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_WaveGamma) do
		if SGroup_TotalMembersCount(this.sgroup) < 3 then 
			--this.phase = 5
		end
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 60) == false then 
			SGroup_Clear(this.attacker)
		end
		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)

			if SGroup_Count(this.attacker) > 0 then 
				if Prox_SGroupSGroup(this.sgroup, this.attacker, PROX_SHORTEST) < 10 then 
				
					Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)					
				elseif SGroup_Count(this.enemy1) > 0 then 
					Cmd_AttackMove(this.sgroup, SGroup_GetPosition(this.enemy1), false, nil, 30)
				end
			end
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_IsCapturing(this.sgroup, ANY) == false then

				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				else
					Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, this.depart)	
			this.phase = 0
			Modifier_RemoveAllFromSGroup(this.sgroup)			
		end
	end
end


-------------------------------------------------------------------------

-- Interval Units
-- This units once called will recreate themselves over and over until the rule is stopped.  
-- A timer allows the to recreate rate to be slower and slower
-------------------------------------------------------------------------
function AirborneAlpha_Init()
	tmkr_AirborneAlpha = Marker_GetTable("mkr_AirborneAlpha%d")
	--tsg_AirborneAlpha = SGroup_CreateTable("sg_AirborneAlpha%d", table.getn(tmkr_AirborneAlpha))
	sg_AirborneAlpha1 = SGroup_CreateIfNotFound("sg_AirborneAlpha1")
	sg_AirborneAlpha2 = SGroup_CreateIfNotFound("sg_AirborneAlpha2")
	sg_AirborneAlpha3 = SGroup_CreateIfNotFound("sg_AirborneAlpha3")
	
	sg_AirborneAlphaAttacker1 = SGroup_CreateIfNotFound("sg_AirborneAlphaAttacker1")
	sg_AirborneAlphaAttacker2 = SGroup_CreateIfNotFound("sg_AirborneAlphaAttacker2")
	sg_AirborneAlphaAttacker3 = SGroup_CreateIfNotFound("sg_AirborneAlphaAttacker3")
	
	
	t_AirborneAlpha = {
		{
			sgroup = sg_AirborneAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_AirborneAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			capture1 = eg_pnt_Oosterbeek, 
			capture2 = eg_pnt_D3, 
			capture3 = eg_pnt_D4, 
			capture4 = eg_pnt_C4, 
			attacker = sg_AirborneAlphaAttacker1, 

		},
--~ 		{
--~ 			sgroup = sg_AirborneAlpha2,
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,			
--~ 			timername = "tmr_AirborneAlpha2", 
--~ 			timer = 60, 
--~ 			upgrade = false, 
--~ 			count = 4,
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn2,
--~ 			capture1 = eg_pnt_R1, 
--~ 			capture2 = eg_pnt_R2, 
--~ 			capture3 = eg_pnt_R3, 
--~ 			capture4 = eg_pnt_R4, 
--~ 			attacker = sg_AirborneAlphaAttacker2, 
--~ 		},
	}
	AirborneAlpha_Preset()
end

function AirborneAlpha_Preset()
	for k, this in pairs(t_AirborneAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(AirborneAlpha_Kickoff) == false then 
		Rule_AddInterval(AirborneAlpha_Kickoff, 1)
	end

	
end
  

function AirborneAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_AirborneAlpha) do
		--SGroup_GetLastAttacker(this.sgroup, this.attacker)
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 60) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 2 and SGroup_Count(this.sgroup) > 0 then
			this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 3)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 

			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_IsCapturing(this.sgroup, ANY) == false then
				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
					if SGroup_TotalMembersCount(this.sgroup) > SGroup_TotalMembersCount(this.attacker) then 
						Cmd_AttackMove(this.sgroup, this.attacker)						
					else
						Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_FRONT_RIGHT, 60, true)
					end
				end
			end
			
		end
		if this.phase == 5 then 
			Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end

-------------------------------------------------------------------------

-- Interval Units
-- This units once called will recreate themselves over and over until the rule is stopped.  
-- A timer allows the to recreate rate to be slower and slower
-------------------------------------------------------------------------
function AirborneBeta_Init()
	tmkr_AirborneBeta = Marker_GetTable("mkr_AirborneBeta%d")
	--tsg_AirborneBeta = SGroup_CreateTable("sg_AirborneBeta%d", table.getn(tmkr_AirborneBeta))
	sg_AirborneBeta1 = SGroup_CreateIfNotFound("sg_AirborneBeta1")
	sg_AirborneBeta2 = SGroup_CreateIfNotFound("sg_AirborneBeta2")
	sg_AirborneBeta3 = SGroup_CreateIfNotFound("sg_AirborneBeta3")
	
	sg_AirborneBetaAttacker1 = SGroup_CreateIfNotFound("sg_AirborneBetaAttacker1")

	t_AirborneBeta = {
		{
			sgroup = sg_AirborneBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_AirborneBeta1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn2,
			capture1 = eg_pnt_R2, 
			capture2 = eg_pnt_R1, 
			capture3 = eg_pnt_R4, 
			capture4 = eg_pnt_R3, 
			attacker = sg_AirborneBetaAttacker1, 

		},

	}
	AirborneBeta_Preset()
end

function AirborneBeta_Preset()
	for k, this in pairs(t_AirborneBeta) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 3)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(AirborneBeta_Kickoff) == false then 
		Rule_AddInterval(AirborneBeta_Kickoff, 10)
	end
	
end



function AirborneBeta_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_AirborneBeta) do
		
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 2 and SGroup_Count(this.sgroup) > 0 then
			this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 3)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					
					if SGroup_TotalMembersCount(this.sgroup) > SGroup_TotalMembersCount(this.attacker) then 
						Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)					
					else
						Cmd_AttackMove(this.sgroup, SGroup_GetPosition(this.attacker))
					end
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0 and SGroup_IsCapturing(this.sgroup, ANY) == false then
				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				else
					Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
				end
			end
		end
		if this.phase == 5 then
			Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))
		end
	end
end


function BazookaAlpha_Init()
	tmkr_BazookaAlpha = Marker_GetTable("mkr_BazookaAlpha%d")
	--tsg_BazookaAlpha = SGroup_CreateTable("sg_BazookaAlpha%d", table.getn(tmkr_BazookaAlpha))
	sg_BazookaAlpha1 = SGroup_CreateIfNotFound("sg_BazookaAlpha1")
	sg_BazookaAlpha2 = SGroup_CreateIfNotFound("sg_BazookaAlpha2")
	sg_BazookaAlpha3 = SGroup_CreateIfNotFound("sg_BazookaAlpha3")
	
	sg_BazookaAlphaAttacker1 = SGroup_CreateIfNotFound("sg_BazookaAlphaAttacker1")
	sg_BazookaAlphaAttacker2 = SGroup_CreateIfNotFound("sg_BazookaAlphaAttacker2")
	sg_BazookaAlphaAttacker3 = SGroup_CreateIfNotFound("sg_BazookaAlphaAttacker3")
	
	eg_BazookaAlphaAttacker1 = EGroup_CreateIfNotFound("eg_BazookaAlphaAttacker1")
	eg_BazookaAlphaAttacker2 = EGroup_CreateIfNotFound("eg_BazookaAlphaAttacker2")
	eg_BazookaAlphaAttacker3 = EGroup_CreateIfNotFound("eg_BazookaAlphaAttacker3")
	
	t_BazookaAlpha = {
		{
			sgroup = sg_BazookaAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_BazookaAlpha1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			egroup = eg_AxisAll, 
			egroupattack = eg_BazookaAlphaAttacker1, 
			attacker = sg_BazookaAlphaAttacker1, 

		},
--~ 		{
--~ 			sgroup = sg_BazookaAlpha2,
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,			
--~ 			timername = "tmr_BazookaAlpha2", 
--~ 			timer = 60, 
--~ 			upgrade = false, 
--~ 			count = 4,
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn2,
--~ 			capture1 = eg_pnt_R1, 
--~ 			capture2 = eg_pnt_R2, 
--~ 			capture3 = eg_pnt_R3, 
--~ 			capture4 = eg_pnt_R4, 
--~ 			attacker = sg_BazookaAlphaAttacker2, 
--~ 		},
	}
	BazookaAlpha_Preset()
end

function BazookaAlpha_Preset()
	for k, this in pairs(t_BazookaAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 3)
		Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
		this.phase = 2

	end
	if Rule_Exists(BazookaAlpha_Kickoff) == false then 
		Rule_AddInterval(BazookaAlpha_Kickoff, 5)
	end
	
	
end
  

function BazookaAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_BazookaAlpha) do
		
		--SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
			--this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
			Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
				
					Cmd_AttackMove(this.sgroup, this.attacker)
					--Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
				
				if EGroup_Count(this.egroup) > 0 then 
					EGroup_Single(eg_BazookaAlphaAttacker1, Util_GetClosestAllyEntity(this.egroup, this.sgroup))
					Cmd_AttackMove(this.sgroup, eg_BazookaAlphaAttacker1)
					
				elseif EGroup_Count(this.egroup) == 0 and SGroup_Count(sg_AxisAll) > 0 then   
					Cmd_AttackMove(this.sgroup,  Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end


function BazookaBeta_Init()
	tmkr_BazookaBeta = Marker_GetTable("mkr_BazookaBeta%d")
	--tsg_BazookaBeta = SGroup_CreateTable("sg_BazookaBeta%d", table.getn(tmkr_BazookaBeta))
	sg_BazookaBeta1 = SGroup_CreateIfNotFound("sg_BazookaBeta1")
	sg_BazookaBeta2 = SGroup_CreateIfNotFound("sg_BazookaBeta2")
	sg_BazookaBeta3 = SGroup_CreateIfNotFound("sg_BazookaBeta3")
	
	sg_BazookaBetaAttacker1 = SGroup_CreateIfNotFound("sg_BazookaBetaAttacker1")
	sg_BazookaBetaAttacker2 = SGroup_CreateIfNotFound("sg_BazookaBetaAttacker2")
	sg_BazookaBetaAttacker3 = SGroup_CreateIfNotFound("sg_BazookaBetaAttacker3")

	sg_BazookaBetaTank1 = SGroup_CreateIfNotFound("sg_BazookaBetaTank1 ")

	
	t_BazookaBeta = {
		{
			sgroup = sg_BazookaBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_BazookaBeta1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			egroup = eg_AxisAll, 
			attacker = sg_BazookaBetaAttacker1, 
			tank = sg_BazookaBetaTank1, 
		},
	}
	BazookaBeta_Preset()
end

function BazookaBeta_Preset()
	for k, this in pairs(t_BazookaBeta) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
		Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
		this.phase = 2

	end
	if Rule_Exists(BazookaBeta_Kickoff) == false then 
		Rule_AddInterval(BazookaBeta_Kickoff, 5)
	end
	
	
end
  

function BazookaBeta_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_BazookaBeta) do
		
		--SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
			--this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
			Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
				
					Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_BACK, 10, true)
					--Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
				if SGroup_Count(sg_AxisTank) > 0 then 
					--SGroup_Single(this.tank, Util_GetClosestSquadPosition(sg_AxisTank, this.sgroup))
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisTank, this.sgroup))
				elseif SGroup_Count(sg_AxisTank) == 0 and SGroup_Count(sg_AxisAll) > 0 then  
					Cmd_AttackMove(this.sgroup,  Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end













function PiatAlpha_Init()
	tmkr_PiatAlpha = Marker_GetTable("mkr_PiatAlpha%d")
	--tsg_PiatAlpha = SGroup_CreateTable("sg_PiatAlpha%d", table.getn(tmkr_PiatAlpha))
	sg_PiatAlpha1 = SGroup_CreateIfNotFound("sg_PiatAlpha1")
	sg_PiatAlpha2 = SGroup_CreateIfNotFound("sg_PiatAlpha2")
	sg_PiatAlpha3 = SGroup_CreateIfNotFound("sg_PiatAlpha3")
	
	sg_PiatAlphaAttacker1 = SGroup_CreateIfNotFound("sg_PiatAlphaAttacker1")
	sg_PiatAlphaAttacker2 = SGroup_CreateIfNotFound("sg_PiatAlphaAttacker2")
	sg_PiatAlphaAttacker3 = SGroup_CreateIfNotFound("sg_PiatAlphaAttacker3")
	
	
	t_PiatAlpha = {
		{
			sgroup = sg_PiatAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_PiatAlpha1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			egroup1 = eg_AxisR1, 
			egroup2 = eg_AxisR2,  
			egroup3 = eg_AxisR3,  
			egroup4 = eg_AxisR4, 
			attacker = sg_PiatAlphaAttacker1, 

		},
	}
	PiatAlpha_Preset()
end

function PiatAlpha_Preset()
	for k, this in pairs(t_PiatAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_PIAT, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(PiatAlpha_Kickoff) == false then 
		Rule_AddInterval(PiatAlpha_Kickoff, 5)
	end
	
	
end
  

function PiatAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_PiatAlpha) do
		
		--SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
			--this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_PIAT, this.spawn)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
					Cmd_AttackMove(this.sgroup, this.attacker)
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
				if EGroup_Count(this.egroup1) > 0 then 
					
					Cmd_AttackMove(this.sgroup, Util_GetClosestEntityPosition(this.egroup1, this.sgroup))
				elseif EGroup_Count(this.egroup2) > 0  then
					Cmd_AttackMove(this.sgroup,  Util_GetClosestEntityPosition(this.egroup2, this.sgroup))
				elseif EGroup_Count(this.egroup3) > 0  then
					Cmd_AttackMove(this.sgroup,  Util_GetClosestEntityPosition(this.egroup3, this.sgroup))
				elseif EGroup_Count(this.egroup4) > 0  then
					Cmd_AttackMove(this.sgroup, Util_GetClosestEntityPosition(this.egroup4, this.sgroup))
				elseif SGroup_Count(sg_AxisAll) > 0 then
					Cmd_AttackMove(this.sgroup, sg_AxisAll)
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end

function Util_GetClosestFreeEntity(egroup, source)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local result = Util_GetPosition(egroup)
	
	local _CheckEntity = function(gid, idx, eid)
		if World_OwnsEntity(eid) then
			local thispos = Entity_GetPosition(eid)
			local thisdist = World_DistancePointToPoint(source, thispos)
			if  thisdist < dist then
				result = eid
				dist = thisdist
			end
		end
	end
	EGroup_ForEach(egroup, _CheckEntity)
	
	return result
	
end

function Util_GetClosestAllyEntity(egroup, source)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local result = Util_GetPosition(egroup)
	
	local _CheckEntity = function(gid, idx, eid)
		if Player_OwnsEntity(player1, eid) then
			local thispos = Entity_GetPosition(eid)
			local thisdist = World_DistancePointToPoint(source, thispos)
			if  thisdist < dist then
				result = eid
				dist = thisdist
			end
		end
	end
	EGroup_ForEach(egroup, _CheckEntity)
	
	return result
	
end




function Util_GetClosestEntityPosition(egroup, source)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local pos = Util_GetPosition(egroup)
	
	local _CheckEntity = function(gid, idx, eid)
		local thispos = Entity_GetPosition(eid)
		local thisdist = World_DistancePointToPoint(source, thispos)
		if  thisdist < dist then
			pos = thispos
			dist = thisdist
		end
	end
	EGroup_ForEach(egroup, _CheckEntity)
	
	return pos
	
end

function Util_GetClosestSquadPosition(sgroup, source)

	if scartype(source) ~= ST_SCARPOS then
		source = Util_GetPosition(source)
	end
	
	local dist = 9999999
	local pos = Util_GetPosition(sgroup)
	
	local _CheckSquad = function(gid, idx, sid)
		local thispos = Squad_GetPosition(sid)
		local thisdist = World_DistancePointToPoint(source, thispos)
		if  thisdist < dist then
			pos = thispos
			dist = thisdist
		end
	end
	SGroup_ForEach(sgroup, _CheckSquad)
	
	return pos
	
end




function MortarAlpha_Init()
	tmkr_MortarAlpha = Marker_GetTable("mkr_MortarAlpha%d")
	--tsg_MortarAlpha = SGroup_CreateTable("sg_MortarAlpha%d", table.getn(tmkr_MortarAlpha))
	sg_MortarAlpha1 = SGroup_CreateIfNotFound("sg_MortarAlpha1")
	sg_MortarAlpha2 = SGroup_CreateIfNotFound("sg_MortarAlpha2")
	sg_MortarAlpha3 = SGroup_CreateIfNotFound("sg_MortarAlpha3")
	
	sg_MortarAlphaAttacker1 = SGroup_CreateIfNotFound("sg_MortarAlphaAttacker1")
	sg_MortarAlphaAttacker2 = SGroup_CreateIfNotFound("sg_MortarAlphaAttacker2")
	sg_MortarAlphaAttacker3 = SGroup_CreateIfNotFound("sg_MortarAlphaAttacker3")
	
	
	t_MortarAlpha = {
		{
			sgroup = sg_MortarAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MortarAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn3,
			egroup = eg_AxisAll, 
			attacker = sg_MortarAlphaAttacker1, 
			ability = ABILITY.ALLIES.MORTAR_SMOKE, 
			sgroupenemy = sg_AxisAll, 

		},
		{
			sgroup = sg_MortarAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MortarAlpha2", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			egroup = eg_AxisAll, 
			attacker = sg_MortarAlphaAttacker2, 
			ability = ABILITY.ALLIES.MORTAR_SMOKE,
			sgroupenemy = sg_AxisAll, 
		},
	}
	MortarAlpha_Preset()
end

function MortarAlpha_Preset()
	for k, this in pairs(t_MortarAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MORTAR, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(MortarAlpha_Kickoff) == false then 
		Rule_AddInterval(MortarAlpha_Kickoff, 10)
	end
	
	
end
  

function MortarAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_MortarAlpha) do
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MORTAR, this.spawn)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 10) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
				
					Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_Count(this.attacker) == 0  then
				if SGroup_Count(this.sgroupenemy) > 0 then 
					Cmd_Ability(this.sgroup, this.ability, Util_GetClosestSquadPosition(this.sgroupenemy, this.sgroup), nil, true)
				end
			end
		end

	end
end



function MortarBeta_Init()

	tmkr_MortarBeta = Marker_GetTable("mkr_MortarBeta%d")
	tsg_MortarBeta = SGroup_CreateTable("sg_MortarBeta%d", table.getn(tmkr_MortarBeta))
	t_MortarBeta = {
		{
			sgroup = sg_MortarBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MortarBeta1", 
			timer = 60, 
			count = 4, 
			phase = 2,

		},
--~ 		{
--~ 			sgroup = sg_MortarBeta2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_MortarBeta2", 
--~ 			timer = 60, 
--~ 			count = 4, 
--~ 			phase = 2,

--~ 		},

	}
	for i = 1, table.getn(t_MortarBeta) do
		t_MortarBeta[i].sgroup = tsg_MortarBeta[i]
		t_MortarBeta[i].spawn = tmkr_MortarBeta[i]
	end
	MortarBeta_Preset()
end


function MortarBeta_Preset()
	for k, this in pairs(t_MortarBeta) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MORTAR, this.spawn)
		Modify_Vulnerability(this.sgroup, 2)
		Modify_AbilityMaxCastRange(player2, ABILITY.ALLIES.MORTAR_BARRAGE, 3 )
		Cmd_InstantSetupTeamWeapon(this.sgroup)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	
	end
	if Rule_Exists(MortarBeta_Kickoff) == false then 
		Rule_AddInterval(MortarBeta_Kickoff, 1)
	end
	
end

function MortarBeta_Kickoff()
	for k, this in pairs(t_MortarBeta) do
		if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true and SGroup_TotalMembersCount(this.sgroup) < 4 then 
			Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
		end
	end
end
		




function MGAlpha_Init()
	tmkr_MGAlpha = Marker_GetTable("mkr_MGAlpha%d")
	--tsg_MGAlpha = SGroup_CreateTable("sg_MGAlpha%d", table.getn(tmkr_MGAlpha))
	sg_MGAlpha1 = SGroup_CreateIfNotFound("sg_MGAlpha1")
	sg_MGAlpha2 = SGroup_CreateIfNotFound("sg_MGAlpha2")
	sg_MGAlpha3 = SGroup_CreateIfNotFound("sg_MGAlpha3")
	
	sg_MGAlphaAttacker1 = SGroup_CreateIfNotFound("sg_MGAlphaAttacker1")
	sg_MGAlphaAttacker2 = SGroup_CreateIfNotFound("sg_MGAlphaAttacker2")
	sg_MGAlphaAttacker3 = SGroup_CreateIfNotFound("sg_MGAlphaAttacker3")
	
	eg_MGAlpha1 = EGroup_CreateIfNotFound("eg_MGAlpha1")
	
	t_MGAlpha = {
		{
			sgroup = sg_MGAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MGAlpha1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn3,
			sgroupenemy = sg_AxisAll, 
			attacker = sg_MGAlphaAttacker1, 
			egroup = eg_blg_AllAlpha,  
			holdegroup = eg_MGAlpha1,
		},
		{
			sgroup = sg_MGAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MGAlpha2", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			sgroupenemy = sg_AxisAll, 
			attacker = sg_MGAlphaAttacker2, 
			egroup = eg_blg_AllAlpha,  
			holdegroup = eg_MGAlpha1,
		},
	}
	MGAlpha_Preset()
end

function MGAlpha_Preset()
	for k, this in pairs(t_MGAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MG, this.spawn)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(MGAlpha_Kickoff) == false then 
		Rule_AddInterval(MGAlpha_Kickoff, 10)
	end
	
	
end
  

function MGAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_MGAlpha) do
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 30) == false then 
			SGroup_Clear(this.attacker)
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_MG, this.spawn)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false  then 
				if SGroup_Count(sg_AxisAll) > 0 then 
					if Prox_AreSquadsNearMarker(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup), ANY, 60) == false then 
						Cmd_Move(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					elseif Prox_AreSquadsNearMarker(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup), ANY, 60) then 
						StripWeakBuildings4(this.egroup)
						EGroup_Single(eg_MGAlpha1, Util_GetClosestFreeEntity(this.egroup, this.sgroup))
						Cmd_Garrison(this.sgroup, eg_MGAlpha1)
					end
				end
			elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == true then 
				if SGroup_Count(sg_AxisAll) > 0 then 
					if Prox_AreSquadsNearMarker(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup), ANY, 60) == false then 
						
						SGroup_GetHoldEGroup(this.sgroup, this.holdegroup)
						if	EGroup_GetAvgHealth(eg_MGAlpha1) < 0.99 or SGroup_IsUnderAttack(this.sgroup, ANY, 10) == false then 
							Cmd_UngarrisonSquad(this.sgroup)
					
							StripWeakBuildings4(this.egroup)
						end
					end
				end
			end
		end
	end
end

function StripWeakBuildings4(egroup)
	local _CheckBuilding  = function(gid, idx, eid)
		local health = Entity_GetHealth(eid) / Entity_GetHealthMax(eid)
		print(health)
		if health < 0.99 then 
			EGroup_Remove(gid, eid)
		end
	end
	EGroup_ForEach(egroup, _CheckBuilding)
end

function MGBeta_Init()

	tmkr_MGBeta = Marker_GetTable("mkr_MGBeta%d")
	tsg_MGBeta = SGroup_CreateTable("sg_MGBeta%d", table.getn(tmkr_MGBeta))
	
	sg_MGBetaAttacker1 = SGroup_CreateIfNotFound("sg_MGBetaAttacker1")
	sg_MGBetaAttacker2 = SGroup_CreateIfNotFound("sg_MGBetaAttacker2")
	sg_MGBetaAttacker3 = SGroup_CreateIfNotFound("sg_MGBetaAttacker3")
	
	
	t_MGBeta = {
		{
			sgroup = sg_MGBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MGBeta1", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn = mkr_MGBeta1, 
			unit = SBP.CW.COMMANDOS_MG, 
			attacker = sg_MGBetaAttacker1, 

		},
		{
			sgroup = sg_MGBeta2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MGBeta2", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn =  mkr_MGBeta2,  
			unit = SBP.CW.COMMANDOS_MG, 
			attacker = sg_MGBetaAttacker2, 
		},
	}
	for i = 1, table.getn(t_MGBeta) do
		t_MGBeta[i].sgroup = tsg_MGBeta[i]
		--t_MGBeta[i].spawn = tmkr_MGBeta[i]
	end
	MGBeta_Preset()
end


function MGBeta_Preset()
	for k, this in pairs(t_MGBeta) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn)
		Cmd_InstantSetupTeamWeapon(this.sgroup)
		Modify_Vulnerability(this.sgroup, 2)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(MGBeta_Kickoff) == false then 
		Rule_AddInterval(MGBeta_Kickoff, 1)
	end
	
end

function MGBeta_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_MGBeta) do
		--print(SGroup_GetAvgHealth(this.sgroup))
		if SGroup_TotalMembersCount(this.sgroup) < 3 then
			this.phase = 5
		end
		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)
			if SGroup_IsUnderAttackFromDirection(this.sgroup, ANY, OFFSET_DIRECTION_BACK, 1) then 
				Cmd_AttackMove(this.sgroup, this.attacker)
			end
		end	
		if this.phase == 5 then 
			if Prox_AreSquadsNearMarker(this.sgroup, this.depart, ANY) == false and SGroup_Count(this.sgroup) > 0 then
				--Cmd_AbandonTeamWeapon(this.sgroup) 
				Cmd_Retreat(this.sgroup, this.depart)
			end
		end
	end
end

function MGGamma_Init()

	tmkr_MGGamma = Marker_GetTable("mkr_MGGamma%d")
	tsg_MGGamma = SGroup_CreateTable("sg_MGGamma%d", table.getn(tmkr_MGGamma))
	
	sg_MGGammaAttacker1 = SGroup_CreateIfNotFound("sg_MGGammaAttacker1")
	sg_MGGammaAttacker2 = SGroup_CreateIfNotFound("sg_MGGammaAttacker2")
	sg_MGGammaAttacker3 = SGroup_CreateIfNotFound("sg_MGGammaAttacker3")
	sg_MGGammaCarrier = SGroup_CreateIfNotFound("sg_MGGammaCarrier1")
	
	t_MGGamma = {
		{
			sgroup = sg_MGGamma1, 
			stronghold = eg_blg_StrongHold1,
			carrier = sg_MGGammaCarrier,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_MGGamma1", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn = mkr_MGSpawnGamma1, 
			unit = SBP.CW.LIEUTENANT, 
			attacker = sg_MGGammaAttacker1, 
			location1 = mkr_MGGamma1,

		},
--~ 		{
--~ 			sgroup = sg_MGGamma2, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_MGGamma2", 
--~ 			timer = 60, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn =  mkr_MGSpawnGamma2,  
--~ 			unit = SBP.CW.COMMANDOS_MG, 
--~ 			attacker = sg_MGGammaAttacker2, 
--~ 			location1 = mkr_MGGamma2,
--~ 		},
	}
	for i = 1, table.getn(t_MGGamma) do
		t_MGGamma[i].sgroup = tsg_MGGamma[i]
		--t_MGGamma[i].spawn = tmkr_MGGamma[i]
	end
	MGGamma_Preset()
end


function MGGamma_Preset()
	for k, this in pairs(t_MGGamma) do
		Util_CreateSquads(player2, this.carrier, SBP.CW.BREN_CARRIER, this.spawn)
		Util_CreateSquads(player2, this.sgroup, this.unit, this.carrier)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(MGGamma_Kickoff) == false then 
		Rule_AddInterval(MGGamma_Kickoff, 1)
	end
	
end

function MGGamma_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_MGGamma) do
		--print(SGroup_GetAvgHealth(this.sgroup))

		if this.phase == 2 then 
			Cmd_Move(this.carrier, mkr_Bridge)
			this.phase = 3
		end
		if this.phase == 3 then 
			if Prox_ArePlayersNearMarker(player1, mkr_Bridge, ANY, 80) then 
				Cmd_Move(this.carrier, mkr_eb_barb1_2)
				this.phase = 4
			end
		end
		if this.phase == 4 then 
			if Prox_AreSquadsNearMarker(this.carrier, mkr_Bridge, ANY, 30) then 
				Cmd_Ungarrison(this.carrier, this.location1)
				
				this.phase = 5
			end
		end
		
		if this.phase == 5 then 
			if SGroup_IsInHoldEntity(this.sgroup, ANY) == false then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and Prox_AreSquadsNearMarker(this.sgroup, this.location1, ANY, 5) == false then 
					Cmd_Move(this.sgroup, this.location1, nil, nil, mkr_PlayerAlpha3) 
				end
				if SGroup_IsUnderAttackFromDirection(this.sgroup, ANY, OFFSET_DIRECTION_BACK, 1) then 
					Cmd_AttackMove(this.sgroup, this.attacker)
				end
			end
		end	

--~ 		if speech_hill == nil and SGroup_IsDoingAttack(this.sgroup, ANY, 1) then 
--~ 			Util_AutoIntel(t_event_AttackHill)
--~ 			speech_hill = 1
--~ 		end
	end
end





function TrenchAlpha_Init()

	tmkr_TrenchAlpha = Marker_GetTable("mkr_TrenchAlpha%d")
	tsg_TrenchAlpha = SGroup_CreateTable("sg_TrenchAlpha%d", table.getn(tmkr_TrenchAlpha))
	
	sg_TrenchAlpha1 = SGroup_CreateIfNotFound("sg_TrenchAlpha1")
	sg_TrenchAlpha2 = SGroup_CreateIfNotFound("sg_TrenchAlpha2")
	sg_TrenchAlpha3 = SGroup_CreateIfNotFound("sg_TrenchAlpha3")
	
	t_TrenchAlpha = {
		{
			sgroup = sg_TrenchAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_TrenchAlpha1", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn = eg_Trench1, 
			unit = SBP.CW.COMMANDOS, 

		},
		{
			sgroup = sg_TrenchAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_TrenchAlpha2", 
			timer = 60, 
			count = 4, 
			phase = 2,
			spawn =  eg_Trench2,  
			unit = SBP.CW.COMMANDOS, 
		},
--~ 		{
--~ 			sgroup = sg_TrenchAlpha3, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_TrenchAlpha3", 
--~ 			timer = 60, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = eg_Trench3, 
--~ 			unit = SBP.CW.SAPPER, 
--~ 		},
	}
	for i = 1, table.getn(t_TrenchAlpha) do
		--t_TrenchAlpha[i].sgroup = tsg_TrenchAlpha[i]
		--t_TrenchAlpha[i].spawn = tmkr_TrenchAlpha[i]
	end
	TrenchAlpha_Preset()
end


function TrenchAlpha_Preset()
	for k, this in pairs(t_TrenchAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, 3)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(TrenchAlpha_Kickoff) == false then 
		Rule_AddInterval(TrenchAlpha_Kickoff, 1)
	end
end


function TrenchAlpha_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_TrenchAlpha) do
		
		if SGroup_TotalMembersCount(sg_AllyHeights) < 8 then
			this.phase = 5
		end
		if this.phase == 2 then 

		end	
		if this.phase == 5 then 
			if SGroup_IsInHoldEntity(this.sgroup, ANY) then 
				Cmd_Ungarrison(this.spawn)
			end
			if SGroup_IsInHoldEntity(this.sgroup, ANY) == false then 
				
				Cmd_Retreat(this.sgroup, this.depart)
				
				for i = 1, table.getn(t_CounterAlpha) do
					t_CounterAlpha[i].phase = 2
				end
			end
		end
		if g_nadespeech == nil then 
			if SGroup_IsInHoldEntity(this.sgroup, ANY) and SGroup_IsUnderAttack(this.sgroup, ANY, 1) and SGroup_IsUnderAttack(sg_AxisInfantry, ANY, 1) then 
				flashid1 = UI_FlashAbilityButton(ABILITY.ELITE.INCENDIARY_GRENADE_FALLSH, true, BT_UI_Weak_CommandBtn)
				flashid2 = UI_FlashAbilityButton(ABILITY.ELITE.INCENDIARY_GRENADE_GREN, true, BT_UI_Weak_CommandBtn)
				hintpointtrench = HintPoint_Add(this.spawn, true, 1439063)
				g_nadespeech = 1
			end
		end
		if g_nadespeech == 1 and SGroup_Count(this.sgroup) == 0 then 
			HintPoint_Remove(hintpointtrench)
			UI_StopFlashing(flashid1)
			UI_StopFlashing(flashid2)
			g_nadespeech = 2
		end
	end
end










function GarrisonAlpha_Init()
	tmkr_GarrisonAlpha = Marker_GetTable("mkr_GarrisonAlpha%d")
	--tsg_GarrisonAlpha = SGroup_CreateTable("sg_GarrisonAlpha%d", table.getn(tmkr_GarrisonAlpha))
	sg_GarrisonAlpha1 = SGroup_CreateIfNotFound("sg_GarrisonAlpha1")
	sg_GarrisonAlpha2 = SGroup_CreateIfNotFound("sg_GarrisonAlpha2")
	sg_GarrisonAlpha3 = SGroup_CreateIfNotFound("sg_GarrisonAlpha3")
	
	sg_GarrisonAlphaAttacker1 = SGroup_CreateIfNotFound("sg_GarrisonAlphaAttacker1")
	sg_GarrisonAlphaAttacker2 = SGroup_CreateIfNotFound("sg_GarrisonAlphaAttacker2")
	sg_GarrisonAlphaAttacker3 = SGroup_CreateIfNotFound("sg_GarrisonAlphaAttacker3")
	
	eg_GarrisonAlpha1 = EGroup_CreateIfNotFound("eg_GarrisonAlpha1")
	
	eg_GarrisonAlphaRemove = EGroup_CreateIfNotFound("eg_GarrisonAlphaRemove")
	
	t_GarrisonAlpha = {
		{
			sgroup = sg_GarrisonAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GarrisonAlpha1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn3,
			building1 = eg_blg_A1, 
			building2 = eg_blg_A2,
			building3 = eg_blg_A3,
			building4 = eg_blg_A4,
			attacker = sg_GarrisonAlphaAttacker1, 
			egroup = eg_blg_AllBuildings,  
			holdegroup = eg_GarrisonAlpha1,


		},
--~ 		{
--~ 			sgroup = sg_GarrisonAlpha2,
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,			
--~ 			timername = "tmr_GarrisonAlpha2", 
--~ 			timer = 60, 
--~ 			upgrade = false, 
--~ 			count = 4,
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn2,
--~ 			capture1 = eg_pnt_R1, 
--~ 			capture2 = eg_pnt_R2, 
--~ 			capture3 = eg_pnt_R3, 
--~ 			capture4 = eg_pnt_R4, 
--~ 			attacker = sg_GarrisonAlphaAttacker2, 
--~ 		},
	}
	GarrisonAlpha_Preset()
end

function GarrisonAlpha_Preset()
	for k, this in pairs(t_GarrisonAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(GarrisonAlpha_Kickoff) == false then 
		Rule_AddInterval(GarrisonAlpha_Kickoff, 5)
	end
	
end
  

function GarrisonAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_GarrisonAlpha) do
		SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 150) == false then 
			SGroup_Clear(this.attacker)
		end
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
			--this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false  then 
				if SGroup_Count(sg_AxisAll) > 0 then 
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
				else
					
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 5) == true and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_Count(this.attacker) > 0 then 	
				StripWeakBuildings(this.egroup)
				EGroup_Single(eg_GarrisonAlphaRemove, Util_GetClosestFreeEntity(this.egroup, this.sgroup))
				Cmd_Garrison(this.sgroup, eg_GarrisonAlphaRemove)
					
			elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == true then 
				SGroup_GetHoldEGroup(this.sgroup, this.holdegroup)
				if	EGroup_GetAvgHealth(eg_GarrisonAlphaRemove) < 0.99 or SGroup_IsUnderAttack(this.sgroup, ANY, 10) == false then 
					Cmd_UngarrisonSquad(this.sgroup)
					
					StripWeakBuildings(this.egroup)
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end

function StripWeakBuildings(egroup)
	local _CheckBuilding  = function(gid, idx, eid)
		local health = Entity_GetHealth(eid) / Entity_GetHealthMax(eid)
		print(health)
		if health < 0.99 then 
			EGroup_Remove(gid, eid)
		end
	end
	EGroup_ForEach(egroup, _CheckBuilding)
end

function GarrisonBeta_Init()
	tmkr_GarrisonBeta = Marker_GetTable("mkr_GarrisonBeta%d")
	--tsg_GarrisonBeta = SGroup_CreateTable("sg_GarrisonBeta%d", table.getn(tmkr_GarrisonBeta))
	sg_GarrisonBeta1 = SGroup_CreateIfNotFound("sg_GarrisonBeta1")
	sg_GarrisonBeta2 = SGroup_CreateIfNotFound("sg_GarrisonBeta2")
	sg_GarrisonBeta3 = SGroup_CreateIfNotFound("sg_GarrisonBeta3")
	
	sg_GarrisonBetaAttacker1 = SGroup_CreateIfNotFound("sg_GarrisonBetaAttacker1")
	sg_GarrisonBetaAttacker2 = SGroup_CreateIfNotFound("sg_GarrisonBetaAttacker2")
	sg_GarrisonBetaAttacker3 = SGroup_CreateIfNotFound("sg_GarrisonBetaAttacker3")
	
	eg_GarrisonBeta1 = EGroup_CreateIfNotFound("eg_GarrisonBeta1")
	
	eg_GarrisonBetaRemove = EGroup_CreateIfNotFound("eg_GarrisonBetaRemove")
	
	t_GarrisonBeta = {
		{
			sgroup = sg_GarrisonBeta1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GarrisonBeta1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn4,
			building1 = eg_blg_A1, 
			building2 = eg_blg_A2,
			building3 = eg_blg_A3,
			building4 = eg_blg_A4,
			attacker = sg_GarrisonBetaAttacker1, 
			egroup = eg_blg_AllBuildings,  
			holdegroup = eg_GarrisonBeta1,


		},
--~ 		{
--~ 			sgroup = sg_GarrisonBeta2,
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,			
--~ 			timername = "tmr_GarrisonBeta2", 
--~ 			timer = 60, 
--~ 			upgrade = false, 
--~ 			count = 4,
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn2,
--~ 			capture1 = eg_pnt_R1, 
--~ 			capture2 = eg_pnt_R2, 
--~ 			capture3 = eg_pnt_R3, 
--~ 			capture4 = eg_pnt_R4, 
--~ 			attacker = sg_GarrisonBetaAttacker2, 
--~ 		},
	}
	GarrisonBeta_Preset()
end

function GarrisonBeta_Preset()
	for k, this in pairs(t_GarrisonBeta) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(GarrisonBeta_Kickoff) == false then 
		Rule_AddInterval(GarrisonBeta_Kickoff, 5)
	end
	
end
  

function GarrisonBeta_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_GarrisonBeta) do
		SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 150) == false then 
			SGroup_Clear(this.attacker)
		end
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
			--this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 10) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false  then 
				if SGroup_Count(sg_AxisAll) > 0 then 
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 10) == true and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_Count(this.attacker) > 0 then 	
				StripWeakBuildings2(this.egroup)
				EGroup_Single(eg_GarrisonBetaRemove, Util_GetClosestFreeEntity(this.egroup, this.sgroup))
					
					Cmd_Garrison(this.sgroup, eg_GarrisonBetaRemove)
			
			elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == true  then 
				SGroup_GetHoldEGroup(this.sgroup, this.holdegroup)
				if	EGroup_GetAvgHealth(eg_GarrisonBetaRemove) < 0.99 or SGroup_IsUnderAttack(this.sgroup, ANY, 10) == false then 
					print(EGroup_GetAvgHealth(eg_GarrisonBeta1))
					Cmd_UngarrisonSquad(this.sgroup)
					--Cmd_Ungarrison((this.sgroup, mkr_BeaconBeta2) 
					
					StripWeakBuildings2(this.egroup)
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end

function StripWeakBuildings2(egroup)
	local _CheckBuilding  = function(gid, idx, eid)
		local health = Entity_GetHealth(eid) / Entity_GetHealthMax(eid)
		print(health)
		if health < 0.99 then 
			EGroup_Remove(gid, eid)
		end
	end
	EGroup_ForEach(egroup, _CheckBuilding)
end

 function GarrisonGamma_Init()
	tmkr_GarrisonGamma = Marker_GetTable("mkr_GarrisonGamma%d")
	--tsg_GarrisonGamma = SGroup_CreateTable("sg_GarrisonGamma%d", table.getn(tmkr_GarrisonGamma))
	sg_GarrisonGamma1 = SGroup_CreateIfNotFound("sg_GarrisonGamma1")
	sg_GarrisonGamma2 = SGroup_CreateIfNotFound("sg_GarrisonGamma2")
	sg_GarrisonGamma3 = SGroup_CreateIfNotFound("sg_GarrisonGamma3")
	
	sg_GarrisonGammaAttacker1 = SGroup_CreateIfNotFound("sg_GarrisonGammaAttacker1")
	sg_GarrisonGammaAttacker2 = SGroup_CreateIfNotFound("sg_GarrisonGammaAttacker2")
	sg_GarrisonGammaAttacker3 = SGroup_CreateIfNotFound("sg_GarrisonGammaAttacker3")
	
	eg_GarrisonGamma1 = EGroup_CreateIfNotFound("eg_GarrisonGamma1")
	
	eg_GarrisonGammaRemove = EGroup_CreateIfNotFound("eg_GarrisonGammaRemove")
	
	t_GarrisonGamma = {
		{
			sgroup = sg_GarrisonGamma1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GarrisonGamma1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			building1 = eg_blg_A1, 
			building2 = eg_blg_A2,
			building3 = eg_blg_A3,
			building4 = eg_blg_A4,
			attacker = sg_GarrisonGammaAttacker1, 
			egroup = eg_blg_AllBuildings,  
			holdegroup = eg_GarrisonGamma1,


		},
--~ 		{
--~ 			sgroup = sg_GarrisonGamma2,
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,			
--~ 			timername = "tmr_GarrisonGamma2", 
--~ 			timer = 60, 
--~ 			upgrade = false, 
--~ 			count = 4,
--~ 			phase = 2,
--~ 			spawn = mkr_Spawn2,
--~ 			capture1 = eg_pnt_R1, 
--~ 			capture2 = eg_pnt_R2, 
--~ 			capture3 = eg_pnt_R3, 
--~ 			capture4 = eg_pnt_R4, 
--~ 			attacker = sg_GarrisonGammaAttacker2, 
--~ 		},
	}
	GarrisonGamma_Preset()
end

function GarrisonGamma_Preset()
	for k, this in pairs(t_GarrisonGamma) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 3)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(GarrisonGamma_Kickoff) == false then 
		Rule_AddInterval(GarrisonGamma_Kickoff, 5)
	end
	
end
  

function GarrisonGamma_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_GarrisonGamma) do
		SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		
		if SGroup_Count(this.attacker) > 0 and Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 150) == false then 
			SGroup_Clear(this.attacker)
		end
		if SGroup_TotalMembersCount(this.sgroup) < 3 and SGroup_Count(this.sgroup) > 0 then
			--this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, 1, 3)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false  then 
				if SGroup_Count(sg_AxisAll) > 0 then 
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					print("Attack them")
				else
					
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 5) == true and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_Count(this.attacker) > 0 then 	
				StripWeakBuildings3(this.egroup)
				EGroup_Single(eg_GarrisonGammaRemove, Util_GetClosestFreeEntity(this.egroup, this.sgroup))
				Cmd_Garrison(this.sgroup, eg_GarrisonGammaRemove)
					
				print("Garrison")
			elseif SGroup_IsInHoldEntity(this.sgroup, ANY) == true then 
				SGroup_GetHoldEGroup(this.sgroup, this.holdegroup)
				if	EGroup_GetAvgHealth(eg_GarrisonGammaRemove) < 0.99 or SGroup_IsUnderAttack(this.sgroup, ANY, 10) == false then 
					Cmd_UngarrisonSquad(this.sgroup)
					--Cmd_Ungarrison((this.sgroup, mkr_BeaconGamma2) 
					print("Ungarrison")
					StripWeakBuildings3(this.egroup)
				end
			end
		end
		if this.phase == 5 then 
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))		
		end
	end
end
function StripWeakBuildings3(egroup)
	local _CheckBuilding  = function(gid, idx, eid)
		local health = Entity_GetHealth(eid) / Entity_GetHealthMax(eid)
		print(health)
		if health < 0.99 then 
			EGroup_Remove(gid, eid)
		end
	end
	EGroup_ForEach(egroup, _CheckBuilding)
end
function BrenAlpha_Init()
	tmkr_BrenAlpha = Marker_GetTable("mkr_BrenAlpha%d")
	tsg_BrenAlpha = SGroup_CreateTable("sg_BrenAlpha%d", table.getn(tmkr_BrenAlpha))
	sg_BrenAlpha1 = SGroup_CreateIfNotFound("sg_BrenAlpha1")
	sg_BrenAlpha2 = SGroup_CreateIfNotFound("sg_BrenAlpha2")
	sg_BrenAlpha3 = SGroup_CreateIfNotFound("sg_BrenAlpha3")
	sg_BrenInfantryAlpha1 = SGroup_CreateIfNotFound("sg_BrenInfantryAlpha1")
	sg_BrenInfantryAlpha2 = SGroup_CreateIfNotFound("sg_BrenInfantryAlpha2")
	sg_BrenInfantryAlpha3 = SGroup_CreateIfNotFound("sg_BrenInfantryAlpha3")

	sg_BrenAlphaAttacker1 = SGroup_CreateIfNotFound("sg_BrenAlphaAttacker1")
	sg_BrenAlphaAttacker2 = SGroup_CreateIfNotFound("sg_BrenAlphaAttacker2")
	sg_BrenAlphaAttacker3 = SGroup_CreateIfNotFound("sg_BrenAlphaAttacker3")

	
	t_BrenAlpha = {
		{
			sgroup = sg_BrenAlpha1,
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			timername = "tmr_BrenAlpha1", 
			timer = 10, 
			phase = 2,
			spawn = mkr_Spawn3,
			inf = sg_BrenInfantryAlpha1,
			egroup = eg_blg_Bridge,
			mkrstart = mkr_StartWire1, 
			mkrend = mkr_EndWire1, 
			attacker = sg_BrenAlphaAttacker1, 
			egroup1 = eg_pnt_R1, 
			egroup2 = eg_pnt_R2, 
			enemy1 = sg_AxisR1,
		},
		{
			sgroup = sg_BrenAlpha2,
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			timername = "tmr_BrenAlpha2", 
			timer = 10, 
			phase = 2,
			spawn = mkr_Spawn4, 
			inf = sg_BrenInfantryAlpha2,
			egroup = eg_blg_Bridge,
			mkrstart = mkr_StartWire2, 
			mkrend = mkr_EndWire2, 
			attacker = sg_BrenAlphaAttacker2, 
			egroup1 = eg_pnt_R2, 
			egroup2 = eg_pnt_R1, 
			enemy1 = sg_AxisR2,
		},
	}
	
	for i = 1, table.getn(t_BrenAlpha) do
		--t_BrenAlpha[i].sgroup = tsg_BrenAlpha[i]
		--t_BrenAlpha[i].spawn = tmkr_BrenAlpha[i]
	end
	BrenAlpha_Preset()
end

function BrenAlpha_Preset()
	for k, this in pairs(t_BrenAlpha) do

			Util_CreateSquads(player2, this.sgroup, SBP.CW.BREN_CARRIER, this.spawn)
			Util_CreateSquads(player2, this.inf, SBP.CW.COMMANDOS_PIAT, this.sgroup)	
			local panzerrand = World_GetRand(1, 2)
			if  panzerrand== 1 then 
				Cmd_InstantUpgrade(this.sgroup, UPG.CW.BREN_CARRIER_MMG)
			end
			if  panzerrand== 2 then 
				
			end			
		this.phase = 2
	end	
	if Rule_Exists(BrenAlpha_Kickoff) == false then 
		Rule_AddInterval(BrenAlpha_Kickoff, 8)
	end
end

function BrenAlpha_Kickoff()
	for k, this in pairs(t_BrenAlpha) do
		SGroup_GetLastAttacker(this.inf, this.attacker) 
		SGroup_GetLastAttacker(this.sgroup, this.attacker) 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and SGroup_TotalMembersCount(this.inf) == 0  and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and SGroup_TotalMembersCount(this.inf) == 0 and  Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 and EGroup_Count(eg_blg_Bridge) > 0 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.BREN_CARRIER, this.spawn)
			Util_CreateSquads(player2, this.inf, SBP.CW.COMMANDOS_PIAT, this.sgroup)	
			local panzerrand = World_GetRand(1, 2)
			if  panzerrand== 1 then 
				Cmd_InstantUpgrade(this.sgroup, UPG.CW.BREN_CARRIER_MMG)
			end
			if  panzerrand== 2 then 
				
			end
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and SGroup_TotalMembersCount(this.inf) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_Count(this.enemy1) > 0 then 
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(this.enemy1, this.sgroup))
					this.phase = 3
				elseif SGroup_Count(sg_AxisAll) > 0 then 
					Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					this.phase = 3
				end
			end
		end
		if this.phase == 3 then 
			if SGroup_Count(this.sgroup) > 0 then 
				if SGroup_GetAvgHealth(this.sgroup) < 0.8 and SGroup_IsHoldingAny(this.sgroup) then 
					Cmd_Ungarrison(this.sgroup) 
				end
				if SGroup_IsInHoldEntity(this.inf, ANY) == false and SGroup_Count(this.inf) > 0 then 
					if SGroup_Count(this.attacker) > 0 then 
						Cmd_Move(this.inf, this.attacker, false, nil, this.attacker, OFFSET_LEFT, 20, true)	
					elseif SGroup_Count(this.enemy1) > 0 then 
						Cmd_AttackMove(this.inf, SGroup_GetPosition(this.enemy1))
					elseif SGroup_Count(sg_AxisAll) > 0 then 
						Cmd_AttackMove(this.inf, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					end
				end
				if SGroup_IsHoldingAny(this.sgroup) == false and SGroup_GetAvgHealth(this.sgroup) > 0.2 then 
					if SGroup_Count(this.attacker) > 0 then 
						Cmd_AttackMove(this.sgroup, SGroup_GetPosition(this.attacker))
					elseif SGroup_Count(this.enemy1) > 0 then 
						Cmd_AttackMove(this.sgroup, SGroup_GetPosition(this.enemy1))
					elseif SGroup_Count(sg_AxisAll) > 0 then 
						Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					end
	
				elseif SGroup_GetAvgHealth(this.sgroup) < 0.2 then
					
					if Prox_AreSquadsNearMarker(this.sgroup, this.depart, ANY) == false then
						Cmd_Move(this.sgroup, this.depart)
					end
				end
				if SGroup_IsUnderAttack(this.sgroup, ANY, 8) == false  then
					if SGroup_Count(sg_AxisAll) > 0 then 
						Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
					end
				end
			end
		end
		if SGroup_IsHoldingAny(this.sgroup) == true and SGroup_GetAvgHealth(this.sgroup) < 0.20 then 
			SGroup_Kill(this.sgroup)
			SGroup_Kill(this.inf)
		end
	end
end
 
 

function GrenadeAlpha_Init()
	tmkr_GrenadeAlpha = Marker_GetTable("mkr_GrenadeAlpha%d")
	--tsg_GrenadeAlpha = SGroup_CreateTable("sg_GrenadeAlpha%d", table.getn(tmkr_GrenadeAlpha))
	sg_GrenadeAlpha1 = SGroup_CreateIfNotFound("sg_GrenadeAlpha1")
	sg_GrenadeAlpha2 = SGroup_CreateIfNotFound("sg_GrenadeAlpha2")
	sg_GrenadeAlpha3 = SGroup_CreateIfNotFound("sg_GrenadeAlpha3")
	
	sg_GrenadeAlphaAttacker1 = SGroup_CreateIfNotFound("sg_GrenadeAlphaAttacker1")

	t_GrenadeAlpha = {
		{
			sgroup = sg_GrenadeAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GrenadeAlpha1", 
			timer = 30, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			attacker = sg_GrenadeAlphaAttacker1, 

		},

	}
	GrenadeAlpha_Preset()
end

function GrenadeAlpha_Preset()
	for k, this in pairs(t_GrenadeAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(GrenadeAlpha_Kickoff) == false then 
		Rule_AddInterval(GrenadeAlpha_Kickoff, 1)
	end
	
end



function GrenadeAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_GrenadeAlpha) do
		
		if SGroup_Count(this.attacker) > 0 and  Prox_AreSquadsNearMarker(this.sgroup, SGroup_GetPosition(this.attacker), ANY, 120) == false then 
			SGroup_Clear(this.attacker)
		end
		
		if SGroup_TotalMembersCount(this.sgroup) < 2 and SGroup_Count(this.sgroup) > 0 then
			this.phase = 5
		end
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)
			if SGroup_Count(this.attacker) > 0 then 
				if Prox_SGroupSGroup(this.sgroup, this.attacker, PROX_SHORTEST) < 10 then 
					print("THROW IT")
					Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, this.attacker, nil, true)					
				else
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
					Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_BACK, 10, true)
				end
			elseif SGroup_Count(sg_AxisAll) > 0 then 
				Cmd_AttackMove(this.sgroup, Util_GetClosestSquadPosition(sg_AxisAll, this.sgroup))
			end
		end
		if this.phase == 5 then
			Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
			Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))
		end
	end
end




function HalftrackAlpha_Init()
	tmkr_HalftrackAlpha = Marker_GetTable("mkr_HalftrackAlpha%d")
	tsg_HalftrackAlpha = SGroup_CreateTable("sg_HalftrackAlpha%d", table.getn(tmkr_HalftrackAlpha))
	sg_HalftrackAlpha1 = SGroup_CreateIfNotFound("sg_HalftrackAlpha1")
	sg_HalftrackAlpha2 = SGroup_CreateIfNotFound("sg_HalftrackAlpha2")
	sg_HalftrackAlpha3 = SGroup_CreateIfNotFound("sg_HalftrackAlpha3")
	sg_HalftrackInfantryAlpha1 = SGroup_CreateIfNotFound("sg_HalftrackInfantryAlpha1")
	sg_HalftrackInfantryAlpha2 = SGroup_CreateIfNotFound("sg_HalftrackInfantryAlpha2")
	sg_HalftrackInfantryAlpha3 = SGroup_CreateIfNotFound("sg_HalftrackInfantryAlpha3")
	sg_HalftrackFollowAlpha1 = SGroup_CreateIfNotFound("sg_HalftrackFollowAlpha1")
	sg_HalftrackFollowAlpha2 = SGroup_CreateIfNotFound("sg_HalftrackFollowAlpha2")
	sg_HalftrackFollowAlpha3 = SGroup_CreateIfNotFound("sg_HalftrackFollowAlpha3")

	sg_HalftrackAlphaAttacker1 = SGroup_CreateIfNotFound("sg_HalftrackAlphaAttacker1")
	sg_HalftrackAlphaAttacker2 = SGroup_CreateIfNotFound("sg_HalftrackAlphaAttacker2")
	sg_HalftrackAlphaAttacker3 = SGroup_CreateIfNotFound("sg_HalftrackAlphaAttacker3")

	
	t_HalftrackAlpha = {
		{
			sgroup = sg_HalftrackAlpha1,
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			timername = "tmr_HalftrackAlpha1", 
			timer = 300, 
			phase = 2,
			spawn = mkr_Spawn1,
			inf = sg_HalftrackInfantryAlpha1,
			egroup = eg_blg_Bridge,
			mkrstart = mkr_StartWire1, 
			mkrend = mkr_EndWire1, 
			follow = sg_HalftrackFollowAlpha1, 
			attacker = sg_HalftrackAlphaAttacker1, 			
			release = mkr_Bridge,
			firstspawn = mkr_SpawnHalftrackAlpha1, 
		},
		{
			sgroup = sg_HalftrackAlpha2,
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_StrongHold1,
			depart = mkr_Final1,			
			timername = "tmr_HalftrackAlpha2", 
			timer = 300, 
			phase = 2,
			spawn = mkr_Spawn2, 
			inf = sg_HalftrackInfantryAlpha2,
			egroup = eg_blg_Bridge,
			mkrstart = mkr_StartWire2, 
			mkrend = mkr_EndWire2, 
			follow = sg_HalftrackFollowAlpha2, 
			attacker = sg_HalftrackAlphaAttacker2, 
			release = mkr_Intercept, 
			firstspawn = mkr_SpawnHalftrackAlpha2, 
		},
	}
	
	for i = 1, table.getn(t_HalftrackAlpha) do
		--t_HalftrackAlpha[i].sgroup = tsg_HalftrackAlpha[i]
		--t_HalftrackAlpha[i].spawn = tmkr_HalftrackAlpha[i]
	end
	HalftrackAlpha_Preset()
end

function HalftrackAlpha_Preset()
	for k, this in pairs(t_HalftrackAlpha) do
			Util_CreateSquads(player2, this.sgroup, SBP.CW.BREN_CARRIER, this.firstspawn)
			Util_CreateSquads(player2, this.inf, SBP.CW.TOMMIES, this.firstspawn, nil, nil, 3)		
			Util_CreateSquads(player2, this.follow, SBP.CW.SAPPER, this.sgroup, nil, nil, 3)		
		this.phase = 2
	end	
	if Rule_Exists(HalftrackAlpha_Kickoff) == false then 
		Rule_AddInterval(HalftrackAlpha_Kickoff, 2)
	end
end

function HalftrackAlpha_Kickoff()
	for k, this in pairs(t_HalftrackAlpha) do
		SGroup_GetLastAttacker(this.inf, this.attacker) 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and SGroup_TotalMembersCount(this.inf) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 and EGroup_Count(eg_blg_Bridge) > 0 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.BREN_CARRIER, this.spawn)
			--Cmd_InstantUpgrade(this.sgroup, UPG.CW.BREN_CARRIER_MMG)
			Util_CreateSquads(player2, this.inf, SBP.CW.COMMANDOS_PIAT, this.sgroup)	
			Util_CreateSquads(player2, this.follow, SBP.CW.SAPPER, this.sgroup, nil, nil, 3)	
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and SGroup_Count(this.inf) == 0 and SGroup_Count(this.follow) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			
			if Prox_AreSquadsNearMarker(this.sgroup, this.release, ANY) == false and SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false then 	
				Cmd_SquadPath(this.sgroup, "pth_Bridge", true, false, false, 0)
				Cmd_Move(this.inf, this.sgroup)
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 5) == true then
				Cmd_Ungarrison(this.sgroup)
				this.phase = 3
			elseif Prox_AreSquadsNearMarker(this.sgroup, this.release, ANY) then 
				Cmd_Ungarrison(this.sgroup)
				this.phase = 3
			end

		end
		if this.phase == 3 then 
			if SGroup_IsHoldingAny(this.sgroup) == false then 
				if Prox_AreSquadsNearMarker(this.sgroup, this.depart, ANY) == false and SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false then
					Cmd_Move(this.sgroup, this.depart)
					this.phase = 4
				end
				if SGroup_Count(this.inf) > 0 and SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false then 					
					Cmd_AttackMove(this.inf, this.release) 
					this.phase = 4
				end
			else
				Cmd_Ungarrison(this.sgroup)
			end
		end
		if this.phase == 4 then 
			--and Prox_ArePlayersNearMarker(player1, SGroup_GetPosition(this.follow), ANY, 140)
			if SGroup_Count(this.follow) > 0 and SGroup_IsConstructingBuilding(this.follow, ANY) == false then
				Command_PlayerSquadConstructFence(player2, this.follow, EBP.CW.BARBED_WIRE, Util_GetPosition(this.mkrstart), Util_GetPosition(this.mkrend), false)
			end
			if SGroup_IsInHoldEntity(this.inf, ANY) == false and SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and Prox_AreSquadsNearMarker(this.follow, this.release, ANY, 5) == false and SGroup_TotalMembersCount(this.inf) > 1 then 
				Cmd_AttackMove(this.inf, this.release)
			end
			if SGroup_IsInHoldEntity(this.inf, ANY) == false and SGroup_IsUnderAttack(this.sgroup, ANY, 5) == false and Prox_AreSquadsNearMarker(this.follow, this.release, ANY, 5) == false and SGroup_TotalMembersCount(this.inf) < 2 then 
				Cmd_Retreat(this.inf, mkr_Final2)
			end
		end
		
		if SGroup_IsHoldingAny(this.sgroup) == true and SGroup_GetAvgHealth(this.sgroup) < 0.40 then 
			SGroup_Kill(this.sgroup)
			SGroup_Kill(this.inf)
		end
		if SGroup_Count(this.sgroup) > 0 and SGroup_IsHoldingAny(this.sgroup) == true then 
			UI_CreateMinimapBlip(this.sgroup, 5, BT_CombatPing)
			FOW_RevealSGroup(this.sgroup, 5)
		end
		if speech_barbwire == nil and SGroup_IsDoingAttack(this.follow, ANY, 1) then 
			Util_AutoIntel(t_firstwire)
			speech_barbwire = 1
		end
	end
end




function ATGunAlpha_Init()
	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_ATGunAlpha = Marker_GetTable("mkr_ATGunAlpha%d")
	tsg_ATGunAlpha = SGroup_CreateTable("sg_ATGunAlpha%d", table.getn(tmkr_ATGunAlpha))
	sg_ATGunAlpha1Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha1Attacker")
	sg_ATGunAlpha2Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha2Attacker")
	sg_ATGunAlpha3Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha3Attacker")
	sg_ATGunAlpha4Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha4Attacker")
	sg_ATGunAlpha5Attacker = SGroup_CreateIfNotFound("sg_ATGunAlpha5Attacker")
	
	
	t_ATGunAlpha = {
		{
			phase = 2,
			attacker = sg_ATGunAlpha1Attacker ,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			attacker = sg_ATGunAlpha2Attacker ,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			attacker = sg_ATGunAlpha3Attacker ,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			attacker = sg_ATGunAlpha4Attacker ,
			depart = mkr_Final1, 
		},
		{
			phase = 2,
			attacker = sg_ATGunAlpha5Attacker ,
			depart = mkr_Final1, 
		},
	}
	
	for i = 1, table.getn(t_ATGunAlpha) do
		t_ATGunAlpha[i].sgroup = tsg_ATGunAlpha[i]
		t_ATGunAlpha[i].spawn = tmkr_ATGunAlpha[i]
	end
	
	ATGunAlpha_Preset()


end

-- preset any units or events needed before the kickoff
function ATGunAlpha_Preset()
	-- spawn squads
	-- start enemy behavior
	-- do other cool things
	for k, this in pairs(t_ATGunAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS_PAK38_SP, this.spawn)
		this.phase = 2
	end
	
	Rule_AddInterval(ATGunAlpha_Kickoff, 1)

end

-- start the related action
function ATGunAlpha_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_ATGunAlpha) do
		--print(SGroup_GetAvgHealth(this.sgroup))
		if SGroup_TotalMembersCount(this.sgroup) < 4 then
			--this.phase = 5
		end
		if this.phase == 2 then 
			if SGroup_Count(this.sgroup) > 0 then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_IsUnderAttackFromDirection(this.sgroup, ANY, OFFSET_DIRECTION_BACK, 1) and SGroup_Count(this.attacker) > 0 then 
					Cmd_AttackMove(this.sgroup, this.attacker)
				end
			end
		end	
	end
end

function StillAlpha_Init()
	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_StillAlpha = Marker_GetTable("mkr_Still2Alpha%d")
	tsg_StillAlpha = SGroup_CreateTable("sg_StillAlpha%d", table.getn(tmkr_StillAlpha))
	tsg_StillAlphaAttacker = SGroup_CreateTable("sg_StillAlpha%dAttacker", table.getn(tmkr_StillAlpha))
--~ 	sg_StillAlpha1Attacker = SGroup_CreateIfNotFound("sg_StillAlpha1Attacker")
--~ 	sg_StillAlpha2Attacker = SGroup_CreateIfNotFound("sg_StillAlpha2Attacker")
--~ 	sg_StillAlpha3Attacker = SGroup_CreateIfNotFound("sg_StillAlpha3Attacker")
--~ 	sg_StillAlpha4Attacker = SGroup_CreateIfNotFound("sg_StillAlpha4Attacker")
--~ 	sg_StillAlpha5Attacker = SGroup_CreateIfNotFound("sg_StillAlpha5Attacker")
	
	
	t_StillAlpha = {
		{
			phase = 2,
			unit = SBP.CW.TOMMIES,
			count = 3,
			upgrade = UPG.CW.BREN,
			marker = mkr_StillAlphaDest1, 
		},
		{
			phase = 2,
			unit = SBP.CW.TOMMIES,
			count = 3,
			upgrade = UPG.CW.BREN,
			marker = mkr_StillAlphaDest2, 
		},
	}
	
	for i = 1, table.getn(t_StillAlpha) do
		t_StillAlpha[i].sgroup = tsg_StillAlpha[i]
		t_StillAlpha[i].spawn = tmkr_StillAlpha[i]
		t_StillAlpha[i].attacker = tsg_StillAlphaAttacker[i]
	end
	
	StillAlpha_Preset()


end

-- preset any units or events needed before the kickoff
function StillAlpha_Preset()
	-- spawn squads
	-- start enemy behavior
	-- do other cool things
	for k, this in pairs(t_StillAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, this.count)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(StillAlpha_Kickoff) == false then 
		Rule_AddInterval(StillAlpha_Kickoff, 1)
	end

end

-- start the related action
function StillAlpha_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_StillAlpha) do
		--print(SGroup_GetAvgHealth(this.sgroup))
		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)
			if SGroup_TotalMembersCount(this.sgroup) == 1 and Prox_AreSquadsNearMarker(this.sgroup, this.marker, ANY, 5) == false then 
				Cmd_Retreat(this.sgroup, this.marker)
			end
		end	
	end
end


function RetreatAlpha_Init()
	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_RetreatAlpha = Marker_GetTable("mkr_RetreatAlpha%d")
	tsg_RetreatAlpha = SGroup_CreateTable("sg_RetreatAlpha%d", table.getn(tmkr_RetreatAlpha))
	tsg_RetreatAlphaAttacker = SGroup_CreateTable("sg_RetreatAlpha%dAttacker", table.getn(tmkr_RetreatAlpha))
--~ 	sg_RetreatAlpha1Attacker = SGroup_CreateIfNotFound("sg_RetreatAlpha1Attacker")
--~ 	sg_RetreatAlpha2Attacker = SGroup_CreateIfNotFound("sg_RetreatAlpha2Attacker")
--~ 	sg_RetreatAlpha3Attacker = SGroup_CreateIfNotFound("sg_RetreatAlpha3Attacker")
--~ 	sg_RetreatAlpha4Attacker = SGroup_CreateIfNotFound("sg_RetreatAlpha4Attacker")
--~ 	sg_RetreatAlpha5Attacker = SGroup_CreateIfNotFound("sg_RetreatAlpha5Attacker")
	
	
	t_RetreatAlpha = {
		{
			phase = 2,
			unit = SBP.CW.BREN_CARRIER,
			count = 2,
			marker =  mkr_RetreatAlphaDes1, 
			marker2 = mkr_PlayerDelta1, 
		},
		{
			phase = 2,
			unit = SBP.CW.BREN_CARRIER,
			count = 2,
			marker =  mkr_RetreatAlphaDes2, 
			marker2 = mkr_PlayerDelta2, 
		},

	}
	
	for i = 1, table.getn(t_RetreatAlpha) do
		t_RetreatAlpha[i].sgroup = tsg_RetreatAlpha[i]
		t_RetreatAlpha[i].spawn = tmkr_RetreatAlpha[i]
		t_RetreatAlpha[i].attacker = tsg_RetreatAlphaAttacker[i]
	end
	
	RetreatAlpha_Preset()


end

-- preset any units or events needed before the kickoff
function RetreatAlpha_Preset()
	-- spawn squads
	-- start enemy behavior
	-- do other cool things
	for k, this in pairs(t_RetreatAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, this.count)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	
	if Rule_Exists(RetreatAlpha_Kickoff) == false then 
		Rule_AddInterval(RetreatAlpha_Kickoff, 1)
	end

end

-- start the related action
function RetreatAlpha_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_RetreatAlpha) do
		--print(SGroup_GetAvgHealth(this.sgroup))
		if SGroup_TotalMembersCount(this.sgroup) < 4 then
			--this.phase = 5
		end
		if this.phase == 2 then 
			if Prox_ArePlayersNearMarker(player1, this.marker, ANY, 50)  then 
				Cmd_SquadPath(this.sgroup, "pth_RetreatAlpha1", true, false, false, 0)
				this.phase = 3
			end
		end	
		if this.phase == 3 then 
			if Prox_AreSquadsNearMarker(this.sgroup, this.marker2, ANY, 7) and SGroup_GetAvgHealth(this.sgroup) > 0.4 then 
				Cmd_Stop(this.sgroup)
			elseif SGroup_GetAvgHealth(this.sgroup) < 0.41 then 
				Cmd_Move(this.sgroup, mkr_Final2)
			end
		end
		if speech_retreat == nil and SGroup_IsDoingAttack(this.sgroup, ANY, 1) then 
			Util_AutoIntel(t_firstbrencarrier)
			speech_retreat = 1
		end		
	end
end

function AttackAlpha_Init()
	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_AttackAlpha = Marker_GetTable("mkr_AttackAlpha%d")
	tsg_AttackAlpha = SGroup_CreateTable("sg_AttackAlpha%d", table.getn(tmkr_AttackAlpha))
	tsg_AttackAlphaAttacker = SGroup_CreateTable("sg_AttackAlpha%dAttacker", table.getn(tmkr_AttackAlpha))
--~ 	sg_AttackAlpha1Attacker = SGroup_CreateIfNotFound("sg_AttackAlpha1Attacker")
--~ 	sg_AttackAlpha2Attacker = SGroup_CreateIfNotFound("sg_AttackAlpha2Attacker")
--~ 	sg_AttackAlpha3Attacker = SGroup_CreateIfNotFound("sg_AttackAlpha3Attacker")
--~ 	sg_AttackAlpha4Attacker = SGroup_CreateIfNotFound("sg_AttackAlpha4Attacker")
--~ 	sg_AttackAlpha5Attacker = SGroup_CreateIfNotFound("sg_AttackAlpha5Attacker")
	
	
	t_AttackAlpha = {
		{
			phase = 2,
			unit = SBP.CW.TOMMIES,
			count = 2,
			upgrade = UPG.CW.BREN,
			marker =  mkr_AttackAlphaDes1, 
		},
		{
			phase = 2,
			unit = SBP.CW.COMMANDOS,
			count = 2,
			upgrade = UPG.CW.BREN,
			marker =  mkr_AttackAlphaDes2, 
		},
	}
	
	for i = 1, table.getn(t_AttackAlpha) do
		t_AttackAlpha[i].sgroup = tsg_AttackAlpha[i]
		t_AttackAlpha[i].spawn = tmkr_AttackAlpha[i]
		t_AttackAlpha[i].attacker = tsg_AttackAlphaAttacker[i]
	end
	
	AttackAlpha_Preset()


end

-- preset any units or events needed before the kickoff
function AttackAlpha_Preset()
	-- spawn squads
	-- start enemy behavior
	-- do other cool things
	for k, this in pairs(t_AttackAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, this.count)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(AttackAlpha_Kickoff) == false then 
		Rule_AddInterval(AttackAlpha_Kickoff, 1)
	end
end

-- start the related action
function AttackAlpha_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_AttackAlpha) do
		--print(SGroup_GetAvgHealth(this.sgroup))
		if SGroup_TotalMembersCount(this.sgroup) < 4 then
			--this.phase = 5
		end
		if this.phase == 2 then 
			if Prox_ArePlayersNearMarker(player1, this.marker, ANY, 50) then 
				if Prox_AreSquadsNearMarker(this.sgroup, this.marker, ANY, 5) == false then 
					Cmd_Move(this.sgroup, this.marker)
				end				
			end
		end	
	end
end



function CounterAlpha_Init()
	-- define sgroups, egroups, etc associated with this Encounter
	tmkr_CounterAlpha = Marker_GetTable("mkr_CounterAlpha%d")
	tsg_CounterAlpha = SGroup_CreateTable("sg_CounterAlpha%d", table.getn(tmkr_CounterAlpha))
	
	sg_CounterAlpha1Attacker = SGroup_CreateIfNotFound("sg_CounterAlpha1Attacker")
	sg_CounterAlpha2Attacker = SGroup_CreateIfNotFound("sg_CounterAlpha2Attacker")
	sg_CounterAlpha3Attacker = SGroup_CreateIfNotFound("sg_CounterAlpha3Attacker")
	sg_CounterAlpha4Attacker = SGroup_CreateIfNotFound("sg_CounterAlpha4Attacker")
	sg_CounterAlpha5Attacker = SGroup_CreateIfNotFound("sg_CounterAlpha5Attacker")
	
	
	t_CounterAlpha = {
		{
			phase = 2,
			attacker = sg_CounterAlpha1Attacker ,
			depart = mkr_Final1, 
			capture1 = eg_pnt_Heights,
			capture2 = eg_pnt_D1,
			capture3 = eg_pnt_C2,
			capture4 = eg_pnt_D2,
		},
		{
			phase = 2,
			attacker = sg_CounterAlpha2Attacker ,
			depart = mkr_Final1, 
			capture1 = eg_pnt_Heights,
			capture2 = eg_pnt_D1,
			capture3 = eg_pnt_C2,
			capture4 = eg_pnt_D2,
		},
	}
	
	for i = 1, table.getn(t_CounterAlpha) do
		t_CounterAlpha[i].sgroup = tsg_CounterAlpha[i]
		t_CounterAlpha[i].spawn = tmkr_CounterAlpha[i]
	end
	
	CounterAlpha_Preset()
end

-- preset any units or events needed before the kickoff
function CounterAlpha_Preset()
	-- spawn squads
	-- start enemy behavior
	-- do other cool things
	for k, this in pairs(t_CounterAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 3)
		this.phase = 3
	end
	if Rule_Exists(CounterAlpha_Kickoff) == false then 
		Rule_AddInterval(CounterAlpha_Kickoff, 5)
	end

end

-- start the related action
function CounterAlpha_Kickoff()
	-- action that starts when this interval is triggered
	
	for k, this in pairs(t_CounterAlpha) do
		--print(SGroup_GetAvgHealth(this.sgroup))
		if SGroup_TotalMembersCount(this.sgroup) < 3 then
			this.phase = 5
		end
		if this.phase == 2 then 
			if speech_counter == nil and Player_CanSeeSGroup(player1, this.sgroup, ANY) and SGroup_IsDoingAttack(this.sgroup, ANY, 5) then 
				Util_AutoIntel(t_CaptureHeights_counter)
				speech_counter = 1 
			end
			
			if SGroup_Count(sg_AxisHill) > 0 then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_TotalMembersCount(this.sgroup) < SGroup_TotalMembersCount(this.attacker) then 
					Cmd_Ability(this.sgroup, ABILITY.CW.GRENADE_COMMANDO, sg_AxisHill, nil, true)					
					
				else
					
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
					Cmd_AttackMove(this.sgroup, sg_AxisHill)
				end
			elseif SGroup_Count(sg_AxisHill) == 0 and SGroup_IsCapturing(this.sgroup, ANY) == false then
				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				else
					Cmd_Retreat(this.sgroup, Marker_GetPosition(this.depart))	
				end
			end
		end
	end
end

function GliderAlpha_Init()

	tmkr_GliderAlpha = Marker_GetTable("mkr_GliderAlpha%d")
	--tsg_GliderAlpha = SGroup_CreateTable("sg_GliderAlpha%d", table.getn(tmkr_GliderAlpha))
	
	sg_GliderAlpha1 = SGroup_CreateIfNotFound("sg_GliderAlpha1")
	sg_GliderAlpha2 = SGroup_CreateIfNotFound("sg_GliderAlpha2")
	sg_GliderAlpha3 = SGroup_CreateIfNotFound("sg_GliderAlpha3")
	sg_GliderAlpha4 = SGroup_CreateIfNotFound("sg_GliderAlpha4")

	eg_GliderAlpha1 = EGroup_CreateIfNotFound("eg_GliderAlpha1")
	eg_GliderAlpha2 = EGroup_CreateIfNotFound("eg_GliderAlpha2")
	eg_GliderAlpha3 = EGroup_CreateIfNotFound("eg_GliderAlpha3")
	eg_GliderAlpha4 = EGroup_CreateIfNotFound("eg_GliderAlpha4")
	
	sg_GliderAlphaAttacker1 = SGroup_CreateIfNotFound("sg_GliderAlphaAttacker1")
	sg_GliderAlphaAttacker2 = SGroup_CreateIfNotFound("sg_GliderAlphaAttacker2")
	sg_GliderAlphaAttacker3 = SGroup_CreateIfNotFound("sg_GliderAlphaAttacker3")
	sg_GliderAlphaAttacker4 = SGroup_CreateIfNotFound("sg_GliderAlphaAttacker4")
	
	
	t_GliderAlpha = {
		{
			sgroup = sg_GliderAlpha1, 
			egroup = eg_GliderAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GliderAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_GliderSpawnAlpha1, 
			landing = mkr_GliderAlpha1, 			
			attacker = sg_GliderAlphaAttacker1, 

		},
		{
			sgroup = sg_GliderAlpha2, 
			egroup = eg_GliderAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GliderAlpha2", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_GliderSpawnAlpha2,
			landing = mkr_GliderAlpha2,
			attacker = sg_GliderAlphaAttacker2, 

		},
		{
			sgroup = sg_GliderAlpha3, 
			egroup = eg_GliderAlpha3, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_GliderAlpha3", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_GliderSpawnAlpha3,
			landing = mkr_GliderAlpha3,
			attacker = sg_GliderAlphaAttacker3, 

		},
--~ 		{
--~ 			sgroup = sg_GliderAlpha4, 
--~ 			egroup = eg_GliderAlpha4, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_GliderAlpha4", 
--~ 			timer = 10, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = mkr_GliderSpawnAlpha4,
--~ 			landing = mkr_GliderAlpha4,
--~ 			attacker = sg_GliderAlphaAttacker4, 

--~ 		},
		
	}
	GliderAlpha_Preset()
	
end


function GliderAlpha_Preset()
--Spawns the units
	for k, this in pairs(t_GliderAlpha) do
		if EGroup_Count(this.egroup) == 0 then 
			Util_SpawnGlider(player2, EBP.CW.GLIDER_TETRARCH, this.spawn, this.landing, this.sgroup)
			this.phase = 2
		end
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(GliderAlpha_Kickoff) == false then 
		Rule_AddInterval(GliderAlpha_Kickoff, 1)
	end

end

function GliderAlpha_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_GliderAlpha) do		
		if this.phase == 2 then 
			SGroup_GetLastAttacker(this.sgroup, this.attacker)
			if SGroup_Count(sg_AxisTank) > 0 then
				Cmd_AttackMove(this.sgroup, sg_AxisTank) 
			elseif SGroup_Count(sg_AxisAll) > 0 then 
				Cmd_AttackMove(this.sgroup, sg_AxisAll)
			end
		end
	end
end

function FlyerAlpha_Init()

	tmkr_FlyerAlpha = Marker_GetTable("mkr_FlyerAlpha%d")
	--tsg_FlyerAlpha = SGroup_CreateTable("sg_FlyerAlpha%d", table.getn(tmkr_FlyerAlpha))
	
	sg_FlyerAlpha1 = SGroup_CreateIfNotFound("sg_FlyerAlpha1")
	sg_FlyerAlpha2 = SGroup_CreateIfNotFound("sg_FlyerAlpha2")
	sg_FlyerAlpha3 = SGroup_CreateIfNotFound("sg_FlyerAlpha3")
	sg_FlyerAlpha4 = SGroup_CreateIfNotFound("sg_FlyerAlpha4")

	eg_FlyerAlpha1 = EGroup_CreateIfNotFound("eg_FlyerAlpha1")
	eg_FlyerAlpha2 = EGroup_CreateIfNotFound("eg_FlyerAlpha2")
	eg_FlyerAlpha3 = EGroup_CreateIfNotFound("eg_FlyerAlpha3")
	eg_FlyerAlpha4 = EGroup_CreateIfNotFound("eg_FlyerAlpha4")
	
	sg_FlyerAlphaAttacker1 = SGroup_CreateIfNotFound("sg_FlyerAlphaAttacker1")
	sg_FlyerAlphaAttacker2 = SGroup_CreateIfNotFound("sg_FlyerAlphaAttacker2")
	sg_FlyerAlphaAttacker3 = SGroup_CreateIfNotFound("sg_FlyerAlphaAttacker3")
	sg_FlyerAlphaAttacker4 = SGroup_CreateIfNotFound("sg_FlyerAlphaAttacker4")
	
	
	t_FlyerAlpha = {
		{
			sgroup = sg_FlyerAlpha1, 
			egroup = eg_FlyerAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_FlyerAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_FlyerSpawnAlpha1, 
			landing = mkr_FlyerAlpha1, 			
			attacker = sg_FlyerAlphaAttacker1, 
			capture1 = eg_pnt_R2, 
			capture2 = eg_pnt_R1, 
			capture3 = eg_pnt_C3, 
			capture4 = eg_pnt_R3, 

		},
		{
			sgroup = sg_FlyerAlpha2, 
			egroup = eg_FlyerAlpha2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_FlyerAlpha2", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_FlyerSpawnAlpha2,
			landing = mkr_FlyerAlpha2,
			attacker = sg_FlyerAlphaAttacker2, 
			capture1 = eg_pnt_R4, 
			capture2 = eg_pnt_R2, 
			capture3 = eg_pnt_C3, 
			capture4 = eg_pnt_R3, 

		},
--~ 		{
--~ 			sgroup = sg_FlyerAlpha3, 
--~ 			egroup = eg_FlyerAlpha3, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_FlyerAlpha3", 
--~ 			timer = 10, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = mkr_FlyerSpawnAlpha3,
--~ 			landing = mkr_FlyerAlpha3,
--~ 			attacker = sg_FlyerAlphaAttacker3, 
--~ 			capture1 = eg_pnt_C3, 
--~ 			capture2 = eg_pnt_R1, 
--~ 			capture3 = eg_pnt_R2, 
--~ 			capture4 = eg_pnt_R3, 
--~ 		},
--~ 		{
--~ 			sgroup = sg_FlyerAlpha4, 
--~ 			egroup = eg_FlyerAlpha4, 
--~ 			stronghold = eg_blg_StrongHold1,
--~ 			field = eg_pnt_Ally,
--~ 			depart = mkr_Final1,
--~ 			upgrade = false,
--~ 			timername = "tmr_FlyerAlpha4", 
--~ 			timer = 10, 
--~ 			count = 4, 
--~ 			phase = 2,
--~ 			spawn = mkr_FlyerSpawnAlpha4,
--~ 			landing = mkr_FlyerAlpha4,
--~ 			attacker = sg_FlyerAlphaAttacker4, 

--~ 		},
		
	}
	FlyerAlpha_Preset()
	
end


function FlyerAlpha_Preset()
--Spawns the units
	for k, this in pairs(t_FlyerAlpha) do
		if EGroup_Count(this.egroup) == 0 then 
			Util_SpawnGlider(player2, EBP.CW.GLIDER_COMMANDOS, this.spawn, this.landing, this.sgroup)
			this.phase = 2
		end
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end	
	if Rule_Exists(FlyerAlpha_Kickoff) == false then 
		Rule_AddInterval(FlyerAlpha_Kickoff, 1)
	end

end

function FlyerAlpha_Kickoff()
--checks what they need to do after being spawned
	for k, this in pairs(t_FlyerAlpha) do		
		if this.phase == 2 then 
			if SGroup_IsUnderAttack(this.sgroup, ANY, 1) == true then 
				SGroup_GetLastAttacker(this.sgroup, this.attacker)
				if SGroup_Count(this.attacker) > 0 then 
					Cmd_Ability(this.sgroup, ABILITY.CW.SUPPRESSION_BREAK, nil, nil, true)
					if SGroup_TotalMembersCount(this.sgroup) > SGroup_TotalMembersCount(this.attacker) then 
						Cmd_AttackMove(this.sgroup, this.attacker)						
					else
						Cmd_Move(this.sgroup, this.attacker, false, nil, this.attacker, OFFSET_FRONT_RIGHT, 60, true)
					end
				end
			elseif SGroup_IsUnderAttack(this.sgroup, ANY, 1) == false and SGroup_IsCapturing(this.sgroup, ANY) == false then
				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				end
			end
		end
	end
end


function SupplyAlpha_Init()
	tmkr_SupplyAlpha = Marker_GetTable("mkr_SupplyAlpha%d")
	--tsg_SupplyAlpha = SGroup_CreateTable("sg_SupplyAlpha%d", table.getn(tmkr_SupplyAlpha))
	sg_SupplyAlpha1 = SGroup_CreateIfNotFound("sg_SupplyAlpha1")
	sg_SupplyAlpha2 = SGroup_CreateIfNotFound("sg_SupplyAlpha2")
	sg_SupplyAlpha3 = SGroup_CreateIfNotFound("sg_SupplyAlpha3")
	
	sg_SupplyAlphaAttacker1 = SGroup_CreateIfNotFound("sg_SupplyAlphaAttacker1")
	sg_SupplyAlphaAttacker2 = SGroup_CreateIfNotFound("sg_SupplyAlphaAttacker2")
	sg_SupplyAlphaAttacker3 = SGroup_CreateIfNotFound("sg_SupplyAlphaAttacker3")
	
	
	t_SupplyAlpha = {
		{
			sgroup = sg_SupplyAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_SupplyAlpha1", 
			timer = 10, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			capture1 = eg_pnt_Heights, 
			capture2 = eg_pnt_C2, 
			capture3 = eg_pnt_D1, 
			capture4 = eg_pnt_B2, 

		},
	}
	SupplyAlpha_Preset()
end

function SupplyAlpha_Preset()
	for k, this in pairs(t_SupplyAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
		this.phase = 2
		if this.upgrade ~= nil and this.upgrade ~= false then
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
			Cmd_InstantUpgrade(this.sgroup, this.upgrade)
		end
	end
	if Rule_Exists(SupplyAlpha_Kickoff) == false then 
		Rule_AddInterval(SupplyAlpha_Kickoff, 1)
	end
Rule_ChangeInterval(SupplyAlpha_Kickoff, 1)
	
end
  

function SupplyAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  


	
	for k, this in pairs(t_SupplyAlpha) do
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn, nil, nil, 4)
			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			if EGroup_Count(eg_SupplyDrops1) > 0 and g_drop1 == 1 then 
				if EGroup_Count(eg_SupplyDrops1a) == 0 then 
					EGroup_Single(eg_SupplyDrops1a,  EGroup_GetRandomSpawnedEntity(eg_SupplyDrops1))
					this.phase = 3
				else
					this.phase = 3
				end
			elseif  EGroup_Count(eg_SupplyDrops2) > 0 and g_drop2 == 1 then 
				if EGroup_Count(eg_SupplyDrops2a) == 0 then 
					EGroup_Single(eg_SupplyDrops2a,  EGroup_GetRandomSpawnedEntity(eg_SupplyDrops2))
					this.phase = 3
				else
					this.phase = 3
				end
			elseif  EGroup_Count(eg_SupplyDrops3) > 0 and g_drop3 == 1 then 
				if EGroup_Count(eg_SupplyDrops3a) == 0 then 
					EGroup_Single(eg_SupplyDrops3a,  EGroup_GetRandomSpawnedEntity(eg_SupplyDrops3))
					this.phase = 3
				else
					this.phase = 3
				end
			elseif SGroup_IsCapturing(this.sgroup, ANY) == false then 
				if Player_OwnsEGroup(player2, this.capture1) == false then 
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture1) 
				elseif Player_OwnsEGroup(player2, this.capture2) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture2)
				elseif Player_OwnsEGroup(player2, this.capture3) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture3)
				elseif Player_OwnsEGroup(player2, this.capture4) == false then
					Cmd_AttackMoveThenCapture(this.sgroup, this.capture4)
				end
			end
		end
		if this.phase == 3 then 
			if EGroup_Count(eg_SupplyDrops1a) > 0 then 
				Cmd_Move(this.sgroup,  eg_SupplyDrops1a)
				if Prox_EGroupSGroup(eg_SupplyDrops1a, this.sgroup, PROX_SHORTEST) < 10 and Prox_ArePlayersNearMarker(player1, EGroup_GetPosition(eg_SupplyDrops1a), ANY, 30) == false then
					EGroup_DestroyAllEntities(eg_SupplyDrops1a)
					if g_medalfail == nil then 
						Objective_Fail(OBJ_Medal)
						g_medalfail = 1
					end
					this.phase = 2
				elseif Prox_ArePlayersNearMarker(player1, EGroup_GetPosition(eg_SupplyDrops1a), ANY, 30) then 
					Player_GetAllSquadsNearMarker(player1, sg_SupplyAlphaAttacker1, EGroup_GetPosition(eg_SupplyDrops1a), 30) 
					Cmd_AttackMove(this.sgroup, sg_SupplyAlphaAttacker1)
					
				end
			elseif EGroup_Count(eg_SupplyDrops1) == 0 and g_drop1 == 2 then 
					this.phase = 2
					g_drop1 = 3
			elseif EGroup_Count(eg_SupplyDrops2a) > 0 then
				Cmd_Move(this.sgroup,  eg_SupplyDrops2a)
				if Prox_EGroupSGroup(eg_SupplyDrops2a, this.sgroup, PROX_SHORTEST) < 10 and Prox_ArePlayersNearMarker(player1, EGroup_GetPosition(eg_SupplyDrops2a), ANY, 30) == false then
					EGroup_DestroyAllEntities(eg_SupplyDrops2a)
					if g_medalfail == nil then 
						Objective_Fail(OBJ_Medal)
						g_medalfail = 1
					end
					this.phase = 2
				elseif Prox_ArePlayersNearMarker(player1, EGroup_GetPosition(eg_SupplyDrops2a), ANY, 30) then 
					Player_GetAllSquadsNearMarker(player1, sg_SupplyAlphaAttacker2, EGroup_GetPosition(eg_SupplyDrops2a), 30) 
					Cmd_AttackMove(this.sgroup, sg_SupplyAlphaAttacker2)
				end
			elseif EGroup_Count(eg_SupplyDrops2) == 0 and g_drop2 == 2 then 
				this.phase = 2	
				g_drop2 = 3
			elseif EGroup_Count(eg_SupplyDrops3a) > 0 then
				Cmd_Move(this.sgroup,  eg_SupplyDrops3a)
				if Prox_EGroupSGroup(eg_SupplyDrops3a, this.sgroup, PROX_SHORTEST) < 10 and Prox_ArePlayersNearMarker(player1, EGroup_GetPosition(eg_SupplyDrops3a), ANY, 30) == false then
					EGroup_DestroyAllEntities(eg_SupplyDrops3a)
					if g_medalfail == nil then 
						Objective_Fail(OBJ_Medal)
						g_medalfail = 1
					end
					this.phase = 2
				elseif Prox_ArePlayersNearMarker(player1, EGroup_GetPosition(eg_SupplyDrops3a), ANY, 30) then 
					Player_GetAllSquadsNearMarker(player1, sg_SupplyAlphaAttacker3, EGroup_GetPosition(eg_SupplyDrops3a), 30) 
					Cmd_AttackMove(this.sgroup, sg_SupplyAlphaAttacker3)
				end
			elseif EGroup_Count(eg_SupplyDrops3) == 0 and g_drop3 == 2 then 
				this.phase = 2	
				g_drop3 = 3
			end
		end
	end
end


 function ManningAlpha_Init()
	tmkr_ManningAlpha = Marker_GetTable("mkr_ManningAlpha%d")
	--tsg_ManningAlpha = SGroup_CreateTable("sg_ManningAlpha%d", table.getn(tmkr_ManningAlpha))
	sg_ManningAlpha1 = SGroup_CreateIfNotFound("sg_ManningAlpha1")
	sg_ManningAlpha2 = SGroup_CreateIfNotFound("sg_ManningAlpha2")
	eg_PlayerDelta1 = EGroup_CreateIfNotFound("eg_PlayerDelta1")
	eg_PlayerDelta2 = EGroup_CreateIfNotFound("eg_PlayerDelta2")
	t_ManningAlpha = {
		{
			sgroup = sg_ManningAlpha1,
			egroup = eg_PlayerDelta1, 
			unit = SBP.CW.COMMANDOS,
			mount = eg_PlayerDelta1, 
			timername = "tmr_ManningAlpha1", 
			timer = 30, 
			count = 2, 
			phase = 2,
			spawn = mkr_Spawn5,
			final = mkr_Final4, 
		},
		{
			sgroup = sg_ManningAlpha2,
			egroup = eg_PlayerDelta2, 
			unit = SBP.CW.COMMANDOS,
			mount = eg_PlayerDelta2, 
			timername = "tmr_ManningAlpha2", 
			timer = 30, 
			count = 2, 
			phase = 2,
			spawn = mkr_spawngoliath,
			final = mkr_Final1,
		},
		
		
	}
	ManningAlpha_Preset()
end

function ManningAlpha_Preset()
	for k, this in pairs(t_ManningAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, this.count)
		Modify_Vulnerability(this.sgroup, 2)
		this.phase = 2
	end
	if Rule_Exists(ManningAlpha_Kickoff) == false then 
		Rule_AddInterval(ManningAlpha_Kickoff, 1)
	end
	
end
  
function ManningAlpha_Kickoff()
	World_GetNeutralEntitiesNearMarker(eg_PlayerDelta1, mkr_PlayerDelta1)
	EGroup_Filter(eg_PlayerDelta1, {EBP.PICKUP.AXIS.HMG}, FILTER_KEEP) 
	World_GetNeutralEntitiesNearMarker(eg_PlayerDelta2, mkr_PlayerDelta2)
	EGroup_Filter(eg_PlayerDelta2, {EBP.PICKUP.AXIS.HMG}, FILTER_KEEP) 
	
	for k, this in pairs(t_ManningAlpha) do
		
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and EGroup_Count(this.mount) > 0 and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, this.count)

			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			if EGroup_Count(eg_blg_Bridge) > 0 then
				if EGroup_Count(this.egroup) > 0 then  
					Cmd_CaptureTeamWeapon(this.sgroup, this.egroup)
					this.phase = 3
				else
					Cmd_Move(this.sgroup, mkr_Final4)
				end
			else 
				Cmd_Retreat(this.sgroup, mkr_Final1)
				Rule_RemoveMe()
			end
		end
		if this.phase == 3 then 
			if EGroup_Count(eg_blg_Bridge) > 0 then
				if EGroup_Count(this.egroup) == 0 then  
					Cmd_Move(this.sgroup, mkr_Final2)
				end
			else 
				Cmd_Retreat(this.sgroup, mkr_Final1)
				Rule_RemoveMe()
			end
		end
	end
end
 

function DontEnterAlpha_Init()
	tmkr_DontEnterAlpha = Marker_GetTable("mkr_DontEnterAlpha%d")
	--tsg_DontEnterAlpha = SGroup_CreateTable("sg_DontEnterAlpha%d", table.getn(tmkr_DontEnterAlpha))
	sg_DontEnterAlpha1 = SGroup_CreateIfNotFound("sg_DontEnterAlpha1")
	sg_DontEnterAlpha2 = SGroup_CreateIfNotFound("sg_DontEnterAlpha2")
	sg_DontEnterAlpha3 = SGroup_CreateIfNotFound("sg_DontEnterAlpha3")
	
	sg_DontEnterAlphaAttacker1 = SGroup_CreateIfNotFound("sg_DontEnterAlphaAttacker1")
	sg_DontEnterAlphaAttacker2 = SGroup_CreateIfNotFound("sg_DontEnterAlphaAttacker2")
	sg_DontEnterAlphaAttacker3 = SGroup_CreateIfNotFound("sg_DontEnterAlphaAttacker3")
	
	
	t_DontEnterAlpha = {
		{
			sgroup = sg_DontEnterAlpha1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_DontEnterAlpha1", 
			timer = 4, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			attacker = sg_DontEnterAlphaAttacker1, 

		},
	}
	DontEnterAlpha_Preset()
end

function DontEnterAlpha_Preset()
	for k, this in pairs(t_DontEnterAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn)
		Modify_ReceivedAccuracy(this.sgroup, 0.3)
		Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
		this.phase = 2
	end
	if Rule_Exists(DontEnterAlpha_Kickoff) == false then 
		Rule_AddInterval(DontEnterAlpha_Kickoff, 1)
	end
	
	
end
  

function DontEnterAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_DontEnterAlpha) do
		
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.COMMANDOS, this.spawn)
			Cmd_InstantUpgrade(this.sgroup, UPG.ALLIES.PARATROOPER_AT)
			Modify_ReceivedAccuracy(this.sgroup, 0.3)
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		
		if this.phase == 2 then 
			Player_GetAllSquadsNearMarker(player1, sg_DontEnterAlphaAttacker1, mkr_Oosterbeek)
			if SGroup_Count(sg_DontEnterAlphaAttacker1) > 0 then 
				Cmd_AttackMove(this.sgroup,	sg_DontEnterAlphaAttacker1)
			end
		end
	end
end
function TravelAlpha_Init()
	tmkr_TravelAlpha = Marker_GetTable("mkr_TravelAlpha%d")
	--tsg_TravelAlpha = SGroup_CreateTable("sg_TravelAlpha%d", table.getn(tmkr_TravelAlpha))
	sg_TravelAlpha1 = SGroup_CreateIfNotFound("sg_TravelAlpha1")
	sg_TravelAlpha2 = SGroup_CreateIfNotFound("sg_TravelAlpha2")
	sg_TravelAlphaCarry1 = SGroup_CreateIfNotFound("sg_TravelAlphaCarry1")
	sg_TravelAlphaCarry2 = SGroup_CreateIfNotFound("sg_TravelAlphaCarry2")
	sg_TravelAlphaAttacker1 = SGroup_CreateIfNotFound("sg_TravelAlphaAttacker1")
	sg_TravelAlphaAttacker2 = SGroup_CreateIfNotFound("sg_TravelAlphaAttacker2")

	t_TravelAlpha = {
		{
			sgroup = sg_TravelAlpha1, 
			sgroup2 = sg_TravelAlphaCarry1, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_TravelAlpha1", 
			timer = 90, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn2,
			attacker = sg_TravelAlphaAttacker1, 
			path = "pth_Travel1", 
		},
		{
			sgroup = sg_TravelAlpha2, 
			sgroup = sg_TravelAlphaCarry2, 
			stronghold = eg_blg_StrongHold1,
			field = eg_pnt_Ally,
			depart = mkr_Final1,
			upgrade = false,
			timername = "tmr_TravelAlpha2", 
			timer = 90, 
			count = 4, 
			phase = 2,
			spawn = mkr_Spawn1,
			attacker = sg_TravelAlphaAttacker2, 
			path = "pth_Travel2", 
		},

	}
	TravelAlpha_Preset()
end

function TravelAlpha_Preset()
	for k, this in pairs(t_TravelAlpha) do
		Util_CreateSquads(player2, this.sgroup, SBP.CW.BREN_CARRIER, this.spawn)
		Util_CreateSquads(player2, this.sgroup2, SBP.CW.BREN_CARRIER, this.sgroup, nil, 1, 3)
		this.phase = 2
		local panzerrand = World_GetRand(1, 2)
		if  panzerrand== 1 then 
			Cmd_InstantUpgrade(this.sgroup, UPG.CW.BREN_CARRIER_MMG)
		end
		if  panzerrand== 2 then 
			
		end		
	end
	if Rule_Exists(TravelAlpha_Kickoff) == false then 
		Rule_AddInterval(TravelAlpha_Kickoff, 1)
	end
	
end



function TravelAlpha_Kickoff()
--reacrates after a certain time of death and captures the points across the line.  
	
	for k, this in pairs(t_TravelAlpha) do
	
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and Player_OwnsEGroup(player2, this.stronghold) and Player_OwnsEGroup(player2, this.field) and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, SBP.CW.BREN_CARRIER, this.spawn)
			Util_CreateSquads(player2, this.sgroup2, SBP.CW.BREN_CARRIER, this.sgroup, nil, 1, 3)
			local panzerrand = World_GetRand(1, 2)
			if  panzerrand== 1 then 
				Cmd_InstantUpgrade(this.sgroup, UPG.CW.BREN_CARRIER_MMG)
			end
			if  panzerrand== 2 then 
				
			end		
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			Cmd_SquadPath(this.sgroup, this.path, true, false, false, 0)
		end
	end
end
 function InterfereAlpha_Init()
	tmkr_InterfereAlpha = Marker_GetTable("mkr_InterfereAlpha%d")
	--tsg_InterfereAlpha = SGroup_CreateTable("sg_InterfereAlpha%d", table.getn(tmkr_InterfereAlpha))
	sg_InterfereAlpha1 = SGroup_CreateIfNotFound("sg_InterfereAlpha1")
	sg_InterfereAlpha2 = SGroup_CreateIfNotFound("sg_InterfereAlpha2")
	eg_PlayerDelta1 = EGroup_CreateIfNotFound("eg_PlayerDelta1")
	eg_PlayerDelta2 = EGroup_CreateIfNotFound("eg_PlayerDelta2")
	t_InterfereAlpha = {
		{
			sgroup = sg_InterfereAlpha1, 
			unit = SBP.CW.COMMANDOS,
			timername = "tmr_InterfereAlpha1", 
			timer = 80, 
			count = 4, 
			phase = 2,
			spawn = mkr_spawngoliath,
			final = mkr_Final4, 
		},
--~ 		{
--~ 			sgroup = sg_InterfereAlpha2,
--~ 			egroup = eg_PlayerDelta2, 
--~ 			unit = SBP.CW.COMMANDOS,
--~ 			mount = eg_PlayerDelta2, 
--~ 			timername = "tmr_InterfereAlpha2", 
--~ 			timer = 30, 
--~ 			count = 2, 
--~ 			phase = 2,
--~ 			spawn = mkr_spawngoliath,
--~ 			final = mkr_Final1,
--~ 		},
		
		
	}
	InterfereAlpha_Preset()
end

function InterfereAlpha_Preset()
	for k, this in pairs(t_InterfereAlpha) do
		Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, this.count)
		this.phase = 2
	end
	if Rule_Exists(InterfereAlpha_Kickoff) == false then 
		Rule_AddInterval(InterfereAlpha_Kickoff, 1)
	end
	
end
  
function InterfereAlpha_Kickoff()

	for k, this in pairs(t_InterfereAlpha) do
		
		if SGroup_TotalMembersCount(this.sgroup) == 0 and this.phase == 0 then 
			Timer_Start(this.timername, this.timer)
			this.phase = 1
		end 
		if SGroup_TotalMembersCount(this.sgroup) == 0 and Timer_GetRemaining(this.timername) == 0 and this.phase == 1 then		
			Util_CreateSquads(player2, this.sgroup, this.unit, this.spawn, nil, nil, this.count)

			if upgrade ~= nil and upgrade ~= false then
				Cmd_InstantUpgrade(this.sgroup, upgrade)
			end
			this.timer = this.timer 
			this.phase = 2
		end 
		if SGroup_CountSpawned(this.sgroup) == 0 and this.phase ~= 1 then 
			this.phase = 0
		end
		if this.phase == 2 then 
			if  EGroup_Count(eg_blg_Bridge) > 0  then 
				if SGroup_Count(this.sgroup) > 0 then 
					if SGroup_Count(sg_AxisAll) > 0 then
						Cmd_AttackMove(this.sgroup, sg_AxisAll)
					else 
						Cmd_AttackMove(this.sgroup, mkr_PlayerBeta2)
					end
				end
			else
				Rule_RemoveMe()
			end
		end
	end
end
 

function EngineerBuilding_Init()
	
	tmkr_eb = Marker_GetTable("mkr_ambush_eb%d")
	
	t_Priest = {
		idx = 1
	}
	t_Priest.squads = {}
	
	for i=1, table.getn(tmkr_eb) do
		t_Priest.squads[i] = {
			sgroup 			= SGroup_CreateIfNotFound("sg_Howie_build"..i),
			egroup			= EGroup_CreateIfNotFound("eg_Howie_build"..i),
			sbp 			= SBP.CW.SAPPER,
			upg 			= {},
			mkr 			= tmkr_eb[i],
			ebp 			= EBP.CW.HOWITZER_NEST,
			fg_spawned		= false,
			mkr_retreat		= mkr_Final1,
			egroup2  		= EGroup_CreateIfNotFound("eg_Howie_temp"..i),
			sgroup2			= SGroup_CreateIfNotFound("sg_Howie_temp"..i),
		}
--~ 		if Marker_Exists("mkr_eb_barb"..i.."_1", "") then
--~ 			this = t_Priest.squads[i]
--~ 			this.mkr_start = Marker_FromName("mkr_eb_barb"..i.."_1", "")
--~ 			--this.mkr_end = Marker_FromName("mkr_eb_barb"..i.."_2", "")
--~ 			this.sbp = SBP.CW.SAPPER
--~ 			this.ebp = EBP.CW.BARBED_WIRE
--~ 		end
		EngineerBuilding_Kickoff()
		 
	end

end

function EngineerBuilding_Kickoff()
	if Rule_Exists(EB_CheckProx) == false then 
		Rule_AddInterval(EB_CheckProx, 2.5)
	end

end


function EB_CheckProx()









	for k, this in pairs(t_Priest.squads) do
		
		if EGroup_IsEmpty(this.egroup) then

			EGroup_Clear(this.egroup2)
			Player_GetAllEntitiesNearMarker(player2, this.egroup2, this.mkr, 15)
			
			-- since slit trenches are not owned until manned, make sure that we include those as well
			World_GetEntitiesNearMarker(player2, this.egroup2, this.mkr, OT_Neutral) 
			
			-- filter out for the appropriate building being constructed
			EGroup_Filter(this.egroup2, EBP.CW.HOWITZER_NEST, FILTER_KEEP)
			EGroup_FilterUnderConstruction(this.egroup2, FILTER_REMOVE)
			EGroup_Clear(this.egroup)
			EGroup_AddEGroup(this.egroup, this.egroup2)
			--Modify_Vulnerability(this.egroup2, 5)
			
		end
		if Player_OwnsEGroup(player2, this.egroup) == true then 
			FOW_RevealArea(Marker_GetPosition(this.mkr), 20, 10)
			g_howiebuilt = 1
			if SGroup_Count(sg_AxisAll) > 0 then 
				if ( Util_GetPlayerOwner(this.egroup) ~= nil ) then
					Cmd_Ability(this.egroup, ABILITY.CW.PDR_25_BARRAGE, Util_GetClosestSquadPosition(sg_AxisAll, this.egroup), nil, true)
				end
				
			end
		end
		if SGroup_IsEmpty(this.sgroup) then
			if this.fg_spawned == false then
	
 				Player_GetAllSquadsNearMarker(player1, this.sgroup2, this.mkr, 150)
--~ 			--	Player_GetAllSquadsNearMarker(player1, this.sgroup3, this.mkr_start, 5)
				if SGroup_IsEmpty(this.sgroup2) == false or g_artystart == 1 then
--~ 					
					local pos = Util_GetOffsetPosition(this.mkr, OFFSET_BACK, 40)
					pos = World_GetHiddenPositionOnPath(player1, pos, Util_GetPosition(this.mkr), CHECK_OFFCAMERA)
					
					if pos == nil then
						pos = mkr_Spawn3
					end
					Util_CreateSquads(player2, this.sgroup, this.sbp, pos)
					this.fg_spawned = true
				end
			end
			
		elseif EGroup_IsEmpty(this.egroup) == false and SGroup_IsConstructingBuilding(this.sgroup, ANY) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_TotalMembersCount(this.sgroup) > 0 and SGroup_IsMoving(this.sgroup, ANY) == false then 
			Cmd_Retreat(this.sgroup, mkr_Final1)
	
			
		elseif not SGroup_IsMoving(this.sgroup, ANY)
		and not SGroup_IsConstructingBuilding(this.sgroup, ANY) then
			
			if this.mkr_end == nil then

				Cmd_Construct(this.sgroup, EBP.CW.HOWITZER_NEST, this.mkr)
			else
				-- construct a fence or barbed wire
				--Command_PlayerSquadConstructFence(player2, this.sgroup, this.ebp, Util_GetPosition(this.mkr_start), Util_GetPosition(this.mkr_end), false)
			end
		end
		
	end

end


-- this is an encounter or a set of encounters that is triggered if the player enters an area
-- and finds some sappers building emplacements at a location
function EngineerBuilding_Init2()
	tmkr_Trench = Marker_GetTable("mkr_Trench%d")
	
	
	t_Trench = {
		idx = 1
	}
	t_Trench.squads = {}
	
	for i=1, table.getn(tmkr_Trench) do
		t_Trench.squads[i] = {
			sgroup 			= SGroup_CreateIfNotFound("sg_Trench_build"..i),
			egroup			= EGroup_CreateIfNotFound("eg_Trench_build"..i),
			sbp 			= SBP.CW.COMMANDOS,
			upg 			= {},
			mkr 			= tmkr_Trench[i],
			ebp 			= EBP.CW.SLITTRENCH_NEST,
			fg_spawned		= false,
			mkr_retreat		= mkr_Final1,
			egroup2  		= EGroup_CreateIfNotFound("eg_Trench_temp"..i),
			sgroup2			= SGroup_CreateIfNotFound("sg_Trench_temp"..i),
		}
		if Marker_Exists("mkr_Trench_barb"..i.."_1", "") then
			this = t_Trench.squads[i]
			this.mkr_start = Marker_FromName("mkr_Trench_barb"..i.."_1", "")
			--this.mkr_end = Marker_FromName("mkr_eb_barb"..i.."_2", "")
			this.sbp = SBP.CW.SAPPER
			this.ebp = EBP.CW.BARBED_WIRE
		end
		EngineerBuilding_Kickoff2()
		 
	end

end

function EngineerBuilding_Kickoff2()
	if Rule_Exists(EB_CheckProx2) == false then 
		Rule_AddInterval(EB_CheckProx2, 2.5)
	end

end


function EB_CheckProx2()


	for k, this in pairs(t_Trench.squads) do
		
		if EGroup_IsEmpty(this.egroup) then

			EGroup_Clear(this.egroup2)
			Player_GetAllEntitiesNearMarker(player2, this.egroup2, this.mkr, 15)
			
			-- since slit trenches are not owned until manned, make sure that we include those as well
			World_GetEntitiesNearMarker(player2, this.egroup2, this.mkr, OT_Neutral) 
			
			-- filter out for the appropriate building being constructed
			EGroup_Filter(this.egroup2, EBP.CW.SLITTRENCH_NEST, FILTER_KEEP)
			EGroup_FilterUnderConstruction(this.egroup2, FILTER_REMOVE)
			EGroup_Clear(this.egroup)
			EGroup_AddEGroup(this.egroup, this.egroup2)
			
		end
		
		if SGroup_IsEmpty(this.sgroup) then
			if this.fg_spawned == false then
	
				Player_GetAllSquadsNearMarker(player1, this.sgroup2, this.mkr_start, 60)
				if SGroup_IsEmpty(this.sgroup2) == false then
					
					local pos = Util_GetOffsetPosition(this.mkr, OFFSET_BACK, 40)
					pos = World_GetHiddenPositionOnPath(player1, pos, Util_GetPosition(this.mkr), CHECK_OFFCAMERA)
					
					if pos == nil then
						pos = this.mkr
					end
					Util_CreateSquads(player2, this.sgroup, this.sbp, pos)
					this.fg_spawned = true
				end
			else
				table.remove(t_Trench.squads, k)
			end
			
		elseif EGroup_IsEmpty(this.egroup) == false and SGroup_IsConstructingBuilding(this.sgroup, ANY) == false and SGroup_IsInHoldEntity(this.sgroup, ANY) == false and SGroup_TotalMembersCount(this.sgroup) > 0 and SGroup_IsMoving(this.sgroup, ANY) == false then 
			Cmd_Garrison(this.sgroup, this.egroup)
--~ 			else
--~ 				Cmd_Retreat(this.sgroup, this.mkr_retreat)
			
		elseif not SGroup_IsMoving(this.sgroup, ANY)
		and not SGroup_IsConstructingBuilding(this.sgroup, ANY) then
			
			if this.mkr_end == nil then
				Cmd_Construct(this.sgroup, EBP.CW.SLITTRENCH_NEST, this.mkr)
			else
				-- construct a fence or barbed wire
				--Command_PlayerSquadConstructFence(player2, this.sgroup, this.ebp, Util_GetPosition(this.mkr_start), Util_GetPosition(this.mkr_end), false)
			end
		end
				
	end

end

function Remove_NadeUI()
	UI_StopFlashing(nadeUI1)
	UI_StopFlashing(nadeUI2)
end
---------------------------------------------------------------------------------------------------------------------------
-- Misc functions
-- functions that do have anything to do with spawning units
---------------------------------------------------------------------------------------------------------------------------
--this function gathers the units and puts them into sgroup names for reference. 
--this creates the ability to create a tanks specifically or a sniper etc.. 

-- puts sgroup names to guys being in the sectors
function Misc_GrabTerritory()
	sectorIDR1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_R1))
	sectorIDR2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_R2))
	sectorIDR3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_R3))
	sectorIDR4 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_R4))
	sectorIDHeights = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_Heights))
	sectorIDB1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_B1))
	sectorIDB2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_B2))
	sectorIDB3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_B3))

	sectorIDC1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_C1))
	sectorIDC2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_C2))
	sectorIDC3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_C3))
	sectorIDC4 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_C4))
	sectorIDD1 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_D1))
	sectorIDD2 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_D2))
	sectorIDD3 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_D3))
	sectorIDD4 = World_GetTerritorySectorID(EGroup_GetPosition(eg_pnt_D4))
	
	sg_AllyR1 = SGroup_CreateIfNotFound("sg_AllyR1")
	sg_AllyR2 = SGroup_CreateIfNotFound("sg_AllyR2")
	sg_AllyR3 = SGroup_CreateIfNotFound("sg_AllyR3")
	sg_AllyR4 = SGroup_CreateIfNotFound("sg_AllyR4")
	sg_AllyHeights = SGroup_CreateIfNotFound("sg_AllyHeights")
	sg_AllyAll = SGroup_CreateIfNotFound("sg_AllyAll")
	sg_AllyInfantry = SGroup_CreateIfNotFound("sg_AllyInfantry")
	sg_AllyTanks = SGroup_CreateIfNotFound("sg_AllyTanks")
	sg_AllyBridge = SGroup_CreateIfNotFound("sg_AllyBridge")
	
	sg_AxisR1 = SGroup_CreateIfNotFound("sg_AxisR1")
	sg_AxisR2 = SGroup_CreateIfNotFound("sg_AxisR2")
	sg_AxisR3 = SGroup_CreateIfNotFound("sg_AxisR3")
	sg_AxisR4 = SGroup_CreateIfNotFound("sg_AxisR4")
	sg_AxisB1 = SGroup_CreateIfNotFound("sg_AxisB1")
	sg_AxisB2 = SGroup_CreateIfNotFound("sg_AxisB2")
	sg_AxisB3 = SGroup_CreateIfNotFound("sg_AxisB3")
	sg_AxisB4 = SGroup_CreateIfNotFound("sg_AxisB4")
	sg_AxisC1 = SGroup_CreateIfNotFound("sg_AxisC1")
	sg_AxisC2 = SGroup_CreateIfNotFound("sg_AxisC2")
	sg_AxisC3 = SGroup_CreateIfNotFound("sg_AxisC3")
	sg_AxisC4 = SGroup_CreateIfNotFound("sg_AxisC4")
	sg_AxisD1 = SGroup_CreateIfNotFound("sg_AxisD1")
	sg_AxisD2 = SGroup_CreateIfNotFound("sg_AxisD2")
	sg_AxisD3 = SGroup_CreateIfNotFound("sg_AxisD3")
	sg_AxisD4 = SGroup_CreateIfNotFound("sg_AxisD4")
	
	
	sg_AxisBeacon2 = SGroup_CreateIfNotFound("sg_AxisBeacon2")
	sg_AxisAll = SGroup_CreateIfNotFound("sg_AxisAll")
	sg_AxisBridge = SGroup_CreateIfNotFound("sg_AxisBridge")
	sg_AxisHill = SGroup_CreateIfNotFound("sg_AxisHill")
	
	sg_AxisInfantry = SGroup_CreateIfNotFound("sg_AxisInfantry")
	sg_AxisTank = SGroup_CreateIfNotFound("sg_AxisTank")
	
	sg_AxisGoliath = SGroup_CreateIfNotFound("sg_AxisGoliath")
	sg_AxisHalftrack = SGroup_CreateIfNotFound("sg_AxisHalftrack")
	sg_AxisMunitionHalftrack = SGroup_CreateIfNotFound("sg_AxisMunitionHalftrack")
	
	eg_AxisR1 = EGroup_CreateIfNotFound("eg_AxisR1")
	eg_AxisR2 = EGroup_CreateIfNotFound("eg_AxisR2")
	eg_AxisR3 = EGroup_CreateIfNotFound("eg_AxisR3")
	eg_AxisR4 = EGroup_CreateIfNotFound("eg_AxisR4")
	eg_AxisAll = EGroup_CreateIfNotFound("eg_AxisAll")
	

	
	
	Rule_AddInterval(Misc_GatherUnit, 1)
	Rule_AddInterval(Misc_GatherEgroup, 1)
end
function Misc_GatherUnit()
	Player_GetAll(player1, sg_AxisAll)
	SGroup_Filter(sg_AxisAll, {SBP.ELITE.FLAK_38}, FILTER_REMOVE)
	
	Player_GetAll(player1, sg_AxisInfantry)		
	SGroup_Filter(sg_AxisInfantry, {SBP.ELITE.FALLSCHIRMJAGER, SBP.ELITE.LUFTWAFFE, SBP.ELITE.PANZERGRENADIER}, FILTER_KEEP) 
	
	Player_GetAll(player1, sg_AxisTank)
	--SGroup_FilterUnderConstruction(sg_AxisTank, FILTER_REMOVE)
	SGroup_Filter(sg_AxisTank, {SBP.ELITE.WIRBLEWIND, SBP.ELITE.FLAK_38, SBP.ELITE.ARMOURCAR_221, SBP.ELITE.ARMOURCAR_222, SBP.ELITE.ARMOURCAR_223, SBP.ELITE.HALFTRACK_250, SBP.ELITE.HALFTRACK_251, SBP.ELITE.HALFTRACK_MORTAR, SBP.ELITE.HALFTRACK_SNIPER, SBP.ELITE.HALFTRACK_VAMPIRE}, FILTER_KEEP) 
	
	Player_GetAll(player1, sg_AxisGoliath)
	SGroup_Filter(sg_AxisGoliath, {SBP.ELITE.GOLIATH}, FILTER_KEEP) 
	
	Player_GetAll(player1, sg_AxisHalftrack)
	SGroup_Filter(sg_AxisHalftrack, {SBP.ELITE.ARMOURCAR_221, SBP.ELITE.ARMOURCAR_222, SBP.ELITE.ARMOURCAR_223, SBP.ELITE.HALFTRACK_250, SBP.ELITE.HALFTRACK_251, SBP.ELITE.HALFTRACK_MORTAR, SBP.ELITE.HALFTRACK_SNIPER, SBP.ELITE.HALFTRACK_VAMPIRE}, FILTER_KEEP) 
	
	Player_GetAll(player1, sg_AxisMunitionHalftrack)
	SGroup_Filter(sg_AxisMunitionHalftrack, {SBP.ELITE.HALFTRACK_251}, FILTER_KEEP) 
	
	
	Player_GetAllSquadsNearMarker(player1, sg_AxisBridge, mkr_Bridge)
	Player_GetAllSquadsNearMarker(player1, sg_AxisHill, mkr_Hill)
	Player_GetAllSquadsNearMarker(player1, sg_AxisR1, sectorIDR1)
	Player_GetAllSquadsNearMarker(player1, sg_AxisR2, sectorIDR2)
	Player_GetAllSquadsNearMarker(player1, sg_AxisR3, sectorIDR3)
	Player_GetAllSquadsNearMarker(player1, sg_AxisR4, sectorIDR4)
	Player_GetAllSquadsNearMarker(player1, sg_AxisC1, sectorIDC1)
	Player_GetAllSquadsNearMarker(player1, sg_AxisC2, sectorIDC2)
	Player_GetAllSquadsNearMarker(player1, sg_AxisC3, sectorIDC3)
	Player_GetAllSquadsNearMarker(player1, sg_AxisC4, sectorIDC4)
	Player_GetAllSquadsNearMarker(player1, sg_AxisD1, sectorIDD1)
	Player_GetAllSquadsNearMarker(player1, sg_AxisD2, sectorIDD2)
	Player_GetAllSquadsNearMarker(player1, sg_AxisD3, sectorIDD3)
	Player_GetAllSquadsNearMarker(player1, sg_AxisD4, sectorIDD4)
	Player_GetAllSquadsNearMarker(player1, sg_AxisB1, sectorIDB1)
	Player_GetAllSquadsNearMarker(player1, sg_AxisB2, sectorIDB2)
	Player_GetAllSquadsNearMarker(player1, sg_AxisB3, sectorIDB3)
	Player_GetAllSquadsNearMarker(player1, sg_AxisB4, sectorIDB4)
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	
	Player_GetAllSquadsNearMarker(player2, sg_AllyR1, sectorIDR1)
	Player_GetAllSquadsNearMarker(player2, sg_AllyR2, sectorIDR2)
	Player_GetAllSquadsNearMarker(player2, sg_AllyR3, sectorIDR3)
	Player_GetAllSquadsNearMarker(player2, sg_AllyR4, sectorIDR4)
	Player_GetAllSquadsNearMarker(player2, sg_AllyHeights, sectorIDHeights)
	Player_GetAllSquadsNearMarker(player2, sg_AllyBridge, mkr_Bridge)
	
	
	Player_GetAll(player2, sg_AllyInfantry)		
	SGroup_Filter(sg_AllyInfantry, {SBP.CW.COMMANDOS, SBP.CW.COMMANDOS_MG, SBP.CW.COMMANDOS_MORTAR, SBP.CW.COMMANDOS_PIAT, SBP.CW.TOMMIES}, FILTER_KEEP) 
	
	Player_GetAll(player2, sg_AllyAll)
	
	Player_GetAll(player2, sg_AllyTanks)
	SGroup_Filter(sg_AllyTanks, {SBP.CW.TETRARCH}, FILTER_KEEP)
	
end

function Misc_GatherEgroup()
	Player_GetAllEntitiesNearMarker(player1, eg_AxisR1, EGroup_GetPosition(eg_pnt_R1), 30)
	Player_GetAllEntitiesNearMarker(player1, eg_AxisR2, EGroup_GetPosition(eg_pnt_R2), 30)
	Player_GetAllEntitiesNearMarker(player1, eg_AxisR3, EGroup_GetPosition(eg_pnt_R3), 30)
	Player_GetAllEntitiesNearMarker(player1, eg_AxisR4, EGroup_GetPosition(eg_pnt_R4), 30)
	
	Player_GetAllEntitiesNearMarker(player1, eg_AxisAll, mkr_AllMap)


end	

--Destroys everybody that enters the exit
function Misc_DestroyAllSquads()
	sg_tempDestroy1 = SGroup_CreateIfNotFound("sg_tempDestroy1")
	Player_GetAllSquadsNearMarker(player2, sg_tempDestroy1, mkr_Final1)
	sg_tempDestroy2 = SGroup_CreateIfNotFound("sg_tempDestroy2")
	Player_GetAllSquadsNearMarker(player2, sg_tempDestroy2, mkr_Final2)
	sg_tempDestroy3 = SGroup_CreateIfNotFound("sg_tempDestroy3")
	Player_GetAllSquadsNearMarker(player2, sg_tempDestroy3, mkr_Final4)
	if SGroup_Count(sg_tempDestroy1) > 0 then
		SGroup_DestroyAllSquads(sg_tempDestroy1)
	end
	if SGroup_Count(sg_tempDestroy2) > 0 then
		SGroup_DestroyAllSquads(sg_tempDestroy2)
	end
	if SGroup_Count(sg_tempDestroy3) > 0 then
		SGroup_DestroyAllSquads(sg_tempDestroy3)
	end
end

function Bombing_Form1()
	if v_form1 == 0 then 
		Timer_Start("tmr_Strafing1", 10)
		
		v_form1 = 1
	end
	if v_form1 == 1 and Timer_GetRemaining("tmr_Strafing1") == 9 then 
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_RECON, Marker_GetPosition(mkr_Form4), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form1 == 1 and Timer_GetRemaining("tmr_Strafing1") == 7 then 
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form5), Marker_GetDirection(mkr_ATGunAlpha2), true)
		--Cmd_Ability(player2, ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form3), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form1 == 1 and Timer_GetRemaining("tmr_Strafing1") == 5 then 
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_RECON, Marker_GetPosition(mkr_Form6), Marker_GetDirection(mkr_ATGunAlpha2), true)
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form2), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form1 == 1 and Timer_GetRemaining("tmr_Strafing1") == 3 then 
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET , Marker_GetPosition(mkr_Form7), Marker_GetDirection(mkr_ATGunAlpha2), true)
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_RECON,   Marker_GetPosition(mkr_Form1), Marker_GetDirection(mkr_ATGunAlpha2), true)
		v_form1 = 0
		Rule_RemoveMe()
	end

end
function Bombing_Form2()
	if v_form2 == 0 then 
		Timer_Start("tmr_Strafing2", 10)
		
		v_form2 = 1
	end
	if v_form2 == 1 and Timer_GetRemaining("tmr_Strafing2") == 9 then 
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_RECON, Marker_GetPosition(mkr_Form4a), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form2 == 1 and Timer_GetRemaining("tmr_Strafing2") == 7 then 
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form5a), Marker_GetDirection(mkr_ATGunAlpha2), true)
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form3a), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form2 == 1 and Timer_GetRemaining("tmr_Strafing2") == 5 then 
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form6a), Marker_GetDirection(mkr_ATGunAlpha2), true)
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form2a), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form2 == 1 and Timer_GetRemaining("tmr_Strafing2") == 3 then 
		--Cmd_Ability(player2,  ABILITY.SP.CAEN_RECON_RUN, Marker_GetPosition(mkr_Form7a), Marker_GetDirection(mkr_ATGunAlpha2), true)
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form1a), Marker_GetDirection(mkr_ATGunAlpha2), true)
		v_form2 = 0
		Rule_RemoveMe()
	end

end
function Bombing_Form3()
	if v_form3 == 0 then 
		Timer_Start("tmr_Strafing3", 10)
		
		v_form3 = 1
	end
	if v_form3 == 1 and Timer_GetRemaining("tmr_Strafing3") == 9 then 
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_RECON, Marker_GetPosition(mkr_Form4b), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form3 == 1 and Timer_GetRemaining("tmr_Strafing3") == 7 then 
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form5b), Marker_GetDirection(mkr_ATGunAlpha2), true)
		--Cmd_Ability(player2,  ABILITY.SP.CAEN_RECON_RUN, Marker_GetPosition(mkr_Form3b), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form3 == 1 and Timer_GetRemaining("tmr_Strafing3") == 5 then 
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_RECON, Marker_GetPosition(mkr_Form6b), Marker_GetDirection(mkr_ATGunAlpha2), true)
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form2b), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form3 == 1 and Timer_GetRemaining("tmr_Strafing3") == 3 then 
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form7b), Marker_GetDirection(mkr_ATGunAlpha2), true)
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form1b), Marker_GetDirection(mkr_ATGunAlpha2), true)
		v_form3 = 0
		Rule_RemoveMe()
	end

end
function Bombing_Form4()
	if v_form4 == 0 then 
		Timer_Start("tmr_Strafing4", 10)
		
		v_form4 = 1
	end
	if v_form4 == 1 and Timer_GetRemaining("tmr_Strafing4") == 9 then 
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_RECON, Marker_GetPosition(mkr_Form4c), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form4 == 1 and Timer_GetRemaining("tmr_Strafing4") == 7 then 
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form5c), Marker_GetDirection(mkr_ATGunAlpha2), true)
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form3c), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form4 == 1 and Timer_GetRemaining("tmr_Strafing4") == 5 then 
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form6c), Marker_GetDirection(mkr_ATGunAlpha2), true)
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form2c), Marker_GetDirection(mkr_ATGunAlpha2), true)
	end
	if v_form4 == 1 and Timer_GetRemaining("tmr_Strafing4") == 3 then 
		--Cmd_Ability(player2,  ABILITY.CW.TYPHOON_RECON, Marker_GetPosition(mkr_Form7c), Marker_GetDirection(mkr_ATGunAlpha2), true)
		Cmd_Ability(player2,  ABILITY.CW.TYPHOON_ROCKET, Marker_GetPosition(mkr_Form1c), Marker_GetDirection(mkr_ATGunAlpha2), true)
		v_form4 = 0
		Rule_RemoveMe()
	end

end
function Bombing_Form5()
	if v_form5 == 0 then 
		Timer_Start("tmr_Strafing5", 60)
		
		v_form5 = 1
	end
	if v_form5 == 1 and Timer_GetRemaining("tmr_Strafing5") == 55 then 
		Rule_AddInterval(Bombing_Form3, 1)
	end
	if v_form5 == 1 and Timer_GetRemaining("tmr_Strafing5") == 40 then 
		Rule_AddInterval(Bombing_Form4, 1)
		Rule_RemoveMe()
	end
--~ 	if v_form5 == 1 and Timer_GetRemaining("tmr_Strafing5") == 50 then 
--~ 		Rule_AddInterval(Bombing_Form3, 1)
--~ 	end
--~ 	if v_form5 == 1 and Timer_GetRemaining("tmr_Strafing5") == 20 then 
--~ 		Rule_AddInterval(Bombing_Form4, 1)
--~ 		v_form5 = 0
--~ 		
--~ 	end

end


function Supply_Drop()
	print(Timer_GetRemaining("tmr_Strafing"))
	print(v_Strafing)
	if v_Strafing == 0 then 
		local StrafingRunTime = 705
		--World_GetRand(100, 200)
		Rule_AddInterval(Medal_DelayGrant, 1)
		Timer_Start("tmr_Strafing", StrafingRunTime)
		v_Strafing = 1
		Rule_AddOneShot(SupplyAlpha_Init, 300)
	end
	if g_dropped == 1 and droppos ~= nil then 		
		Player_GetAllEntitiesNearMarker(player2, eg_SupplyDrops1, droppos, 30)
		EGroup_Filter(eg_SupplyDrops1, {EBP.PICKUP.AIRDROP_MUNITIONS}, FILTER_KEEP) 
	end
	if g_dropped == 2 then 		
		Player_GetAllEntitiesNearMarker(player2, eg_SupplyDrops1, mkr_Supply1, 30)
		EGroup_Filter(eg_SupplyDrops1, {EBP.PICKUP.AIRDROP_MUNITIONS}, FILTER_KEEP) 
	end
	Player_GetAllEntitiesNearMarker(player2, eg_SupplyDrops2, mkr_Supply2, 30)
	EGroup_Filter(eg_SupplyDrops2, {EBP.PICKUP.AIRDROP_MUNITIONS}, FILTER_KEEP) 
	Player_GetAllEntitiesNearMarker(player2, eg_SupplyDrops3, mkr_Supply3, 30)
	EGroup_Filter(eg_SupplyDrops3, {EBP.PICKUP.AIRDROP_MUNITIONS}, FILTER_KEEP) 
	
	if v_Strafing == 1 and Timer_GetRemaining("tmr_Strafing") == 700 then 
		droppos = Camera_GetTargetPos()	
		if Player_CanSeePosition(player1, droppos) then
		Cmd_Ability(player2,  ABILITY.SP.SP_DROP_MUNITION, droppos, Marker_GetDirection(mkr_ATGunAlpha2), true)
		UI_CreateMinimapBlip(droppos, 10, BT_GeneralPing)
		end
		
		g_dropped = 1
	elseif v_Strafing == 1 and Timer_GetRemaining("tmr_Strafing") == 690  then 
		if EGroup_Count(eg_SupplyDrops1) > 0 then 
			OBJ_Medal.ID1 = Objective_AddUIElements(OBJ_Medal, eg_SupplyDrops1, true, 1439082, true)
			Util_AutoIntel(t_supplystart)
		elseif g_drop1 ~= 2 then
			UI_CreateMinimapBlip(mkr_Supply1, 10, BT_GeneralPing)
			Cmd_Ability(player2,  ABILITY.SP.SP_DROP_MUNITION, mkr_Supply1, Marker_GetDirection(mkr_ATGunAlpha2), true)
			g_dropped = 2
		end
		g_drop1 = 1	
		Util_AutoIntel(t_supplymedal)
	elseif v_Strafing == 1 and Timer_GetRemaining("tmr_Strafing") == 680  then 
		if EGroup_Count(eg_SupplyDrops1) > 0 and g_dropped == 2 then 
			OBJ_Medal.ID1 = Objective_AddUIElements(OBJ_Medal, eg_SupplyDrops1, true, 1439082, true)
		end
				
	elseif v_Strafing == 1 and Timer_GetRemaining("tmr_Strafing") == 500  then 
		Cmd_Ability(player2,  ABILITY.SP.SP_DROP_MUNITION, mkr_Supply2, Marker_GetDirection(mkr_ATGunAlpha2), true)
		UI_CreateMinimapBlip(mkr_Supply2, 10, BT_GeneralPing)
		Util_AutoIntel(t_supply2)
		
	elseif v_Strafing == 1 and Timer_GetRemaining("tmr_Strafing") == 490  then 
		if EGroup_Count(eg_SupplyDrops2) > 0 then 
			OBJ_Medal.ID2 = Objective_AddUIElements(OBJ_Medal, eg_SupplyDrops2, true, 1439082, true)
		end
		g_drop2 = 1		
	elseif v_Strafing == 1 and Timer_GetRemaining("tmr_Strafing") == 300  then 
		Cmd_Ability(player2,  ABILITY.SP.SP_DROP_MUNITION, mkr_Supply3, Marker_GetDirection(mkr_ATGunAlpha2), true)
		UI_CreateMinimapBlip(mkr_Supply3, 10, BT_GeneralPing)
		Util_AutoIntel(t_supply3)
		
	elseif v_Strafing == 1 and Timer_GetRemaining("tmr_Strafing") == 290  then 
		if EGroup_Count(eg_SupplyDrops3) > 0 then 
			OBJ_Medal.ID3 = Objective_AddUIElements(OBJ_Medal, eg_SupplyDrops3, true, 1439082, true)
		end
		g_drop3 = 1		
	end
end



function ToggleUIFOW()
	if g_FowUI == 0 then 
		print("reveal")
		--FOW_RevealAll()
		Game_SetMode(UI_Fullscreen)
		g_FowUI = 1
	elseif g_FowUI == 1 then 
		--FOW_UnRevealAll()
		print("hide")
		Game_SetMode(UI_Normal)
		g_FowUI = 0
	end
end


function Modify_EntityRecievedDamage(playerid, ebp, scalefactor)

	local modifier = Modifier_Create(MAT_EntityType, "modifiers\\received_damage_modifier.lua", MUT_Multiplication, false, scalefactor, ebp)

	return {Modifier_ApplyToPlayer(modifier, playerid)}
	
end


function Modify_EntityRecievedAccuracy(playerid, ebp, scalefactor)

	local modifier = Modifier_Create(MAT_EntityType, "modifiers\\received_accuracy_modifier.lua", MUT_Multiplication, false, scalefactor, ebp)

	return {Modifier_ApplyToPlayer(modifier, playerid)}
	
end









