-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Arnhem

-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")



-------------------------------------------------------------------------

-- [[ SETUP ]]

-------------------------------------------------------------------------

function OnGameSetup()
	-- string numbers should reference dat files
	-- "allies_commonwealth" "allies" "axis" "axis_panzer_elite"
	player1 = Setup_Player(1, 1309230, TRACE_AXIS_PANZER_ELITE, 1)
	player2 = Setup_Player(2, 1309237, TRACE_ALLIES_COMMONWEALTH, 2)
	player3 = Setup_Player(3, 1309230, TRACE_AXIS_PANZER_ELITE, TEAM_NEUTRAL)
	player4 = Setup_Player(4, 1309236, TRACE_ALLIES_COMMONWEALTH, 2)

end

function OnGameRestore()
	player1 = World_GetPlayerAt(1)
	player2 = World_GetPlayerAt(2)
	player3 = World_GetPlayerAt(3)
	player4 = World_GetPlayerAt(4)
	
	-- function takes care of restoring all global mission parameters after a save/load
	Game_DefaultGameRestore()
end




-------------------------------------------------------------------------

-- [[ ONINIT ]]

-------------------------------------------------------------------------

function OnInit()

	g_MissionSpeechPath="omg\\sp\\Mission6"
	
	g_AIControl_Enable = false
	g_AIControl_Pause = true
	
	--g_Oosterbeek_Speechpath = "Speech/MP/sp_gameplay_speechfx/sp_panzerofficerpropaganda"
	--Sound_PreCacheSound (g_Oosterbeek_Speechpath)
	
	-- a constant that stores the mission number for use with
	-- setting the global speech paths, tech tree setup, and 
	-- the player's starting resources
	MISSION_NUMBER = 0206
	
	--[[ PRESET GAME STATE ]]
	Setup_MissionPreset(MISSION_NUMBER)
	
	--[[ PRESET DEBUG CONDITIONS ]]
	Arnhem_Debug()
	
	--[[ Timer IDs ]]
	PlayedTigerAttacked_Cue = 1
	PlayedTigerDamaged_Cue = 2
	NebFired_Timer = 3
	g_SupplySpeechTimer = 4
	SurrenderDelay_Timer = 5
	
	--[[ SET DIFFICULTY ]]
	Arnhem_Difficulty()
	
	--[[ MISSION PRESETS ]]
	Arnhem_SpeechPreset()
	Arnhem_MissionPreset()
	
	--[[ REGISTER OBJECTIVES ]]
	Arnhem_ObjectiveRegister()
	
	--[[ MOD INITIAL STATS ]]
	Arnhem_ModifyStats()
	
	--[[ SET RESTRICTIONS ]]
	Arnhem_Restrictions()
	
	--[[ GAME START CHECK ]]
	Rule_Add(Arnhem_NISStart)

end

Scar_AddInit(OnInit)

function Arnhem_Debug()
	
	-- looks for the command line option [-debug]
	if Misc_IsCommandLineOptionSet("debug") then
		
		g_debug = true
		
		-- reveal FOW
		FOW_RevealAll()
		
	end
	
	if Misc_IsCommandLineOptionSet("ninja") then
		
		g_encounters = false
	else
	
		g_encounters = true
	
	end
	
		-- set up bindings for NISes
	Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('Util_StartNIS(NIS_OPENING)')]])")
	Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('Util_StartNIS(NIS_CLOSING)')]])")

	
end

function Arnhem_ObjectiveRegister()

	--[[ *** MUST INITIALIZE THE OBJ TABLE BEFORE REGISTERING *** ]]
	-- Primary Objectives
	Initialize_OBJ_CaptureBridge()
	Initialize_OBJ_SecureRoads()
	
	-- Secondary Objectives
	Initialize_OBJ_SupplyDepot()
	
	-- Medal Op
	Initialize_OBJ_DestroyBoats()
	
end

function Arnhem_ModifyStats()

	-- mod resource rates
	t_player1_res_mods= {}
	t_player1_res_mods[1] = Modify_PlayerResourceRate(player1, RT_Manpower, 1)
	t_player1_res_mods[2] = Modify_PlayerResourceRate(player1, RT_Munition, 1)
	t_player1_res_mods[3] = Modify_PlayerResourceRate(player1, RT_Fuel, 1)
	
end

function Arnhem_Restrictions()

	--UN/RESTRICT UPGRADES 
	Cmd_InstantUpgrade (player1, UPG.ELITE.ADVANCED_REPAIR)
	Cmd_InstantUpgrade (player1, UPG.ELITE.CAPTURE_RATE)
	
	--RESOURCES 
	Player_SetResource(player1, RT_Manpower, 800)
	Player_SetResource(player1, RT_Munition, 300)
	Player_SetResource(player1, RT_Fuel, 200)
	
	-- UN/RESTRICT POP CAP
	Player_SetPopCapOverride(player1, 90)

end

function Arnhem_Difficulty()

	--left as an example 
	
	-- get the difficulty
	g_difficulty = Game_GetSPDifficulty()  -- set a global difficulty variable
	print("********* DIFFICULTY: "..g_difficulty)
	
	-- set health bonus for player 1
	Setup_Difficulty(player1, g_difficulty) -- pass the player and difficulty global variable into the Set Health function
	Setup_Difficulty(player1, g_difficulty, TRACE_AXIS) -- Add any axis allied tanks player controlled to the difficulty modifier
	Setup_Difficulty(player2, g_difficulty) -- do it for each player that you have defined
	--Setup_Difficulty(player3, g_difficulty) -- do it for each player that you have defined
	Setup_Difficulty(player4, g_difficulty) -- do it for each player that you have defined
	
end




-------------------------------------------------------------------------

-- MISSION Preset 

-------------------------------------------------------------------------

function Arnhem_MissionPreset()
	
	-- Setup variables
	-- these determine if the intersections have been initialized
	v_intersectionA = false
	v_intersectionB = false
	v_intersectionC = false
	v_intersectionD = false
	v_intersectionE = false
	v_intersectionF = false
	v_intersectionG = false
	v_intersectionH = false
	v_intersectionI = false
	v_intersectionJ = false
	v_intersectionK = false
	v_IntersectionL = false
	v_intersectionSR1 = false
	v_LeftHQ = false
	v_RightHQ = false
	v_BunkersHQ = false
	v_BaseCounterAttack = false
	
	t_arnhem_allies = {}
	t_bridge_mod = {} -- modifiers used to control the difficulty of the squads around the bridge.
	
	t_PanzerElite_Tanks = {SBP.ELITE.HETZER, SBP.ELITE.PANTHER, SBP.ELITE.PANZER_SUPPORT, SBP.ELITE.KING_TIGER_ARNHEM, SBP.ELITE.PANZER_IV}
	
	v_scalelevel = 0
	v_based_modified = 0
	
	g_TeachingHintpoint = 10
	g_PanzerIVStubby_HPID = 11
	g_Flammenwerfer_HPID = 12
	g_Teaching_ATGunHintpoint = nil
	
	g_IdleTimer = 0
	g_PlayedEarlyBridgeSpeech = false
	g_HasPlayedTakeBridgeSpeech = false
	g_HasFinalSurrendered = false
	g_LaunchedSR2Jeeps = false
	g_LaunchedSR1Jeeps = false
	g_PlayedRoadsOpenSpeech = false
	g_LaunchedFinalCounterattack = false

	sg_allyheadquartersdefense_all = SGroup_CreateIfNotFound("sg_allyheadquartersdefense_all")
	sg_player1_all = SGroup_CreateIfNotFound ("sg_player1_all")
	
	
	-- Set the 2 bridge bases to player2 and upgrade them to HQs
	EGroup_SetPlayerOwner( eg_AllyBaseHQ_1, player2 )
	Cmd_InstantUpgrade( eg_AllyBaseHQ_1, UPG.CW.CONVERT_AMBIENT_BUILDING )
	
	EGroup_SetPlayerOwner( eg_AllyBaseHQ_2, player2 )
	Cmd_InstantUpgrade( eg_AllyBaseHQ_2, UPG.CW.CONVERT_AMBIENT_BUILDING )
	
	-- Set the garrison buildings on the map to invulnerable but damageable until the encounter triggers
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_Church, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_AllyBaseHQ_1, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_AllyBaseHQ_2, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_Bunker1, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_Bunker2, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_IntersectionC_garrison_1, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_intersectionJ_snipergarrison_1, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_sr1_4, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_hq_garrison_1, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_EndgameGarrison1, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_EndgameGarrison3, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_EndgameGarrison5, 1), 60, 0)
	Entity_SetInvulnerableMinCap (EGroup_GetSpawnedEntityAt (eg_intersectionK_garrison1, 1), 60, 0)

	-- Initialize the Ally HQ defense groups
	AllyHeadquartersDefense_Init()
	
	-- Initialize the intersection-based encounters
	BaseCounterAttack_Init()
	IntersectionA_Init()
	IntersectionB_Init()
	IntersectionC_Init()
	IntersectionD_Init()
	IntersectionE_Init()
	IntersectionF_Init()
	IntersectionG_Init()
	IntersectionH_Init()
	IntersectionI_Init()
	IntersectionJ_Init()
	IntersectionK_Init()
	IntersectionL_Init()
	IntersectionM_Init()
	IntersectionJ_BaitTroops_Init()
	SecureRoads1Defence_Init()
	
	Arnhem_HeavyWeapons_Init() -- Flak weapon crewing and threat-arrow functions
	CheckSurrender_Init() -- Check Surrender functions
	Reinforcements_Init() -- Reinforcement functions
	KingTiger_Monitor_Init() -- Data for the player's King Tiger monitor
	IdleAttack_Init() -- Idle Attackers 
	Nebelwerfers_Init() -- Neb fire from first supply depot
	
	Camera_ClampToMarker (mkr_Arnhem_CameraClamp)
	
end

function Arnhem_SpeechPreset()

	----------------------------------
	-- Master tables
	----------------------------------
	t_COMP_speech = {}
	t_AMBI_speech = {}
	t_OBJ_speech = {}
	t_TAC_speech = {}
	
	---------------------------------------------------
	-- PRIMARY OBJECTIVE: Secure the Roads into Arnhem
	---------------------------------------------------
	
	-- Objective Start
	t_OBJ_speech.RoadSecured_ObjectiveStart = {
		-- Wolfgang Berger
		{ACTOR.CXP2.Wolfgang, 1464000},					-- Kampfgruppe Lehr it is the time for action!
		{ACTOR.CXP2.Wolfgang, 1464010},					-- Use the King Tiger Tank support provided to forge a path to the main roads!
	}
	
	-- First Road Secured
	t_OBJ_speech.RoadSecured1 = {
		-- Wilhelm Deinhard
		{ACTOR.CXP2.Deinhard, 1464020},	-- Kampfgruppe controls the Road, area secured!
	}
	
	-- Second Road Secured
	t_OBJ_speech.RoadSecured2 = {
		-- Wilhelm Deinhard
		{ACTOR.CXP2.Deinhard, 1464030},	-- Kampfgruppe has secured the second Road into Arnhem!
		{ACTOR.CXP2.Deinhard, 1464040},	-- The road is now open to vehicle traffic.
	}
	
	-- Both roads secured
	t_COMP_speech.RoadsOpen = {
		
		-- Wilhelm Deinhard
		{ACTOR.CXP2.Deinhard, 1464120},					-- Wolfgang, All road objectives are secure.  It's only a matter of time until the British come walking out!
		-- Wolfgang Berger
		{ACTOR.CXP2.Wolfgang, 1461116},					-- Form up the combat groups, ready for next objective, and wait for new orders.
		-- Wilhelm Deinhard
		{ACTOR.CXP2.Deinhard, 1461117},					-- Hauptmann Berger, we have an incoming radio transmission from MajorGeneral Voss.
		-- Wolfgang Berger
		{ACTOR.CXP2.Wolfgang, 1461118},					-- Patch it through, Deinhard.
		
	}
	
	---------------------------------------------------
	-- SECONDARY OBJECTIVE: Capture the supply depots
	---------------------------------------------------
	
	-- When the player gets near the supply depots, trigger the objective and play the start speech
	t_OBJ_speech.SupplyDepotStart = {
		{ACTOR.CXP2.Henze, 1461000},					-- Uschka Henze		Hauptmann Berger, it appears that the British are raiding our depots for munitions
		{ACTOR.CXP2.Wolfgang, 1461005},					-- Wolfgang Berger	I know, damn vampires! Assemble into combat groups and recapture those depots!
	}
	
	-- After capturing the first supply depot
	t_OBJ_speech.FirstDepotCaptured = {
		
		{ACTOR.CXP2.Aldrich, 1461024},					-- Mein Kampfgruppen, the munitions depot is secured!	
		{ACTOR.CXP2.Aldrich, 1461025},					-- I advise we position a security picket to defend the captured munitions depot, the dogs will surely fight for their supplies!	
		{ACTOR.CXP2.Wolfgang, 1461023},					-- There is only one supply target left. Move to the grid location, secure and capture the area!	
	}
	
	-- Captured both depots
	t_OBJ_speech.BothDepotsCaptured = {
		{ACTOR.CXP2.Aldrich, 1461030},					-- The second depot is ours. Now it's a waiting game, I doubt the British will last long without munitions!	
		{ACTOR.CXP2.Aldrich, 1461115},					-- The supply objectives have been secured! 
	}
	
	-- Took the Neb depot
	t_TAC_speech.NebDepot = {
		{ACTOR.CXP2.Deinhard, 1461062},					-- Nebelwerfer ammunition captured and secured!
	}
	
	-- Took the 88 depot
	t_TAC_speech.FlakDepot = {
		{ACTOR.CXP2.Deinhard, 1461061},					-- Flak 88 ammunition depot captured!
	}
	
	-- Took the PaK depot
	t_TAC_speech.PaKDepot = {
		{ACTOR.CXP2.Deinhard, 1461064},					-- Ammunition for Pak38 is secure.
	}
	
	-- Brits attackling the depot
	t_TAC_speech.BritishAttackingDepot = {
		{ACTOR.CXP2.Aldrich, 1461055},					-- The British mutterficken (motherfuckers) have mounted a counter attack on our supply position!
		{ACTOR.CXP2.Aldrich, 1461060},					-- Maintain your positions and defend that target!
	}
	
	-- Brits are recapturing the Depot
	t_TAC_speech.TakingBackDepot = {
		{ACTOR.CXP2.Aldrich, 1461035},					-- British Para-forces trying to take back a munitions depot!
		{ACTOR.CXP2.Aldrich, 1461040},					-- We must prevent them from resupplying in anyway!
	}
	
	-- Brits retook the depot
	t_TAC_speech.DepotRetaken = {
		{ACTOR.CXP2.Wolfgang, 1461045},					-- Scheiße! We must retake that position!
		{ACTOR.CXP2.Wolfgang, 1461050},					-- Aldrich! Assemble a quick reaction force and take back the target!
		{ACTOR.CXP2.Aldrich, 1461051},					-- Kampfgruppen! Assemble and secure that point!
	}
	
	-- Player is attacking a depot
	t_AMBI_speech.PlayerAssaultingDepot = {
		{{ACTOR.CXP2.GenericPanzerElite, 1461085}},			-- They've got covering fire on the area!
		{{ACTOR.CXP2.GenericPanzerElite, 1461090}},			-- Push through the objective! We need that depot!
		{{ACTOR.CXP2.GenericPanzerElite, 1461095}},			-- Do not let those assholes take the depot! Get suppressive fire on their positions! They'll give up soon!
	}
	
	-- Stubby recovered after capturing the supply depot
	t_TAC_speech.StubbyRecovered = {
		{ACTOR.CXP2.Deinhard, 1461065},					-- Mein Kampgruppen! We have recovered a Stubby Panzerkampfwagen IV armored infantry support gun!
		--{ACTOR.CXP2.Deinhard, 1464070},					-- The Stubby's 75mm low velocity gun with high-explosive shells eats infantry fortifications! It is a perfect addition for further penetrating Arnhem!
	}
	
	-- British Speech reacting to the capture of supply depots
	t_COMP_speech.CapturedDepot1 = {
		{ACTOR.CXP2.GenericCommonwealth, 1460835},		-- Brit Officer 1	German's are starving us out sir. Supplies are at 35%
	}
	
	t_AMBI_speech.CapturedDepot1 = {
		{{ACTOR.CXP2.GenericCommonwealth, 1460840}},		-- Brit Soldier 1	Shite! What are we gonna do! 
		{{ACTOR.CXP2.GenericCommonwealth, 1460845}},		-- Brit Soldier 1	We're right fucked gents!
	}
	
	t_COMP_speech.CapturedDepot2 = {
		{ACTOR.CXP2.GenericCommonwealth, 1460850},		-- Brit Officer 1	Supplies are at 15%. WE need some god damn support! Maintain supply lines!!
	}
	
	t_AMBI_speech.CapturedDepot2 = {
		{{ACTOR.CXP2.GenericCommonwealth, 1460855}},		-- Brit Soldier 1	If 30th Corps doesn't arrive soon, frankly we're buggered tits-up. 
		{{ACTOR.CXP2.GenericCommonwealth, 1460860}},		-- Brit Soldier 1	Fucking hell mates!
	}
	
	t_COMP_speech.CapturedDepot3 = {
		{ACTOR.CXP2.GenericCommonwealth, 1460865},		-- Brit Officer 1	Supplies are down to 5%, pull back to HQ! I say again... Pull back to HQ!
	}
	
	t_AMBI_speech.CapturedDepot3 = {
		{{ACTOR.CXP2.GenericCommonwealth, 1460870}},		-- Brit Soldier 1	The ammo's gone gents! Get a message up the chain! It's fucking over! 
		{{ACTOR.CXP2.GenericCommonwealth, 1460875}},		-- Brit Soldier 1	Fucking cunts! Took all our Depots!
	}
	
	-- British reacting to the germans going after the supply depots
	t_AMBI_speech.SupplyDepots = {
		-- Brit Soldier 1
		{{ACTOR.CXP2.GenericCommonwealth, 1460700}},		-- Hold those points gents!
		{{ACTOR.CXP2.GenericCommonwealth, 1460705}},		-- Jerry's after our resources!
		{{ACTOR.CXP2.GenericCommonwealth, 1460710}},		-- Maintain supplies!
		{{ACTOR.CXP2.GenericCommonwealth, 1460715}},		-- Captain Wood, keep you men on that depot!
		{{ACTOR.CXP2.GenericCommonwealth, 1460720}},		-- Keep off our supplies Jerry!
		{{ACTOR.CXP2.GenericCommonwealth, 1460725}},		-- Pour it on 'em thick lads.
		{{ACTOR.CXP2.GenericCommonwealth, 1460730}},		-- We're loosing ammo here Captain!
		
		-- Brit Soldier 2
		{{ACTOR.CXP2.GenericCommonwealth, 1460735}},		-- Keep off Jerry Arnhem is ours!
		{{ACTOR.CXP2.GenericCommonwealth, 1460740}},		-- We need those bloody depots lads!
		{{ACTOR.CXP2.GenericCommonwealth, 1460745}},		-- Maintain defences!
		{{ACTOR.CXP2.GenericCommonwealth, 1460750}},		-- Shite, you ain't getting it that easy Jerry!
		{{ACTOR.CXP2.GenericCommonwealth, 1460755}},		-- Cod wallopers!
		{{ACTOR.CXP2.GenericCommonwealth, 1460760}},		-- Fucking hell, Jerry's got this one mates!
		{{ACTOR.CXP2.GenericCommonwealth, 1460765}},		-- Ammo supplies are down to 30% sir!
	}
	
	
	---------------------------------------------------
	-- GAMEPLAY: King Tiger Speech
	---------------------------------------------------
	
	t_TAC_speech.TigerUnderAttack = {
		{{ACTOR.CXP2.Deinhard, 1462015}},					-- We need infantry around that Tiger!
		{{ACTOR.CXP2.Deinhard, 1462020}},					-- Get a security screen around that Tiger tank!  Use the troops!
		{{ACTOR.CXP2.Deinhard, 1462021}},					-- Tiger tank needs Grenadier support!  Cover his advance!
	}
	
	t_TAC_speech.TigerNearlyDead = {
		{{ACTOR.CXP2.Deinhard, 1462025}},					-- Our Panzer Königstiger (King-tiger-tank) is taking a lot of fire! Suppress the enemy anti-tank weapons before we advance!
		{{ACTOR.CXP2.Deinhard, 1462030}},					-- Get repair crews on that Tiger!  Deploy a security screen around its position!
		{{ACTOR.CXP2.Deinhard, 1462035}},					-- Save the King Tiger!  Surround it with bodies if you must!
	}
	
	t_TAC_speech.TigerDestroyed = {
		{ACTOR.CXP2.Deinhard, 1462040},					-- A King Tiger tank has been lost! Setz deinen Arsch in Bewegung (get your ass in gear)!
		{ACTOR.CXP2.Deinhard, 1462045},					-- We will not get any additional armor to the bridge without taking the main roads into Arnhem!
		{ACTOR.CXP2.Deinhard, 1462046},					-- Call up a Bergetiger! We need to recover this wreck!
	}
	
	t_TAC_speech.TigerReinforcements = {
		{ACTOR.CXP2.Deinhard, 1462050},					-- Additional Panzer Königstiger have been attached to our battle group!
	}
	
	t_TAC_speech.TigerDamaged = {
		{ACTOR.CXP2.Deinhard, 1462060},					-- Repair the damaged Tiger!  It is critical to our operation.
	}
	
	----------------------------------
	-- GENERAL SPEECH
	----------------------------------
	
	-- Nebelwerfer Artillery fires on the player
	t_TAC_speech.FirstArtilleryFiring = { 
		{ACTOR.CXP2.Aldrich, 1461100},					-- Incoming artillery fire! They're using our Nebs!
		{ACTOR.CXP2.Aldrich, 1461105},					-- One of the depots must be supplying those Nebelwerfers!
		{ACTOR.CXP2.Aldrich, 1461110},					-- Cut off their supplies! The Brits need the ammo to keep firing, take them!
	}
	
	-- Reactions to various captured weapons used by British
	t_TAC_speech.Panzerschrecks = { 
		{ACTOR.CXP2.Aldrich, 1464050},					-- Panzerschreck fire! Fick! Those Commandos have Panzershrecks!
		{ACTOR.CXP2.Aldrich, 1461110},					-- Cut off their supplies! The Brits need the ammo to keep firing, take them!
	}
	
	t_TAC_speech.PaK38s = { 
		{ACTOR.CXP2.Aldrich, 1464060},					-- A-T!  A-T Fire!  (beat) Damn it!  That's one of ours!
	}
	
	t_TAC_speech.Flak88s = {
		-- Aldrich Berger
		{{ACTOR.CXP2.Aldrich, 1464070}},					-- 88s! English They're using our guns against us!
		{{ACTOR.CXP2.Aldrich, 1464080}},					-- They captured 88s!  Alert the vehicle crews!
	}
	
	-- Blockade Speech
	t_TAC_speech.Blockade_WithKingTiger = {
		{ACTOR.CXP2.Deinhard, 1464090},					-- Ha! Blödes arschlochen (stupid assholes)! little blockades won't stand up to the armor of the 3rd Empire!
	}
	
	t_TAC_speech.Blockade_WithoutKingTiger = {
		{ACTOR.CXP2.Deinhard, 1464100},					-- The path is blocked, we'll have to find another way around until we can get more heavy vehicles on the scene.
		{ACTOR.CXP2.Deinhard, 1464110},					-- Secure the roadways!
	}
	
	-- British Taunts
	t_AMBI_speech.BritishTaunts = {
		
		-- Brit Soldier 1
		{{ACTOR.CXP2.GenericCommonwealth, 1460505}},		-- Go home, Jerries!
		{{ACTOR.CXP2.GenericCommonwealth, 1460505}},		-- Arnhem's our town, now!
		{{ACTOR.CXP2.GenericCommonwealth, 1460510}},		-- Come and get us, Hans!
		{{ACTOR.CXP2.GenericCommonwealth, 1460515}},		-- Over here, ya rotters!
		{{ACTOR.CXP2.GenericCommonwealth, 1460520}},		-- Get the fuck outta Arnhem!
		{{ACTOR.CXP2.GenericCommonwealth, 1460525}},		-- This the best you got?
		{{ACTOR.CXP2.GenericCommonwealth, 1460530}},		-- My nanna's more menacing than you lot!
		{{ACTOR.CXP2.GenericCommonwealth, 1460535}},		-- Give up and go home, you ain't taking this town!
		{{ACTOR.CXP2.GenericCommonwealth, 1460540}},		-- Jerry!  Jerry!
		{{ACTOR.CXP2.GenericCommonwealth, 1460545}},		-- The bulldogs'll bite you in the ass!
		
	}
	
	-- Speech for the British retreating after 
	t_AMBI_speech.BritRetreatHQ = {
		
		-- Brit Soldier 1			
		{{ACTOR.CXP2.GenericCommonwealth, 1460550}},		-- Shit! There's too many, pull back!
		{{ACTOR.CXP2.GenericCommonwealth, 1460555}},		-- Fall back to the HQ, lads!
		{{ACTOR.CXP2.GenericCommonwealth, 1460560}},		-- Pull back! Reinforce the HQ!
		{{ACTOR.CXP2.GenericCommonwealth, 1460565}},		-- We've done our lot, get outta here!
		
	}
	
	-- Play before player gets ambushed by Commandos during general encounters
	t_AMBI_speech.BackgroundNoise = {
		
		-- Brit Soldier 1
		{{ACTOR.CXP2.GenericCommonwealth, 1460770}},		-- SShhhhhh!
		{{ACTOR.CXP2.GenericCommonwealth, 1460775}},		-- Quiet!
		{{ACTOR.CXP2.GenericCommonwealth, 1460780}},		-- <tripping and grunting>
		{{ACTOR.CXP2.GenericCommonwealth, 1460785}},		-- < a quick whistle>
		{{ACTOR.CXP2.GenericCommonwealth, 1460790}},		-- Over here.
		{{ACTOR.CXP2.GenericCommonwealth, 1460795}},		-- Zip it Quinn!
		{{ACTOR.CXP2.GenericCommonwealth, 1460800}},		-- There's one now!
		
	}
	
	-- Commandos react to the King Tiger
	t_AMBI_speech.KingTigerReaction = {
		
		-- Brit Soldier 2
		{{ACTOR.CXP2.GenericCommonwealth, 1460810}},		-- Some fucking heavy armored Panzer hellhound?
		{{ACTOR.CXP2.GenericCommonwealth, 1460815}},		-- Jerry's pulled out the stops for us lads! Protect your domes!
		
		-- Brit Soldier 1
		{{ACTOR.CXP2.GenericCommonwealth, 1460820}},		-- Shite! Look at the bloody thing!
		{{ACTOR.CXP2.GenericCommonwealth, 1460825}},		-- Hellhound, I'd say it was a fucking Titan!
		{{ACTOR.CXP2.GenericCommonwealth, 1460830}},		-- Heavy Armor spotted!
		
	}
	
	t_AMBI_speech.FirstKingTigerReaction = {
		
		{ACTOR.CXP2.GenericCommonwealth, 1460805},		-- Sweet Jesus! What the fuck is that bloody thing!
		
	}
	
	----------------------------------
	-- First Encounter Speech
	----------------------------------
	
	-- Played in the Intesection_A encounter, against the first British opposition
	t_AMBI_speech.FirstEncounter = {
		
		{{ACTOR.CXP2.GenericCommonwealth, 1460680}},		-- Brit Soldier 1	We got Jerry contact!
		{{ACTOR.CXP2.GenericCommonwealth, 1460685}},		-- Brit Officer 1	Infantry in open, rapid rate!
		{{ACTOR.CXP2.GenericCommonwealth, 1460690}},		-- Brit Soldier 1	Arnhem is ours, you hun bastards!
		{{ACTOR.CXP2.GenericCommonwealth, 1460695}},		-- Brit Soldier 1	Bunker down on them lads!
		
	}
	
	----------------------------------
	-- XXX Corps
	----------------------------------
	
	-- Arrives
	t_TAC_speech.XXXCorpsArrives = {
		
		{ACTOR.CXP2.Aldrich, 1463066},					-- Forward elements of the XXX Corps are inbound!
		--{ACTOR.CXP2.Aldrich, 1463067},					-- Man those Flak 88's and fire on that Armor!
		{ACTOR.CXP2.Wolfgang, 1463068},					-- Do not worry, with they no longer have the capabilities of reaching Arnhem.
		{ACTOR.CXP2.Wolfgang, 1463069},					-- Destroy anything that tries to cross the bridge, but the remainder of the enemy forces will be pulling back to regroup in Valkenswaard. 
		
	}
	

	------------------------------------
	-- PRIMARY OBJECTIVE: Capture Bridge
	------------------------------------
	
	-- Objective Start
	t_OBJ_speech.CaptureBridgeStart = {
		
		{ACTOR.CXP2.Wolfgang, 1462000},					-- Kampfgruppe Lehr we must take the bridge!!!
		{ACTOR.CXP2.Wolfgang, 1462002},					-- XXX Corps has advanced beyond Nijmegen and will be arriving shortly!
		--{ACTOR.CXP2.Wolfgang, 1462005},					-- Kampfgruppe! All the major roads into Arnhem are now secured! Access to vehicle reinforcements has been granted.
	}
	
	-- 
	t_OBJ_speech.FirstBuildingCapped = {
		
		{ACTOR.CXP2.Aldrich, 1463030},					-- We've taken the first structure!
		{ACTOR.CXP2.Aldrich, 1463031},					-- Taking heavy fire from the bridge deck!
	}
	
	t_OBJ_speech.TakeTheBridge = {
		
		--{ACTOR.CXP2.Aldrich, 1463035},					-- The remaining British HQ is secured!
		{ACTOR.CXP2.Wolfgang, 1463045},					-- Kamfgruppe! Push onto the bridge!  Neutralize those defensive positions!
		{ACTOR.CXP2.Wolfgang, 1463046},					-- Adjust the axis of advance!  Blitz the English and secure that bridge!
		{ACTOR.CXP2.Wolfgang, 1463047},					-- Our sheer numbers will overpower them! Move to secure the bridge!
	}
	
	t_OBJ_speech.BridgeDeckSecured = {
		
		{ACTOR.CXP2.Deinhard, 1463060},					-- We have secured the bridge deck! 
		{ACTOR.CXP2.Deinhard, 1463065},					-- Kampfgruppe Lehr now controls the bridge deck!
	}
	
	t_TAC_speech.AttackingBridgeTooEarly = {
		
		{ACTOR.CXP2.Wolfgang, 1463050},					-- The paratroopers defensive positions are too strong!
		{ACTOR.CXP2.Wolfgang, 1463055},					-- Secure the supply depots before the main assault on the bridge and we will drain them of munitions!
		
	}
	
	----------------------------------
	-- Medal Objective
	----------------------------------
	
	-- Medal Objective announced
	t_OBJ_speech.DestroyBoats = {
		
		{ACTOR.CXP2.Deinhard, 1466000},					-- We have to deny the English movement along the river.
		{ACTOR.CXP2.Deinhard, 1466005},					-- The boats moored at the dock must be destroyed.
		{ACTOR.CXP2.Deinhard, 1466010},					-- However, the bridge is the priority.
		
	}
	-- Boat Destroyed
	t_AMBI_speech.BoatSunk = {
		
		{{ACTOR.CXP2.GenericPanzerElite, 1466015}},					-- Splash one boat!  Nice shot!
		{{ACTOR.CXP2.GenericPanzerElite, 1466020}},					-- Good hit!  Look at it go!
		{{ACTOR.CXP2.GenericPanzerElite, 1466025}},					-- Reminds me of Dunkirk!
		
	}
	
	-- Medal Earned
	t_OBJ_speech.MedalEarned = {
		
		{ACTOR.CXP2.Deinhard, 1466030},					-- Dock line secured!  The flank is clear!
		
	}
	
	----------------------------------
	-- MISSION COMPLETE
	----------------------------------
	
	-- The British Surrender from the HQ positions
	t_COMP_speech.MissionComplete_British = {
		
		{ACTOR.CXP2.GenericCommonwealth, 1460885},		-- Brit Officer 1	That's it, my good men, rest for another day.
		{ACTOR.CXP2.GenericCommonwealth, 1460890},		-- Brit Soldier 1	We surrender! Bloody hell, Sich aufgeben! Damn Jerries.
	}
	
	t_AMBI_speech.MissionComplete_British = {
		
		-- Brit Soldier 1
		{{ACTOR.CXP2.GenericCommonwealth, 1460895}},		-- Hold fire, I say again, hold your fire!
		{{ACTOR.CXP2.GenericCommonwealth, 1460900}},		-- Do like I do lads! Sich aufgeben! Sich aufgeben!
		
		-- Brit Soldier 2
		{{ACTOR.CXP2.GenericCommonwealth, 1460905}},		-- Cease fire! Cease fire!!!! 
		{{ACTOR.CXP2.GenericCommonwealth, 1460910}},		-- That's it lads! We surrender! 
		{{ACTOR.CXP2.GenericCommonwealth, 1460915}},		-- Bloody hell, fucking Hun wankers got us mates!
	}
	
	-- German victory speech (NISLET)
	t_events = {
		EndGameSurrendering = {
			
			{camPos = mkr_FinalSurrenderCamera, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.GenericCommonwealth, 1460880},},	-- Brit Soldier 1	Out of ammo, God save the King.
			{camPos = mkr_FinalSurrenderCamera, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Deinhard, 1463070},},				-- ha-ha! The bridge is ours!!! 
			{camPos = mkr_FinalSurrenderCamera, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Deinhard, 1463075},},				-- Wolfgang we've done it! The bridge across the Rhine is ours!
			{camPos = mkr_FinalSurrenderCamera, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Wolfgang, 1463080},},				-- Excellent job Kampfgruppe Lehr!
			{camPos = mkr_FinalSurrenderCamera, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Wolfgang, 1463085},},				-- Clear the wreckage on the roadway and call up command.  The bridge is open for business.=
			{camPos = mkr_FinalSurrenderCamera, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Deinhard, 1463076},},				-- What should we do with all these prisoners?
			{camPos = mkr_FinalSurrenderCamera, waitType = NISLET_VO, waitValue = {ACTOR.CXP2.Wolfgang, 1463090},},				-- Let's line them up and march them out!
			
		},
	}
	
end




-------------------------------------------------------------------------

-- MISSION START 

-------------------------------------------------------------------------

function Arnhem_NISStart()
	
	if g_debug == true then
		Game_FadeToBlack(FADE_IN, 0)
		Arnhem_MissionStart()
	else
		Util_StartNIS(NIS_OPENING_BLACK, Arnhem_POSTNIS)
	end
	
	Rule_RemoveMe()

end

function Arnhem_POSTNIS()
	
	IntersectionA_Preset()
	Camera_ResetToDefault()
	Camera_MoveToPosition(mkr_intro_camera1)
	Objective_Start(OBJ_SecureRoads)
	Rule_Add (Arnhem_MissionStart)

end
	
function Arnhem_MissionStart()

	if Event_IsAnyRunning (EVENT_INTEL) == false then
		
		Rule_AddOneShot(SecureRoads_Delay, 0.1)
		
		Rule_AddOneShot(Arnhem_SetInvincibleObjects,1)
		
		Rule_AddOneShot( Arnhem_HeavyWeapons,1 )
		
		Rule_AddInterval(SupplyDepot_DelayObjStart, 3)
		
		Rule_Add ( Arnhem_Encounter_Notifier )
		
		Rule_AddInterval (PlayerBaseCheck, 5)
		
		IntersectionA_Kickoff()
		
		Rule_RemoveMe()
		
	end
	
end

function Delay_CaptureBridge()

	if g_PlayedRoadsOpenSpeech == false then
		Util_AutoIntel (t_COMP_speech.RoadsOpen)
		-- Add the King Tiger reinforcement ability now that the roads are secured
		SecureRoads_UnlockTigerAbility()
		g_PlayedRoadsOpenSpeech = true
	end
	
	if Event_IsAnyRunning(EVENT_INTEL) == false then
		Objective_Start(OBJ_CaptureBridge)
		Rule_RemoveMe()
	end
	
end

function Arnhem_SetInvincibleObjects()
	EGroup_SetInvulnerable( eg_InvincibleRubble, true )
	EGroup_SetInvulnerable( eg_ArnhemBridge, true )
end

-- a utility function that is used by all the intersections to spawn the squads
function Arnhem_EncounterSpawner( squadTable, squadGroup )
	for k, this in pairs (squadTable) do
		Util_CreateSquads(player2, this.sg, this.sbp, this.pos, this.dest, this.number, this.load, this.attackmove, this.pos_facing, this.upgrade)
		if this.heavy == true then
			Cmd_InstantSetupTeamWeapon(this.sg)
		end
		if this.managed == true then -- Add to the AT gun manager with threat arrows
			ATGun_AddGroup( this.sg, player2, nil, nil, nil, nil, true )
		end
		if this.garrison == true then
			Cmd_Garrison( this.sg, this.garrison_loc )
		end	
		SGroup_AddGroup(squadGroup, this.sg)
	end
	
end

-- watches for players squads to come close to the the encounters on the map
function Arnhem_Encounter_Notifier()	
	if g_encounters == true then
		
		if v_BunkersHQ == false then
			if Prox_ArePlayersNearMarker (player1, mkr_base_prox_3, ANY) then
				AllyHeadquartersDefense_Bunkers_Preset()
				v_BunkersHQ = true
			end
		end
		
		if v_LeftHQ == false then
			if Prox_ArePlayersNearMarker (player1, mkr_base_prox_1, ANY) then
				AllyHeadquartersDefense_Left_Preset()
				v_LeftHQ = true
			end
		end
		
		if v_RightHQ == false then
			if Prox_ArePlayersNearMarker (player1, mkr_base_prox_4, ANY) or Prox_ArePlayersNearMarker(player1, mkr_intersectionA, ANY) then
				AllyHeadquartersDefense_Right_Preset()
				v_RightHQ = true
			end
		end
		
		if v_intersectionB == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionB, ANY) or Prox_ArePlayersNearMarker(player1, mkr_intersectionA, ANY) == true then
				IntersectionB_Preset()
				v_intersectionB = true
				-- Trigger the Brit Taunt speech
				if Event_IsAnyRunning () == false then
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
			end
		end
		
		if v_intersectionC == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionC, ANY) == true or Prox_ArePlayersNearMarker (player1, mkr_base_prox_2, ANY) == true then
				IntersectionC_Preset()
				IntersectionM_Preset()
				v_intersectionC = true
				
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
				
			end
		end
		
		if v_intersectionD == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionD, ANY) == true then
				IntersectionD_Preset()
				v_intersectionD = true
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
			end
		end
		
		if v_intersectionE == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionE, ANY) == true or Prox_ArePlayersNearMarker(player1, mkr_intersectionE_trigger2, ANY) then
				IntersectionE_Preset()
				v_intersectionE = true
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
			end
		end
		
		if v_intersectionF == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionF, ANY) == true then
				IntersectionF_Preset()
				v_intersectionF = true
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
			end
		end
		
		if v_intersectionG == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionG, ANY) == true then
				IntersectionG_Preset()
				v_intersectionG = true
				
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
				-- Start watching for the player's proximity to the point to launch XXX Corps
				Rule_AddInterval (Delay_XXXCorps, 2)
			end
		end
		
		if v_intersectionH == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionH, ANY) == true then
				IntersectionH_Preset()
				v_intersectionH = true
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
			end
		end
	
		if v_intersectionI == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionI, ANY) == true then
				IntersectionI_Preset()
				v_intersectionI = true
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
			end
		end
		
		if v_intersectionJ == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionJ_1, ANY) == true or Prox_ArePlayersNearMarker(player1, mkr_intersectionJ_2, ANY) == true then
				IntersectionJ_Preset()
				v_intersectionJ = true
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
			end
		end
		
		if v_intersectionK == false then
			if Prox_ArePlayersNearMarker(player1, mkr_intersectionK_trigger1, ANY) == true or Prox_ArePlayersNearMarker(player1, mkr_intersectionK_trigger2, ANY) == true or Prox_ArePlayersNearMarker(player1, mkr_intersectionK_trigger3, ANY) == true then
				IntersectionK_Preset()
				v_intersectionK = true
				if Event_IsAnyRunning () == false then
					-- Trigger the Brit Taunt speech
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.BritishTaunts))
					Util_AutoAmbient (t_AMBI_speech.BritishTaunts[rand])
				end
			end
		end
		
		if v_intersectionSR1 == false then
			if Prox_ArePlayersNearMarker(player1, mkr_sp_sr1_trigger1, ANY) == true or Prox_ArePlayersNearMarker(player1, mkr_sp_sr1_trigger2, ANY) == true then
				SecureRoads1Defence_Preset()
				v_intersectionSR1 = true
				-- Trigger Intersection J as well
				IntersectionJ_Preset()
				v_intersectionJ = true
			end
		end
		
		if v_BaseCounterAttack == false then
			if Prox_ArePlayersNearMarker(player1, mkr_BaseCounterAttack_Trigger1, ANY) == true or Prox_ArePlayersNearMarker(player1, mkr_BaseCounterAttack_Trigger2, ANY) == true 
			or Prox_ArePlayersNearMarker(player1, mkr_BaseCounterAttack_Trigger3, ANY) == true or Prox_ArePlayersNearMarker(player1, mkr_BaseCounterAttack_Trigger4, ANY) == true then
				BaseCounterAttack_Preset()
				v_BaseCounterAttack = true
			end
		end
		
		if ( Player_OwnsEGroup (player2, eg_BridgePoint_1) == false or Player_OwnsEGroup (player2, eg_BridgePoint_2) == false or Player_OwnsEGroup (player2, eg_BridgePoint_3) == false )
		and Objective_IsStarted (OBJ_CaptureBridge) == false then
			Objective_Start (OBJ_CaptureBridge)
		end
		
		if g_PlayedEarlyBridgeSpeech == false and v_intersectionG == true then 
			if SGroup_IsDoingAttack (sg_intersections_G_all, ANY, 10) and Objective_IsComplete (OBJ_SupplyDepot) == false then		
				Util_AutoIntel (t_TAC_speech.AttackingBridgeTooEarly)
				g_PlayedEarlyBridgeSpeech = true
			end
		end
		
		-- Launch some jeeps if the player is taking back the last secure roads objective point
		if g_LaunchedSR2Jeeps == false then
			if Prox_ArePlayersNearMarker (player1, mkr_SR2_point_prox, ANY) then
				Util_CreateSquads (player2, sg_intersection_G_JeepsAttack, SBP.CW.COMMANDOS_JEEP, mkr_JeepsAttack_spawn, NIL_DEST, 3)
				Cmd_SquadPath (sg_intersection_G_JeepsAttack, "wp_IntersectionG_JeepsAttack", false, 0, false)
				g_LaunchedSR2Jeeps = true
				Rule_AddInterval (SR2Jeeps_Monitor, 1)
			end
		end
		
		-- Attack with jeeps if the player is taking back the first secure roads objective point
		if g_LaunchedSR1Jeeps == false then
			if Prox_ArePlayersNearMarker (player1, EGroup_GetPosition (eg_SecureRoad1), ALL, 5) then
				if g_difficulty == GD_EASY then 
					Util_CreateSquads (player2, sg_intersectionSR1_JeepsAttack, SBP.CW.COMMANDOS_JEEP, mkr_offmap_SR1, mkr_SR1_ForwardCommandos2, 3, nil, true)
				elseif g_difficulty == GD_NORMAL then 
					Util_CreateSquads (player2, sg_intersectionSR1_JeepsAttack, SBP.CW.COMMANDOS_JEEP, mkr_offmap_SR1, mkr_SR1_ForwardCommandos2, 3, nil, true)
				elseif g_difficulty == GD_HARD then 
					Util_CreateSquads (player2, sg_intersectionSR1_JeepsAttack, SBP.CW.COMMANDOS_JEEP, mkr_offmap_SR1, mkr_SR1_ForwardCommandos2, 4, nil, true)
				elseif g_difficulty == GD_EXPERT then 
					Util_CreateSquads (player2, sg_intersectionSR1_JeepsAttack, SBP.CW.COMMANDOS_JEEP, mkr_offmap_SR1, mkr_SR1_ForwardCommandos2, 4, nil, true)
				end
				g_LaunchedSR1Jeeps = true
				Rule_AddInterval (SR1Jeeps_Monitor, 1)
			end
		end
		
		-- Deploy some infantry into buildings nearby if the player starts decapturing the munitions point near Intersections A and B
		-- Alternatively, if Intersection J has been triggered then deploy them also to prevent popping
		if v_IntersectionL == false then
			if Prox_ArePlayersNearMarker (player1, EGroup_GetPosition (eg_IntersectionL), ANY, 6) or v_intersectionJ == true then
				IntersectionL_Preset()
				v_IntersectionL = true
			end
		end
		
	end
end

function SR1Jeeps_Monitor()
	
	-- If the jeeps have too few units left or the intersection has surrendered then retreat
	if SGroup_Count (sg_intersection_G_JeepsAttack) <= 1 or t_Monitor_Intersections[3].surrendered == true then
		Cmd_Move (sg_intersection_G_JeepsAttack, mkr_HQ2_Offmap, false, mkr_HQ2_Offmap)
		Rule_RemoveMe()
	end
	
	local attacker = SGroup_CreateIfNotFound ("attacker")
	if SGroup_IsUnderAttack (sg_intersections_D_all, ANY, 5) then
		SGroup_GetLastAttacker (sg_intersections_D_all, attacker)
		SGroup_Filter (attacker, t_PanzerElite_Tanks, FILTER_REMOVE)
		if SGroup_IsEmpty (attacker) == false then
			Cmd_AttackMove (sg_intersection_G_JeepsAttack, attacker)
		end
	end
	
end

function SR2Jeeps_Monitor()
	
	-- If the jeeps have too few units left or the intersection has surrendered then retreat
	if SGroup_Count (sg_intersectionSR1_JeepsAttack) <= 1 or t_Monitor_Intersections[11].surrendered == true then
		Cmd_Move (sg_intersectionSR1_JeepsAttack, mkr_HQ2_Offmap, false, mkr_HQ2_Offmap)
		Rule_RemoveMe()
	end
	
	local attacker = SGroup_CreateIfNotFound ("attacker")
	
	if SGroup_IsUnderAttack (sg_IntersectionSR1_All, ANY, 5) then
		SGroup_GetLastAttacker (sg_IntersectionSR1_All, attacker)
		SGroup_Filter (attacker, t_PanzerElite_Tanks, FILTER_REMOVE)
		if SGroup_IsEmpty (attacker) == false then
			Cmd_AttackMove (sg_intersectionSR1_JeepsAttack, attacker)
		end
	end
	
end

-- spawn troops to get in all the heavy weapons on the map
function Arnhem_HeavyWeapons_Init()

	sg_heavyweapons_squads = SGroup_CreateIfNotFound("sg_heavyweapons_squads")
	eg_heavyweapons_guns = EGroup_CreateIfNotFound("eg_heavyweapons_guns")
	sg_heavyweapons_bigguns = SGroup_CreateIfNotFound ("sg_heavyweapons_bigguns")
	
	sg_IntersectionF_gunteam_1 = SGroup_CreateIfNotFound ("sg_IntersectionF_gunteam_1")
	sg_SR1_gunteam_1 = SGroup_CreateIfNotFound ("sg_SR1_gunteam_1")
	sg_Bridge_gunteam_1 = SGroup_CreateIfNotFound ("sg_Bridge_gunteam_1")
	
	-- Needed for the scattered squads with panzershreks throughout the city
	sg_Garrison_Panzershrecks = SGroup_CreateIfNotFound ("sg_Garrison_Panzershrecks")
	
end

function Arnhem_HeavyWeapons()
	
	EGroup_AddEGroup (eg_heavyweapons_guns, eg_IntersectionF_88_1)
	EGroup_AddEGroup (eg_heavyweapons_guns, eg_hq_88_1)
	EGroup_AddEGroup (eg_heavyweapons_guns, eg_hq_88_3)
	
	v_Flak88sFired_Speech = 0
	
	t_arnhem_allies.t_heavyweapon_squads = {
		
		{-- Far right 88
			sg 	= SGroup_CreateIfNotFound ("sg_IntersectionF_88_Crew"),
			sg_crewed = sg_IntersectionF_gunteam_1,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionF_spawn_1,
			dest = eg_IntersectionF_88_1,
			eg_capture = eg_IntersectionF_88_1,
			sync_id = SyncWeapon_GetFromEGroup(eg_IntersectionF_88_1),
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false, 
			garrison_loc = nil,
			managed = false,
			active = false,
			prox_marker = mkr_heavy88_prox_IF1,
			intersection_sg = sg_intersections_G_all,
			is_attacking = false,
			flak88 = true,
			crewed = false,
			threat_arrow = nil,
			ThreatArrowCreated = false,
			SecondsActive = 0,
			Accuracy_Mod = nil,
		},
		
		{-- Bridge 88
			sg = SGroup_CreateIfNotFound ("sg_Bridge_88_Crew"),
			sg_crewed = sg_Bridge_gunteam_1,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_hq_troops_5,
			dest = eg_hq_88_3,
			eg_capture = eg_hq_88_3,
			sync_id = SyncWeapon_GetFromEGroup(eg_hq_88_3),
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
			active = false,
			prox_marker = mkr_heavy88_prox_HQ3,
			intersection_sg = sg_intersections_G_all,
			is_attacking = false,
			flak88 = true,
			crewed = false,
			threat_arrow = nil,
			ThreatArrowCreated = false,
			SecondsActive = 0,
			Accuracy_Mod = nil,
		},
		
		{-- 88 near SR1
			sg = SGroup_CreateIfNotFound ("sg_SR1_88_Crew"),
			sg_crewed = sg_SR1_gunteam_1,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_possible_harassmentspawn3,
			dest = eg_hq_88_1,
			eg_capture = eg_hq_88_1,
			sync_id = SyncWeapon_GetFromEGroup(eg_hq_88_1),
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
			active = false,
			prox_marker = mkr_heavy88_prox_HQ1,
			intersection_sg = sg_IntersectionSR1_All,
			is_attacking = false,
			flak88 = true,
			crewed = false,
			threat_arrow = nil,
			ThreatArrowCreated = false,
			SecondsActive = 0,
			Accuracy_Mod = nil,
		},
		
		{ -- Flakvierling AA Gun
			sg = SGroup_CreateIfNotFound("sg_hq_gunteam_2"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_hq_troops_2,
			dest = eg_hq_aa_1,
			eg_capture = eg_hq_aa_1,
			sync_id = SyncWeapon_GetFromEGroup(eg_hq_aa_1),
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
			active = false,
		},
		
		{ -- Flakvierling AA Gun
			sg = SGroup_CreateIfNotFound("sg_hq_gunteam_4"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_hq_troops_4,
			dest = eg_hq_aa_2,
			eg_capture = eg_hq_aa_2,
			sync_id = SyncWeapon_GetFromEGroup(eg_hq_aa_2),
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
			active = false,
		},
		
	}
	
	Arnhem_EncounterSpawner( t_arnhem_allies.t_heavyweapon_squads, sg_heavyweapons_squads )
	Rule_AddDelayedInterval (Monitor_For88Activation, 5, 1)
	
	-- Spawn the panzerschrek squads in the buildings
	Util_CreateSquads (player2, sg_Garrison_Panzershrecks, SBP.CW.COMMANDOS_PARATROOPER_SP, eg_TigerShrek1, nil, 1, 1, false, nil, UPG.ELITE.PANZERSCHRECK)
	Util_CreateSquads (player2, sg_Garrison_Panzershrecks, SBP.CW.COMMANDOS_PARATROOPER_SP, eg_TigerShrek2, nil, 1, 1, false, nil, UPG.ELITE.PANZERSCHRECK)
	Util_CreateSquads (player2, sg_Garrison_Panzershrecks, SBP.CW.COMMANDOS_PARATROOPER_SP, eg_TigerShrek3, nil, 1, 1, false, nil, UPG.ELITE.PANZERSCHRECK)
	Util_CreateSquads (player2, sg_Garrison_Panzershrecks, SBP.CW.COMMANDOS_PARATROOPER_SP, eg_TigerShrek4, nil, 1, 1, false, nil, UPG.ELITE.PANZERSCHRECK)
	Util_CreateSquads (player2, sg_Garrison_Panzershrecks, SBP.CW.COMMANDOS_PARATROOPER_SP, eg_TigerShrek5, nil, 1, 1, false, nil, UPG.ELITE.PANZERSCHRECK)
	Util_CreateSquads (player2, sg_Garrison_Panzershrecks, SBP.CW.COMMANDOS_PARATROOPER_SP, eg_TigerShrek6, nil, 1, 1, false, nil, UPG.ELITE.PANZERSCHRECK)
	Util_CreateSquads (player2, sg_Garrison_Panzershrecks, SBP.CW.COMMANDOS_PARATROOPER_SP, eg_TigerShrek7, nil, 1, 1, false, nil, UPG.ELITE.PANZERSCHRECK)
	
end

-- If the player can see any of the flak 88s or they are under attack, mark that gun as active, get the squad into the gun and get the new sgroup for it
function Monitor_For88Activation()
	
	g_All_88sActive = true
	
	for k, this in pairs(t_arnhem_allies.t_heavyweapon_squads) do 
		
		if this.eg_capture == eg_hq_aa_2 or this.eg_capture == eg_hq_aa_1 then -- If it's a Flakvierling AA gun man the gun
			
			Cmd_CaptureTeamWeapon(this.sg, this.eg_capture)
			
		elseif this.active == false then -- Otherwise it's an 88, man the gun and trigger the monitor rule
			
			g_All_88sActive = false
			
			Cmd_CaptureTeamWeapon (this.sg, this.eg_capture)
			this.active = true
			this.sync_id = SyncWeapon_GetFromEGroup (this.eg_capture)
			if Rule_Exists (Has88BeenCrewed) == false then Rule_AddInterval (Has88BeenCrewed, 1) end
			
		end
		
	end
	
	if g_All_88sActive == true then Rule_RemoveMe() end
	
end

function Has88BeenCrewed()
	
	All_Crewed = true
	
	for k, this in pairs(t_arnhem_allies.t_heavyweapon_squads) do
		
		if this.flak88 == true and this.crewed == false then
			
			All_Crewed = false
			
			if SyncWeapon_IsOwnedByPlayer (this.sync_id, player2) then
				Player_GetAllSquadsNearMarker (player2, this.sg_crewed, this.prox_marker, 5 )
				SGroup_AddGroup (sg_heavyweapons_bigguns, this.sg_crewed)
				this.crewed = true
			end
			
		end
		
	end
	
	if All_Crewed == true then 
		Rule_RemoveMe()
		Rule_AddDelayedInterval (Arnhem_HeavyWeaponsFired, 5, 1)
	end
	
end

-- if the 88 heavy weapon has fired on the player, add a threat arrow for them
function Arnhem_HeavyWeaponsFired()
	
	all_dead = true
	
	for k, this in pairs(t_arnhem_allies.t_heavyweapon_squads) do
		
		-- If the flak hasn't fired yet, modify the accuracy down once
		if this.flak88 == true then
			
			if this.SecondsActive == 0 and this.crewed == true and this.Accuracy_Mod == nil then
				this.Accuracy_Mod = Modify_WeaponAccuracy (this.sg_crewed, "hardpoint_01", 0.1)
				print ("Accuracy modified")
				print (SGroup_GetName (this.sg_crewed))
			end
			
		end
		
		-- If the flak has fired and a certain number of seconds have elapsed (based on difficulty) then remove the accuracy modifier
		if this.flak88 == true then
			
			if this.SecondsActive >= 15 and this.crewed == true and this.Accuracy_Mod ~= false and g_difficulty == GD_EASY then
				Modifier_Remove (this.Accuracy_Mod)
				this.Accuracy_Mod = false
				print ("Accuracy modifier removed")
				print (SGroup_GetName (this.sg_crewed))
				
			elseif this.SecondsActive >= 5 and this.crewed == true and this.Accuracy_Mod ~= false and g_difficulty >= GD_NORMAL then
				Modifier_Remove (this.Accuracy_Mod)
				this.Accuracy_Mod = false
				print ("Accuracy modifier removed")
				print (SGroup_GetName (this.sg_crewed))
				
			end
			
		end
		
		-- If the flak is active and crewed, check if it's attacking and add the threat arrows. Remove them if it's not attacking.
		if this.flak88 == true and this.crewed == true then
			
			if SGroup_IsDoingAttack (this.sg_crewed, ANY, 10) and this.is_attacking == false and this.ThreatArrowCreated == false then
				this.is_attacking = true
				this.SecondsActive = this.SecondsActive + 1
				this.threat_arrow = ThreatArrow_CreateGroup(this.sg_crewed)
				UI_CreateMinimapBlip(this.sg_crewed, 10, BT_CombatPing)
				FOW_RevealArea (Marker_GetPosition (this.prox_marker), 5, 60) 
				if v_Flak88sFired_Speech <= 1 then Arnhem_HeavyWeaponFiredSpeech() end
				this.ThreatArrowCreated = true
				print ("88 is attacking")
				print (SGroup_GetName (this.sg_crewed))
				
			elseif SGroup_IsDoingAttack (this.sg_crewed, ANY, 10) == false and this.is_attacking == true  and this.ThreatArrowCreated == true then
				ThreatArrow_DestroyGroup (this.threat_arrow)
				FOW_UnRevealArea (Marker_GetPosition (this.prox_marker) , 5)
				this.is_attacking = false
				this.ThreatArrowCreated = false
				print ("88 is no longer attacking")
				print (SGroup_GetName (this.sg_crewed))
				
			end
			
			if SGroup_IsDoingAttack (this.sg_crewed, ANY, 10) then
				this.SecondsActive = this.SecondsActive + 1
			end
			
			if SGroup_IsEmpty (this.sg_crewed) == false and this.flak88 == true then 
				all_dead = false
			end
			
		else all_dead = false	
			
		end
		
	end
	
	if all_dead == true then Rule_RemoveMe() end
	
end

function Arnhem_HeavyWeaponFiredSpeech()
	local rand = World_GetRand(1, table.getn(t_TAC_speech.Flak88s))
	Util_AutoIntel (t_TAC_speech.Flak88s[rand])
	v_Flak88sFired_Speech = v_Flak88sFired_Speech + 1
end

	
-- 1. Capture the Bridge before British Reinforcements can arrive
-- 2. Capture the road leading up to, and including, the Bridge
-- Secondary - Take and Hold the Ammunition Dumps to stop the British troops from resupplying
-- Medal - The British are preparing the boats to bring their reinforcements across, destroy them!

-------------------------------------------------------------------------
-- CAPTUREBRIDGE
-------------------------------------------------------------------------
-- Player must now capture the british base
-------------------------------------------------------------------------
function Initialize_OBJ_CaptureBridge()

	OBJ_CaptureBridge = {
		
		SetupUI = function() 
			CaptureBridge_SetupUI()
			
		end,
		
		OnStart = function()
			
			Sound_PlayMusic("Music/SP/OMG/trepidation/OMG/Lurking_invaders.bsc",2,0)
			Sound_PlayStreamed("Ambiences/SP_specific/Crows")
			-- announce the goal
			Util_AutoIntel (t_OBJ_speech.CaptureBridgeStart)
			CaptureBridge_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			-- Util_AutoIntel (t_COMP_speech.MissionComplete_British)
			-- Util_AutoIntel (t_COMP_speech.MissionComplete_German)
			Sound_PlayMusic("Music/SP/OMG/sitreps/OMG/situation_report_1.bsc",2,0)
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1469100,
		Description = 1469110,
		Type = OT_Primary,
		
		SitRep = {
			Movie = "CXP2_SR_06-02",
			Force = true,
			SpeechTiming = -- All timings are PLACEHOLDER!!!!!
			{
				{ 1,	ACTOR.CXP2.Voss, 1465500 },
				{ 10.4,	ACTOR.CXP2.Voss, 1465510 },
				{ 18.6,	ACTOR.CXP2.Voss, 1465520 },
			--	{ 13,	ACTOR.CXP2.Voss, 1465530 }, -- No longer used, July 17 2007 -cmartin
			--	{ 17,	ACTOR.CXP2.Voss, 1465540 }, -- No longer used, July 17 2007 -cmartin
				{ 25.3,	ACTOR.CXP2.Voss, 1465550 },
			--	{ 25,	ACTOR.CXP2.Voss, 1465560 }, -- No longer used, July 17 2007 -cmartin
				{ 34,	ACTOR.CXP2.Voss, 1465570 },
			--	{ 33,	ACTOR.CXP2.Voss, 1465580 }, -- No longer used, July 17 2007 -cmartin
				{ 38.1,	ACTOR.CXP2.Voss, 1465590 },
			},
		},
	}
	
	-- Register Objective
	Objective_Register(OBJ_CaptureBridge)
	-- Initialize Data
	CaptureBridge_Init()
	
end

-------------------------------------------------------------------------
-- CAPTUREBRIDGE - Functions
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function CaptureBridge_Init()

	-- define sgroups, egroups, etc associated with this obj
	t_OBJ_speech.fg_PlayedFirstTerritoryCapped = false
	t_OBJ_speech.fg_PlayedSecondTerritoryCapped = false
	
	v_bridgepoints_owned = 0
	g_BridgePoint1_Capped = false 
	g_BridgePoint2_Capped = false 
	g_BridgePoint3_Capped = false
	
	g_XXXCorps_Spawned = false

	t_BridgePoints_Remaining = {eg_BridgePoint_1, eg_BridgePoint_2, eg_BridgePoint_3}
	
end

-- example of how to finish an Obj
function CaptureBridge_WinCheck()
	
	-- one of them must be set to true before the player can win or lose the objective
	if Player_OwnsEGroup(player1, eg_BridgePoint_1, ALL) == true and g_BridgePoint1_Capped == false then
		v_bridgepoints_owned = v_bridgepoints_owned + 1
		g_BridgePoint1_Capped = true
		for k, this in pairs (t_BridgePoints_Remaining) do
			if this == eg_BridgePoint_1 then table.remove (t_BridgePoints_Remaining, k) end
		end
		Objective_RemoveUIElements(OBJ_CaptureBridge, OBJ_CaptureBridge.mapElementID1)
	end
	
	if Player_OwnsEGroup(player1, eg_BridgePoint_2, ALL) == true  and g_BridgePoint2_Capped == false then
		v_bridgepoints_owned = v_bridgepoints_owned + 1
		g_BridgePoint2_Capped = true
		for k, this in pairs (t_BridgePoints_Remaining) do
			if this == eg_BridgePoint_2 then table.remove (t_BridgePoints_Remaining, k) end
		end
		Objective_RemoveUIElements(OBJ_CaptureBridge, OBJ_CaptureBridge.mapElementID2)		
	end
	
	if Player_OwnsEGroup(player1, eg_BridgePoint_3, ALL) == true and g_BridgePoint3_Capped == false then
		v_bridgepoints_owned = v_bridgepoints_owned + 1
		g_BridgePoint3_Capped = true
		for k, this in pairs (t_BridgePoints_Remaining) do
			if this == eg_BridgePoint_3 then table.remove (t_BridgePoints_Remaining, k) end
		end
		Objective_RemoveUIElements(OBJ_CaptureBridge, OBJ_CaptureBridge.mapElementID3)
	end
	
	if v_bridgepoints_owned == 2 and Player_OwnsEGroup(player1, eg_BridgePoint_3, ALL) == false and g_HasPlayedTakeBridgeSpeech == false then
		g_HasPlayedTakeBridgeSpeech = true
		Util_AutoIntel(t_OBJ_speech.TakeTheBridge)
	end
	
	if v_bridgepoints_owned == 2 and Rule_Exists (CheckForCappingFinalPoint) == false then
		Rule_AddInterval (CheckForCappingFinalPoint, 1)
	end	
	
	-- Player has all the bridgepoints and has completed the secure roads objective
	if v_bridgepoints_owned == 3 then
		-- player has captured all of the base, player is teh winnorz
		Util_AutoIntel(t_OBJ_speech.BridgeDeckSecured)
		Objective_Complete(OBJ_CaptureBridge)
		if Objective_IsComplete (OBJ_SecureRoads) then Rule_AddInterval(Arnhem_MissionEnd, 1) end
		Rule_RemoveMe()
	end
	
	if v_bridgepoints_owned ~= 3 then
		if Objective_GetTimerSeconds (OBJ_CaptureBridge) <= 0 and Objective_IsFailed (OBJ_CaptureBridge) == false then
			Objective_Fail (OBJ_CaptureBridge)
			Rule_RemoveAll()
			Rule_AddInterval(Arnhem_MissionFail, 1)
		end
	end
	
end

function CaptureBridge_SetupUI()
	OBJ_CaptureBridge.mapElementID1 = Objective_AddUIElements(OBJ_CaptureBridge, eg_BridgePoint_1, true, 1469120, true, 2.3)
	OBJ_CaptureBridge.mapElementID2 = Objective_AddUIElements(OBJ_CaptureBridge, eg_BridgePoint_2, true, 1469120, true, 2.3)
	OBJ_CaptureBridge.mapElementID3 = Objective_AddUIElements(OBJ_CaptureBridge, mkr_BridgeVP_HP, true, 1469120, true, 2.3)
end

-- start the related action
function CaptureBridge_Kickoff()
	
	if Rule_Exists(CaptureBridge_WinCheck) == false then
		Rule_AddInterval(CaptureBridge_WinCheck, 1)
	end
	
	Objective_StartTimer (OBJ_CaptureBridge, COUNT_DOWN, 1800, 300)
	
	Rule_RemoveMe()
	
end

function CheckForCappingFinalPoint()
	
	eg_FinalPoint = EGroup_CreateIfNotFound ("eg_FinalPoint")
	sg_FinalPointcappers = SGroup_CreateIfNotFound ("sg_FinalPointcappers")
	
	if table.getn (t_BridgePoints_Remaining) > 0 then
		EGroup_AddEGroup (eg_FinalPoint, t_BridgePoints_Remaining[1])
	end
		
	Player_GetAllSquadsNearMarker (player1, sg_FinalPointcappers, EGroup_GetPosition (eg_FinalPoint), 20)
	if SGroup_IsCapturing (sg_FinalPointcappers, ANY) and g_LaunchedFinalCounterattack == false then
				g_LastPoint = SGroup_GetPosition (sg_FinalPointcappers)
		g_LaunchedFinalCounterattack = true
				FinalCounterattack()
		Rule_RemoveMe()
	end
	
end

function FinalCounterattack()
	
	local pos = World_GetHiddenPositionOnPath(player1, mkr_FinalCounterAttack_Spawn1, mkr_HQ2_Offmap, CHECK_OFFCAMERA)
	if pos == nil then pos = mkr_HQ2_Offmap end
	
	sg_FinalAttackers_Transports = SGroup_CreateIfNotFound ("sg_FinalAttackers_Transports")
	sg_FinalAttackers_Transport1 = SGroup_CreateIfNotFound ("sg_FinalAttackers_Transport1")
	sg_FinalAttackers_Transport2 = SGroup_CreateIfNotFound ("sg_FinalAttackers_Transport2")
	sg_FinalAttackers_Commandos = SGroup_CreateIfNotFound ("sg_FinalAttackers_Commandos")
	sg_FinalAttackers_Commando1 = SGroup_CreateIfNotFound ("sg_FinalAttackers_Commando1")
	sg_FinalAttackers_Commando2 = SGroup_CreateIfNotFound ("sg_FinalAttackers_Commando2")
	sg_FinalAttackers_Jeep = SGroup_CreateIfNotFound ("sg_FinalAttackers_Jeep")
	sg_FinalAttackers_All = SGroup_CreateIfNotFound ("sg_FinalAttackers_All")
	
	Util_CreateSquads (player2, sg_FinalAttackers_Transport1, SBP.CW.BREN_CARRIER, pos, nil, 1)
	SGroup_AddGroup (sg_FinalAttackers_Transports, sg_FinalAttackers_Transport1)
	SGroup_AddGroup (sg_FinalAttackers_All, sg_FinalAttackers_Transports)
	
	if g_difficulty >= GD_NORMAL then
		Util_CreateSquads (player2, sg_FinalAttackers_Transport2, SBP.CW.BREN_CARRIER, pos, nil, 1)
		SGroup_AddGroup (sg_FinalAttackers_Transports, sg_FinalAttackers_Transport2)
		SGroup_AddGroup (sg_FinalAttackers_All, sg_FinalAttackers_Transports)
	end
	
	Util_CreateSquads (player2, sg_FinalAttackers_Commando1, SBP.CW.COMMANDOS, sg_FinalAttackers_Transport1, nil, 1)
	SGroup_AddGroup (sg_FinalAttackers_Commandos, sg_FinalAttackers_Commando1)
	SGroup_AddGroup (sg_FinalAttackers_All, sg_FinalAttackers_Commandos)
	
	if g_difficulty >= GD_NORMAL then
		Util_CreateSquads (player2, sg_FinalAttackers_Commando2, SBP.CW.COMMANDOS, sg_FinalAttackers_Transport2, nil, 1)
		SGroup_AddGroup (sg_FinalAttackers_Commandos, sg_FinalAttackers_Commando2)
		SGroup_AddGroup (sg_FinalAttackers_All, sg_FinalAttackers_Commandos)
	end
	
	Util_CreateSquads (player2, sg_FinalAttackers_Jeep, SBP.CW.COMMANDOS_JEEP, pos, nil, 1)
	SGroup_AddGroup (sg_FinalAttackers_All, sg_FinalAttackers_Jeep)
	
	EventCue_Create (CUE.NORMAL, 1469906, 1469906, sg_FinalAttackers_All) -- Event cue the ambush
	if Rule_Exists (FinalCounterattack_Monitor) == false then Rule_AddInterval (FinalCounterattack_Monitor, 1) end
	
end

function FinalCounterattack_Monitor()
	
	local Attacker = SGroup_CreateIfNotFound ("Attacker")
	
	if SGroup_IsEmpty (sg_FinalAttackers_All) == false then
		if SGroup_IsIdle (sg_FinalAttackers_All, ALL) then
			Cmd_AttackMove (sg_FinalAttackers_All, g_LastPoint)
		end
	end
	
	if SGroup_IsEmpty (sg_FinalAttackers_Commandos) == false then
		if SGroup_IsDoingAttack (sg_FinalAttackers_Commandos, ALL, 10) and Prox_AreSquadsNearMarker (sg_FinalAttackers_All, g_LastPoint, ANY, 10) then
			Cmd_UngarrisonSquad (sg_FinalAttackers_Commandos)
			SGroup_GetLastAttacker (sg_FinalAttackers_Commandos, Attacker)
			if SGroup_CountSpawned(Attacker) > 0 then
				Cmd_AttackMove (sg_FinalAttackers_Commandos, Attacker)
			end
		end
	end
	
	--[[
	-- Get back in transports if not attacking and sitting around
	if SGroup_IsIdle (sg_FinalAttackers_Commandos, ALL) and SGroup_IsHoldingAny (sg_FinalAttackers_Transports) == false then
		if SGroup_IsEmpty (sg_FinalAttackers_Commando1) == false and SGroup_IsEmpty (sg_FinalAttackers_Transport1) == false then 
			Cmd_Garrison (sg_FinalAttackers_Commando1, sg_FinalAttackers_Transport1)
		end
	end
	--]]
	
	if SGroup_TotalMembersCount (sg_FinalAttackers_Commandos) <= 4 then
		if SGroup_IsHoldingAny (sg_FinalAttackers_Transports) == true then Cmd_UngarrisonSquad (sg_FinalAttackers_Commandos) end
		Cmd_Surrender (sg_FinalAttackers_Commandos)
		Cmd_Move (sg_FinalAttackers_Transports, mkr_HQ2_Offmap, false, mkr_HQ2_Offmap)
		Cmd_Move (sg_FinalAttackers_Jeep, mkr_HQ2_Offmap, false, mkr_HQ2_Offmap)
		Rule_RemoveMe()
	end
	
end

function Delay_XXXCorps()

	-- Bring on XXX Corps
	if Prox_ArePlayersNearMarker (player1, mkr_intersectionG, ANY, 20) then
		if g_XXXCorps_Spawned == false then
			XXXCorps_Arrives()
			g_XXXCorps_Spawned = true
			Rule_RemoveMe()
		end
	end
	
end

function XXXCorps_Arrives()
	
	g_XXXCorps_Spawned = true
	g_XXXCorps_SecondWave = false
	
	sg_XXXCorps_Shermans = SGroup_CreateIfNotFound ("sg_XXXCorps_Shermans")
	sg_XXXCorps_Sherman1 = SGroup_CreateIfNotFound ("sg_XXXCorps_Sherman1")
	sg_XXXCorps_Sherman2 = SGroup_CreateIfNotFound ("sg_XXXCorps_Sherman2")
	sg_XXXCorps_Fireflies = SGroup_CreateIfNotFound ("sg_XXXCorps_Fireflies")
	sg_XXXCorps_Stuarts = SGroup_CreateIfNotFound ("sg_XXXCorps_Stuarts")
	sg_XXXCorps_Stuart1 = SGroup_CreateIfNotFound ("sg_XXXCorps_Stuart1")
	sg_XXXCorps_Stuart2 = SGroup_CreateIfNotFound ("sg_XXXCorps_Stuart2")
	sg_XXXCorps_All = SGroup_CreateIfNotFound ("sg_XXXCorps_All")
	
	t_arnhem_allies.XXXCorps = {
		
		{
			sg = sg_XXXCorps_Sherman1,
			sbp = SBP.ALLIES.SHERMAN,
			dest = mkr_XXXCorps_Dest1,
			arrived = false,
			spawned = false,
		},
		
		{
			sg = sg_XXXCorps_Sherman2,
			sbp = SBP.ALLIES.SHERMAN,
			dest = mkr_XXXCorps_Dest2,
			arrived = false,
			spawned = false,
		},
		
		{
			sg = sg_XXXCorps_Stuart1,
			sbp = SBP.CW.STUART,
			dest = mkr_XXXCorps_Dest5,
			arrived = false,
			spawned = false,
		},
		
		{
			sg = sg_XXXCorps_Stuart2,
			sbp = SBP.CW.STUART,
			dest = mkr_XXXCorps_Dest5,
			arrived = false,
			spawned = false,
		},
		
	}
	
	if g_difficulty == GD_EASY then
		table.remove (t_arnhem_allies.XXXCorps, 3)
		table.remove (t_arnhem_allies.XXXCorps, 3) -- was entry 4
	elseif g_difficulty == GD_NORMAL then
		table.remove (t_arnhem_allies.XXXCorps, 3)
	end
	
	t_XXXCorps_All = {}
	t_XXXCorps_Stuarts = {}
	t_XXXCorps_Shermans = {}
	
	for i=1, table.getn (t_arnhem_allies.XXXCorps) do
		table.insert (t_XXXCorps_All, t_arnhem_allies.XXXCorps[i].sg)
		if t_arnhem_allies.XXXCorps[i].sbp == SBP.ALLIES.SHERMAN then 
			table.insert (t_XXXCorps_Shermans, t_arnhem_allies.XXXCorps[i].sg)
		elseif t_arnhem_allies.XXXCorps[i].sbp == SBP.CW.STUART then 
			table.insert (t_XXXCorps_Stuarts, t_arnhem_allies.XXXCorps[i].sg)
		end
	end
	
	Rule_AddInterval (Spawn_XXXCorps, 6)
	
end

function Spawn_XXXCorps()
	
	local pos = World_GetHiddenPositionOnPath(player1, mkr_HQ_BunkerTroops, mkr_XXXCorps_MapEntry, CHECK_OFFCAMERA)
	if pos == nil then pos = mkr_XXXCorps_MapEntry end
	
	Spawn_Complete = true
	
	g_XXXCorps_Deployed = false
	g_XXXCorps_Target = false
	
	for k, this in pairs (t_arnhem_allies.XXXCorps) do
		if this.spawned == false then
			Spawn_Complete = false
			Util_CreateSquads (player4, this.sg, this.sbp, pos)
			if this.sbp == SBP.ALLIES.SHERMAN then SGroup_AddGroup (sg_XXXCorps_Shermans, this.sg)
			elseif this.sbp == SBP.CW.STUART then SGroup_AddGroup (sg_XXXCorps_Stuarts, this.sg)
			end
			SGroup_AddGroup (sg_XXXCorps_All, this.sg)
			Cmd_AttackMove (this.sg, this.dest)
			this.spawned = true
			return
		end
	end
	
	if Spawn_Complete == true then 
	Rule_AddInterval (Monitor_XXXCorps, 1)
		Rule_RemoveMe()
		Util_AutoIntel (t_TAC_speech.XXXCorpsArrives)
	end
	
end


function Monitor_XXXCorps()
	
	g_XXXCorpsReadytoRoll = true
	
	if g_XXXCorps_Deployed == false then
		
		for k, this in pairs (t_arnhem_allies.XXXCorps) do 
			
			if Prox_AreSquadsNearMarker (this.sg, this.dest, ALL, 10) == true then 
				this.arrived = true
			else g_XXXCorpsReadytoRoll = false
			end
			
		end
		
		if g_XXXCorpsReadytoRoll == true or SGroup_IsUnderAttack (sg_XXXCorps_All, ANY, 30) then
			g_XXXCorps_Deployed = true
		end
		
	end
	
	if g_XXXCorpsReadytoRoll == true then
		
		if g_XXXCorps_Target == false then 
			
			if g_difficulty <= GD_NORMAL then
				g_XXCorps_TankGroup = TankCombat_AddGroup (t_XXXCorps_All, mkr_attackers_playersbase_1)
				g_XXXCorps_Target = true
			else
				g_XXCorps_TankGroup_Shermans = TankCombat_AddGroup (t_XXXCorps_Shermans, mkr_attackers_playersbase_1)
				g_XXCorps_TankGroup_Stuart = TankCombat_AddGroup (t_XXXCorps_Stuarts, mkr_attackers_playersbase_1)
				g_XXXCorps_Target = true
			end	
			
		end
		
	end
	
	if SGroup_IsEmpty (sg_XXXCorps_Shermans) and g_XXXCorps_SecondWave == false then
		local pos = World_GetHiddenPositionOnPath(player1, mkr_HQ_BunkerTroops, mkr_XXXCorps_MapEntry, CHECK_OFFCAMERA)
		if pos == nil then pos = mkr_XXXCorps_MapEntry end
		
		Util_CreateSquads (player4, sg_XXXCorps_Sherman1, SBP.ALLIES.SHERMAN, pos, mkr_HQ_BunkerTroops)
		Util_CreateSquads (player4, sg_XXXCorps_Sherman2, SBP.ALLIES.SHERMAN, pos, mkr_HQ_BunkerTroops)
		
		TankCombat_RemoveGroup (g_XXCorps_TankGroup_Shermans)
		TankCombat_AddGroup (t_XXXCorps_Shermans, mkr_attackers_playersbase_1)
		
		g_XXXCorps_SecondWave = true
		
	end
	
end

-------------------------------------------------------------------------
-- SUPPLY DEPOTS
-------------------------------------------------------------------------
-- Player must capture the supply depots
-------------------------------------------------------------------------
function Initialize_OBJ_SupplyDepot()

	OBJ_SupplyDepot = {
		
		SetupUI = function() 
			-- mark a point or position
		end,
		
		OnStart = function()
			
			-- start related action
			SupplyDepot_Kickoff()
			for k, this in pairs (t_supplydepot_spstate) do
				this.active = true
			end
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			for k, this in pairs (t_supplydepot_spstate) do
				this.state = 3
				HintPoint_Remove (this.hintpoint)
			end
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1469200,
		Description = 1469210,
		Type = OT_Secondary,
	}
	
	-- Register Objective
	Objective_Register(OBJ_SupplyDepot)
	-- Initialize Data
	SupplyDepot_Init()
	
end

-------------------------------------------------------------------------
-- SUPPLY DEPOTS - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function SupplyDepot_Init()

	-- define sgroups, egroups, etc associated with this obj
	-- Nebs	
	sg_PanzerIVStubby = SGroup_CreateIfNotFound ("sg_PanzerIVStubby")
	sg_Flammenwerfer = SGroup_CreateIfNotFound ("sg_Flammenwerfer")
	sg_attackers_supplydepot_1 = SGroup_CreateIfNotFound("sg_attackers_supplydepot_1")
	sg_attackers_supplydepot_2 = SGroup_CreateIfNotFound("sg_attackers_supplydepot_2")
	sg_attackers_supplydepot_3 = SGroup_CreateIfNotFound("sg_attackers_supplydepot_3")
	eg_TellerMine1_depot1 = EGroup_CreateIfNotFound ("eg_TellerMine1_depot1")
	eg_TellerMine2_depot1 = EGroup_CreateIfNotFound ("eg_TellerMine2_depot1")
	
	g_Depot1Captured = false
	g_Depot2Captured = false
	
	t_arnhem_allies.t_supply_depot_retake = {
		
		-- Spawn 1
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_supdep_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_hq_spawn_sd_assaults,
			dest = mkr_hq_spawn_sd_assaults,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
		},
		
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_supdep_2"),
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_hq_spawn_sd_assaults,
			dest = mkr_hq_spawn_sd_assaults,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
		},		
		
	}
	
	-- this table is used to track the capture states of the ammunition dumps and respond accodingly as the states shift
	-- states:
	-- 0 = held by ally
	-- 1 = held by player	
	-- 2 = held by neither
	-- 3 = secured by Scout Car
	t_supplydepot_spstate = {
		{ 
			active = false,
			point = eg_SupplyDepot_1,
			state = 0,
			-- we use this to determine if the number of times captured is odd or even, thereby telling us whether we should recreate the ping or not
			-- each time its captured we increase the value by 1			
			timescaptured = 0,
			timesattacked = 0,
			ping = 1,
			hintpoint = 11,
			bonus_speech = t_TAC_speech.StubbyRecovered,
			firstcapturedspeech = null,
			encounter_sg = sg_intersections_C_all,
			
		},
		{ 
			active = false,
			point = eg_SupplyDepot_2,
			state = 0, 
			timescaptured = 0,
			timesattacked = 0,
			hintpoint = 12,
			ping = 3,
			bonus_speech = nil,
			firstcapturedspeech = null,
			encounter_sg = sg_intersections_F_all,
		},
	}
	
	SupplyDepot_abandonedFlaks = false
	SupplyDepot_abandonedNebs = false
	
	Modify_AbilityMaxCastRange( player2, ABILITY.AXIS.NEB_BARRAGE, 10 )

end

function SupplyDepot_Kickoff()

	-- action that starts with the Obj being granted	
	for k, this in pairs (t_supplydepot_spstate) do
		this.ping = Objective_AddUIElements(OBJ_SupplyDepot, this.point, true, 1469220, true, 2.3)
	end
	
	Rule_AddInterval( SupplyDepots_Retake, 120 )
	
	Rule_AddInterval(SupplyDepot_WinCheck, 1)
	
	Rule_AddInterval( SupplyDepot_Watcher, 1 )
	
	Util_CreateSquads (player3, sg_PanzerIVStubby, SBP.ELITE.PANZER_SUPPORT, mkr_PanzerIVStubby_spawn)
	Util_CreateSquads (player3, sg_Flammenwerfer, SBP.AXIS.HALFTRACK_FLAME, mkr_Flammenwerfer_spawn)
	
end

function SupplyDepot_DelayObjStart()

	for k, this in pairs(t_supplydepot_spstate) do
		SGroup_Clear(sg_temp)
		Player_GetAllSquadsNearMarker(player1, sg_temp, Util_GetPosition(this.point), 60)
		
		if SGroup_IsEmpty(sg_temp) == false then
			Objective_Start(OBJ_SupplyDepot)
			Rule_RemoveMe()
			return
		end
	end

end

-- example of how to finish an Obj
function SupplyDepot_WinCheck()

	if Player_OwnsEGroup (player1, eg_SupplyDepot_2) and g_Depot2Captured == false then
		
		g_Depot2Captured = true
		
		-- Depot 2 is the flak 88 supply centre
		Util_AutoIntel (t_TAC_speech.FlakDepot)
		
		if Player_OwnsEGroup (player1, eg_SupplyDepot_1) == false then
			Util_AutoIntel (t_COMP_speech.CapturedDepot1)
			Util_AutoIntel(t_OBJ_speech.FirstDepotCaptured)
			if Event_IsAnyRunning () == false then
				local rand = World_GetRand(1, table.getn(t_AMBI_speech.CapturedDepot1))
				Util_AutoAmbient (t_AMBI_speech.CapturedDepot1[rand])
			end
		end
		for k, this in pairs (t_arnhem_allies.t_heavyweapon_squads) do
			Cmd_AbandonTeamWeapon (sg_heavyweapons_bigguns, false)
		end
		
		SupplyDepot_abandonedFlaks = true
		
	end
	
	-- Depot 1 is the Neb ammo supply, if it's been captured then stop firing Nebs, then blow the place up
	if Player_OwnsEGroup (player1, eg_SupplyDepot_1) and g_Depot1Captured == false then
		
		g_Depot1Captured = true
		
		if Rule_Exists (SupplyDepots_FireNebs) then
			Util_AutoIntel (t_TAC_speech.NebDepot)
			Rule_Remove( SupplyDepots_FireNebs )
			Cmd_AbandonTeamWeapon (sg_supplydepot_nebs, false)
			SupplyDepot_abandonedNebs = true
		end
		if Player_OwnsEGroup (player1, eg_SupplyDepot_2) == false then
			Util_AutoIntel (t_COMP_speech.CapturedDepot1)
			Util_AutoIntel(t_OBJ_speech.FirstDepotCaptured)
			if Event_IsAnyRunning () == false then
				local rand = World_GetRand(1, table.getn(t_AMBI_speech.CapturedDepot1))
				Util_AutoAmbient (t_AMBI_speech.CapturedDepot1[rand])
			end
		end
		
	end	
	
	-- Both depots captured and secured
	if ( Player_OwnsEGroup (player1, eg_SupplyDepot_1) and Player_OwnsEGroup (player1, eg_SupplyDepot_2) ) or
	( t_supplydepot_spstate[1].state == 3 and t_supplydepot_spstate[2].state == 3 ) then
		
		Util_AutoIntel (t_COMP_speech.CapturedDepot2)
		Util_AutoIntel(t_OBJ_speech.BothDepotsCaptured)
		if Event_IsAnyRunning () == false then
			local rand = World_GetRand(1, table.getn(t_AMBI_speech.CapturedDepot2))
			Util_AutoAmbient (t_AMBI_speech.CapturedDepot2[rand])
		end
		Objective_Complete (OBJ_SupplyDepot)
		
		if not SGroup_IsEmpty(sg_attackers_supplydepot_1) then
			Cmd_Retreat( sg_attackers_supplydepot_1 )
		end
		if not SGroup_IsEmpty(sg_attackers_supplydepot_2) then
			Cmd_Retreat( sg_attackers_supplydepot_2 )
		end
		
		Rule_RemoveMe()
		
	end
	
end


-- this function watches both supply depots and sets their state based on capture status
function SupplyDepot_Watcher()

	for k, this in pairs (t_supplydepot_spstate) do
		
		if this.state ~= 1 and this.state~= 3 and SGroup_IsDoingAttack (this.encounter_sg, ANY, 30) == true and Timer_GetRemaining (g_SupplySpeechTimer) <= 0 then
			if Prox_ArePlayersNearMarker (player1, EGroup_GetPosition (this.point), ANY, 30) then
				if Event_IsAnyRunning () == false then
					local rand = World_GetRand(1, table.getn(t_AMBI_speech.SupplyDepots))
					Util_AutoAmbient (t_AMBI_speech.SupplyDepots[rand])
				end
				Timer_Start (g_SupplySpeechTimer, 30)
			end
		end
		
		if this.active then
			
			-- if the player owns the point and they didnt own the point already based on state tracking
			if Player_OwnsEGroup(player1, this.point, ALL) == true and this.state ~= 1 and this.state ~= 3 then
				this.state = 1
				
				-- this is the first time the player has captured the point
				if this.timescaptured == 0 then
					
					if this.point == eg_SupplyDepot_2 then
						SGroup_SetPlayerOwner( sg_Flammenwerfer, player1 )
						g_Flammenwerfer_HPID = EventCue_Create (CUE.NORMAL_REPEATING, 1469212, 1469212, sg_Flammenwerfer)
						Rule_AddOneShot (RemoveHintPoint_Halftrack, 30)
						SGroup_SetPlayerOwner( sg_PanzerIVStubby, player1 )
						g_PanzerIVStubby_HPID = EventCue_Create (CUE.NORMAL_REPEATING, 1469211, 1469211, sg_PanzerIVStubby)
						Rule_AddOneShot (RemoveHintPoint_Panzer, 30) 
					end
					
				end
				
				this.timescaptured = this.timescaptured + 1
				
				Objective_RemoveUIElements (OBJ_SupplyDepot, this.ping)
				
				this.hintpoint = HintPoint_Add (this.point, true, 1469230)
				
				
			-- if the player owns the point already, then check to see if it's locked down by a scout car
			elseif Player_OwnsEGroup(player1, this.point, ALL) == true and this.state == 1 and this.state ~= 3 then
				local ScoutCar = SGroup_CreateIfNotFound ("ScoutCar")
				Player_GetAllSquadsNearMarker (player1, ScoutCar, World_GetTerritorySectorID(Util_GetPosition(this.point)))
				SGroup_Filter (ScoutCar, SBP.ELITE.ARMOURCAR_221, FILTER_KEEP)
				-- If the player has a scout car using an ability (lockdown) then the point is state 3, otherwise no change
				if SGroup_Count (ScoutCar) ~= 0 then
					if SGroup_IsUsingAbility (ScoutCar, ANY) then 
						
						this.state = 3 -- it's locked down
						HintPoint_Remove (this.hintpoint)
						
						-- If there are supply depot attackers, then retreat them
						if not SGroup_IsEmpty(sg_attackers_supplydepot_1) then
							Cmd_Retreat( sg_attackers_supplydepot_1 )
						end
						
					end
					
				end
				
				
			-- Check to see of the point has been disabled by the Scorched Earth commander tree ability	
			elseif Modifier_IsEnabledOnEGroup(this.point, "modifiers\\enable_capture_entity_modifier.lua", ANY, true) == false then
				
				this.state = 3 -- it's locked down
				HintPoint_Remove (this.hintpoint)
				
				-- If there are supply depot attackers, then retreat them
				if not SGroup_IsEmpty(sg_attackers_supplydepot_1) then
					Cmd_Retreat( sg_attackers_supplydepot_1 )
				end
				
				
				
			-- if the ally owns the point and they didnt own the point already based on state tracking
			elseif Player_OwnsEGroup(player2, this.point, ALL) == true and this.state ~= 0 then
				-- we are here because the state has changed!
				this.state = 0
				
				-- this is the first time the ally have taken back a point
				if this.timescaptured >= 1 then
					Util_AutoIntel(t_TAC_speech.DepotRetaken)
				end
				
				this.timescaptured = this.timescaptured + 1
				Objective_RemoveUIElements (OBJ_SupplyDepot, this.ping)
				this.ping = Objective_AddUIElements(OBJ_SupplyDepot, this.point, true, 1469220, true, 2.3)
				
				
			-- if the noone owns the point and it wasnt already owned based on state tracking
			elseif Player_OwnsEGroup(player1, this.point, ALL) == false and 
					Player_OwnsEGroup(player2, this.point, ALL) == false and 
					Modifier_IsEnabledOnEGroup(this.point, "modifiers\\enable_capture_entity_modifier.lua", ANY, true) == true and
					this.state ~= 2 and this.state ~= 3 then
					
				-- we are here because the state has changed!
				this.state = 2		
				
				-- this is the first time the ally are taking a point
				if this.timescaptured == 1 then
					Util_AutoIntel(t_TAC_speech.BritishAttackingDepot)
				end
				
			end	
			
		end
		
	end

end

-- Wire the tram building with demolition charges and spawn the tellermines to go boom
function Depot1_WireDemolitions()
	
	g_SupplyDepotDetonated = false
	
	-- Reveal FOW so that player can always see the stuff blow up and the troops retreat
	FOW_RevealEGroupOnly (eg_IntersectionC_BlowBuilding, 20)
	FOW_RevealMarker (mkr_intersectionC_capture, 20)
	
	if EGroup_IsEmpty(eg_IntersectionC_BlowBuilding) == false then
		EGroup_SetDemolitions(player2, eg_IntersectionC_BlowBuilding)
	end
	
	Rule_AddInterval (Depot1_Detonate, 1)
	
end

-- Blow shit up slightly delayed for more epic boom
function Depot1_Detonate()
	
	if Prox_ArePlayersNearMarker (player2, World_GetTerritorySectorID ( Util_GetPosition (eg_SupplyDepot_1) ), ALL) == false and g_SupplyDepotDetonated == false then
		-- detonate
		Cmd_DetonateDemolitions(player2, eg_IntersectionC_BlowBuilding)
		EGroup_Kill (eg_IntersectionC_BlowBuilding)
		g_SupplyDepotDetonated = true
		Rule_AddOneShot (Tellermine1_Detonate, 1)
		Rule_RemoveMe()
	end
	
end

function Tellermine1_Detonate()
	Util_CreateEntities (player2, eg_TellerMine1_depot1, EBP.ELITE.MINE_TELLER, mkr_intersectionC_demo1, 1)
	EGroup_Kill (eg_TellerMine1_depot1)
	Rule_AddOneShot (Tellermine2_Detonate, 1)
end

function Tellermine2_Detonate()
	Util_CreateEntities (player2, eg_TellerMine2_depot1, EBP.ELITE.MINE_TELLER, mkr_intersectionC_demo2, 1)
	EGroup_Kill (eg_TellerMine2_depot1)
end

function RemoveHintPoint_Panzer()
	
	HintPoint_Remove (g_PanzerIVStubby_HPID)

end

function RemoveHintPoint_Halftrack()

	HintPoint_Remove (g_Flammenwerfer_HPID)

end

function SupplyDepots_Retake()
	
	if Objective_IsComplete(OBJ_SupplyDepot) then
		Rule_RemoveMe()
		return
	end
	
	if Player_OwnsEGroup (player1, eg_SupplyDepot_1, ALL) == true 
	and SGroup_Count (sg_attackers_supplydepot_1) == 0 
	and t_supplydepot_spstate[1].state ~= 3 
	and t_supplydepot_spstate[1].timesattacked < 3 then
		if not Rule_Exists (SupplyDepot_Retake_1) then
			Rule_AddOneShot (SupplyDepot_Retake_1, 2)
			t_supplydepot_spstate[1].timesattacked = t_supplydepot_spstate[1].timesattacked + 1
		end
	elseif t_supplydepot_spstate[1].timesattacked >= 3 then
		t_supplydepot_spstate[1].state = 3
		HintPoint_Remove (t_supplydepot_spstate[1].hintpoint)
	end
	
	if Player_OwnsEGroup (player1, eg_SupplyDepot_2, ALL) == true 
	and SGroup_Count (sg_attackers_supplydepot_2) == 0 
	and t_supplydepot_spstate[2].state ~= 3 
	and t_supplydepot_spstate[2].timesattacked < 3 then
		if not Rule_Exists (SupplyDepot_Retake_2) then
			Rule_AddOneShot (SupplyDepot_Retake_2, 2)
			t_supplydepot_spstate[2].timesattacked = t_supplydepot_spstate[2].timesattacked + 1
		end
	elseif t_supplydepot_spstate[2].timesattacked >= 3 then
		t_supplydepot_spstate[2].state = 3
		HintPoint_Remove (t_supplydepot_spstate[2].hintpoint)
	end

end

function SupplyDepot_Retake_1()
	-- depot 1 is taken, spawn some dudes and order them to take it back
	for k, this in pairs (t_arnhem_allies.t_supply_depot_retake) do
		Util_CreateSquads(player2, sg_attackers_supplydepot_1, this.sbp, mkr_hq_spawn_sd_assaults_1, mkr_hq_spawn_sd_assaults_1, this.number, this.load, this.attackmove, this.pos_facing, this.upgrade)
	end	
	
	v_retake1_path = World_GetRand( 1, 3 )
	
	if v_retake1_path == 1 then
		Cmd_SquadPath( sg_attackers_supplydepot_1, "wp_Retake1_Path_1", true, 0, false, 0 )
	elseif v_retake1_path == 2 then
		Cmd_SquadPath( sg_attackers_supplydepot_1, "wp_Retake1_Path_2", true, 0, false, 0 )
	elseif v_retake1_path == 3 then
		Cmd_SquadPath( sg_attackers_supplydepot_1, "wp_Retake1_Path_3", true, 0, false, 0 )
	end
	
	if not Rule_Exists(SupplyDepot_Retake_1_CapPoint) then
		Rule_AddInterval(SupplyDepot_Retake_1_CapPoint, 3 )
	end
end

-- when in proximity get the squad to capture the point
function SupplyDepot_Retake_1_CapPoint()

	if not SGroup_IsEmpty( sg_attackers_supplydepot_1 ) 
	and Prox_AreSquadsNearMarker( sg_attackers_supplydepot_1, mkr_intersectionC_capture, false ) then
		Cmd_AttackMoveThenCapture( sg_attackers_supplydepot_1, eg_SupplyDepot_1 )
		Rule_RemoveMe()
	end
	
	if t_supplydepot_spstate[1].state == 3 then
		if SGroup_IsIdle (sg_attackers_supplydepot_1, ALL) and Player_CanSeeSGroup (player1, sg_attackers_supplydepot_1, ALL) == false then SGroup_DestroyAllSquads (sg_attackers_supplydepot_1) end
		Rule_RemoveMe()
	end
	
end

-- hmmm so options
-- 1. scout out the enemy position and determine what they have
-- 2. rain hell with nebs
-- 3. throw in an assault that has some counters to what the player has
-- 4. try to lure the player away from the point
-- 5. hammer it with artillery
-- 6. mass troop rush
-- 7. assault from many sides at once
-- 8. charge in bren carriers
-- 9. use the buildings surrounding the point and fire from them
-- 10. 


function SupplyDepot_Retake_2()
	for k, this in pairs (t_arnhem_allies.t_supply_depot_retake) do
		Util_CreateSquads(player2, sg_attackers_supplydepot_2, this.sbp, mkr_hq_spawn_sd_assaults_2, mkr_hq_spawn_sd_assaults_2, this.number, this.load, this.attackmove, this.pos_facing, this.upgrade)
	end	
	
	v_retake2_path = World_GetRand( 1, 3 )
	
	if v_retake2_path == 1 then
		Cmd_SquadPath( sg_attackers_supplydepot_2, "wp_Retake2_Path_1", true, 0, false, 0 )
	elseif v_retake2_path == 2 then
		Cmd_SquadPath( sg_attackers_supplydepot_2, "wp_Retake2_Path_2", true, 0, false, 0 )
	elseif v_retake2_path == 3 then
		Cmd_SquadPath( sg_attackers_supplydepot_2, "wp_Retake2_Path_3", true, 0, false, 0 )
	end
	
	if not Rule_Exists(SupplyDepot_Retake_2_CapPoint) then
		Rule_AddInterval(SupplyDepot_Retake_2_CapPoint, 3 )
	end

end

-- when in proximity get the squad to capture the point
function SupplyDepot_Retake_2_CapPoint()

	if not SGroup_IsEmpty( sg_attackers_supplydepot_2 ) 
	and Prox_AreSquadsNearMarker( sg_attackers_supplydepot_2, EGroup_GetPosition (eg_SupplyDepot_2), false, 30 ) then
		Cmd_AttackMoveThenCapture( sg_attackers_supplydepot_2, eg_SupplyDepot_2 )
		Rule_RemoveMe()
	end
	
	if t_supplydepot_spstate[2].state == 3 then
		if SGroup_IsIdle (sg_attackers_supplydepot_2, ALL) and Player_CanSeeSGroup (player1, sg_attackers_supplydepot_2, ALL) == false then SGroup_DestroyAllSquads (sg_attackers_supplydepot_2) end
		Rule_RemoveMe()
	end
	
end

-------------------------------------------------------------------------
-- DESTROY BOATS
-------------------------------------------------------------------------
-- Medal objective related to the boats
-------------------------------------------------------------------------
function Initialize_OBJ_DestroyBoats()

	OBJ_DestroyBoats = {
		
		SetupUI = function() 
			
			
		end,
		
		OnStart = function()
			
			-- announce the goal
			Util_AutoIntel(t_OBJ_speech.DestroyBoats)
			
			-- start related action
			DestroyBoats_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			Util_AutoIntel(t_OBJ_speech.MedalEarned)
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1469500,
		Description = 1469510,
		Type = OT_Medal,
		MedalID = MEDALS.CXP2.ARNHEM,
		
	}
	
	-- Register Objective
	Objective_Register(OBJ_DestroyBoats)
	-- Initialize Data
	DestroyBoats_Init()
	
end

-------------------------------------------------------------------------
-- DESTROY BOATS (Medal Objective) - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function DestroyBoats_Init()

	-- define sgroups, egroups, etc associated with this obj
	sg_starting_units = SGroup_CreateIfNotFound("sg_starting_units")
	g_LastBoatCount = 0
	
end

-- example of how to finish an Obj
function DestroyBoats_WinCheck()

	if EGroup_Count(eg_Boats) == 0 then
		Objective_Complete(OBJ_DestroyBoats)
		Rule_RemoveMe()
	elseif EGroup_Count(eg_Boats) < g_LastBoatCount then
		if Event_IsAnyRunning () == false then
			local rand = World_GetRand ( 1, table.getn (t_AMBI_speech.BoatSunk) )
			Util_AutoAmbient (t_AMBI_speech.BoatSunk[rand])
		end
		g_LastBoatCount = EGroup_Count(eg_Boats)
	else
		g_LastBoatCount = EGroup_Count(eg_Boats)
	end
	
end

-- start the related action
function DestroyBoats_Kickoff()	
	
	Boat1_pos = EGroup_GetPosition (eg_Boat1)
	EGroup_DestroyAllEntities (eg_Boat1)
	Util_CreateEntities (player2, eg_Boat1, EBP.SP.SP_RIVERBARGE, Boat1_pos, 1, mkr_boat1_facing)
	EGroup_AddEGroup (eg_Boats, eg_Boat1)
	
	Boat2_pos = EGroup_GetPosition (eg_Boat2)
	EGroup_DestroyAllEntities (eg_Boat2)
	Util_CreateEntities (player2, eg_Boat2, EBP.SP.SP_RIVERBARGE, Boat2_pos, 1, mkr_boat2_facing)
	EGroup_AddEGroup (eg_Boats, eg_Boat2)
	
	Boat3_pos = EGroup_GetPosition (eg_Boat3)
	EGroup_DestroyAllEntities (eg_Boat3)
	Util_CreateEntities (player2, eg_Boat3, EBP.SP.SP_RIVERBARGE, Boat3_pos, 1, mkr_boat3_facing)
	EGroup_AddEGroup (eg_Boats, eg_Boat3)
	
	-- mark a point or position
	OBJ_DestroyBoats.mapElementID1 = Objective_AddUIElements(OBJ_DestroyBoats, eg_Boats, true, 1469520, true)
	
	Rule_AddInterval(DestroyBoats_WinCheck, 5)
	
end









-------------------------------------------------------------------------
-- SECURE ROADS
-------------------------------------------------------------------------
function Initialize_OBJ_SecureRoads()

	OBJ_SecureRoads = {
		
		SetupUI = function() 
			-- mark a point or position
			for k, this in pairs(t_sr.points) do 
				this.mapID = Objective_AddUIElements(OBJ_SecureRoads, this.point, true, 1469220, true, 4)
			end
			
		end,
		
		OnStart = function()
			
			Sound_PlayMusic("Music/SP/OMG/preparation/OMG/THEY'RE_OUT_THERE.bsc",2,0)
			Rule_AddInterval(SecureRoads_WinCheck, 1)
			-- start related action
			SecureRoads_Kickoff()
			
		end,
		
		OnComplete = function()			
			Sound_StopMusic(6,0)
			
			-- Set the following intersections to true to prevent them spawning in after objective completed
			v_intersectionK = true
			v_IntersectionL = true
			v_intersectionE = true
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		Title = 1469550,
		Description = 1469551,
		Type = OT_Primary,
		
		SitRep = {
			Movie = "CXP2_SR_06-01",
			Force = true,
			SpeechTiming = -- All timings are PLACEHOLDER!!!!!
			{
				{ 1,	ACTOR.CXP2.Wolfgang, 1465000 },
				{ 6.7,	ACTOR.CXP2.Wolfgang, 1465010 },
				{ 9.9,	ACTOR.CXP2.Wolfgang, 1465020 },
				{ 15.3,	ACTOR.CXP2.Wolfgang, 1465030 },
				{ 22,	ACTOR.CXP2.Wolfgang, 1465040 },
				{ 25.7,	ACTOR.CXP2.Voss, 1465050 },
			--	{ 25,	ACTOR.CXP2.Voss, 1465060 }, -- No longer used, July 17 2007 -cmartin
				{ 28.8,	ACTOR.CXP2.Voss, 1465070 },
				{ 33.5,	ACTOR.CXP2.Voss, 1465080 },
				{ 38.8,	ACTOR.CXP2.Voss, 1465090 },
			--	{ 41,	ACTOR.CXP2.Voss, 1465100 }, -- No longer used, July 17 2007 -cmartin
				{ 45,	ACTOR.CXP2.Voss, 1465110 },
				{ 53,	ACTOR.CXP2.Voss, 1465120 },
			--	{ 53,	ACTOR.CXP2.Voss, 1465130 }, -- No longer used, July 17 2007 -cmartin
			--	{ 57,	ACTOR.CXP2.Voss, 1465140 }, -- No longer used, July 17 2007 -cmartin
			},
		},
	}
	
	-- Register Objective
	Objective_Register(OBJ_SecureRoads)
	-- Initialize Data
	SecureRoads_Init()
	
end

-------------------------------------------------------------------------
-- CAPTURE ROADS - Functions 
-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Obj data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function SecureRoads_Init()

	-- define sgroups, egroups, etc associated with this obj
	sg_SecureRoad1_infantry = SGroup_CreateIfNotFound ("sg_SecureRoad1_infantry")
	sg_SecureRoad1_MG = SGroup_CreateIfNotFound ("sg_SecureRoad1_MG")
	sg_SecureRoad1_schrek = SGroup_CreateIfNotFound ("sg_SecureRoad1_schrek")
	
	t_sr = {}
	
	t_sr.points = {
		{
			point 		= eg_SecureRoad1,
			captured 	= false,
			mapID = 1
		},
		{
			point 		= eg_SecureRoad2,
			captured 	= false,
			mapID = 2
		},
	}
	
	t_sr.PointsCaptured = 0
	
end

function SecureRoads_Delay()
	
	SGroup_AddGroup (sg_KingTigers, sg_KingTiger_Starting)
	Misc_SetSquadControlGroup(SGroup_GetSpawnedSquadAt(sg_KingTiger_Starting, 1), 1)
	
	Rule_AddInterval (KingTiger_Monitor, 5) 								-- Add the status monitor function for the King Tiger

end




-- preset any units or events needed before the kickoff, but you do not
-- want them to occur at the outset of the map.
-- Example: Often units are needed to exist before the objective start (because they start the objective)
-- then spawn those units here when they need to be spawned
function SecureRoads_Preset()

	-- spawn squads
	-- start enemy behavior
	-- do other cool things

end

-- example of how to finish an Obj
function SecureRoads_WinCheck()
	
	if Player_OwnsEGroup (player1, eg_SecureRoad2) and Player_OwnsEGroup (player1, eg_SecureRoad1) then
		
		Objective_Complete(OBJ_SecureRoads)
		
		-- If the player has already captured the territory for the next objective, then deal with it
		if Objective_IsComplete (OBJ_CaptureBridge) then
			if Rule_Exists (Arnhem_MissionEnd) == false then Rule_AddInterval(Arnhem_MissionEnd, 1) end
			return
		else
			
			Rule_AddDelayedInterval(Delay_CaptureBridge, 5, 1)
			Rule_RemoveMe()
		end
		
	end
	
	for k, this in pairs (t_sr.points) do
		
		if this.captured == false and Player_OwnsEGroup (player1, this.point) and t_sr.PointsCaptured == 0 then
			t_sr.PointsCaptured = t_sr.PointsCaptured + 1
			this.captured = true
			-- Deploy reinforcements
			Reinforcements_Kickoff(this.point)
			Objective_RemoveUIElements (OBJ_SecureRoads, this.mapID)
		end
		
		if this.captured == false and Player_OwnsEGroup (player1, this.point) and t_sr.PointsCaptured == 1 then
			t_sr.PointsCaptured = t_sr.PointsCaptured + 1
			this.captured = true
			-- Deploy reinforcements
			Reinforcements_Kickoff(this.point)
			Objective_RemoveUIElements (OBJ_SecureRoads, this.mapID)
		end
		
	end
	
end

-- start the related action
function SecureRoads_Kickoff()
	Util_AutoIntel(t_OBJ_speech.RoadSecured_ObjectiveStart)
end

function SecureRoads_UnlockTigerAbility()
	Cmd_InstantUpgrade(player1, UPG.SP.KING_TIGER)
--~ 	Player_SetAbilityAvailability (player1, ABILITY.SP.KING_TIGER, ITEM_UNLOCKED)
end

------------------------------

-- MISSION END

------------------------------
function Arnhem_MissionEnd()
	
	sg_endgamegarrison = SGroup_CreateIfNotFound ("sg_endgamegarrison")
	sg_endgameP1All = SGroup_CreateIfNotFound ("sg_endgameP1All")
	sg_endgameP2All = SGroup_CreateIfNotFound ("sg_endgameP2All")
	
	Rule_Remove (Arnhem_Encounter_Notifier)
	
	if g_HasFinalSurrendered == false then
		
		g_HasFinalSurrendered = true
		Player_GetAll(player2, sg_endgameP2All)
		Player_GetAll(player1, sg_endgameP1All)
		
		if SGroup_CountSpawned(sg_endgameP1All) > 0 then
			SGroup_SetAutoTargetting (sg_endgameP1All, "hardpoint_01", false)
		end
		
		if SGroup_CountSpawned(sg_endgameP2All) > 0 then
			SGroup_SetAutoTargetting (sg_endgameP2All, "hardpoint_01", false)
                        Cmd_Surrender (sg_endgameP2All)
		end
		
		Rule_AddOneShot (SpawnNISLET_SurrenderSquads, 1)
		
	end

end

function SpawnNISLET_SurrenderSquads()
	
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison1, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison2, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison3, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison4, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison5, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison6, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison7, nil, 1, 1)

	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison8, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison9, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison10, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison11, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison12, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison13, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison14, nil, 1, 1)

	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison15, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison16, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison17, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison18, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison19, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison20, nil, 1, 1)
	Util_CreateSquads (player2, sg_endgamegarrison, SBP.CW.COMMANDOS, mkr_EndgameGarrison21, nil, 1, 1)
	
	Cmd_Surrender (sg_endgamegarrison)
	Rule_AddInterval (WaitforFinalNIS, 1)
	Endgame_NISLET()
	
end

function Endgame_NISLET()
	
	Camera_ResetToDefault()
	FOW_RevealArea (Marker_GetPosition (mkr_FinalSurrenderCamera), 100, -1)
	Util_AutoNISlet (NISLET_GAME2LETTER, t_events.EndGameSurrendering)
	
end

function WaitforFinalNIS()
	
	if Event_IsAnyRunning (EVENT_INTEL) == false then
		
		Util_StartNIS(NIS_CLOSING)
		Rule_Add(Arnhem_EndSP)
		Rule_RemoveMe()
		
	end
	
end

function Arnhem_MissionFail()
	
	if Event_IsAnyRunning (EVENT_INTEL) == false then
		Game_EndSP (false)
		Rule_RemoveMe()
	end
	
end

function Arnhem_EndSP()

	if Event_IsAnyRunning (EVENT_INTEL) == false then
		Game_EndSP(true)
		Rule_RemoveMe()
	end
	
end


-----------------------------------------------------------------------------------

-- All of the Intersections are just encounters that are scattered across the map
-- you can see the location of an intersection by looking at the markers

-----------------------------------------------------------------------------------

-- INTERSECTION A

-- This encounter is the first for the player. It is initialized here, but triggered
-- and spawned as part of the B intersection.

-----------------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionA_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_A_all = SGroup_CreateIfNotFound("sg_intersections_A_all")
	sg_intersections_A_MG = SGroup_CreateIfNotFound ("sg_intersections_A_MG")
	sg_intersections_A_Infantry = SGroup_CreateIfNotFound ("sg_intersections_A_Infantry")
	sg_intersections_A_Infantry1 = SGroup_CreateIfNotFound ("sg_intersections_A_Infantry1")
	sg_intersections_A_Infantry2 = SGroup_CreateIfNotFound ("sg_intersections_A_Infantry2")
	sg_intersections_A_Panzerschreks = SGroup_CreateIfNotFound ("sg_intersections_A_Panzerschreks")
	sg_intersections_A_Pak38 = SGroup_CreateIfNotFound ("sg_intersections_A_Pak38")
	
	sg_intersections_B_all = SGroup_CreateIfNotFound("sg_intersections_B_all")
	
	g_HasPlayedFirstEncounterSpeech = false
	g_IntA_ATGun_Active = false
	
	t_arnhem_allies.t_intersections_A = {
		fg_spawnedMG = false,
		fg_spawnedPanzerschreks = false,
		fg_surrendered = false,
	}
	
	t_arnhem_allies.t_intersections_A_Troops = {
	-- Intersection A troops
		{
			sg = sg_intersections_A_Infantry1,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionA_spawn_1,
			dest = mkr_intersectionA_spawn_1,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = sg_intersections_A_Infantry2,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionA_spawn_1,
			dest = mkr_intersectionA_dest_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = sg_intersections_A_MG,
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionA_mg_1,
			dest = mkr_intersectionA_mg_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = sg_intersections_A_Panzerschreks,
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_intersectionA_flankspawn,
			dest = mkr_intersectionA_flankspawn,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
	}
	
end

function IntersectionA_Preset()
	
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_A_Troops, sg_intersections_A_all)
	
	SGroup_AddGroup (sg_intersections_A_Infantry, sg_intersections_A_Infantry1)
	SGroup_AddGroup (sg_intersections_A_Infantry, sg_intersections_A_Infantry2)
	
end

function IntersectionA_Kickoff()
	
	-- start enemy behavior
	Rule_AddInterval (IntersectionA_Monitor, 2)
	Rule_AddOneShot (IntersectionA_DelayMoveSchreks, 20)
	SGroup_SetAutoTargetting (sg_intersections_B_all, "hardpoint_01", false)
	
	EGroup_SetInvulnerable (eg_intersectionA_Pak38, true)
	SGroup_SetInvulnerable (sg_intersections_A_Infantry1, true)
	
end

function IntersectionA_DelayMoveSchreks()
	
	Cmd_SquadPath (sg_intersections_A_Panzerschreks, "wp_intersectionA_flankers", true, 0, false, 0)
	
end

function IntersectionA_Monitor()
	
	-- Get last attacker of the Intersection's forces
	sg_IntersectionA_Attacker = SGroup_CreateIfNotFound ("sg_IntersectionA_Attacker")
	SGroup_GetLastAttacker (sg_intersections_A_all, sg_IntersectionA_Attacker)
	
	-- When the group starts attacking, play ambient brit speech
	if SGroup_IsDoingAttack (sg_intersections_A_all, ANY, 5) and g_HasPlayedFirstEncounterSpeech == false then
		if Event_IsAnyRunning () == false then
			local rand = World_GetRand ( 1, table.getn (t_AMBI_speech.FirstEncounter) )
			Util_AutoAmbient (t_AMBI_speech.FirstEncounter[rand])
		end
		g_HasPlayedFirstEncounterSpeech = true
	end
	
	-- If intersection A is defeated then add the nebs firing/idletimer if not already there
	if g_IntersectionA_Surrendered == true or SGroup_IsEmpty (sg_intersections_A_all) then
		if Rule_Exists (IdleTimer) == false then Rule_AddInterval (IdleTimer, 2) end -- Create the idle timer to depoy commandos that harass the player
		if Rule_Exists (SupplyDepots_FireNebs) == false then Rule_AddInterval( SupplyDepots_FireNebs, 5 ) end -- Start firing the nebelwerfers to draw the player to the top-right of the map
		Rule_RemoveMe()
		return
	end
	
	-- Commandos attack the player from cover
	if SGroup_IsDoingAttack (sg_intersections_A_Infantry2, ANY, 5) == false then
		Cmd_Attack (sg_intersections_A_Infantry2, sg_IntersectionA_Attacker, false, true)
	end
	
	-- Check if the panzerschrek commandos have finished moving (path) and get in the building
	if Prox_AreSquadsNearMarker (sg_intersections_A_Panzerschreks, mkr_intersectionA_flankers_pathEnd, ANY, 2) then
		Cmd_Garrison (sg_intersections_A_Panzerschreks, eg_intersectionA_flankersgarrison)
	end
	
	-- If the squad is under attack by any AT armour threats, move 3 of the commandos to the nearby PaK 38
	SGroup_Filter (sg_IntersectionA_Attacker, t_PanzerElite_Tanks, FILTER_KEEP)
	if SGroup_Count (sg_IntersectionA_Attacker) > 0 and Rule_Exists (IntersectionA_ATGun_Monitor) == false and SGroup_IsEmpty (sg_intersections_A_Pak38) == true then
		Rule_AddInterval (IntersectionA_ATGun_Monitor, 1)
	end
	
end

function IntersectionA_ATGun_Monitor()
	
	if Prox_AreSquadsNearMarker (sg_intersections_A_Infantry1, mkr_intersectionA_Pak38, ANY, 5) and g_IntA_ATGun_Active == false and g_IntersectionA_ATGun == "capturing" then
		
		EGroup_SetInvulnerable (eg_intersectionA_Pak38, false)
		SGroup_SetInvulnerable (sg_intersections_A_Infantry1, false)
		Cmd_CaptureTeamWeapon (sg_intersections_A_Infantry1, eg_intersectionA_Pak38)
		g_IntersectionA_ATGun = "crewed"
		
	elseif Prox_AreSquadsNearMarker (sg_intersections_A_Infantry1, mkr_intersectionA_Pak38, ANY, 5) == false and g_IntA_ATGun_Active == false and g_IntersectionA_ATGun == "capturing" then
		
		Cmd_Move (sg_intersections_A_Infantry1, mkr_intersectionA_Pak38)
		
	end
	
	if g_IntersectionA_ATGun == "crewed" and SGroup_IsEmpty (sg_intersections_A_Infantry1) == true then
		
		Player_GetAllSquadsNearMarker (player2, sg_intersections_A_Infantry1, mkr_intersectionA_Pak38, 5)
		SGroup_RemoveGroup (sg_intersections_A_Infantry1, sg_intersections_A_Infantry2)
		SGroup_Filter(sg_intersections_A_Infantry1, SBP.CW.CAPTURE_ATGUN, FILTER_KEEP)
		SGroup_AddGroup (sg_intersections_A_Pak38, sg_intersections_A_Infantry1)
		ATGun_AddGroup (sg_intersections_A_Pak38, player2, nil, nil, nil, nil, true)
		HintPoint_Add (sg_intersections_A_Pak38, true, 1469910)
		g_IntA_ATGun_Active = true
		
	end
	
	if g_IntA_ATGun_Active == true and SGroup_IsEmpty (sg_intersections_A_Infantry1) == true then
		g_IntersectionA_ATGun = "Crewed_ATGun_destroyed"
	end
	
	if g_IntersectionA_ATGun ~= "crewed" and g_IntA_ATGun_Active == false then
		
		if EGroup_IsEmpty (eg_intersectionA_Pak38) == false then
			Cmd_Move (sg_intersections_A_Infantry1, mkr_intersectionA_Pak38)
			
			g_IntersectionA_ATGun = "capturing"
		elseif EGroup_IsEmpty (eg_intersectionA_Pak38) == true and g_IntersectionA_ATGun ~= "capturing" then
			g_IntersectionA_ATGun = "ATGun_destroyed"
			Rule_RemoveMe()
		end
		
	end
	
	-- If the at gun is dead, check for armour threats	
	if (g_IntersectionA_ATGun == "Crewed_ATGun_destroyed" or g_IntersectionA_ATGun == "ATGun_destroyed") and Timer_Exists (SurrenderDelay_Timer) == false then
		
		-- first run the check for the armor threats
		SGroup_ForEach (sg_intersections_A_all, CheckForArmorThreat)
		
		local AddHintpoint = function(gid, idx, sid)
			
			g_TeachingHintpoint = HintPoint_Add (sid, true, 1469911)
			
		end
		
		-- Then add the sgroups to the filter table
		SGroup_ForEach (sg_ArmorAttacker, AddHintpoint)
		
		-- If one of the threats is the King Tiger, play the speech
		if SGroup_ContainsBlueprints (sg_ArmorAttacker, SBP.ELITE.KING_TIGER_ARNHEM, ALL) then
			Util_AutoAmbient (t_AMBI_speech.FirstKingTigerReaction)
		end
		
		Timer_Start (SurrenderDelay_Timer, 5)
		
	end
	
	-- If the timer has elapsed then trigger the squad's surrender
	if Timer_Exists (SurrenderDelay_Timer) and g_IntersectionA_Surrendered == false then
		if Timer_GetRemaining (SurrenderDelay_Timer) <= 0 then
			IntersectionA_Surrender()
			g_IntersectionA_Surrendered = true
			Rule_AddDelayedInterval (RemoveFirstSurrenderHP, 10, 1)
			Rule_RemoveMe()
		end
	end
	
end

function RemoveFirstSurrenderHP()
	
	HintPoint_Remove(g_TeachingHintpoint)
	Rule_RemoveMe()
	
end

function IntersectionA_Surrender()
	
	Cmd_Surrender (sg_intersections_A_all)
	
	if Rule_Exists (IdleTimer) == false then Rule_AddInterval (IdleTimer, 2) end -- Create the idle timer to depoy commandos that harass the player
	
	-- Remove the monitor and at monitor functions if they exist still
	if Rule_Exists (IntersectionA_Monitor) == false then Rule_Remove (IntersectionA_Monitor) end
	if Rule_Exists (IntersectionA_ATGun_Monitor) == false then Rule_Remove (IntersectionA_ATGun_Monitor) end
	
	-- Let intersection B Fire after 3 seconds
        if Rule_Exists(IntB_Firewhenready) == false then
		Rule_AddOneShot (IntB_Firewhenready, 3)
	end	
end

function IntB_Firewhenready()

	SGroup_SetAutoTargetting (sg_intersections_B_all, "hardpoint_01", true)

end

-------------------------------------------------------------------------

-- INTERSECTION B

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionB_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_B_all = 			SGroup_CreateIfNotFound("sg_intersections_B_all")
	sg_attackers_intersectionB_1 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionB_1")
	sg_attackers_intersectionB_2 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionB_2")
	sg_attackers_intersectionB_3 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionB_3")
	sg_attackers_intersectionB_4 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionB_4")
	sg_attackers_intersectionB_jeep = 	SGroup_CreateIfNotFound("sg_attackers_intersectionB_jeep")
	sg_attackers_intersectionB_5 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionB_5")

	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_B = {
		
		-- Spawn 1
		{
			sg = sg_attackers_intersectionB_1,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionB_spawn_1,
			dest = mkr_intersectionB_spawn_1,
			number = 1,
			load = 2,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionB_garrison_1,
			managed = false,
		},
		
		-- MG's
		{
			sg = sg_attackers_intersectionB_2,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionB_mg_1,
			dest = mkr_intersectionB_mg_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = sg_attackers_intersectionB_3,
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionB_mg_2,
			dest = mkr_intersectionB_mg_dest_2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- PAK38s
		{
			sg = sg_attackers_intersectionB_4,
			sbp = SBP.CW.COMMANDOS_PAK38_SP,
			pos = mkr_intersectionB_p38_1,
			dest = mkr_intersectionB_p38_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
		-- Jeeps
		{
			sg = sg_attackers_intersectionB_jeep,
			sbp = SBP.CW.COMMANDOS_JEEP,			
			pos = mkr_intersectionB_jeep_1,
			dest = mkr_intersectionB_jeep_1,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
	}
	
	
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_B, sg_intersections_B_all )	
	
	sg_attackers_intersectionB_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionB_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionB_ATGuns, sg_intersections_B_all)
	SGroup_Filter (sg_attackers_intersectionB_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	
	
end

-- preset any units or events needed before the kickoff
function IntersectionB_Preset()
	
	Modify_UnitSpeed (sg_attackers_intersectionB_jeep, 0.6)
	Rule_AddInterval (JeepLure_Wait, 1)
	
	-- do other cool things
	IntersectionB_Kickoff()
	
end

-- start the related action
function IntersectionB_Kickoff()
	
	-- Watch for attack so sgroups don't fire on player until either fired on or intersection A is done
	Rule_AddInterval (IntB_FireWhenFiredOn, 2)
	
	-- Add this intersection to the surrender monitor functions
	t_Monitor_Intersections[1].fg_active = true
	CheckSurrender_Kickoff()
	
end

function JeepLure_Wait()

	if SGroup_IsOnScreen (player1, sg_attackers_intersectionB_jeep, ANY) or SGroup_IsUnderAttack (sg_attackers_intersectionB_jeep, ANY, 5) then
		Cmd_SquadPath(sg_attackers_intersectionB_jeep, "wp_IntersectionB_JeepLure", true, 0, false, 0 )
		Rule_RemoveMe()
	end
	
end

function IntB_FireWhenFiredOn()
	
	if SGroup_IsUnderAttack (sg_intersections_B_all, ANY, 30) then
		if Rule_Exists(IntB_Firewhenready) == false then
			Rule_AddOneShot (IntB_Firewhenready, 1)
		end
		Rule_RemoveMe()
	end
	
end

-------------------------------------------------------------------------

-- INTERSECTION C

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionC_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_C_all = SGroup_CreateIfNotFound("sg_intersections_C_all")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_C = {
		
		{-- 1
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionC_1"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionC_mg_3,
			dest = mkr_intersectionC_mg_3,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 2
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionC_2"),
			sbp = SBP.CW.COMMANDOS,
			pos = eg_IntersectionC_garrison_1,
			dest = nil,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- Mortars
		{-- 3
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionC_3"),
			sbp = SBP.CW.COMMANDOS_MORTAR,			
			pos = mkr_intersectionC_mort_2,
			dest = mkr_intersectionC_mort_2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- antitank
		{-- 4
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionC_5"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,			
			pos = mkr_intersectionC_p38_2,
			dest = mkr_intersectionC_p38_2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
	}
	
end

-- preset any units or events needed before the kickoff
function IntersectionC_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_C, sg_intersections_C_all )
	
	-- start enemy behavior
	sg_attackers_intersectionC_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionC_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionC_ATGuns, sg_intersections_C_all)
	SGroup_Filter (sg_attackers_intersectionC_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- do other cool things
	IntersectionC_Kickoff()
	
end

-- start the related action
function IntersectionC_Kickoff()

	-- action that starts when this encounter is triggered
	
	t_Monitor_Intersections[2].fg_active = true
	t_Monitor_Intersections[2].surrendered = true -- Flag it as surrendered so that the Monitor function can proceed normally
	CheckSurrender_Kickoff()
	
	Rule_AddInterval (IntersectionC_Monitor, 1)
	
end

function IntersectionC_Monitor()
	
	if SGroup_IsEmpty (sg_attackers_intersectionC_ATGuns) or Player_OwnsEGroup (player1, eg_SupplyDepot_1) then
		Cmd_Ungarrison (eg_IntersectionC_garrison_1)
		EGroup_SetInvulnerable (eg_IntersectionC_garrison_1, false) -- Set the egroups to invulnerable
		Rule_AddOneShot (IntersectionC_Retreat, 2)
		Rule_RemoveMe()
	end
	
end

function IntersectionC_Retreat()
	
	if SGroup_IsEmpty (sg_intersections_C_all) == false then
		Cmd_Retreat (sg_intersections_C_all, mkr_HQ2_Offmap, mkr_HQ2_Offmap)
		Rule_AddOneShot (Depot1_WireDemolitions, 1)
	end
	
end

-------------------------------------------------------------------------

-- INTERSECTION D

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionD_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_D_all = SGroup_CreateIfNotFound("sg_intersections_D_all")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_D = {
		
		-- Spawn 1
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionD_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionD_spawn_1,
			dest = mkr_intersectionD_dest_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionD_6"),
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_intersectionD_spawn_1,
			dest = mkr_intersectionD_dest2,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionD_garrison1,
			managed = false,
		},
		
		-- mg
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionD_2"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionD_mg_1,
			dest = mkr_intersectionD_mg_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = true,
			garrison_loc = eg_intersectionD_garrison2,
			managed = false,
		},
		
		-- p38
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionD_4"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,
			pos = mkr_intersectionD_p38_1,
			dest = mkr_intersectionD_p38_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionD_5"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,
			pos = mkr_intersectionD_p38_2,
			dest = mkr_intersectionD_p38_2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
	}
	

	
end

-- preset any units or events needed before the kickoff
function IntersectionD_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_D, sg_intersections_D_all )
	
	-- start enemy behavior
	sg_attackers_intersectionD_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionD_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionD_ATGuns, sg_intersections_D_all)
	SGroup_Filter (sg_attackers_intersectionD_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- Stop the Paks from firing until the rest of the group fires
	SGroup_SetAutoTargetting (sg_attackers_intersectionD_ATGuns, "hardpoint_01", false)
	Rule_AddInterval (IntersectionD_OpenFire, 1)
	
	-- do other cool things
	IntersectionD_Kickoff()
	
end

-- start the related action
function IntersectionD_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[3].fg_active = true
	CheckSurrender_Kickoff()
	
end

function IntersectionD_OpenFire()
	
	if SGroup_IsDoingAttack (sg_intersections_D_all, ANY, 5) then
		SGroup_SetAutoTargetting (sg_attackers_intersectionD_ATGuns, "hardpoint_01", true)
		Rule_RemoveMe()
	end
	
end

-------------------------------------------------------------------------

-- INTERSECTION E

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionE_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_E_all = SGroup_CreateIfNotFound("sg_intersections_E_all")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_E = {
		
		-- Spawn 1
		{-- 1
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionE_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionE_spawn_1,
			dest = mkr_intersectionE_dest_1,
			number = 1,
			load = 5,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionE_garrison1,
			managed = false,
		},
		
		{-- 2
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionE_1a"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionE_spawn_1,
			dest = mkr_intersectionE_dest_1,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionE_garrison2,
			managed = false,
		},
		
		{-- 3
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionE_3"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionE_mg_2,
			dest = mkr_intersectionE_mg_2,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 4
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionE_5"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,
			pos = mkr_intersectionE_p38_1,
			dest = mkr_intersectionE_p38_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
	}
	
	if g_difficulty == GD_EASY then 
		table.remove (t_arnhem_allies.t_intersections_E, 1)
		table.remove (t_arnhem_allies.t_intersections_E, 2) -- was 3
	end
	
end

-- preset any units or events needed before the kickoff
function IntersectionE_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_E, sg_intersections_E_all )
	
	-- start enemy behavior
	sg_attackers_intersectionE_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionE_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionE_ATGuns, sg_intersections_E_all)
	SGroup_Filter (sg_attackers_intersectionE_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- do other cool things
	IntersectionE_Kickoff()
	
end

-- start the related action
function IntersectionE_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[4].fg_active = true
	CheckSurrender_Kickoff()
end


-------------------------------------------------------------------------

-- INTERSECTION F

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionF_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_F_all = SGroup_CreateIfNotFound("sg_intersections_F_all")
	sg_IntersectionF_forwardCommandos = SGroup_CreateIfNotFound ("sg_IntersectionF_forwardCommandos")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_F = {
		
		-- Spawn 1
		{-- 1
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionF_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionF_spawn_1,
			dest = mkr_sp_sr2_infantry_dest1,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 2
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionF_2"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionF_spawn_2,
			dest = mkr_sp_sr2_infantry_dest2,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 3
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionF_3"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionF_spawn_3,
			dest = mkr_sp_sr2_infantry_dest3,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 4
			sg = SGroup_CreateIfNotFound("sg_attackers_SR2_1"),
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_intersectionF_spawn_1,
			dest = mkr_sp_sr2_infantry_dest2,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
	}
	
end

-- preset any units or events needed before the kickoff
function IntersectionF_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_F, sg_intersections_F_all )
	
	-- start enemy behavior
	sg_attackers_intersectionF_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionF_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionF_ATGuns, sg_intersections_F_all)
	SGroup_Filter (sg_attackers_intersectionF_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	SGroup_AddGroup (sg_IntersectionF_forwardCommandos, SGroup_FromName ("sg_attackers_intersectionF_1") )
	SGroup_AddGroup (sg_IntersectionF_forwardCommandos, SGroup_FromName ("sg_attackers_intersectionF_2") )
	SGroup_AddGroup (sg_IntersectionF_forwardCommandos, SGroup_FromName ("sg_attackers_intersectionF_3") )
	SGroup_AddGroup (sg_IntersectionF_forwardCommandos, SGroup_FromName ("sg_attackers_SR2_1") )
	
	-- do other cool things
	IntersectionF_Kickoff()
	
end

-- start the related action
function IntersectionF_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[5].fg_active = true
	CheckSurrender_Kickoff()
end

-------------------------------------------------------------------------

-- INTERSECTION G

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionG_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_G_all = SGroup_CreateIfNotFound("sg_intersections_G_all")
	sg_intersection_G_JeepsAttack = SGroup_CreateIfNotFound ("sg_intersection_G_JeepsAttack")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_G = {
		
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionG_2"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionG_mg_1,
			dest = mkr_intersectionG_mg_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionG_3"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionG_mg_2,
			dest = mkr_intersectionG_mg_2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- Mortars
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionG_4"),
			sbp = SBP.CW.COMMANDOS_MORTAR,			
			pos = mkr_intersectionG_mort_1,
			dest = mkr_intersectionG_mort_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- antitank
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionG_1"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,			
			pos = mkr_intersectionG_p38_1,
			dest = mkr_intersectionG_p38_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
	}
	
end

-- preset any units or events needed before the kickoff
function IntersectionG_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_G, sg_intersections_G_all )
	
	-- start enemy behavior
	sg_attackers_intersectionG_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionG_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionG_ATGuns, sg_intersections_G_all)
	SGroup_Filter (sg_attackers_intersectionG_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- do other cool things
	IntersectionG_Kickoff()
	
end

-- start the related action
function IntersectionG_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[6].fg_active = true
	CheckSurrender_Kickoff()
	
end



-------------------------------------------------------------------------

-- INTERSECTION H

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionH_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_H_all = SGroup_CreateIfNotFound("sg_intersections_H_all")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_H = {
		
		-- Spawn 1
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionH_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = eg_Church,
			dest = nil,
			number = 1,
			load = 8,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionH_2"),
			sbp = SBP.CW.COMMANDOS_SNIPER,
			pos = eg_Church,
			dest = nil,
			number = 1,
			load = 8,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- mg
		
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionH_3"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionH_mg_1,
			dest = mkr_intersectionH_mg_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionH_4"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionH_mg_2,
			dest = mkr_intersectionH_mg_2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		
		-- Mortars
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionH_6"),
			sbp = SBP.CW.COMMANDOS_MORTAR,			
			pos = mkr_intersectionH_mort_1,
			dest = mkr_intersectionH_mort_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- antitank
		{
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionH_7"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,			
			pos = mkr_intersectionH_p38_1,
			dest = mkr_intersectionH_p38_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
	}
	
end

-- preset any units or events needed before the kickoff
function IntersectionH_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_H, sg_intersections_H_all )
	
	-- start enemy behavior
	sg_attackers_intersectionH_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionH_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionH_ATGuns, sg_intersections_H_all)
	SGroup_Filter (sg_attackers_intersectionH_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- Set the garrison building to vulnerable
	EGroup_SetInvulnerable (eg_Church, false)
	
	-- do other cool things
	IntersectionH_Kickoff()
	
end

-- start the related action
function IntersectionH_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[7].fg_active = true
	CheckSurrender_Kickoff()
end


-------------------------------------------------------------------------

-- INTERSECTION I

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionI_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_I_all = SGroup_CreateIfNotFound("sg_intersections_I_all")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_I = {
		
		-- Spawn 1
		
		{-- 1
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionI_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionI_troops_1,
			dest = mkr_intersectionI_troops_1,
			number = 1,
			load = 8,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- mg
		
		{-- 2
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionI_2"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_intersectionI_mg_1,
			dest = mkr_intersectionI_mg_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},	
		
		-- Mortars
		
		{-- 3
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionI_4"),
			sbp = SBP.CW.COMMANDOS_MORTAR,			
			pos = mkr_intersectionI_mort_1,
			dest = mkr_intersectionI_mort_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- antitank
		
		{-- 4
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionI_6"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,			
			pos = mkr_intersectionI_p38_1,
			dest = mkr_intersectionI_p38_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
	}
	
end

-- preset any units or events needed before the kickoff
function IntersectionI_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_I, sg_intersections_I_all )
	
	-- start enemy behavior
	sg_attackers_intersectionI_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionI_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionI_ATGuns, sg_intersections_I_all)
	SGroup_Filter (sg_attackers_intersectionI_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- do other cool things
	IntersectionI_Kickoff()
	
end

-- start the related action
function IntersectionI_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[8].fg_active = true
	CheckSurrender_Kickoff()
	
end



-------------------------------------------------------------------------

-- INTERSECTION J

-------------------------------------------------------------------------
-- this is for defending the boats


-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionJ_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_J_all = SGroup_CreateIfNotFound("sg_intersections_J_all")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_J = {
		
		-- Spawn 1
		
		{-- 1
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionJ_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionJ_troops_1,
			dest = mkr_intersectionJ_troops_1,
			number = 1,
			load = 7,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 2
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionJ_2"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionJ_troops_2,
			dest = mkr_intersectionJ_troops_2,
			number = 1,
			load = 5,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		-- sniper
		
		{-- 3
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionJ_3"),
			sbp = SBP.CW.COMMANDOS_SNIPER,
			pos = eg_intersectionJ_snipergarrison_1,
			dest = nil,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 4
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionJ_4"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,
			pos = mkr_intersectionJ_pak1,
			dest = mkr_intersectionJ_pak1,
			number = 1,
			load = 8,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
	}
	
end

-- preset any units or events needed before the kickoff
function IntersectionJ_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_J, sg_intersections_J_all )
	
	-- start enemy behavior
	sg_attackers_intersectionJ_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionJ_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionJ_ATGuns, sg_intersections_J_all)
	SGroup_Filter (sg_attackers_intersectionJ_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- Set the egroups to vulnerable
	EGroup_SetInvulnerable (eg_intersectionJ_snipergarrison_1, false)
	
	-- do other cool things
	IntersectionJ_Kickoff()
	
end

-- start the related action
function IntersectionJ_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[9].fg_active = true
	CheckSurrender_Kickoff()
	Rule_AddInterval (WaitForBoatsObjective, 2)
	
end

function WaitForBoatsObjective()

	if Prox_ArePlayersNearMarker(player1, mkr_intersectionJ_1, ANY) == true or Prox_ArePlayersNearMarker(player1, mkr_intersectionJ_2, ANY) == true then
		Objective_Start (OBJ_DestroyBoats) -- Trigger the boats medal objective
		Rule_RemoveMe()
	end
	
end



-------------------------------------------------------------------------

-- INTERSECTION K

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionK_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_K_all = 			SGroup_CreateIfNotFound("sg_intersections_K_all")
	sg_attackers_intersectionK_1 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionK_1")
	sg_attackers_intersectionK_2 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionK_2")
	sg_attackers_intersectionK_3 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionK_3")
	sg_attackers_intersectionK_4 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionK_4")
	sg_attackers_intersectionK_5 = 		SGroup_CreateIfNotFound("sg_attackers_intersectionK_5")

	-- 
	t_arnhem_allies.t_intersections_K = {
		
		-- Infantry
		{-- 1
			sg = sg_attackers_intersectionK_1,
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_intersectionK_spawn1,
			dest = mkr_intersectionK_spawn1,
			number = 1,
			load = 2,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionK_garrison1,
			managed = false,
		},
		
		{-- 2
			sg = sg_attackers_intersectionK_3,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionK_spawn2,
			dest = mkr_intersectionK_spawn2,
			number = 1,
			load = 5,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionK_garrison3,
			managed = false,
		},
		
		-- Sniper
		{-- 3
			sg = sg_attackers_intersectionK_4,
			sbp = SBP.CW.COMMANDOS_SNIPER,
			pos = mkr_intersectionK_spawn4,
			dest = mkr_intersectionK_spawn4,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionK_garrison_sniper,
			managed = false,
		},
		
	}
	
end



-- preset any units or events needed before the kickoff
function IntersectionK_Preset()
	
	-- start enemy behavior
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_K, sg_intersections_K_all )	
	
	sg_attackers_intersectionK_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionK_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionK_ATGuns, sg_intersections_K_all)
	SGroup_Filter (sg_attackers_intersectionK_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- Set egroups to vulnerable
	EGroup_SetInvulnerable (eg_intersectionK_garrison1, false)
	
	-- do other cool things
	IntersectionK_Kickoff()
	
end

-- start the related action
function IntersectionK_Kickoff()
	
	-- Add this intersection to the surrender monitor functions
	t_Monitor_Intersections[10].fg_active = true
	CheckSurrender_Kickoff()
	
end



function IntersectionK_Monitor()

--

end


-------------------------------------------------------------------------

-- INTERSECTION L

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionL_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_L_all = 			SGroup_CreateIfNotFound("sg_intersections_L_all")
	sg_attackers_IntersectionL_1 = 		SGroup_CreateIfNotFound("sg_attackers_IntersectionL_1")
	sg_attackers_IntersectionL_2 = 		SGroup_CreateIfNotFound("sg_attackers_IntersectionL_2")
	sg_attackers_IntersectionL_3 = 		SGroup_CreateIfNotFound("sg_attackers_IntersectionL_3")
	sg_attackers_IntersectionL_4 = 		SGroup_CreateIfNotFound("sg_attackers_IntersectionL_4")
	sg_attackers_IntersectionL_5 = 		SGroup_CreateIfNotFound("sg_attackers_IntersectionL_5")

	-- 
	t_arnhem_allies.t_intersections_L = {
		
		-- Infantry
		-- Point Guards
		{-- 1
			sg = sg_attackers_IntersectionL_1,
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_intersectionE_pointguards_spawn,
			dest = mkr_intersectionE_pointguards_spawn,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionE_point_garrison1,
			managed = false,
		},
		
		{-- 2
			sg = sg_attackers_IntersectionL_2,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionE_pointguards_spawn,
			dest = mkr_intersectionE_pointguards_spawn,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionE_point_garrison2,
			managed = false,
		},
		
	}
	
end

-- preset any units or events needed before the kickoff
function IntersectionL_Preset()
	
	-- start enemy behavior
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_L, sg_intersections_L_all )
	
	sg_attackers_IntersectionL_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_IntersectionL_ATGuns")
	SGroup_AddGroup (sg_attackers_IntersectionL_ATGuns, sg_intersections_K_all)
	SGroup_Filter (sg_attackers_IntersectionL_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- do other cool things
	IntersectionL_Kickoff()
	
end

-- start the related action
function IntersectionL_Kickoff()
	
	-- Add this intersection to the surrender monitor functions
	t_Monitor_Intersections[12].fg_active = true
	CheckSurrender_Kickoff()
	
end



function IntersectionL_Monitor()

--

end



-------------------------------------------------------------------------

-- INTERSECTION M

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IntersectionM_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_intersections_M_all = SGroup_CreateIfNotFound("sg_intersections_M_all")
	
	-- The "A" group which attacks the first point
	t_arnhem_allies.t_intersections_M = {
		
		-- Spawn 1
		{-- 1
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionM_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_intersectionM_troop_1,
			dest = mkr_intersectionM_dest_1,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 2
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionM_3"),
			sbp = SBP.CW.COMMANDOS_MG42_SP,
			pos = mkr_intersectionC_troop_3,
			dest = mkr_intersectionM_dest_2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionM_sniper_garrison_1,
			managed = false,
		},
		
		-- antitank
		{-- 3
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionM_5"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,			
			pos = mkr_intersectionM_p38_1,
			dest = mkr_intersectionM_p38_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
		-- sniper
		{-- 4
			sg = SGroup_CreateIfNotFound("sg_attackers_intersectionM_6"),
			sbp = SBP.CW.COMMANDOS_SNIPER,
			pos = mkr_intersectionM_sniper_1,
			dest = mkr_intersectionM_sniper_1,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_intersectionM_sniper_garrison_1,
			managed = false,
		},
		
	}
	
end

-- preset any units or events needed before the kickoff
function IntersectionM_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_intersections_M, sg_intersections_M_all )
	
	-- start enemy behavior
	sg_attackers_intersectionM_ATGuns = SGroup_CreateIfNotFound ("sg_attackers_intersectionM_ATGuns")
	SGroup_AddGroup (sg_attackers_intersectionM_ATGuns, sg_intersections_M_all)
	SGroup_Filter (sg_attackers_intersectionM_ATGuns, SBP.CW.COMMANDOS_PAK38_SP, FILTER_KEEP)
	
	-- do other cool things
	IntersectionM_Kickoff()
	
end

-- start the related action
function IntersectionM_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[13].fg_active = true
	CheckSurrender_Kickoff()
	
end


-------------------------------------------------------------------------

-- Secure Roads 1 Defence

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function SecureRoads1Defence_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_IntersectionSR1_All = SGroup_CreateIfNotFound ("sg_IntersectionSR1_All")
	sg_IntersectionSR1 = SGroup_CreateTable ("sg_IntersectionSR1%d", 8)
	
	sg_ForwardCommandos = SGroup_CreateIfNotFound ("sg_ForwardCommandos")
	sg_ForwardCommandos_AT = SGroup_CreateIfNotFound ("sg_ForwardCommandos_AT")
	
	sg_intersectionSR1_JeepsAttack = SGroup_CreateIfNotFound ("sg_intersectionSR1_JeepsAttack")
	
	g_ForwardCommandos_Moved = false
	
	-- table
	t_arnhem_allies.t_intersections_SR1 = {
		
		{-- 1
			sg = sg_IntersectionSR1[2],
			sbp = SBP.CW.COMMANDOS_MG42_SP,
			pos = mkr_sp_sr1_4,
			dest = mkr_sp_sr1_4,
			number = 1,
			load = 5,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_sr1_2,
			managed = false,
		},
		
		{-- 2
			sg = sg_IntersectionSR1[3],
			sbp = SBP.CW.COMMANDOS_PAK38_SP,
			pos = mkr_sp_sr1_7,
			dest = mkr_sp_sr1_7,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
		-- Forward Commandos for the SR1 Intersection
		
		{-- 3
			sg = sg_IntersectionSR1[4],
			sbp = SBP.CW.COMMANDOS_MG42_SP,
			pos = mkr_SR1_ForwardCommandos1,
			dest = mkr_SR1_ForwardCommandos1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = true,
			garrison_loc = eg_sr1_4,
			managed = false,
		},
		
		{-- 4
			sg = sg_IntersectionSR1[5],
			sbp = SBP.CW.COMMANDOS_PAK38_SP,
			pos = mkr_SR1_ForwardPak38,
			dest = mkr_SR1_ForwardPak38,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
	}

end

-- preset any units or events needed before the kickoff
function SecureRoads1Defence_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner (t_arnhem_allies.t_intersections_SR1, sg_IntersectionSR1_All)
	IntersectionJ_BaitTroops_Spawn()
	
	-- Add the forward commandos (depending on difficulty) into the sgroup
	SGroup_AddGroup (sg_ForwardCommandos, sg_IntersectionSR1[5])
	if g_difficulty == GD_NORMAL then 
		SGroup_AddGroup (sg_ForwardCommandos, sg_IntersectionSR1[4])
	end
	if g_difficulty >= GD_HARD then 
		SGroup_AddGroup (sg_ForwardCommandos, sg_IntersectionSR1[4])
		SGroup_AddGroup (sg_ForwardCommandos, sg_IntersectionSR1[6])
	end
	
	-- Set the egroups to vulnerable
	EGroup_SetInvulnerable (eg_sr1_4, false)
	
	-- start enemy behavior
	Rule_AddInterval (IntersectionSR1_ForwardCheck, 1)
	
	-- do other cool things
	SecureRoads1Defence_Kickoff()
	
end

-- start the related action
function SecureRoads1Defence_Kickoff()

	-- action that starts when this encounter is triggered
	t_Monitor_Intersections[11].fg_active = true
	CheckSurrender_Kickoff()
	
end

function IntersectionSR1_ForwardCheck()
	
	if SGroup_Count (sg_ForwardCommandos) == 1 and g_ForwardCommandos_Moved == false then
		Cmd_Ungarrison (eg_sr1_4)
		Rule_AddOneShot (IntersectionSR1_Movetroops, 2)
		g_ForwardCommandos_Moved = true
	end
	
	if SGroup_IsUnderAttack (sg_IntersectionSR1[3], ALL, 5) and SGroup_IsUnderAttack (sg_ForwardCommandos, ALL, 5) == false 
	and SGroup_IsDoingAttack (sg_ForwardCommandos, ANY, 5) == false and g_ForwardCommandos_Moved == false then
		Cmd_Ungarrison (eg_sr1_4)
		Rule_AddOneShot (IntersectionSR1_Movetroops, 2)
		g_ForwardCommandos_Moved = true
	end

	if g_ForwardCommandos_Moved == true then Rule_RemoveMe() end
	
end

function IntersectionSR1_Movetroops()
	
	Cmd_AttackMove (sg_ForwardCommandos, mkr_sp_sr1_8, false, nil, EGroup_GetPosition (eg_SecureRoad1), OFFSET_FRONT, 5)
	if SGroup_IsEmpty (sg_IntersectionSR1[4]) == false then Cmd_Garrison (sg_IntersectionSR1[4], eg_sr1_1) end
	
end

-------------------------------------------------------------------------

-- Troops to draw player towards the Boats

-------------------------------------------------------------------------

function IntersectionJ_BaitTroops_Init()

	-- Intersection J Bait Troops
	t_arnhem_allies.t_IntersectionJ_BaitTroops = {
		{
			sg = SGroup_CreateIfNotFound ("sg_IntersectionJ_Bait1"),
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_intersectionJ_Bait1,
			dest = mkr_intersectionJ_Bait1,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = SGroup_CreateIfNotFound ("sg_IntersectionJ_Bait2"),
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_intersectionJ_Bait2,
			dest = mkr_intersectionJ_Bait2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
	}
	
	sg_IntersectionJ_Bait1 = SGroup_FromName ("sg_IntersectionJ_Bait1")
	sg_IntersectionJ_Bait2 = SGroup_FromName ("sg_IntersectionJ_Bait2")
	
	IJ_Bait1_state = 1
	IJ_Bait2_state = 1
	
end

function IntersectionJ_BaitTroops_Spawn()
	
	Arnhem_EncounterSpawner (t_arnhem_allies.t_IntersectionJ_BaitTroops, sg_intersections_J_all)
	Rule_AddInterval (IntersectionJ_Bait1Check, 8)
	Rule_AddInterval (IntersectionJ_Bait2Check, 8)
	
end


-- Check to see if the player's camera can see the bait commandos or if they are being attacked, then retreat to next point to do the same
function IntersectionJ_Bait1Check()
	
	-- When on screen or under attack, move the unit to the next marker until the state has changed (arrived at the next marker)
	if ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait1, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait1, ANY, 5) ) and IJ_Bait1_state == 1 then
		Cmd_Move (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_second)
	elseif ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait1, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait1, ANY, 5) ) and IJ_Bait1_state == 2 then
		Cmd_Move (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_third)
	elseif ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait1, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait1, ANY, 5) ) and IJ_Bait1_state == 3 then
		Cmd_Move (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_fourth)
	elseif ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait1, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait1, ANY, 5) ) and IJ_Bait1_state == 4 then
		Cmd_Move (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_fifth)
	elseif ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait1, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait1, ANY, 5) ) and IJ_Bait1_state == 5 then
		-- When at the end of the path, stop monitoring
		Cmd_Move (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_final)
		Rule_RemoveMe()
	end

	-- Change the state depending on proximity to the destination marker
	if Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_second, ANY, 10) then
		IJ_Bait1_state = 2
	elseif Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_third, ANY, 10) then
		IJ_Bait1_state = 3
	elseif Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_fourth, ANY, 10) then
		IJ_Bait1_state = 4
	elseif Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_fifth, ANY, 10) then
		IJ_Bait1_state = 5
	elseif Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait1, mkr_IntJ_Bait1_final, ANY, 10) then
		IJ_Bait1_state = 6
	end
	
end

function IntersectionJ_Bait2Check()
	
	-- When on screen or under attack, move the unit to the next marker until the state has changed (arrived at the next marker)
	if ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait2, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait2, ANY, 10) ) and IJ_Bait2_state == 1 then
		Cmd_Move (sg_IntersectionJ_Bait2, mkr_IntJ_Bait2_second)
	elseif ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait2, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait2, ANY, 10) ) and IJ_Bait2_state == 2 then
		Cmd_Move (sg_IntersectionJ_Bait2, mkr_IntJ_Bait2_third)
	elseif ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait2, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait2, ANY, 10) ) and IJ_Bait2_state == 3 then
		Cmd_Move (sg_IntersectionJ_Bait2, mkr_IntJ_Bait2_fourth)
	elseif ( SGroup_IsOnScreen (player1, sg_IntersectionJ_Bait2, ANY) or SGroup_IsUnderAttack (sg_IntersectionJ_Bait2, ANY, 10) ) and IJ_Bait2_state == 4 then
		-- When at the end of the path, stop monitoring
		Cmd_Move (sg_IntersectionJ_Bait2, mkr_IntJ_Bait2_final)
		Rule_RemoveMe()
	end

	-- Change the state depending on proximity to the destination marker
	if Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait2, mkr_IntJ_Bait2_second, ANY, 10) then
		IJ_Bait2_state = 2
	elseif Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait2, mkr_IntJ_Bait2_third, ANY, 10) then
		IJ_Bait2_state = 3
	elseif Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait2, mkr_IntJ_Bait2_fourth, ANY, 10) then
		IJ_Bait2_state = 4
	elseif Prox_AreSquadsNearMarker (sg_IntersectionJ_Bait2, mkr_IntJ_Bait2_final, ANY, 10) then
		IJ_Bait2_state = 5
	end
	
end


-------------------------------------------------------------------------

-- Ally Headquarters Defense

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function AllyHeadquartersDefense_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_allyHQ_Mortars = SGroup_CreateIfNotFound ("sg_allyHQ_Mortars")

	-- The "A" group which attacks the first point
	t_arnhem_allies.t_allyheadquartersdefense_Left = {
		
		------------------------------------------------------------------------------------------
		
		-- Left side of bridge (HQ1)
		
		------------------------------------------------------------------------------------------
		
		{-- 3
			sg = SGroup_CreateIfNotFound("sg_allyheadquartersdefense_6"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = mkr_hq_mg_6,
			dest = mkr_hq_mg_6,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 4
			sg = SGroup_CreateIfNotFound("sg_allyheadquartersdefense_9"),
			sbp = SBP.CW.COMMANDOS_MG42_SP,
			pos = mkr_hq_mg_8,
			dest = mkr_hq_mg_8,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = true,
			garrison_loc = eg_hq_mg_8,
			managed = false,
		},
		
		{-- 5
			sg = SGroup_CreateIfNotFound("sg_allyheadquartersdefense_10"),
			sbp = SBP.CW.COMMANDOS_MORTAR,			
			pos = mkr_hq_mort_1,
			dest = mkr_hq_mort_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 7
			sg = SGroup_CreateIfNotFound("sg_allyheadquartersdefense_13"),
			sbp = SBP.CW.COMMANDOS_PAK38_SP,			
			pos = mkr_hq_p38_1,
			dest = mkr_hq_p38_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = true,
		},
		
		{-- 9
			sg = SGroup_CreateIfNotFound("sg_allyheadquartersdefense_15"),
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,			
			pos = eg_hq_garrison_1,
			dest = eg_hq_garrison_1,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 10
			sg = SGroup_CreateIfNotFound("sg_HQGarrison_1"),
			sbp = SBP.CW.COMMANDOS,
			pos = eg_AllyBaseHQ_1,
			dest = nil,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 11
			sg = SGroup_CreateIfNotFound("sg_HQGarrison_1"),
			sbp = SBP.CW.LIEUTENANT,
			pos = eg_AllyBaseHQ_1,
			dest = nil,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
	}
	
	t_arnhem_allies.t_allyheadquartersdefense_Right = {
		
		------------------------------------------------------------------------------------------
		
		-- Right side of bridge (HQ2)
		
		------------------------------------------------------------------------------------------
		
		{-- 2
			sg = SGroup_CreateIfNotFound("sg_allyheadquartersdefense_5"),
			sbp = SBP.CW.COMMANDOS_MG,
			pos = eg_EndgameGarrison1,
			dest = nil,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 3
			sg = SGroup_CreateIfNotFound("sg_allyheadquartersdefense_7"),
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = eg_EndgameGarrison5,
			dest = nil,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 6
			sg = SGroup_CreateIfNotFound("sg_HQGarrison_2"),
			sbp = SBP.CW.COMMANDOS,
			pos = eg_AllyBaseHQ_2,
			dest = nil,
			number = 1,
			load = 3,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 8
			sg = SGroup_CreateIfNotFound("sg_HQGarrison_2"),
			sbp = SBP.CW.LIEUTENANT,
			pos = eg_AllyBaseHQ_2,
			dest = nil,
			number = 1,
			load = 1,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
	}
	
	t_arnhem_allies.t_allyheadquartersdefense_Bunkers = {
		------------------------------------------------------------------------------------------
		
		-- Bunker Troops
		
		------------------------------------------------------------------------------------------		
		
		{-- 1
			sg = SGroup_CreateIfNotFound("sg_allybunker_1"),
			sbp = SBP.CW.COMMANDOS_MG42_SP,
			pos = eg_Bunker1,
			dest = nil,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{-- 2
			sg = SGroup_CreateIfNotFound("sg_allybunker_2"),
			sbp = SBP.CW.COMMANDOS_MG42_SP,
			pos = eg_Bunker2,
			dest = nil,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
	}

end

-- preset any units or events needed before the kickoff
function AllyHeadquartersDefense_Left_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_allyheadquartersdefense_Left, sg_allyheadquartersdefense_all )
	SGroup_AddGroup (sg_allyHQ_Mortars, sg_allyheadquartersdefense_all)
	SGroup_Filter (sg_allyHQ_Mortars, SBP.CW.COMMANDOS_MORTAR, FILTER_KEEP)
	
	-- Set the egroups to vulnerable
	EGroup_SetInvulnerable (eg_AllyBaseHQ_1, false)
	EGroup_SetInvulnerable (eg_hq_garrison_1, false)
	
	-- Stop the Mortars from firing until the rest of the group fires
	SGroup_SetAutoTargetting (sg_allyHQ_Mortars, "hardpoint_01", false)
	if Rule_Exists (HQMortars_OpenFire) == false then Rule_AddInterval (HQMortars_OpenFire, 5) end
	
	-- do other cool things
	AllyHeadquartersDefense_Kickoff()
	
end

-- preset any units or events needed before the kickoff
function AllyHeadquartersDefense_Right_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_allyheadquartersdefense_Right, sg_allyheadquartersdefense_all )
	SGroup_AddGroup (sg_allyHQ_Mortars, sg_allyheadquartersdefense_all)
	SGroup_Filter (sg_allyHQ_Mortars, SBP.CW.COMMANDOS_MORTAR, FILTER_KEEP)
	
	-- Set the egroups to vulnerable
	EGroup_SetInvulnerable (eg_AllyBaseHQ_2, false)
	EGroup_SetInvulnerable (eg_EndgameGarrison1, false)
	EGroup_SetInvulnerable (eg_EndgameGarrison3, false)
	EGroup_SetInvulnerable (eg_EndgameGarrison5, false)
	
	-- Stop the Mortars from firing until the rest of the group fires
	SGroup_SetAutoTargetting (sg_allyHQ_Mortars, "hardpoint_01", false)
	if Rule_Exists (HQMortars_OpenFire) == false then Rule_AddInterval (HQMortars_OpenFire, 5) end
	
	-- do other cool things
	AllyHeadquartersDefense_Kickoff()
	
end

-- preset any units or events needed before the kickoff
function AllyHeadquartersDefense_Bunkers_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner( t_arnhem_allies.t_allyheadquartersdefense_Bunkers, sg_allyheadquartersdefense_all )
	
	-- Set the egroups to vulnerable
	EGroup_SetInvulnerable (eg_Bunker1, false)
	EGroup_SetInvulnerable (eg_Bunker2, false)
	
	-- Stop the Mortars from firing until the rest of the group fires
	SGroup_SetAutoTargetting (sg_allyHQ_Mortars, "hardpoint_01", false)
	if Rule_Exists (HQMortars_OpenFire) == false then Rule_AddInterval (HQMortars_OpenFire, 5) end
	
	-- do other cool things
	AllyHeadquartersDefense_Kickoff()
	
end

-- start the related action
function AllyHeadquartersDefense_Kickoff()

	-- action that starts when this encounter is triggered
	
end

function HQMortars_OpenFire()
	
	if SGroup_IsDoingAttack (sg_allyheadquartersdefense_all, ANY, 5) then
		SGroup_SetAutoTargetting (sg_allyHQ_Mortars, "hardpoint_01", true)
		Rule_RemoveMe()
	end
	
end

-------------------------------------------------------------------------

-- Base Counter Attack
-- Does not actually target base, but after the player finished the first
-- 2 or 3 intersections, they are attacked by a group of commandos to change
-- the pace and to unlock the left entrance near the player base (barricade)

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function BaseCounterAttack_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_BaseCounterAttack_Troops = SGroup_CreateIfNotFound ("sg_BaseCounterAttack_Troops")
	sg_BaseAttackTarget = SGroup_CreateIfNotFound ("sg_BaseAttackTarget")
	eg_TellerMines = EGroup_CreateIfNotFound ("eg_TellerMines")
	
	g_BaseCounterAttack_State = "NearBase"
	
	t_arnhem_allies.BaseAttackers = {
	-- Infantry for the Base Counterattack
		{
			sg = sg_BaseCounterAttack_Troops,
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = mkr_BaseBarricade_Counterattack_Spawn,
			dest = mkr_BaseBarricade_Counterattack_Spawn,
			number = 1,
			load = 2,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = sg_BaseCounterAttack_Troops,
			sbp = SBP.CW.COMMANDOS,
			pos = mkr_BaseBarricade_Counterattack_Spawn,
			dest = mkr_BaseBarricade_Counterattack_Spawn,
			number = 1,
			load = 5,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
	}
	
	t_arnhem_allies.BaseAttackers_CanSee = {
	-- Infantry for the Base Counterattack
		{
			sg = sg_BaseCounterAttack_Troops,
			sbp = SBP.CW.COMMANDOS_PARATROOPER_SP,
			pos = eg_intersectionK_garrison1,
			dest = eg_intersectionK_garrison1,
			number = 1,
			load = 2,
			attackmove = true,
			pos_facing = true,
			upgrade = UPG.ELITE.PANZERSCHRECK,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
		
		{
			sg = sg_BaseCounterAttack_Troops,
			sbp = SBP.CW.COMMANDOS,
			pos = eg_intersectionK_garrison1,
			dest = eg_intersectionK_garrison1,
			number = 1,
			load = 5,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = false,
			garrison = false,
			garrison_loc = nil,
			managed = false,
		},
	}
	
end

-- preset any units or events needed before the kickoff
function BaseCounterAttack_Preset()

	-- trigger intersection K if it hasn't already been tripped
	if v_intersectionK == false then
		IntersectionK_Preset()
		v_intersectionK = true
	end
	
	Rule_RemoveIfExist (IdleTimer) -- Clear Idle Timer while attackers are present
	
	-- Spawn the troops
	if Player_CanSeePosition ( player1, EGroup_GetPosition (eg_intersectionK_garrison1) ) == false then
		Arnhem_EncounterSpawner (t_arnhem_allies.BaseAttackers, sg_BaseCounterAttack_Troops)
	else
		Arnhem_EncounterSpawner (t_arnhem_allies.BaseAttackers_CanSee, sg_BaseCounterAttack_Troops)
		Cmd_Ungarrison (sg_BaseCounterAttack_Troops)
	end
	
	SGroup_Clear (sg_player1_all)
	Player_GetAll (player1, sg_player1_all)
	Rule_AddInterval (DelayBaseCounterAttack_Kickoff, 1)
	
end

-- When the player is not being attacked, then launch the counterattack
function DelayBaseCounterAttack_Kickoff()

	if SGroup_IsUnderAttack (sg_player1_all, ANY, 5) == false then 
		
		EventCue_Create (CUE.NORMAL, 1469906, 1469906, sg_BaseCounterAttack_Troops) -- Event cue the ambush
		Util_CreateEntities (player2, eg_TellerMines, EBP.ELITE.MINE_TELLER, mkr_tellermine1, 1)
		Util_CreateEntities (player2, eg_TellerMines, EBP.ELITE.MINE_TELLER, mkr_tellermine2, 1)
		EGroup_Kill (eg_TellerMines)
		EGroup_DestroyAllEntities (eg_blockade_nearbase)
		EGroup_DestroyAllEntities (eg_burnbuses_nearbase)
		
		SGroup_SetAutoTargetting (sg_BaseCounterAttack_Troops, "hardpoint_01", false)
		Rule_AddInterval (BaseCounterAttack_Monitor, 1)
		Rule_RemoveMe()
		
	end
	
end

function BaseCounterAttack_Monitor()
	
	if SGroup_Count (sg_BaseCounterAttack_Troops) == 0 then
		if Rule_Exists (IdleTimer) == false then Rule_AddInterval (IdleTimer, 2) end -- Recreate the idle timer
		Rule_RemoveMe()
		return
	end
	
	-- If the counterattackers are near the base still, then move them along the path
	if g_BaseCounterAttack_State == "NearBase" then
		Cmd_SquadPath (sg_BaseCounterAttack_Troops, "wp_BaseCounterAttack_Path", true, 0, false, 0)
	end
	
	if g_BaseCounterAttack_State == "NearBase" then
		if Prox_AreSquadsNearMarker (sg_BaseCounterAttack_Troops, mkr_intersectionB_jeep_1, ANY, 30) == false or 
		SGroup_IsUnderAttack (sg_BaseCounterAttack_Troops, ANY, 10) then
			g_BaseCounterAttack_State = "ReadyToAttack"
			SGroup_SetAutoTargetting (sg_BaseCounterAttack_Troops, "hardpoint_01", true)
		end
	end
	
	if g_BaseCounterAttack_State == "ReadyToAttack" then
		
		if SGroup_IsUnderAttack (sg_BaseCounterAttack_Troops, ANY, 10) then
			SGroup_Clear (sg_temp)
			SGroup_GetLastAttacker (sg_BaseCounterAttack_Troops, sg_temp)
			Cmd_Attack (sg_BaseCounterAttack_Troops, sg_temp)
		else
			local temp = Player_GetSquadConcentration (player1, true, nil, t_PanzerElite_Tanks)
			if temp ~= nil then Cmd_AttackMove (sg_BaseCounterAttack_Troops, temp) end
		end
		
	end
	
	if SGroup_TotalMembersCount (sg_BaseCounterAttack_Troops) < 5 and SGroup_IsRetreating (sg_BaseCounterAttack_Troops, ANY) == false then
		Cmd_Retreat (sg_BaseCounterAttack_Troops, mkr_intersectionJ_2, mkr_intersectionJ_2)
		if Rule_Exists (IdleTimer) == false then Rule_AddInterval (IdleTimer, 2) end -- Recreate the idle timer
		Rule_RemoveMe()
	end
	
end

function CheckSurrender_Init()
	
	--sgroups
	sg_lastsquad = SGroup_CreateIfNotFound ("sg_lastsquad")
	sg_KTattacker = SGroup_CreateIfNotFound ("sg_KTattacker")
	sg_ArmorAttacker = SGroup_CreateIfNotFound ("sg_ArmorAttacker")
	
	-- Tables needed for the init below
	t_SurrenderB = {}
	t_SurrenderC = {}
	t_SurrenderD = {}
	t_SurrenderE = {}
	t_SurrenderF = {}
	t_SurrenderG = {}
	t_SurrenderH = {}
	t_SurrenderI = {}
	t_SurrenderJ = {}
	t_SurrenderK = {}
	t_SurrenderL = {}
	t_SurrenderM = {}
	t_SurrenderSR1 = {}
	
	t_TempHintpoints = {}
	t_HP_SquadPositions = {}
	
	g_LastValue = 200 -- Setting to a high value for later comparison
	
	g_IntersectionA_Surrendered = false
	
	-- Table of encounters with generic surrender functionality
	t_Monitor_Intersections = {
		{-- 1
		table_name = t_arnhem_allies.t_intersections_B,
		marker = mkr_intersectionB,
		egroup = eg_IntersectionD,
		surrender_table = t_SurrenderB,
		AT_Threats = 0,
		sgroup = sg_intersections_B_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = true,
		surrendered = false,
		all_dead = false,
		},
		{-- 2
		table_name = t_arnhem_allies.t_intersections_C,
		marker = mkr_intersectionC,
		egroup = eg_SupplyDepot_1,
		surrender_table = t_SurrenderC,
		AT_Threats = 0,
		sgroup = sg_intersections_C_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},		
		{-- 3
		table_name = t_arnhem_allies.t_intersections_D,
		marker = mkr_intersectionD_spawn_1,
		egroup = eg_IntersectionD,
		surrender_table = t_SurrenderD,
		AT_Threats = 0,
		sgroup = sg_intersections_D_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 4
		table_name = t_arnhem_allies.t_intersections_E,
		marker = mkr_intersectionE,
		egroup = eg_IntersectionE,
		surrender_table = t_SurrenderE,
		AT_Threats = 0,
		sgroup = sg_intersections_E_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 5
		table_name = t_arnhem_allies.t_intersections_F,
		marker = mkr_intersectionF,
		egroup = eg_BridgePoint_1,
		surrender_table = t_SurrenderF,
		AT_Threats = 0,
		sgroup = sg_intersections_F_all,
		fg_active = false,
		triggered = false,
		flak88 = true,
		flakcrew = sg_IntersectionF_gunteam_1,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 6
		table_name = t_arnhem_allies.t_intersections_G,
		marker = mkr_intersectionG,
		egroup = eg_BridgePoint_2,
		surrender_table = t_SurrenderG,
		AT_Threats = 0,
		sgroup = sg_intersections_G_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 7
		table_name = t_arnhem_allies.t_intersections_H,
		marker = mkr_intersectionH,
		egroup = eg_SupplyDepot_2,
		surrender_table = t_SurrenderH,
		AT_Threats = 0,
		sgroup = sg_intersections_H_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 8
		table_name = t_arnhem_allies.t_intersections_I,
		marker = mkr_intersectionI,
		egroup = eg_HQ2point,
		surrender_table = t_SurrenderI,
		AT_Threats = 0,
		sgroup = sg_intersections_I_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 9
		table_name = t_arnhem_allies.t_intersections_J,
		marker = mkr_intersectionJ_1,
		egroup = eg_intersectionJ,
		surrender_table = t_SurrenderJ,
		AT_Threats = 0,
		sgroup = sg_intersections_J_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 10
		table_name = t_arnhem_allies.t_intersections_K,
		marker = mkr_intersectionK,
		egroup = eg_IntersectionK,
		surrender_table = t_SurrenderK,
		AT_Threats = 0,
		sgroup = sg_intersections_K_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 11
		table_name = t_arnhem_allies.t_intersections_SR1,
		marker = mkr_sp_sr1_8,
		egroup = eg_SecureRoad1,
		surrender_table = t_SurrenderSR1,
		AT_Threats = 0,
		sgroup = sg_IntersectionSR1_All,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 12
		table_name = t_arnhem_allies.t_intersections_L,
		marker = mkr_IntersectionL_Point_Prox,
		egroup = eg_IntersectionL,
		surrender_table = t_SurrenderL,
		AT_Threats = 0,
		sgroup = sg_intersections_L_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
		{-- 13
		table_name = t_arnhem_allies.t_intersections_M,
		marker = mkr_intersectionC,
		egroup = eg_IntersectionM,
		surrender_table = t_SurrenderM,
		AT_Threats = 0,
		sgroup = sg_intersections_M_all,
		fg_active = false,
		triggered = false,
		flak88 = false,
		flakcrew = nil,
		teaching = false,
		surrendered = false,
		all_dead = false,
		},
	}
	
end



function CheckSurrender_Kickoff()

	-- Put a far-away sgroup into the sg_lastsquad to allow the prox in the add-hint-point section to work
	SGroup_AddGroup (sg_lastsquad, sg_KingTigers)
	
	-- Add PaK38s and/or FlaK 88s to surrender table before running the monitor function
	
	for k, intersection in pairs (t_Monitor_Intersections) do
		
		if intersection.fg_active == true and intersection.triggered == false then
			
			intersection.triggered = true
			
			for n, this in pairs (intersection.table_name) do
				
				if this.sbp == SBP.CW.COMMANDOS_PAK38_SP then
					table.insert (intersection.surrender_table, this.sg)
					
				elseif intersection.flak88 == true then -- this is only for intersection F's Flak88
					table.insert (intersection.surrender_table, sg_IntersectionF_gunteam_1)
					
				end
				
				
			end
			
		end
		
	end
	
	
	-- Add the monitor function if it's not already active
	if Rule_Exists(CheckSurrender_Monitor) == false then Rule_AddInterval(CheckSurrender_Monitor, 3) end
	
end

function CheckSurrender_Monitor()

	for k, intersection in pairs (t_Monitor_Intersections) do
		
		-- If this intersection has been activated&triggered but NOT surrendered yet then proceed
		if intersection.triggered == true and intersection.surrendered == false then
			
			intersection.all_dead = true
			
			if table.getn(intersection.surrender_table) > 0 then
				
				intersection.AT_Threats = table.getn(intersection.surrender_table) -- Put the value into the table for reference
				
				-- Check each threat from the table and see if the sgroup is empty, if it isn't then the alldead is false
				for j=1, intersection.AT_Threats do
					
					if intersection.surrender_table[j] ~= nil then
						
						if SGroup_IsEmpty(intersection.surrender_table[j]) == false then
							intersection.all_dead = false
						end
						
						-- Add the hintpoint to the AT guns in the intersection
						if intersection.teaching == true and g_Teaching_ATGunHintpoint == nil and SGroup_IsEmpty(intersection.surrender_table[j]) == false then
							g_Teaching_ATGunHintpoint = HintPoint_Add(intersection.surrender_table[j], true, 1469910)
						end
						
					end
					
				end
				
			end
			
			-- All the AT threats are dead and it's teaching, tell player to bring up armour
			if intersection.all_dead == true and intersection.teaching == true then
				
				-- Get a position and distance for each squad to a table, first run the check for the armor threats
				SGroup_ForEach (intersection.sgroup, CheckForArmorThreat)
				SGroup_ForEach (intersection.sgroup, AddSquadsandPositions)
				
				-- Filter the table to the closest squad
				local temp_value = SGroup_Count (sg_ArmorAttacker) + 1
				
				for i = 1, temp_value do
					FilterSquadProxTable()
				end
				
				-- Put a hintpoint on the armored attacking threat
				g_TeachingHintpoint = HintPoint_Add (sg_ArmorAttacker, true, 1469911)
				
				g_TeachingHP_Exists = true
				
				intersection.teaching = false
				
			end
			
			
			
			-- Player has taken the territory, give up
			if Player_OwnsEGroup (player1, intersection.egroup) then
				
				print ("player owns territory, give up")
				
				intersection.surrendered = true -- flag the intersection as completed
				
				for p, this in pairs(intersection.table_name) do
					
					if SGroup_IsEmpty(this.sg) == false and SGroup_ContainsBlueprints (this.sg, SBP.CW.COMMANDOS_JEEP, ALL) == false then
						Cmd_Surrender(this.sg, nil, mkr_surrender_loc)
					elseif SGroup_ContainsBlueprints (this.sg, SBP.CW.COMMANDOS_JEEP, ALL) == true then
						Cmd_Move (this.sg, mkr_HQ2_Offmap, false, mkr_HQ2_Offmap)
					end
					
					if g_TeachingHP_Exists == true and Rule_Exists (RemoveTeachingHintpoints) == false then
						Rule_AddOneShot (RemoveTeachingHintpoints, 20) -- Remove the hintpoint after X seconds
					end
					
				end
				
				return
				
			end
			
			
			-- All the AT threats are dead and there is an armoured threat attacking a member of the Sgroup, then give up
			if intersection.all_dead == true and SGroup_ForEach (intersection.sgroup, CheckForArmorThreat) == true then
				
				if SGroup_ContainsBlueprints (sg_ArmorAttacker, SBP.ELITE.KING_TIGER_ARNHEM, ALL) then
					if Event_IsAnyRunning () == false then
						local rand = World_GetRand(1, table.getn(t_AMBI_speech.KingTigerReaction))
						Util_AutoAmbient (t_AMBI_speech.KingTigerReaction[rand])
					end
				end
				
				for n, this in pairs(intersection.table_name) do
					
					if SGroup_IsEmpty(this.sg) == false and SGroup_ContainsBlueprints (this.sg, SBP.CW.COMMANDOS_JEEP, ALL) == false then
						Cmd_Surrender(this.sg, nil, mkr_surrender_loc)
					elseif SGroup_ContainsBlueprints (this.sg, SBP.CW.COMMANDOS_JEEP, ALL) == true then
						Cmd_Move (this.sg, mkr_HQ2_Offmap, false, mkr_HQ2_Offmap)
					end
					
				end
				
				intersection.surrendered = true -- flag the intersection as completed
				
				if g_TeachingHP_Exists == true and Rule_Exists (RemoveTeachingHintpoints) == false then
					Rule_AddOneShot (RemoveTeachingHintpoints, 10) -- Remove the hintpoint after X seconds
				end
				
			end
			
		end
		
	end
	
end

------------------------------------------------------------------------------------------------------------------------
CheckForArmorThreat = function (gid, idx, sid)
	-- If there's a King Tiger close to the commandos or they are being attacked by one then return true
	SGroup_Clear (sg_ArmorAttacker)
	Squad_GetLastAttacker (sid, sg_ArmorAttacker)
	SGroup_Filter (sg_ArmorAttacker, t_PanzerElite_Tanks, FILTER_KEEP)
	
	if SGroup_IsEmpty(sg_ArmorAttacker) == false then
		if SGroup_Count (sg_ArmorAttacker) >= 1 and Squad_IsUnderAttack (sid, 10) then return true end
	end
	
end

AddSquadsandPositions = function (gid, idx, sid)
	
	local CurrentSquadPosition = Squad_GetPosition (sid) -- add squad position to a table for comparison
	SGroup_Clear (sg_temp)
	SGroup_Add (sg_temp, sid)
	local Distance_ToKT = Prox_SGroupSGroup (sg_ArmorAttacker, sg_temp) -- add distance to armored attackers for comparison
	table.insert (t_HP_SquadPositions, {SquadPos = CurrentSquadPosition, Distance = Distance_ToKT, SquadID = sid}) -- add to table
	
end

function FilterSquadProxTable()
	
	if table.getn (t_HP_SquadPositions) > 1 then
		
		-- Filter the table down to the closest squad
		for q, squad in pairs (t_HP_SquadPositions) do
			
			if squad.Distance < g_LastValue then 
				g_LastValue = squad.Distance
			else table.remove (t_HP_SquadPositions, q)
			end
			
		end
		
	end
	
end

function RemoveTeachingHintpoints()
	
	HintPoint_Remove(g_TeachingHintpoint)
	HintPoint_Remove(g_Teaching_ATGunHintpoint)

end

------------------------------------------------------------------------------------------------------------------------





-------------------------------------------------------------------------

-- Reinforcements Arrive

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Reinforcements_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_Reinforcements_SR1 = SGroup_CreateIfNotFound ("sg_Reinforcements_SR1")
	sg_Reinforcements_Transport_SR1 = SGroup_CreateIfNotFound ("sg_Reinforcements_Transport_SR1")
	sg_Reinforcements_SR2 = SGroup_CreateIfNotFound ("sg_Reinforcements_SR2")
	sg_Reinforcements_Transport_SR2 = SGroup_CreateIfNotFound ("sg_Reinforcements_Transport_SR2")

	-- Define reinforcements table
	t_Reinforcements = {
		{
			point = eg_SecureRoad1,
			sgroup = sg_Reinforcements_SR1,
			spawn = mkr_offmap_SR1,
			destination = mkr_sp_sr1_reinforcement_dest,
		},
		{
			point = eg_SecureRoad2,
			sgroup = sg_Reinforcements_SR2,
			spawn = mkr_offmap_SR2,
			destination = mkr_intersectionB_mg_dest_2,
		},
	}
end

-- No preset needed, proceed to kickoff action when called
function Reinforcements_Kickoff(target)

	-- spawn squads
	for k, this in pairs (t_Reinforcements) do
		if this.point == target	then
			
			-- spawn the reinforcements depending on how many points captured, and send to the points indicated on table above
			if t_sr.PointsCaptured == 2 then 
				Util_AutoIntel (t_OBJ_speech.RoadSecured2)
				Util_CreateSquads (player1, this.sgroup, SBP.ELITE.HUMMEL, this.spawn, NIL_DEST, 1, nil, true)
				Cmd_Move (this.sgroup, this.destination, nil, nil, nil, OFFSET_BACK, 5)
			elseif t_sr.PointsCaptured == 1 then 
				Util_AutoIntel (t_OBJ_speech.RoadSecured1)
				Util_CreateSquads (player1, this.sgroup, SBP.ELITE.PANZER_IV, this.spawn, NIL_DEST, 2, nil, true)
				Cmd_Move (this.sgroup, this.destination, nil, nil, nil, OFFSET_BACK, 5)
			end
			
			Util_ReinforceEvent (this.sgroup)
			UI_CreateMinimapBlip (this.sgroup, 30,  BT_GeneralPing)
			
		end
	end
	
end

-------------------------------------------------------------------------

-- King Tiger Monitor

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function KingTiger_Monitor_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_KingTigers = SGroup_CreateIfNotFound ("sg_KingTigers")
	sg_KingTiger_Starting = SGroup_CreateIfNotFound ("sg_KingTiger_Starting")
	
	t_KingTiger_Threats = {	SBP.CW.COMMANDOS_PAK38_SP, SBP.CW.COMMANDOS_PARATROOPER_SP, SBP.ALLIES.SHERMAN, }
	
	-- State 0 = Not under attack or needing repairs, 1 = Under Attack, 2 = needs repairs, 3 = nearly dead, 4 = warned about nearly dead, 5 = dead
	g_StartingKT_State = 0						
	
	g_StartingKT_CurrentHealth = 1
	g_StartingKT_PlayedNearlyDeadSpeech = false
	g_StartingKT_WreckPosition = nil
	g_StartingKT_Hintpoint = nil
	g_StartingKT_LastKnownPosition = nil
	g_StartingKT_destroyed = false
	
end

-- Monitor the player's starting King Tiger to play speech, warning hintpoints, etc...
function KingTiger_Monitor()
	
	-- If the player's starting KT is alive
	if SGroup_Count (sg_KingTiger_Starting) > 0 then
		
		-- Get the squad ID
		local sid = SGroup_GetSpawnedSquadAt (sg_KingTiger_Starting, 1)
		local KT_attacker = SGroup_CreateIfNotFound ("KT_attacker")
		
		-- Get the health of the King Tiger squad
		if Squad_GetHealthPercentage (sid) ~= 1 then
			g_StartingKT_CurrentHealth = Squad_GetHealthPercentage (sid)
		end
		
		-- Find out if the attackers are a threat
		if SGroup_IsUnderAttack (sg_KingTiger_Starting, ALL, 5) then
			SGroup_GetLastAttacker (sg_KingTiger_Starting, KT_attacker)
			SGroup_FilterThreat (KT_attacker, t_KingTiger_Threats, true)
		end
		
		-- If the tiger's under attack by a threat and the state is 0 (not under attack or needing repairs) then transition State 1	
		if g_StartingKT_CurrentHealth > 0.50 and SGroup_IsEmpty (KT_attacker) == false and 
		SGroup_IsUnderAttack (sg_KingTiger_Starting, ALL, 10) and g_StartingKT_State == 0 then
			
			print ("King Tiger is now in State 1 -- under attack and not needing repairs (KT Monitor Function)")
			g_StartingKT_State = 1
			
			-- Creat the event cue
			EventCue_Create (CUE.ATTACKED, 1469950, 1469950, sg_KingTiger_Starting)
			
			-- Play random speech from table
			local rand = World_GetRand(1, table.getn(t_TAC_speech.TigerUnderAttack))
			Util_AutoIntel(t_TAC_speech.TigerUnderAttack[rand])
			
			-- Start a timer to make sure it's been at least 30 seconds since last playing the speech
			Timer_Start (PlayedTigerAttacked_Cue, 30)
			
		-- Otherwise, if it's been 30 seconds since the last combat (of any kind) ended for the KT and the health is above 50%, then set state to 0 again
		elseif g_StartingKT_CurrentHealth > 0.50 and Timer_GetRemaining (PlayedTigerAttacked_Cue) <= 0 and g_StartingKT_State ~= 0 then
			
			print ("KT is now in State 0 -- not under attack and not needing repairs (KT Monitor Function)")
			g_StartingKT_State = 0
			
		end
		
		-- If the KT is in need of repairs (at or below 50% health) but not nearly dead then move to State 2
		if g_StartingKT_CurrentHealth <= 0.50 and g_StartingKT_CurrentHealth > 0.35 and g_StartingKT_State ~= 2 then
			
			print ("KT Is now in State 2 -- damaged warning (KT Monitor Function)")
			g_StartingKT_State = 2
			
			-- Creat the event cue
			EventCue_Create (CUE.NORMAL, 1469951, 1469951, sg_KingTiger_Starting, 1469951)
			
			-- Play random speech from table
			local rand = World_GetRand(1, table.getn(t_TAC_speech.TigerNearlyDead))
			Util_AutoIntel(t_TAC_speech.TigerNearlyDead[rand])
			
		end
		
		-- When nearly dead, start checking every second for death and getting the latest position
		if g_StartingKT_CurrentHealth <= 0.35 and g_StartingKT_State ~= 3 then
			
			print ("KT Is now in State 3 -- badly damaged warning, running CheckforDeath rule (KT Monitor Function)")
			g_StartingKT_State = 3
			
			g_StartingKT_LastKnownPosition = Squad_GetPosition (sid)
			if Rule_Exists (CheckforKingTigerDeath) == false then Rule_AddInterval (CheckforKingTigerDeath, 1) end
			
		end
		
	-- If there's nothing in the SGroup then the starting King Tiger is dead, stop monitoring
	else 
		Rule_RemoveMe()
	end
	
	-- If the player has finished the Secure Roads objective they are able to call in new KTs, so stop monitoring the starting one
	if Objective_IsComplete (OBJ_SecureRoads) == true then
		
		Rule_AddInterval (AreAllKTs_Dead, 5)
		Rule_RemoveMe()
		
	end
	
end


function CheckforKingTigerDeath()
	
	-- Check if the KT is destroyed, but is still in State 3 (badly damaged)
	if g_StartingKT_State == 3 and SGroup_Count (sg_KingTiger_Starting) ~= 0 then
		
		-- Find out if the attackers are a threat
		local KT_attacker = SGroup_CreateIfNotFound ("KT_attacker")
		if SGroup_IsUnderAttack (sg_KingTiger_Starting, ALL, 5) then
			SGroup_GetLastAttacker (sg_KingTiger_Starting, KT_attacker)
			SGroup_FilterThreat (KT_attacker, t_KingTiger_Threats, true)
		end
		
		-- If they are, then warn player
		if SGroup_IsEmpty (KT_attacker) == false and g_StartingKT_PlayedNearlyDeadSpeech == false then
			
			-- Add a hintpoint
			HintMouseover_Add (1469951, sg_KingTiger_Starting, 10, false)
			
			-- Play random speech from table
			local rand = World_GetRand(1, table.getn(t_TAC_speech.TigerNearlyDead))
			Util_AutoIntel(t_TAC_speech.TigerNearlyDead[rand])
			
			-- Set to a new state (4) it so the speech doesn't play again until repaired
			g_StartingKT_PlayedNearlyDeadSpeech = true
			
		end
		
		local sid = SGroup_GetSpawnedSquadAt (sg_KingTiger_Starting, 1)
		g_StartingKT_WreckPosition = Squad_GetPosition (sid)
		
	end
	
	-- If the KT is in State 3 or 4 (nearly dead) and is destroyed, then warn the player and make the wreck easier to find
	if (g_StartingKT_State == 3 or g_StartingKT_State == 4) and SGroup_Count (sg_KingTiger_Starting) == 0 then
		
		g_StartingKT_State = 5 -- It's... dead... Jim
		
		Util_AutoIntel (t_TAC_speech.TigerDestroyed)
		EventCue_Create (CUE.NORMAL, 1469952, 1469952, g_StartingKT_WreckPosition)
		--HintPoint_Remove (g_StartingKT_Hintpoint)
		HintMouseover_Remove (1469951, sg_KingTiger_Starting)
		g_KTWreck_Hintpoint = HintPoint_Add (g_StartingKT_WreckPosition, true, 1469953)
		Rule_AddInterval (WatchForKT_Recovery, 5)
		Rule_RemoveMe()
		
	end
	
end	
	
function WatchForKT_Recovery()
	
	if Objective_IsComplete (OBJ_SecureRoads) == false then
		
		Player_GetAll (player1, sg_KingTiger_Starting)
		SGroup_Filter (sg_KingTiger_Starting, SBP.ELITE.KING_TIGER_ARNHEM, FILTER_KEEP)
		
		if SGroup_TotalMembersCount (sg_KingTiger_Starting) > 0 then
			
			HintPoint_Remove (g_KTWreck_Hintpoint)
			g_StartingKT_destroyed = false
			Rule_AddInterval (KingTiger_Monitor, 5)
			Rule_RemoveMe()
			
		end
		
	elseif Objective_IsComplete (OBJ_SecureRoads) == true then
		
		Rule_RemoveMe()		
		
	end
	
end	
	
	
function AreAllKTs_Dead()
	
	Player_GetAll (player1, sg_KingTigers)
	SGroup_Filter (sg_KingTigers, SBP.ELITE.KING_TIGER_ARNHEM, FILTER_KEEP)
	
	if SGroup_TotalMembersCount (sg_KingTigers) == 0 then
		
		v_tiger_reinforce_id = UI_FlashAbilityButton (ABILITY.SP.KING_TIGER, true, BT_UI_Weak_AbilityBtn)
		
	elseif v_tiger_reinforce_id ~= nil then
		
		UI_StopFlashing (v_tiger_reinforce_id)
		v_tiger_reinforce_id = nil
		
	end
	
end
	

-------------------------------------------------------------------------

-- Idle Timer

-------------------------------------------------------------------------

function IdleTimer()

	-- This function keeps an internal clock of the time in which the player has not been involved in combat.
	
	local p1All_temp = SGroup_CreateIfNotFound ("p1All_temp")
	Player_GetAll (player1, p1All_temp)
	
	--Player is attacking or being attacked
	if SGroup_IsUnderAttack (p1All_temp, ANY, 5) == false and SGroup_IsDoingAttack (p1All_temp, ANY, 5) == false then
		g_IdleTimer = g_IdleTimer +1
	else
		g_IdleTimer = 0
	end
	
	-- Player is idle
	if g_IdleTimer >= g_IdleAttack_Time then -- Play ambient background noise
		
		IdleAttack_Preset()-- Deploy the idle attack force
		
	end

end



-------------------------------------------------------------------------

-- Idle Attackers
-- Deploy skirmish counterattack forces

-------------------------------------------------------------------------


-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function IdleAttack_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_IdleAttackTarget = SGroup_CreateIfNotFound ("sg_IdleAttackTarget")
	sg_IdleAttackUnits = SGroup_CreateIfNotFound ("sg_IdleAttackUnits")
	
	t_PossibleHarrasmentLocations = {
	mkr_possible_harassmentspawn1, mkr_possible_harassmentspawn2, mkr_possible_harassmentspawn3,
	mkr_possible_harassmentspawn3, mkr_possible_harassmentspawn5, mkr_possible_harassmentspawn6,
	mkr_possible_harassmentspawn7, mkr_possible_harassmentspawn8,
	}
	
	g_IdleAttack_Time = 0
	if g_difficulty == GD_EASY then g_IdleAttack_Time = 70
	elseif g_difficulty == GD_NORMAL then g_IdleAttack_Time = 60
	elseif g_difficulty == GD_HARD then g_IdleAttack_Time = 50
	elseif g_difficulty == GD_EXPERT then g_IdleAttack_Time = 40
	end
	
end

-- preset any units or events needed before the kickoff
function IdleAttack_Preset()
	
	-- Copy table of markers
	t_HarrasmentLocations_Current = World_CopyTable (t_PossibleHarrasmentLocations)
	
	-- List of targets for attackers
	t_IATargetList = {SBP.ELITE.KING_TIGER_ARNHEM, SBP.ELITE.HETZER}
	
	-- Find the closest possible spawn point not visible to player
	for k, this in pairs (t_PossibleHarrasmentLocations) do
		if Player_CanSeePosition (player1, Util_GetPosition (this)) or Prox_ArePlayersNearMarker (player1, Util_GetPosition (this), ANY, 20) then 
			table.remove (t_HarrasmentLocations_Current, k) 
		end
	end
	
	-- End the function if the player can see all of the possible spawn locations
	if table.getn (t_HarrasmentLocations_Current) == 0 then return end
	
	-- Get a target
	GetTarget()
	
	-- If the target is empty (no tanks, King Tiger or Hetzer to attack) then abort the rule/recreate idle timer
	if SGroup_Count (sg_IdleAttackTarget) == 0 then
		
		if Rule_Exists (IdleTimer) == false then Rule_AddInterval (IdleTimer, 2) end
		return
		
	end
	
	-- Get the closest marker to the target
	g_IdleAttackSpawn = Util_GetClosestMarker (sg_IdleAttackTarget, t_HarrasmentLocations_Current)
	
	Util_CreateSquads (player2, sg_IdleAttackUnits, SBP.CW.COMMANDOS, g_IdleAttackSpawn, NIL_DEST, 1, 2, false, nil, UPG.ELITE.PANZERSCHRECK)
	Util_CreateSquads (player2, sg_IdleAttackUnits, SBP.CW.COMMANDOS, g_IdleAttackSpawn, NIL_DEST, 1, 4, false, nil, nil)
	
	EventCue_Create (CUE.NORMAL, 1469906, 1469906, sg_IdleAttackUnits) -- Event cue the ambush
	Cmd_AttackMove (sg_IdleAttackUnits, sg_IdleAttackTarget)
	
	if Event_IsAnyRunning () == false then
		
		local rand = World_GetRand(1, table.getn(t_AMBI_speech.BackgroundNoise))
		Util_AutoAmbient (t_AMBI_speech.BackgroundNoise[rand])
		
	end
	
	Rule_AddInterval (IdleAttacker_StatusCheck, 1)
	
end
 
-- Monitors the status of the Idle Attacker sgroup and takes approriate actions. Also removes the idle timer.
function IdleAttacker_StatusCheck()

	Rule_RemoveIfExist (IdleTimer) -- Clear Idle Timer while attackers are present

	-- if the group is destroyed then clean up and stop the rest of the status check
	if SGroup_Count (sg_IdleAttackUnits) == 0 then
		Rule_AddInterval (IdleTimer, 2) -- Recreate the idle timer
		Rule_RemoveMe ()
		return
	end
	
	-- If the group is currently doing nothing then get a new attack target
	if SGroup_IsIdle (sg_IdleAttackUnits, ALL) == true then 
		GetTarget()
		if SGroup_Count (sg_IdleAttackTarget) ~= 0 then
			Cmd_AttackMove (sg_IdleAttackUnits, sg_IdleAttackTarget)
		end
	end
	
	-- Check to see if the Idle Attackers are below X members and if so withdraw.
	if  SGroup_TotalMembersCount (sg_IdleAttackUnits) <= 4 or SGroup_Count (sg_IdleAttackTarget) == 0 then
		Cmd_Ability (sg_IdleAttackUnits, ABILITY.CW.SUPPRESSION_BREAK) -- Pop smoke
		Cmd_Retreat (sg_IdleAttackUnits)
		Rule_RemoveMe()
		Rule_AddInterval (Delete_IdleAttackers, 1)
	end
	
end

function GetTarget()
	
	-- Get any of the priority targets
	Player_GetAll (player1, sg_IdleAttackTarget)
	SGroup_Filter (sg_IdleAttackTarget, t_IATargetList, FILTER_KEEP)
	
	if SGroup_Count (sg_IdleAttackTarget) == 0 then
		-- Otherwise get the largest concentration of player tanks to attack
		local temp = Player_GetSquadConcentration (player1, true, t_PanzerElite_Tanks)
		if temp ~= nil then SGroup_AddGroup (sg_IdleAttackTarget, temp) end
	end
	
end

-- Once the unit is out of player's sight remove from map to allow another spawn.
function Delete_IdleAttackers()

	if Player_CanSeeSGroup (player1, sg_IdleAttackUnits, ALL) == false then 
		SGroup_DestroyAllSquads (sg_IdleAttackUnits)
		Rule_AddInterval (IdleTimer, 2) -- Recreate the idle timer.
		Rule_RemoveMe ()
	end

end



-------------------------------------------------------------------------

-- Nebelwerfers

-------------------------------------------------------------------------

-- 'Init()' is used to initialize the Encounter data
-- anything that needs to be there for the Obj to work
-- does not need to be called at 'OnInit()'
function Nebelwerfers_Init()

	-- define sgroups, egroups, etc associated with this Encounter
	sg_supplydepot_nebs = SGroup_CreateIfNotFound("sg_supplydepot_nebs")
	g_NebsFired = false
	sg_neb_target = SGroup_CreateIfNotFound("sg_neb_target")
	
	t_arnhem_allies.t_nebs = {
		{
			sg = SGroup_CreateIfNotFound("sg_supplydepot_nebs_1"),
			sbp = SBP.CW.COMMANDOS_NEBEL_SP,
			pos = mkr_hq_neb_1,
			dest = mkr_hq_neb_1,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
			nebfireorigin = "sg_supplydepot_nebs_1",
			nebfirelocation = mkr_neb_fire_1,
			state = 1,
		},
		
		{
			sg = SGroup_CreateIfNotFound("sg_supplydepot_nebs_2"),
			sbp = SBP.CW.COMMANDOS_NEBEL_SP,
			pos = mkr_hq_neb_2,
			dest = mkr_hq_neb_2,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
			nebfireorigin = "sg_supplydepot_nebs_2",
			nebfirelocation = mkr_neb_fire_2,
			state = 1,
		},
		
		{
			sg = SGroup_CreateIfNotFound("sg_supplydepot_nebs_3"),
			sbp = SBP.CW.COMMANDOS_NEBEL_SP,
			pos = mkr_hq_neb_3,
			dest = mkr_hq_neb_3,
			number = 1,
			load = 4,
			attackmove = true,
			pos_facing = true,
			upgrade = nil,
			heavy = true,
			garrison = false,
			garrison_loc = nil,
			managed = false,
			nebfireorigin = "sg_supplydepot_nebs_3",
			nebfirelocation = mkr_neb_fire_3,
			state = 1,
		},
		
	}
	
	if g_difficulty == GD_EASY then 
		local rand = World_GetRand (1, table.getn (t_arnhem_allies.t_nebs))
		-- Remove a random neb from the spawn table
		table.remove (t_arnhem_allies.t_nebs, rand)
		-- Remove another neb from the spawn table based on the random number
		if rand == 1 then table.remove (t_arnhem_allies.t_nebs, 3) end
		if rand == 2 then table.remove (t_arnhem_allies.t_nebs, 1) end
		if rand == 3 then table.remove (t_arnhem_allies.t_nebs, 2) end
	elseif g_difficulty == GD_NORMAL then 
		table.remove (t_arnhem_allies.t_nebs, 3) -- Remove a random neb from the spawn table
	end
	
	Nebelwerfers_Preset()
	
end

-- preset any units or events needed before the kickoff
function Nebelwerfers_Preset()

	-- spawn squads
	Arnhem_EncounterSpawner(t_arnhem_allies.t_nebs, sg_supplydepot_nebs)
	
	-- Get the opening attack time for the nebs
	GetNebsAttackTime()
	
	-- start enemy behavior
	Timer_Start (NebFired_Timer, 0)
	
	-- do other cool things

end

function GetNebsAttackTime()
	
	g_NebsAttack_Time = 0
	
	if g_difficulty == GD_EASY then 
		
		local rand = World_GetRand (120, 160)
		g_NebsAttack_Time = rand
		
	elseif g_difficulty == GD_NORMAL then
		
		local rand = World_GetRand (100, 120)
		g_NebsAttack_Time = rand
		
	elseif g_difficulty == GD_HARD then 
		
		local rand = World_GetRand (80, 100)
		g_NebsAttack_Time = rand
		
	elseif g_difficulty == GD_EXPERT then 
		
		local rand = World_GetRand (70, 80)
		g_NebsAttack_Time = rand
		
	end
	
end

-- start the related action
function SupplyDepots_FireNebs()	
	
	--do all the following only if the nebs haven't fired in the established timeline
	if Timer_GetRemaining (NebFired_Timer) <= 0 then
		
		-- Get a target for nebs
		SGroup_Clear (sg_neb_target)
		local temp = Player_GetSquadConcentration (player1, true, nil, t_PanzerElite_Tanks)
		if temp ~= nil then 
			SGroup_AddGroup (sg_neb_target, temp)
			g_neb_target = SGroup_GetPosition (sg_neb_target)
		else return
		end
		
		-- Get all commando troops
		local FriendlyTroops = SGroup_CreateIfNotFound("FriendlyTroops")
		Player_GetAllSquadsNearMarker(player2, FriendlyTroops, g_neb_target, 10)
		
		-- Fire only if there are no friendlies near the target zone and it's not targeting the player's HQ
		if SGroup_Count (FriendlyTroops) == 0 
		and Prox_AreSquadsNearMarker ( sg_neb_target, World_GetTerritorySectorID ( Util_GetPosition (mkr_attackers_playersbase_1) ), ANY) == false then
			
			for k, this in pairs (t_arnhem_allies.t_nebs) do
				
				if this.state == 1 then
					
					if not SGroup_IsEmpty(SGroup_FromName(this.nebfireorigin)) then
						Cmd_Ability (SGroup_FromName(this.nebfireorigin), ABILITY.AXIS.NEB_BARRAGE, g_neb_target)
					end
					
				end
				
			end
			
			g_NebsFired = true
			
		end	
		
		-- If fired then play speech
		if g_NebsFired == true then
			if Rule_Exists (PlayNebSpeech) == false then Rule_AddOneShot (PlayNebSpeech, 5) end
			Player_GetAll (player1)
			g_NebsFired = false
			Timer_Add (NebFired_Timer, g_NebsAttack_Time)
		end
		
	end
	
end

function PlayNebSpeech()

	if Objective_IsStarted (OBJ_SupplyDepot) == false then 
		Objective_Start (OBJ_SupplyDepot)
		Util_AutoIntel(t_TAC_speech.FirstArtilleryFiring)
	end
	EventCue_Create (CUE.NORMAL, 1469905, 1469905, g_neb_target)

end


-------------------------------------------------------------------------

-- Global Mission Failure Check

-------------------------------------------------------------------------

-- start the related action
function PlayerBaseCheck()
	
	if Player_HasLost (player1, CRITICAL_BUILDINGS.ELITE) then
		Game_EndSP (false)
		Rule_RemoveMe()
	end
	
end
