-------------------------------------------------------------------------
-------------------------------------------------------------------------
--
-- Mission 8 - St. Fromond
--
-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")
-- custom file for table ID's in addition to the default WB generated file
import("M08_Artillery_Duel_IDTables.scar")

-------------------------------------------------------------------------
-- [[ SETUP ]]
-------------------------------------------------------------------------

function OnGameSetup()
	--[[ string numbers should reference dat files ]]
	player1 = Setup_Player(1, 289011, TRACE_ALLIES, 1)
	player2 = Setup_Player(2, 289012, TRACE_AXIS, 2)
	player3 = Setup_Player(3, 289012, TRACE_ALLIES, TEAM_NEUTRAL)
	player4 = Setup_Player(4, 289012, TRACE_AXIS, 2)

	print ("------------------------------------------------------------------------------------------")
	print ("------------------------------------- MISSION 8 STARTED ----------------------------------")
	print ("------------------------------------------------------------------------------------------")
end

function OnGameRestore()
	player1 = World_GetPlayerAt(1)
	player2 = World_GetPlayerAt(2)
	player3 = World_GetPlayerAt(3)
	player4 = World_GetPlayerAt(4)
	
	-- function takes care of restoring all global mission parameters after a save/load
	Game_DefaultGameRestore()
	
	-- AI Restart
	M08_AIPreset()
	
	if g_AI_AGGRESSIVE == true then
		M08_AIChangeAggression()
	end
end


-------------------------------------------------------------------------
-- [[ ONINIT ]]
-------------------------------------------------------------------------

function OnInit()
	--[[ DEBUGGING ]]
	g_DEBUG_MODE = false
	Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS01)')]])")
	Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('Util_StartNIS(EVENTS.NIS02)')]])")
	
	g_AIControl_Enable = false
	g_AIControl_Pause = true
	
	-- use default veteran squads if necessary
	if not Player_HasPersistentSquadFile(player1) then
		Player_LoadPersistentSquadsFromFile(player1, "data:scenarios/sp/m08_artillery_duel/default_veteran_squads.lua")
	end
	
	-- Unlock Improved Nebelwerfer for the Axis player, ABILITY.SP_FIRENEBELWERFER will not work without it
	Player_SetUpgradeAvailability(player2, UPG.SP.SP_M08_IMPROVED_NEBELWERFER, ITEM_UNLOCKED)
	
	--[[ TEMPORARY ]]
	
	--[[ AUDIO ]]
	M08_SetAudio()
	
	--[[ PRESET GAME STATE ]]
	AutoCinematic(true, 0)

	--[[ SET DIFFICULTY ]]
	M08_Difficulty()
	
	--[[ REGISTER OBJECTIVES ]]
	M08_Objective_Register()
	
	--[[ MOD INITIAL STATS ]]
	M08_Set_StatMods()
	
	--[[ SET RESTRICTIONS ]]
	M08_Restrictions()
	
	--[[ SET INITIAL MOOD ]]
	M08_Mood()

	--[[ MISSION PRESETS ]]
	M08_Mission_Preset()
	M08_AIPreset()

	--[[ TECH TREE ]]
	TechTreeSetup()
	
	--[[ GAME START CHECK ]]
	Rule_Add(M08_Mission_Start)
end

Scar_AddInit(OnInit)

function M08_Objective_Register()
	--[[ *** MUST INITIALIZE THE OBJ TABLE BEFORE REGISTERING *** ]]
	Initialize_OBJ_TownSquare()
	Initialize_OBJ_RepairBridge()
	Initialize_OBJ_Nebelwerfers()
	Initialize_OBJ_Chateau()
	Initialize_OBJ_DefendTownSquare()
end

function M08_Set_StatMods()
	Modify_PlayerResourceRate(player1, RT_Manpower, 1)
	Modify_PlayerResourceRate(player1, RT_Munition, 1)
	Modify_PlayerResourceRate(player1, RT_Fuel, 1)
end

function M08_Restrictions()
	--[[ UN/RESTRICT UPGRADES ]]
	
	--[[ RESOURCES ]]
--~ 	Player_SetResource(player1, RT_Manpower, 1000)			-- now set with Util_SetStartingResources after opening NIS
--~ 	Player_SetResource(player1, RT_Munition, 200)
--~ 	Player_SetResource(player1, RT_Fuel, 100)
	
	--[[ UN/RESTRICT ABILITIES ]]
	
	--[[ UN/RESTRICT POP CAP ]]
	Player_SetPopCapOverride(player2, 95)
	Player_SetPopCapOverride(player1, 85)
	
	--[[ UN/RESTRICT UI ]]

	--[[ SETUP COMMANDER TREE ]]
end

function M08_Mood()
	Player_SetDefaultSquadMoodMode(player1, MM_Auto)
	Player_SetDefaultSquadMoodMode(player2, MM_Auto)
	Player_SetDefaultSquadMoodMode(player3, MM_Auto)
	Player_SetDefaultSquadMoodMode(player4, MM_Auto)
end

function M08_Difficulty()
	-- get the difficulty
	g_DIFFICULTY = Game_GetSPDifficulty()
	
	-- set health bonus for player 1
	Setup_Difficulty(player1, g_DIFFICULTY) -- pass the player and difficulty global variable into the Set Health function

	-- set health handicap for player 2
	Setup_Difficulty(player2, g_DIFFICULTY) -- do it for each player that you have defined
	-- player 3 does not need difficulty settings because he is an ally.
	Setup_Difficulty(player4, g_DIFFICULTY) -- do it for each player that you have defined
	
	-- default is GD_EASY
	print("Setting up difficulty parameters")
	t_difficulty = {
		ai_attack_time 			= Util_DifVar( {15*60, 10*60, 5*60, 5*60} ),
		convoy_time 			= Util_DifVar( {7*60, 5*60, 1*60, 1*60} ),
		rp_threshold 			= Util_DifVar( {0.5, 0.4, 0.25, 0.1} ),
		town_retreat_threshold 	= Util_DifVar( {0.4, 0.5, 0.6, 0.8} ),
		ai_aggression			= Util_DifVar( {3, 4, 5, 5}  ), 
	}
end

function M08_SetAudio()
	-- default speech path for the mission
	g_MissionSpeechPath = "Mission08"
	
	-- precaching as required by code
	Sound_PreCacheSinglePlayerSpeech(g_MissionSpeechPath)
	
	-- mute the sound before the NIS plays
	Util_MuteAmbientSound(true)
end


-------------------------------------------------------------------------
-- [[ MISSION Preset ]]
-------------------------------------------------------------------------

function M08_AIPreset()
	--[[ ENABLE/DISABLE ]]
	AI_Enable(player2, false)
	AI_Enable(player3, false)
	
	Util_AI_Setup(player4, {50}, player1, 1, false, 2, 3, 3)
	
	-- turn off the AI for the start of the mission
	if g_AI_ENABLE ~= true then
		AI_Enable(player4, false)
	end
	
	--[[ AI BUILD TABLES ]]
	t_ai_start_table = {
		{ SBP.AXIS.PUMA, 		4, 	4 },
		{ SBP.AXIS.HALFTRACK,		4,  4 },
		{ SBP.AXIS.MORTAR, 			5, 	10},
		{ SBP.AXIS.PIONEER, 		0, 	5 },
		{ SBP.AXIS.VOLKSGRENADIER, 	0, 	3 },
		{ SBP.AXIS.GRENADIER, 		0, 	3 },
	}
	
	AI_ClearBuildDemand(player4)
	AI_SetBuildTable(player4, t_ai_start_table)	
	
	-- used later when the AI is more aggressive
	t_ai_aggro_table = {
		{ SBP.AXIS.STUG, 			0, 	5 },
		{ SBP.AXIS.PUMA, 		0, 	6 },
		{ SBP.AXIS.PANZER, 			0, 	5 },
		{ SBP.AXIS.HALFTRACK,		0,  4 },
		{ SBP.AXIS.OSTWIND, 	0, 	4 },
		{ SBP.AXIS.MORTAR, 			5, 	10},
		{ SBP.AXIS.PIONEER, 		0, 	5 },
		{ SBP.AXIS.GRENADIER, 		0, 	3 },
		{ SBP.AXIS.STORMTROOPER, 	10, 10},
	}
	
	AI_ClearAllBudgetWeight(player4)
	AI_SetBudgetWeight(player4, "BUDGET_Tech", 50)
	AI_SetBudgetWeight(player4, "BUDGET_Units", 950)

	AI_DoString( player4, "s_personality.max_percentage_to_capture = 0.7" )
	AI_DoString( player4, "s_personality.max_num_capturers = 2" )
	AI_DoString( player4, "s_personality.defend_prefer_threat = true" )
end

-- this will change the AI's aggression level depending on the actions of the player
function M08_AIChangeAggression()
	print("M08_AIChangeAggression")
	g_AI_AGGRESSIVE = true
	Util_AI_Setup(player4, {50}, player1, 1, false, t_difficulty.ai_aggression, 3, 3)
	
	if Rule_Exists(OBJ_TS_ConvertRetreaters) == false then
		Rule_AddInterval(OBJ_TS_ConvertRetreaters, 5.7)
	end

	if g_AI_ENABLE ~= true then
		print("-------------- AI ENABLED ---------------- ")
		AI_Enable(player4, true)
		g_AI_ENABLE = true
	end
	
	if Objective_IsStarted(OBJ_DefendTownSquare) then
		print("M08_AIChangeAggression: Time Left to Defend: "..Objective_GetTimerSeconds(OBJ_DefendTownSquare))
	end
	
	-- update the AI's aggro table so that he varies what he builds
	AI_ClearBuildDemand(player4)
	AI_SetBuildTable(player4, t_ai_aggro_table)
	AI_DoString( player4, "s_personality.attack_prefer_threat = true" )
	
	-- remove resource modifier limitations on the AI
	for i=1, table.getn(t_resource_mods) do 
		Modifier_Remove(t_resource_mods[i])
	end
	
	-- respawn the aggression towards the town square
	EGroup_ReSpawn(eg_ai_townsquare)
	
	-- force the AI to attack the town square
	EGroup_SetPlayerOwner(eg_ai_townsquare, player1)
end


function M08_Mission_Preset()
	g_SPAWN_MARKERS = {spawn_east, spawn_north, spawn_northeast, spawn_west}
	g_AI_ENABLE = false
	g_CONVOY_SIZE = 7			-- number of actual vehicles in the convoy 
	g_RP_THRESHOLD = 0.5		-- threshold of resource points that the player needs to control to tip AI's aggression
	g_AUTOSAVE_DELAY = 10		-- the amount of time to wait before trying to autosave.
	g_AI_AGGRESSIVE = false		-- variable to track whether the AI has been changed to be more aggressive
	
	--[[ AI RESOURCES ]]
	Player_SetResource(player4, RT_Manpower, 400)
	Player_SetResource(player4, RT_Munition, 200)
	Player_SetResource(player4, RT_Fuel, 10)
	
	-- timer for when the predetermined attack by the panzer tanks occurs
	g_OBJ_DTS_COUNTERATTACK					= 1890358
	
	-- Setup the enemies
	Enemy_Init()
	OBJ_TS_Setup()
	
	-- Initialize Nebelwerfers
	Nebelwerfers_Init()
	
	OBJ_GT_Init()
	
	FOW_RevealEGroup(eg_chateau, 0.2)
	
	-- spawn a secure structure on the player's starting resource point
	Util_CreateEntities(player1, eg_temp, EBP.ALLIES.OBSERVATION_POST, EGroup_GetPosition_EVEN_IF_EMPTY(eg_rp_player), 1)
	
	local rand = 1
	local sbp_pickup = { EBP.PICKUP.MANPOWER, EBP.PICKUP.MUNITIONS, EBP.ITEM_FUEL,}
	for i=1, table.getn(mkr_res_pickup) do 
		Util_CreateEntities(nil, eg_pickup[i], sbp_pickup[rand], mkr_res_pickup[i], 1)
		rand = rand + 1
		if rand > table.getn(sbp_pickup) then
			rand = 1
		end
	end
	
	--spawn the panzers to patrol and guard the area to the Chateau
	for i=1, table.getn(mkr_sp_panzer_patrol) do 
		Util_CreateSquadsAtMarker(player2, sg_panzer_patrol[i], SBP.AXIS.PANZER, mkr_sp_panzer_patrol[i], 1)
		Cmd_SquadPath(sg_panzer_patrol[i], "path_panzer_patrol", true, true, true, 3)
	end
	
	-- resource modifiers for AI Player
	t_resource_mods = {
		Modify_PlayerResourceRate(player4, RT_Manpower, 0),
		Modify_PlayerResourceRate(player4, RT_Munition, 0),
		Modify_PlayerResourceRate(player4, RT_Fuel, 0),
	}
	
	-- despawn the town square AI marker
	EGroup_DeSpawn(eg_ai_townsquare)
	
	-- make the Axis Chateau invulnerable until the player repairs the bridge
	EGroup_SetInvulnerable(eg_chateau, 0.5)
	
	-- create entities to garrison the building 
	Util_CreateSquadsAndGarrison(player2, sg_ambient_ai, SBP.AXIS.GRENADIER, eg_ai_defense, 1, true)
	Cmd_InstantUpgrade(eg_ai_defense, UPG.ALLIES.CONVERT_AMBIENT_BUILDING)
	
	-- upgrade the AI's phases, so that he has access to a variety of units
	Cmd_InstantUpgrade(player4, UPG.AXIS.PHASE2)
	Cmd_InstantUpgrade(player4, UPG.AXIS.PHASE3)
	
	-- do not let the AI upgrade to this unit type
	Player_SetUpgradeAvailability(player4, UPG.AXIS.HALFTRACK_STUKA, ITEM_LOCKED)
end

-------------------------------------------------------------------------
-- [[ MISSION START ]]
-------------------------------------------------------------------------

function M08_Mission_Start()
	Util_StartNIS(EVENTS.NIS01)
	Rule_Add(M08_NIS01Over)
	Rule_RemoveMe()
end

function M08_DetectBridgeAtStart()
	if EGroup_IsEmpty(eg_bridge2) then
		OBJ_RB_DetectBridge()
	else
		Rule_RemoveMe()
	end
end


function M08_NIS01Over()
	-- wait for the NIS
	if Event_IsAnyRunning() == false then
		-- for debugging purposes
		if g_DEBUG_MODE then
			FOW_RevealAll()
		end
		
		Rule_Add(M08_DetectBridgeAtStart)
		Cmd_CaptureTeamWeapon(sg_watersideaaguncrew, eg_watersideaagun, false)
		Rule_AddInterval(OBJ_RB_DelayStart, 2.14)
		Rule_AddInterval(M08_CheckPlayerFail, 5.6)
		Rule_AddInterval(M08_CheckPlayerRPControl, 10.7)
		Rule_AddInterval(OBJ_DC_StartDelay, 4.16)
		Rule_AddInterval(M08_ObjectivesOutOfOrder, 5.3)
		Rule_AddInterval(OBJ_NW_SpawnDefense, 1.56)
		
		-- set the player's starting resources
		Util_SetStartingResources(8)
		
		-- spawn the pumas to defend the bridge
		for i=1, table.getn(sg_puma) do 
			Util_CreateSquadsAtMarker(player2, sg_puma[i], SBP.AXIS.PUMA, mkr_sp_puma[i], 1)
			Cmd_SquadPath(sg_puma[i], "path_bridge_def", true, true, true, 10)
		end

		-- show the chateau briefly
		FOW_RevealEGroupOnly(eg_chateau, 0.5)
		
		Rule_RemoveMe()
	end
end

function M08_AutosaveDelay()
	--[[ AUTOSAVE ]]
	if Rule_Exists(M08_Autosave) == false then
		Rule_Add(M08_Autosave)		
	end
end



function Enemy_Init()
	g_MAX_RESPAWN = 3 -- diff handle
	
	-- some types...
	PATROL = 1
	GARRISON = 2
	
	-- Patrols that meander about the town
	t_reinforce = {}
	for i=1, table.getn(sg_patrol) do 
		local value = {
			group 			= sg_patrol[i],
			class 			= PATROL,
			
			-- name of patrol path to follow
			dest 			= "patrol"..i,
			unit 			= SBP.AXIS.VOLKSGRENADIER,
			
			-- represents the number of squads within an sgroup before it stops spawning them
			threshold 		= 2,
			
			-- represents the number of times that squad will be respawned after dying
			count 			= World_GetRand(1, g_MAX_RESPAWN),
			
			-- location to spawn from
			spawnpoint 		= Util_GetClosestMarker(sg_patrol[i], g_SPAWN_MARKERS),
		}
		
		table.insert(t_reinforce, i, value)
		Cmd_SquadPath(t_reinforce[i].group, t_reinforce[i].dest, true, true, true)
	end
	
	-- units that garrison various buildings
	local garrison = {}
	for i=1, table.getn(sg_garrison) do 
		garrison[i] = {
			group 			= sg_garrison[i],
			class 			= GARRISON,
			unit 			= SBP.AXIS.HEAVYMG,
			threshold 		= 0,
			count 			= 1,
			spawnpoint 		= Util_GetClosestMarker(eg_garrison[i], g_SPAWN_MARKERS),
			dest 			= eg_garrison[i],
		}
	end
	garrison[3].unit = SBP.AXIS.GRENADIER
	garrison[5].unit = SBP.AXIS.GRENADIER
	garrison[6].unit = SBP.AXIS.GRENADIER
	
	for i=1, table.getn(garrison) do 
		table.insert(t_reinforce, garrison[i])
		Util_CreateSquadsAndGarrison(player2, garrison[i].group, garrison[i].unit, garrison[i].dest, 1)
		
		-- increase the range of their weapons slightly
		Modify_WeaponRange(garrison[i].group, "hardpoint_01", 1.2)
	end
	
	reinforceinterval = 10
	Rule_AddInterval(Enemy_MonitorPhase1, 15)
end




--
-- Phase 1: This is when the VP's come into play. Capturing a VP stops certain reinforcements coming in.
--
function Enemy_MonitorPhase1()
	for n = table.getn(t_reinforce), 1, -1 do
		-- see if this reinforcement is 'blocked' or not
		local blocked = false
		
		if SGroup_Count(t_reinforce[n].group) <= t_reinforce[n].threshold
		and not blocked 
		and not t_reinforce[n].class == GARRISON then
			
			-- create the new unit
			SGroup_Clear(sg_temp)
			Util_CreateSquadsAtMarker(player2, sg_temp, t_reinforce[n].unit, t_reinforce[n].spawnpoint, 1, World_GetRand(4, 6))
			
			-- send it on its way
			if t_reinforce[n].class == PATROL then
				Cmd_SquadPath(sg_temp, t_reinforce[n].dest, true, true, true)
			elseif t_reinforce[n].class == GARRISON then
				if EGroup_IsEmpty(t_reinforce[n].dest) == false then
					Cmd_Garrison(sg_temp, t_reinforce[n].dest)
				else
					table.remove(t_reinforce, n)
					break
				end
			end
			
			-- add this new unit to the main group
			SGroup_AddGroup(t_reinforce[n].group, sg_temp)
			AI_LockSGroup(player2, t_reinforce[n].group)
			
			-- reduce the counter
			t_reinforce[n].count = t_reinforce[n].count - 1
			if (t_reinforce[n].count <= 0) then
				table.remove(t_reinforce, n)
			end
			
			-- slow this rule down a little bit
			reinforceinterval = reinforceinterval + 2
			Rule_ChangeInterval(Enemy_MonitorPhase1, reinforceinterval)
			
			-- no more reinforcements this run through...
			break
		end
	end
	
	if Objective_IsComplete(OBJ_Nebelwerfers) then
		Rule_RemoveMe()
	end
end

-------------------------------------------------------------
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- PRIMARY OBJECTIVE 1
-- Repair the Bridge
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- One of two options is available for this objective
-- 1) The player is responsible for repairing the bridge that let's him access the other side of the water.
-------------------------------------------------------------

function Initialize_OBJ_RepairBridge ()
	OBJ_RepairBridge =
	{
		SetupUI = function()
			OBJ_RepairBridge.PingID = Objective_AddUIElements(OBJ_RepairBridge,  eg_bridge2, true, 289032, true, -3.5)
		end,
		OnStart = function()
		Util_PlayMusic("SOUND/Music/SP/M08/M08_Ob1_TakeTown", 0, 0)
			-- [[ START DIALOGUE ]]
			Util_StartIntel(EVENTS.OBJ_RB_Start)
			
			Rule_AddInterval(OBJ_RB_CheckBridgeRepaired, 3)
			Rule_AddInterval(OBJ_RB_RepairStatus, 1)
			Rule_AddInterval(OBJ_RB_EngineersUnderFire, 5.1)
		end,
		OnComplete = function()
			-- [[ START DIALOGUE ]]
			Util_StartIntel(EVENTS.OBJ_RB_Complete)
			
			--[[ AUTOSAVE ]]
			g_AUTOSAVE = 289101
			if Rule_Exists(M08_AutosaveDelay) == false then
				Rule_AddOneShot(M08_AutosaveDelay, g_AUTOSAVE_DELAY)
			end
			
			-- remove the blocker that prevents the player from crossing the bridge.
			EGroup_DeSpawn(eg_bridge2_blocker)
			Objective_RemoveUIElements(OBJ_RepairBridge, OBJ_RepairBridge.PingID)
			
			Rule_AddInterval(OBJ_TS_AddNewObjDelay, 7)
			
			-- make sure the bridges cannot be fully destroyed.
			EGroup_SetInvulnerable(eg_bridge1, 0.2)
			EGroup_SetInvulnerable(eg_bridge2, 0.2)
			
			-- remove the repair modifier from engineers
			Modifier_Remove(t_obj_rb_mgr.mod_id)
			
			-- enabling AI for when the player finishes repairing bridge
			-- he'll only harass the player slightly.
			AI_Enable(player4, true)
			g_AI_ENABLE = true
			
			-- modify the resources for the AI again.
			-- remove resource modifier limitations on the AI
			for i=1, table.getn(t_resource_mods) do 
				Modifier_Remove(t_resource_mods[i])
			end
			
			t_resource_mods = {
				Modify_PlayerResourceRate(player4, RT_Manpower, 0.25),
				Modify_PlayerResourceRate(player4, RT_Munition, 0.25),
				Modify_PlayerResourceRate(player4, RT_Fuel, 0.25),
			}
			
			-- turn off the invulnerability for the chateau
			EGroup_SetInvulnerable(eg_chateau, false)
		end,
		IsComplete = function()
			return false
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		
		Title 				= 289030,
		Description 		= 289031,
		Icon 				= IT_P_Repair,
		Type 				= OT_Primary,
		CommandRewardAmount = 1,
		
		SitRep =
		{
			Movie = "SR_08-01",
			Force = true,
			SpeechTiming =
			{
				{ 1.5, ACTOR.McKay, 285010 },
				{ 8.8, ACTOR.McKay, 285020 },
				{ 13.5, ACTOR.McKay, 285030 },
				{ 20.25, ACTOR.McKay, 285040 },
				{ 26.1, ACTOR.McKay, 285050 },
				{ 29, ACTOR.McKay, 285060 },
			},
		}
	}
	Objective_Register(OBJ_RepairBridge)
	OBJ_RB_Setup()
end

function OBJ_RB_Setup()
	t_obj_rb_mgr = {
		repair_events						= {},
		timer_repair_start					= "OBJ_RB_REPAIR_START",
		last_bridge_health					= 0,
		timer_ufire							= "OBJ_RB_UNDER_FIRE",
		repair_kicker						= {5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 75, 80, 85, 90, 95},
		mod_id								= Modify_VehicleRepairRate(player1, 3),
		button_hint							= nil,
		button_flash						= nil,
		health_mod							= 0.1,
		health_mod_id						= {},
	}
	t_obj_rb_mgr.repair_events[1] = {
		percent 	= 0.01,
		cue			= 289201,
		speech		= EVENTS.OBJ_RB_RepairStarted,
	}
	t_obj_rb_mgr.repair_events[2] = {
		percent 	= 0.25,
		cue			= 289202,
		speech		= nil,
	}
	t_obj_rb_mgr.repair_events[3] = {
		percent 	= 0.5,
		cue			= 289203,
		speech		= EVENTS.OBJ_RB_Repair50,
	}
	t_obj_rb_mgr.repair_events[4] = {
		percent 	= 0.75,
		cue			= 289204,
		speech		= EVENTS.OBJ_RB_AlmostDone,
	}
end

-- added an additional delay to 
function OBJ_RB_DelayStart()
	if Event_IsAnyRunning() == false and EGroup_IsEmpty(eg_bridge2) == false then
		Objective_Start(OBJ_RepairBridge, true)
		Rule_RemoveMe()
	end
end

function OBJ_RB_DetectBridge()
	-- since when the bridge is destroyed and repaired, it changes ebps,
	-- which empties the egroup referring to the bridge.  This function
	-- detects the presence of the bridge again and puts it back into eg_bridge2
	EGroup_Clear(eg_temp)
	World_GetNeutralEntitiesNearMarker(eg_temp, mkr_bridge_detect)
	local blueprint = {
		BP_GetEntityBlueprint("ebps/environment/art_ambient/bridges/bridge_25_01_rebuilt.lua"), 
		BP_GetEntityBlueprint("ebps/environment/art_ambient/bridges/bridge_25_01_wrecked.lua"), 
		BP_GetEntityBlueprint("ebps/environment/art_ambient/bridges/bridge_25_01_wrecked_sp_m08.lua"),
	}
	
	EGroup_Filter(eg_temp, blueprint, FILTER_KEEP)
	EGroup_AddEGroup(eg_bridge2, eg_temp)
	EGroup_Clear(eg_temp)
end

function OBJ_RB_CheckBridgeRepaired()
	if EGroup_IsEmpty(eg_bridge2) then
		OBJ_RB_DetectBridge()
	end
	
	if EGroup_GetAvgHealth(eg_bridge2) > 0.98 then
		Rule_RemoveMe()
		Objective_Complete(OBJ_RepairBridge, true)
	end
end

function OBJ_RB_EngineersUnderFire()
	if Objective_IsComplete(OBJ_RepairBridge) then
		Rule_RemoveMe()
		return
	end
	
	if Timer_GetRemaining(t_obj_rb_mgr.timer_ufire) == 0 then
		Player_GetAllSquadsNearMarker(player1, sg_temp, Util_GetPosition_EVEN_IF_EMPTY(mkr_hint_bridge2), 30) 
		SGroup_Filter(sg_temp, SBP.ALLIES.ENGINEER, FILTER_KEEP)
		if SGroup_IsUnderAttack(sg_temp, ANY, 5) then
			--[[ DIALOGUE ]] 
			Util_StartStinger(EVENTS.OBJ_RB_EngineersUnderFire)
			-- no event cue because there will already be a cue issued by the game,
			-- whenever the player's unts are under attack.
			
			Timer_Start(t_obj_rb_mgr.timer_ufire, 30)
		end
	end
end

function OBJ_RB_RepairStatus()
	if table.getn(t_obj_rb_mgr.repair_events) == 0 or Objective_IsComplete(OBJ_RepairBridge) then
		Rule_RemoveMe()
		return
	end
	
	Player_GetAllSquadsNearMarker(player1, sg_temp, Util_GetPosition_EVEN_IF_EMPTY(mkr_hint_bridge2), 30)
	SGroup_Filter(sg_temp, SBP.ALLIES.ENGINEER, FILTER_KEEP)
	if SGroup_IsEmpty(sg_temp) then
		Player_GetAll(player1, sg_temp)
		SGroup_Filter(sg_temp, SBP.ALLIES.ENGINEER, FILTER_KEEP)
		
		if g_ENGINEERS_AT_BRIDGE == true 
		and SGroup_IsEmpty( sg_temp) then
			Util_StartStinger(EVENTS.OBJ_RB_EngineersDead)
			EventCue_Create(OBJ_RepairBridge, 289205, 289205, mkr_hint_bridge2)
			g_ENGINEERS_AT_BRIDGE = false
			return
		else
			return
		end
	end
	
	g_ENGINEERS_AT_BRIDGE = true
	
	if EGroup_GetAvgHealth(eg_bridge2) == t_obj_rb_mgr.last_bridge_health 
	and Timer_GetRemaining(t_obj_rb_mgr.timer_repair_start) <= 0 then			
		--[[ DIALOGUE ]]
		Util_StartStinger(EVENTS.OBJ_RB_EngineersNotRepairing)
		EventCue_Create(OBJ_RepairBridge, 289200, 289200, mkr_hint_bridge2)
		Timer_Start(t_obj_rb_mgr.timer_repair_start, 120)
		if Rule_Exists(OBJ_RB_RepairButtonHint) == false then
			Rule_AddInterval(OBJ_RB_RepairButtonHint, 1)
		end
		return
	end
	
	t_obj_rb_mgr.last_bridge_health = EGroup_GetAvgHealth(eg_bridge2)
	
	if EGroup_GetAvgHealth(eg_bridge2) >= (t_obj_rb_mgr.repair_kicker[1] / 100) then
		local num = Loc_ConvertNumber(t_obj_rb_mgr.repair_kicker[1])
		local text = Loc_FormatText(289300, num)
		UI_CreateEntityKickerMessage(player1, EGroup_GetSpawnedEntityAt(eg_bridge2, 1), text)
		
		table.remove(t_obj_rb_mgr.repair_kicker, 1)
		
		if t_obj_rb_mgr.button_hint ~= nil then
			HintPoint_Remove(t_obj_rb_mgr.button_hint)
			UI_StopFlashing(t_obj_rb_mgr.button_flash)
			t_obj_rb_mgr.button_hint = nil
		end
	end 
	
	if EGroup_GetAvgHealth(eg_bridge2) >= t_obj_rb_mgr.repair_events[1].percent then
		if t_obj_rb_mgr.repair_events[1].speech ~= nil then
			--[[ DIALOGUE ]]
			Util_StartStinger(t_obj_rb_mgr.repair_events[1].speech)
		end
		
		if t_obj_rb_mgr.repair_events[1].cue ~= nil then
			EventCue_Create(OBJ_RepairBridge, t_obj_rb_mgr.repair_events[1].cue, t_obj_rb_mgr.repair_events[1].cue, mkr_hint_bridge2)
		end
		
		table.remove(t_obj_rb_mgr.repair_events, 1)
	end
end

function OBJ_RB_RepairButtonHint()
	if Objective_IsComplete(OBJ_RepairBridge) then
		Rule_RemoveMe()
		return
	end	
	
	SGroup_Clear(sg_temp)
	Misc_GetSelectedSquads(sg_temp, true)
	SGroup_Filter(sg_temp, SBP.ALLIES.ENGINEER, FILTER_KEEP)
	
	if SGroup_IsEmpty(sg_temp) == false then
		t_obj_rb_mgr.button_hint = HintPoint_AddToAbilityButton(ABILITY.REPAIR, 289034, true)
		t_obj_rb_mgr.button_flash = UI_FlashAbilityButton(ABILITY.REPAIR, true, BT_UI_Weak_CommandBtn )
		Rule_RemoveMe()
	end
end


-------------------------------------------------------------
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- PRIMARY OBJECTIVE 2
-- Capture the Town Square
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--
-------------------------------------------------------------------------

function Initialize_OBJ_TownSquare()
	OBJ_TownSquare =
	{
		SetupUI = function()
			OBJ_TownSquare.UI_ID = Objective_AddUIElements(OBJ_TownSquare, eg_vp1, true, 289023, true, 2)
		end,
		OnStart = function()
			Util_PlayMusic("SOUND/Music/genericmissionmusic_Legacy", 5, 0)
			
			if Objective_IsComplete(OBJ_RepairBridge) then
				Cmd_CaptureTeamWeapon(sg_townsquareaaguncrew, eg_townsquareaagun, false)
			
				for i=1, table.getn(mkr_sp_tsquare_inf) do 
					Util_CreateSquadsAtMarker(player2, sg_tsquare_inf[i], SBP.AXIS.GRENADIER, mkr_sp_tsquare_inf[i], 1)
				end
			end
			
			Rule_AddInterval(OBJ_TS_EnterTownSquare, 3)
			Rule_AddInterval(OBJ_TS_CheckComplete, 1)
			Rule_AddInterval(OBJ_TS_CheckChateauApproach, 4.5)
		end,
		OnComplete = function()
			if OBJ_TownSquare.DefendTownActive ~= true then
				-- [[ DIALOGUE ]]
				Util_StartIntel(EVENTS.OBJ_TS_Complete)
				
				--[[ AUTOSAVE ]]
				g_AUTOSAVE = 289102
				if Rule_Exists(M08_AutosaveDelay) == false then
					Rule_AddOneShot(M08_AutosaveDelay, 5)
				end
				
			else
				Util_StartIntel(EVENTS.OBJ_DTS_Complete)
			end
		end,
		IsComplete = function()
			return false
		end,
		OnFail = function()
			if OBJ_TownSquare.DefendTownActive then
				Game_EndSP(false, nil, true)
			end
		end,
		OnSitRep = function()
			
		end,
		
		Title 				= 289020,
		Description 		= 289021,
		Icon				= IT_P_Capture,
		Type 				= OT_Primary,
		UI_ID				= nil,
		CommandRewardAmount	= 1,
		DefendTownActiive	= false,
	}
	Objective_Register(OBJ_TownSquare)
end

--------------------------------------------------------------------------------
-- TOWN SQUARE VICTORY POINT
--------------------------------------------------------------------------------
function OBJ_TS_Setup()
	t_chateau_sectors = {
		World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_rp5)),
		World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_rp6)),
		World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_chateau)),
	}
	t_ai_aggro_sectors = {
		World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_rp5)),
		World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_rp6)),
		World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_chateau)),
		World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_rp8)),
		World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_rp11)),
		mkr_chateau_detect1,
	}
	t_obj_ts_mgr = {
		sg_defenders	= {},
		sg_aa_def		= sg_townsquareaaguncrew,
		aa_gun_id 		= SyncWeapon_GetFromEGroup(eg_townsquareaagun),
		sector_id		= World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_vp1)),
		retreat_perc	= t_difficulty.town_retreat_threshold,						-- the percentage at which the axis will retreat from the town
	}
	for i=1, table.getn(t_reinforce) do 
		table.insert(t_obj_ts_mgr.sg_defenders, t_reinforce[i].group)
	end
	for i=1, table.getn(sg_tsquare_inf) do 
		table.insert(t_obj_ts_mgr.sg_defenders, sg_tsquare_inf[i])
	end
	Rule_AddInterval(OBJ_TS_CheckDefenderRetreat, 5)
end

function OBJ_TS_AddNewObjDelay()
	if Event_IsAnyRunning() == false then
		if Objective_IsStarted(OBJ_TownSquare) == false then
			Objective_Start(OBJ_TownSquare, true)
		end
		Rule_RemoveMe()
	end
end

function M08_ObjectivesOutOfOrder()
	if Objective_IsStarted(OBJ_TownSquare) then
		Rule_RemoveMe()
		return
	end
	
	-- check if the player has captured all the territories around the town square
	local bln_all = true
	for i=1, 4 do 
		if Player_OwnsEGroup(player1, eg_rp[i]) == false then
			bln_all = false
		end
	end
	
	-- check if the player has decided to attack the chateau
	for i=1, table.getn(t_chateau_sectors) do
		Player_GetAllSquadsNearMarker(player1, sg_temp, t_chateau_sectors[i])		
		if SGroup_IsEmpty(sg_temp) == false then
			M08_AIChangeAggression()
			OBJ_DC_SpawnDefenders()
			break
		end
	end
	
	-- check if the player has already captured the town square
	-- but not repaired the bridge
	if Player_OwnsEGroup(player1, eg_vp1) 
	or bln_all 
	or SGroup_IsEmpty(sg_temp) == false then
		Rule_RemoveMe()
		Objective_Start(OBJ_TownSquare, true)
	end
end

function OBJ_TS_CheckComplete()
	local bln_all = true
	for i=1, 4 do 
		if Player_OwnsEGroup(player1, eg_rp[i]) == false then
			bln_all = false
		end
	end
	
	if Player_OwnsEGroup(player1, eg_vp1) or bln_all then
		Rule_RemoveMe()
		Objective_Complete(OBJ_TownSquare, true)
		OBJ_TS_Complete()
	end
end

function OBJ_TS_Complete()
	if OBJ_TownSquare.DefendTownActive ~= true then
		Rule_AddInterval(OBJ_DTS_AddNewObjDelay, 2)
	end
	
	Rule_Remove(OBJ_TS_EnterTownSquare)
	Rule_Remove(OBJ_TS_CheckChateauApproach)
	
	-- tell the axis to retreat from the square
	if Rule_Exists(OBJ_TS_AxisRetreat) == false then
		Rule_AddInterval(OBJ_TS_AxisRetreat, 2)
	end
	
	EGroup_InstantCaptureStrategicPoint(eg_vp1, player1)
end

function OBJ_TS_EnterTownSquare()
	Player_GetAllSquadsNearMarker(player1, sg_temp, mkr_tsquare_enter, 15)
	if SGroup_IsEmpty(sg_temp) == false then
		--[[ DIALOGUE ]]
		Util_StartStinger(EVENTS.OBJ_TS_EnterSquare)		
		Rule_RemoveMe()
	end
end

-- this function will update the above objective if the player decides to circumvent
-- the capturing of the square in this mission

function OBJ_TS_CheckChateauApproach()
	if Objective_IsComplete(OBJ_TownSquare) then
		Rule_RemoveMe()
		return
	end
	
	for i=1, table.getn(t_chateau_sectors) do
		Player_GetAllSquadsNearMarker(player1, sg_temp, t_chateau_sectors[i])
		if SGroup_IsEmpty(sg_temp) == false then
			OBJ_DC_SpawnDefenders()
			M08_AIChangeAggression()
			OBJ_TS_ChangeToOBJ_DTS()
			Rule_RemoveMe()
			break
		end
	end
end


function OBJ_TS_ChangeToOBJ_DTS()
	-- remove all the old elements of this objective
	Rule_Remove(OBJ_TS_CheckComplete)

	-- change the description, dialogue
	OBJ_TownSquare.Title 			= OBJ_DefendTownSquare.Title
	OBJ_TownSquare.Description 		= OBJ_DefendTownSquare.Description
	OBJ_TownSquare.Icon				= OBJ_DefendTownSquare.Icon
	OBJ_TownSquare.SitRep 			= OBJ_DefendTownSquare.SitRep
	t_obj_dts_mgr.objective 		= OBJ_TownSquare
	
	-- set a variable to indicate that this objective is now a "Defend Square Objective"
	OBJ_TownSquare.DefendTownActive	= true	
	OBJ_TS_Complete()
	
	-- remove the appropriate UI Elements
	OBJ_TownSquare.UI_ID = Objective_RemoveUIElements(OBJ_TownSquare, OBJ_TownSquare.UI_ID)
	
	-- manually call the sit rep and alert, add it to the objective
	Objective_AlertSitRep(OBJ_TownSquare)
	
	-- start all the things related OBJ_DefendTownSquare
	OBJ_DTS_Start()
	
	-- tell the player that the objective has been updated
	Objective_UpdateText(OBJ_TownSquare, OBJ_DefendTownSquare.Title, OBJ_DefendTownSquare.Description)	
end

function OBJ_TS_AxisRetreat()
	-- amazingly enough, this function will only ungarrison the computer squads, not the player's 
	for i=1, table.getn(eg_garrison) do
		if EGroup_IsEmpty(eg_garrison[i]) == false 
		and Player_OwnsEGroup(player1, eg_garrison[i]) == false then
			Cmd_Ungarrison(eg_garrison[i], Util_GetPosition_EVEN_IF_EMPTY(eg_garrison[i]))
		end
	end
	
	local sw_id = t_obj_ts_mgr.aa_gun_id
	
	if SyncWeapon_Exists(sw_id) 
	and SyncWeapon_IsOwnedByPlayer(sw_id, player2) then
		Player_GetAllSquadsNearMarker(player2, t_obj_ts_mgr.sg_aa_def, SyncWeapon_GetPosition(sw_id), 10)
		
		if SGroup_IsEmpty(t_obj_ts_mgr.sg_aa_def) == false then
			Cmd_AbandonTeamWeapon(t_obj_ts_mgr.sg_aa_def)
		end
	end
	
	if SyncWeapon_IsOwnedByPlayer(sw_id, player2) == false
	and SGroup_IsEmpty(t_obj_ts_mgr.sg_aa_def) == false then
		Cmd_Stop(t_obj_ts_mgr.sg_aa_def)
		Cmd_Move(t_obj_ts_mgr.sg_aa_def, Marker_GetPosition(mkr_chateau_exit), false)
	end
	
	local sector2 = World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_rp1))
	
	for i=1, table.getn(t_obj_ts_mgr.sg_defenders) do 
		local sgroup = t_obj_ts_mgr.sg_defenders[i]
		
		if SGroup_IsEmpty(sgroup) == false then
			SGroup_Clear(sg_temp)
			SGroup_AddGroup(sg_temp, sgroup)
			SGroup_Filter(sg_temp, SBP.AXIS.HEAVYMG, FILTER_KEEP)
			
			if SGroup_IsInHoldEntity(sgroup, ANY) == false
			and (Prox_AreSquadsNearMarker(sgroup, t_obj_ts_mgr.sector_id, ANY) 
				or Prox_AreSquadsNearMarker(sgroup, sector2, ANY)
				or SGroup_IsEmpty(sg_temp)) then
				Cmd_Retreat(sgroup, Marker_GetPosition(mkr_chateau_exit))
			end
		end
	end
	
	SGroup_Clear(sg_blah)
	Player_GetAllSquadsNearMarker(player2, sg_blah, mkr_town_area) 
	if SGroup_IsEmpty(sg_blah) then
		Rule_RemoveMe()
	end
end

function OBJ_TS_ConvertRetreaters()
	if Objective_IsComplete(OBJ_TownSquare) == false and OBJ_TownSquare.DefendTownActive ~= true then
		return
	end
	
	for i=1, table.getn(t_obj_ts_mgr.sg_defenders) do 
		local sgroup = t_obj_ts_mgr.sg_defenders[i]
		if SGroup_IsEmpty(sgroup) == false then
			SGroup_SetPlayerOwner(sgroup, player4)
		end
	end
	
	Rule_RemoveMe()
end

-- checks the number of squads left defending the town square and retreats them if the player
-- kills enough of them.
function OBJ_TS_CheckDefenderRetreat()
	if Objective_IsComplete(OBJ_TownSquare) then
		Rule_RemoveMe()
		return
	end
	
	local count = 0
	local threshold = table.getn(t_obj_ts_mgr.sg_defenders) * t_obj_ts_mgr.retreat_perc
	
	-- check number of squads that are dead
	for i=1,table.getn(t_obj_ts_mgr.sg_defenders) do 
		if SGroup_IsEmpty(t_obj_ts_mgr.sg_defenders[i]) then
			count = count + 1
		end
	end
--~ 	print("OBJ_TS_CheckDefenderRetreat - Dead Squads:"..count)
	
	-- if the number of squads that are dead, are less than required, don't do anything
	if count < threshold then
		return
	end
	
	-- tell the axis to retreat from the square
	if Rule_Exists(OBJ_TS_AxisRetreat) == false then
		Rule_AddInterval(OBJ_TS_AxisRetreat, 2)
	end
	
	Rule_RemoveMe()
end


-------------------------------------------------------------
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- PRIMARY OBJECTIVE : Defend the Town Square
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- The player's goal is to defend the town square from the 
-- attacking AI player.
-------------------------------------------------------------

function Initialize_OBJ_DefendTownSquare()
	OBJ_DefendTownSquare =
	{
		SetupUI = function()
			
		end,
		OnStart = function()	
			
		end,
		OnComplete = function()
			-- award the player command points
			Rule_RemoveAll()
			HintPoint_RemoveAll()
			
			-- [[ START DIALOGUE ]]
			Util_StartIntel(EVENTS.OBJ_DTS_Complete)
		end,
		IsComplete = function()
			return false
		end,
		OnFail = function()
			Game_EndSP(false, nil, true)
		end,
		OnSitRep = function()
			
		end,
		
		Title 				= nil,
		Description 		= 289071,
		Icon 				= IT_P_Defend,
		Type 				= OT_Primary,
		CommandRewardAmount	= 1,
		
		SitRep =
		{
			Movie = "SR_08-02",
			Force = true,
			SpeechTiming =
			{
				{ 1.5, ACTOR.McKay, 282001 },
				{ 4.45, ACTOR.McKay, 282002 },
				{ 7.8, ACTOR.McKay, 282003 },
				{ 10.75, ACTOR.McKay, 281150 },
				{ 14.6, ACTOR.McKay, 285080 },
				{ 19.8, ACTOR.McKay, 281320 },
			},
		}
	}
	
	OBJ_DTS_Setup()
	
	-- set up the title to display the correct number of minutes to defend the town square
	local num = Loc_ConvertNumber(t_obj_dts_mgr.time_defend/60)
	local text = Loc_FormatText(289070, num)
	
	OBJ_DefendTownSquare.Title = text
end

function OBJ_DTS_Setup()
	g_COUNTERATTACK_SPAWNED = false
	
	t_obj_dts_mgr = {
		t_time 			= {20*60, 10*60, 5*60, 1*60},				-- cue amounts to tell the player how much time is left in the mission
		time_cue		= {289221, 289221, 289221, 289220},			-- the localization text to use for a particular cue
		t_autosave		= {289106, 289107, 289108 },				-- autosave loc ids, that match with the timer (from left to right)
		time_defend		= 30*60,									-- the amount of time required to defend the town square
		point_lost		= false,									-- flag to track whether the point is being captured for event cues and dialogue
		sgroup			= sg_capturers,								-- sgroup of the capturing squads that will try to take back the strategic point
		sbp				= SBP.AXIS.GRENADIER,						-- sbp of the capturing squads
		upgrade			= nil,										-- potential upgrades for the capturing squads
		loadout			= nil,										-- loadout for the capturing squads?
		squad_num		= 2,										-- difficulty handle, number of squads to spawn to capture point
		timer			= "OBJ_DTS_CAPTURE_RESPAWN",				-- timer to track when the point capturers are respawned
		timer_length	= 1.5*60,									-- length of point capturing timer
		egroup 			= eg_ai_defense,							-- location from whence the point capturers are spawned
		objective		= OBJ_DefendTownSquare,						-- the current objective (used if the TS objective is converted to this objective)
		tmr_ai			= "OBJ_DTS_AI_AGRRESSION",					-- timer to track when the AI's aggression changes
		tmr_ai_length	= t_difficulty.ai_attack_time,				-- length for AI timer
		crit_buildings 	= {},
	}
	
	for i=1, table.getn(CRITICAL_BUILDINGS.AXIS) do 
		t_obj_dts_mgr.crit_buildings[i] = CRITICAL_BUILDINGS.AXIS[i]
	end
	
	table.insert(t_obj_dts_mgr.crit_buildings, EBP.SP.AXIS_HQ_SP_M08)
end

function OBJ_DTS_Start()
	-- check if this function has already been called, it should only ever be called once
	if g_dts_started ~= nil then
		return
	end
	
	g_dts_started = true
	
	-- [[ START DIALOGUE ]]
	Rule_AddOneShot(OBJ_DTS_DelayStartSpeech, 10)
	
	-- start the timer for when the AI will start being more aggressive
	Timer_Start(t_obj_dts_mgr.tmr_ai, t_obj_dts_mgr.tmr_ai_length)
	
	-- start the timer for when the nebelwerfers will beging to attack the town square
	Timer_Start(t_obj_nw_mgr.tmr_nis, t_obj_nw_mgr.tmr_nis_length)
	
	OBJ_DTS_SetupUI()
	Objective_StartTimer(t_obj_dts_mgr.objective, COUNT_DOWN, t_obj_dts_mgr.time_defend)
	
	Rule_AddOneShot(OBJ_GT_DelayStart, t_gt_mgr.time_start)
	Rule_AddInterval(OBJ_DTS_CheckComplete, 1)
	Rule_AddInterval(OBJ_DTS_CheckFail, 3)
	Rule_AddInterval(OBJ_DTS_PanzersInSquare, 6)
	Rule_AddInterval(OBJ_DTS_CaptureSquare, 10)
	
	Rule_AddInterval(OBJ_DTS_CheckProgress, 7)
	Rule_AddInterval(OBJ_DTS_SniperInChurch, 2)
	Rule_AddInterval(OBJ_NW_PlayNISDelay, 3)
	Rule_AddInterval(OBJ_DTS_CheckAIAggression, 5.7)
	
	-- start the manual counter attack 5 minutes after the AIs attack time
	Timer_Start(g_OBJ_DTS_COUNTERATTACK, t_difficulty.ai_attack_time + 5*60)
	Rule_AddInterval(OBJ_DTS_StartCounterattack, 10)
end

function OBJ_DTS_DelayStartSpeech()
	Util_StartIntel(EVENTS.OBJ_DTS_Start)
end

function OBJ_DTS_SetupUI()
	t_obj_dts_mgr.objective.PingID = Objective_AddUIElements(t_obj_dts_mgr.objective, eg_vp1, true, 289072, true, 2)
end

function OBJ_DTS_AddNewObjDelay()
	if Event_IsAnyRunning() == false then
		-- this objective gets registered late, in case the above town square objective
		-- is converted into this objective.  We don't want this showing up on the win screen
		Objective_Register(OBJ_DefendTownSquare)
		Rule_AddInterval(OBJ_DC_CheckSpawnDefenders, 2.73)
		Objective_Start(t_obj_dts_mgr.objective, true)
		OBJ_DTS_Start()
		Rule_RemoveMe()
	end
end

function OBJ_DTS_CheckComplete()
	-- check to see if the timer has run out, or the player has managed
	-- to destroy all the AIs squads and critical buildings.
	if (Objective_GetTimerSeconds(t_obj_dts_mgr.objective) <=0 and Player_OwnsEGroup(player1, eg_vp1)) 
	or Player_HasLost(player4, t_obj_dts_mgr.crit_buildings) then
		Rule_Remove(OBJ_DTS_CheckFail)
		Objective_Complete(t_obj_dts_mgr.objective, true)
		
		-- delay the game completion so the player can hear the audio.
		Rule_AddInterval(OBJ_DTS_DelayCompletion, 0.5)
		Rule_RemoveMe()
	end
end

function OBJ_DTS_DelayCompletion()
	if Event_IsAnyRunning() == false then
		Game_EndSP(true, nil, true)
		Rule_RemoveMe()
	end
end

function OBJ_DTS_CheckAIAggression()
	if g_AI_AGGRESSIVE == true then
		Rule_RemoveMe()
		return
	end
	
	if Timer_GetRemaining(t_obj_dts_mgr.tmr_ai) <= 0 then
		M08_AIChangeAggression()
		Rule_RemoveMe()
		return
	end
	
	for i=1, table.getn(t_ai_aggro_sectors) do
		Player_GetAllSquadsNearMarker(player1, sg_temp, t_ai_aggro_sectors[i])
		if SGroup_IsEmpty(sg_temp) == false then
			M08_AIChangeAggression()
			Rule_RemoveMe()
			return
		end
	end
end

function OBJ_DTS_CheckProgress()
	if table.getn(t_obj_dts_mgr.t_time) <= 0 or Objective_IsComplete(t_obj_dts_mgr.objective) then
		Rule_RemoveMe()
		return
	end
	
	if Objective_GetTimerSeconds(t_obj_dts_mgr.objective) < t_obj_dts_mgr.t_time[1] then
		local num = t_obj_dts_mgr.t_time[1]
		if t_obj_dts_mgr.t_time[1] >= 60 then
			num = t_obj_dts_mgr.t_time[1]/60
		end
		
		num = Loc_ConvertNumber(num)
		local text = Loc_FormatText(t_obj_dts_mgr.time_cue[1], num)
		
		--[[ DIALOGUE ]]
		Util_StartStinger(EVENTS.OBJ_DTS_Progression)
		Obj_CreatePopup(t_obj_dts_mgr.objective.ID, text)
		
--~ 		if table.getn(t_obj_dts_mgr.t_autosave) > 0 then
--~ 			--[[ AUTOSAVE ]]
--~ 			g_AUTOSAVE = t_obj_dts_mgr.t_autosave[1]
--~ 			if Rule_Exists(M08_AutosaveDelay) == false then
--~ 				Rule_AddOneShot(M08_AutosaveDelay, g_AUTOSAVE_DELAY)
--~ 			end
--~ 			table.remove(t_obj_dts_mgr.t_autosave, 1)
--~ 		end
		
		table.remove(t_obj_dts_mgr.t_time, 1)
		table.remove(t_obj_dts_mgr.time_cue, 1)
	end
	
	if Objective_GetTimerSeconds(t_obj_dts_mgr.objective) < 2*60 then
		AI_ForceAttack(player4, player1)
	end
end

function OBJ_DTS_CheckFail()
	-- if player lost the point and recaptured it
	if Player_OwnsEGroup(player1, eg_vp1) and t_obj_dts_mgr.point_lost == true then
		EventCue_Create(t_obj_dts_mgr.objective, 289236, 289236, eg_vp1)
		t_obj_dts_mgr.point_lost = false
		return
	end
	
	-- if the point falls to "neutral" essentially
	if Player_OwnsEGroup(player1, eg_vp1) == false 
	and not Player_OwnsEGroup(player2, eg_vp1) 
	and not Player_OwnsEGroup(player4, eg_vp1)
	and t_obj_dts_mgr.point_lost == false then
		
		EventCue_Create(t_obj_dts_mgr.objective, 289235, 289235, eg_vp1)
		Util_StartStinger(EVENTS.OBJ_DTS_Failing)
		t_obj_dts_mgr.point_lost = true
		return
	end
	
	if (Player_OwnsEGroup(player2, eg_vp1) or Player_OwnsEGroup(player4, eg_vp1)) then
		Objective_Fail(t_obj_dts_mgr.objective, true)
		Rule_RemoveMe()
		Rule_Remove(OBJ_DTS_CheckComplete)
		
	end
end

function OBJ_DTS_SniperInChurch()
	if Player_CanSeeEGroup(player1, eg_church, ANY)
	and EGroup_IsOnScreen(player1, eg_church, ANY, 0.6) then
		--[[ DIALOGUE ]]
		Util_StartStinger(EVENTS.OBJ_DTS_ChurchSpotted)
		EventCue_Create(CUE.NORMAL, 289231, 289231, mkr_hint_church, 289230)
		Rule_RemoveMe()
	end
end

function OBJ_DTS_PanzersInSquare()
	Player_GetAllSquadsNearMarker(player2, sg_temp, Util_GetPosition_EVEN_IF_EMPTY(eg_vp1), 60)
	SGroup_Filter(sg_temp, SBP.AXIS.PANZER, FILTER_KEEP)
	
	if (SGroup_IsEmpty(sg_temp) == false and Player_CanSeeSGroup(player1, sg_temp, ANY)) then
		Util_StartStinger(EVENTS.OBJ_DTS_PanzersSpotted)
		EventCue_Create(CUE.ATTACKED, 289237, 289237, Util_GetPosition_EVEN_IF_EMPTY(SGroup_GetSpawnedSquadAt(sg_temp, 1)))
		Rule_RemoveMe()
		return
	end
	
	Player_GetAllSquadsNearMarker(player2, sg_temp2, Util_GetPosition_EVEN_IF_EMPTY(eg_vp1), 60)
	SGroup_Filter(sg_temp2, SBP.AXIS.PANZER, FILTER_KEEP)
	
	if (SGroup_IsEmpty(sg_temp2) == false and Player_CanSeeSGroup(player1, sg_temp2, ANY)) then
		Util_StartStinger(EVENTS.OBJ_DTS_PanzersSpotted)
		EventCue_Create(CUE.ATTACKED, 289237, 289237, Util_GetPosition_EVEN_IF_EMPTY(SGroup_GetSpawnedSquadAt(sg_temp, 2)))
		Rule_RemoveMe()
		return
	end
end

-- this function monitors the squads that are sent out specifically to 
-- capture the strategic point from the player.
function OBJ_DTS_CaptureSquare()
	if Objective_IsComplete(t_obj_dts_mgr.objective) or EGroup_IsEmpty(t_obj_dts_mgr.egroup) then
		Rule_RemoveMe()
		return
	end
	
	if Timer_GetRemaining(t_obj_dts_mgr.tmr_ai) > 0 and g_AI_AGGRESSIVE == false then
		return
	end
	
	local sgroup = t_obj_dts_mgr.sgroup
	
	if g_CAPTURERS_SPAWNED == true then
		if SGroup_IsInHoldEntity(sgroup, ANY) then
			Cmd_Ungarrison(t_obj_dts_mgr.egroup, EGroup_GetPosition_EVEN_IF_EMPTY(t_obj_dts_mgr.egroup))
		else
			Cmd_SquadPath(sgroup, "path_counterattack"..World_GetRand(1, 3), true, false, true, 0)
			g_CAPTURERS_SPAWNED = false
		end
	end
	
	if SGroup_IsEmpty(t_obj_dts_mgr.sgroup)
	and EGroup_IsEmpty(t_obj_dts_mgr.egroup) == false
	and Timer_GetRemaining(t_obj_dts_mgr.timer) <= 0 then
		Util_CreateSquadsAndGarrisonExit(player2, sgroup, t_obj_dts_mgr.sbp, t_obj_dts_mgr.egroup, t_obj_dts_mgr.squad_num, EGroup_GetPosition_EVEN_IF_EMPTY(t_obj_dts_mgr.egroup), true, t_obj_dts_mgr.loadout)
		Util_GrantRandomUpgrade(sgroup)
		Timer_Start(t_obj_dts_mgr.timer, t_obj_dts_mgr.timer_length)
		g_CAPTURERS_SPAWNED = true
		return
	end
	
	if SGroup_IsMoving(sgroup, ANY) == false
	and SGroup_IsUnderAttack(sgroup, ANY, 10) == false
	and SGroup_Capturing(sgroup) == false then
		Cmd_AttackMoveThenCapture(sgroup, eg_vp1)
	end
end

function OBJ_DTS_StartCounterattack()
	if Timer_GetRemaining(g_OBJ_DTS_COUNTERATTACK) <= 0 then
		OBJ_DTS_SpawnCounterattack()
		
		for i=1, table.getn(sg_panzer) do
			if SGroup_IsEmpty(sg_panzer[i]) == false then
				Cmd_SquadPath(sg_panzer[i], "path_counterattack"..i, true, false, true, 0)			
			end
		end
		
		Rule_RemoveMe()
	end
end

function OBJ_DTS_SpawnCounterattack()
	if g_COUNTERATTACK_SPAWNED == true then
		return
	end
	
	for i=1, table.getn(mkr_sp_counterattack) do
		local pos = World_GetHiddenPositionOnPath(player1, spawn_northeast, mkr_sp_counterattack[i], CHECK_OFFCAMERA)
		
		if pos == nil then
			pos = mkr_sp_counterattack[i]
		end
		
		Util_CreateSquadsAtMarkerFacing(player2, sg_panzer[i], SBP.AXIS.PANZER, pos, spawn_south, 1)
		Cmd_Move(sg_panzer[i], mkr_sp_counterattack[i])
	end
	g_COUNTERATTACK_SPAWNED = true
end

function SGroup_Capturing(sgroup)
	local result = false
	local _SquadActiveCmd = function(gid, item, sid)
		if Squad_GetActiveCommand(sid) == SQUADSTATEID_Capture then
			result = true
		end
	end
	SGroup_ForEach(sgroup, _SquadActiveCmd)
	return result
end

-------------------------------------------------------------
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- SECONDARY OBJECTIVE 1
-- Destroy the Nebelwerfers
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- 
-------------------------------------------------------------

function Initialize_OBJ_Nebelwerfers()
	OBJ_Nebelwerfers =
	{
		SetupUI = function()
			-- Nebelwerfers appear on the map as the player finds them
		end,
		OnStart = function()
			Objective_SetCounter(OBJ_Nebelwerfers, OBJ_Nebelwerfers.NebsDestroyed, OBJ_Nebelwerfers.TotalNebs)
			Rule_AddOneShot(Nebelwerfers_Start, 2)
			
			-- [[ START DIALOGUE ]]
			Util_StartIntel(EVENTS.OBJ_NW_Start)
			
			--[[ AUTOSAVE ]]
--~ 			g_AUTOSAVE = 289103
--~ 			if Rule_Exists(M08_AutosaveDelay) == false then
--~ 				Rule_AddOneShot(M08_AutosaveDelay, g_AUTOSAVE_DELAY)
--~ 			end
		end,
		OnComplete = function()
			
		end,
		IsComplete = function()
			return false
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		
		Title 				= 289040,	
		Description 		= 289041,
		Type 				= OT_Secondary,
		Icon				= IT_S_Default,
		UI_ID				= {},
		NebsDestroyed		= 0,
		TotalNebs			= 0,
	}
	Objective_Register(OBJ_Nebelwerfers)
end

--------------------------------------------------------------------------------
-- NEBELWERFERS
--------------------------------------------------------------------------------

function Nebelwerfers_Init()
	local neb_def = {}
	neb_def[1] = {
		SBP.AXIS.PAK_38,
		SBP.AXIS.HEAVYMG,
		SBP.AXIS.OSTWIND,
		SBP.AXIS.SNIPER,
	}
	neb_def[2] = {
		SBP.AXIS.HEAVYMG,
		SBP.AXIS.STORMTROOPER,
		SBP.AXIS.OSTWIND,
	}
	neb_def[3] = {
		SBP.AXIS.HALFTRACK_FLAME,
		SBP.AXIS.SNIPER,
		SBP.AXIS.HEAVYMG,
	}

	nebelwerfers = {}
	for i=1, table.getn(mkr_nebel) do 
		nebelwerfers[i] = {
			group 				= sg_nebel[i],
			relatedsgroup 		= sg_nebel_related[i],										-- sgroups of the neblewerfers protectors
			backup_sbp			= SBP.AXIS.GRENADIER,										-- sbps of the nebelwerfer protectors
			backupspawn 		= Util_GetClosestMarker(mkr_nebel[i], g_SPAWN_MARKERS),		-- marker from whence the "protectors" of the nebelwerfers spawn
			mkr					= mkr_nebel[i],												-- location that the nebs are supposed to move
			mkr_backup			= mkr_nebelbackup[i],										-- location for the nebs to spawn at the chateu (or stay if their territory is captured)
			mkr_active			= mkr_nebel[i],												-- the marker that a nebelwerfer will be moving towards
			eg_rp				= eg_rp_nebel[i],											-- the associate territory point that the nebelwerfer will be near
			spotted 			= false,													-- whether a nebelwerfer has been spotted or not
			at_marker			= false,													-- whether a nebelwerfer has moved to its "assigned" location
			tmr_speech			= "NEBELWERFER SPEECH TIMER", 								-- speech timer (note that this timer is shared between all nebs)
			tmr_speech_length	= 45,														-- speech timer length
			squad_num			= 2,														-- number of nebs to spawn (difficulty handle)
			tmr_hq				= "NEBELWERFER HQ TIMER",									-- timer to attack hq (note that this timer is shared between all nebs)
			tmr_hq_length		= 3*60,														-- length of timer before first attack on HQ (difficulty handle)
			t_def				= {},														-- table holding all the various defenders associated with this nebelwerfer
			def_spawned			= false,													-- a marker to detect whether or not the defenders have been spawned
		}
		
		for j=1, table.getn(mkr_neb_def[i]) do
			nebelwerfers[i].t_def[j] = {
				sgroup 		= sg_neb_def[i][j],
				mkr_sp 		= mkr_neb_def[i][j],
				sbp 		= neb_def[i][j],
			}
		end
	end
	
	t_obj_nw_mgr = {
		tmr_nis				= "NEBELWERFER NIS TIMER", 									-- length of time before the NIS plays for attacking the player at the town square
		tmr_nis_length		= t_difficulty.ai_attack_time - (2*60)						-- the nebs start attacking pre-emptively, to the time the AI will start being more aggressive
	}
	
	g_CURRENT_NEBEL = 1
	g_MAX_NEBELS = 3
	g_NEB_ATTACK_INTERVAL = 120
	
	nebelwerfers[1].reaction = Nebelwerfers_Reaction1
	nebelwerfers[2].reaction = Nebelwerfers_Reaction2
	nebelwerfers[3].reaction = Nebelwerfers_Reaction3
	
	OBJ_Nebelwerfers.TotalNebs = table.getn(nebelwerfers)
	
	-- spawn the nebs in the correct location
	Rule_AddInterval(Nebelwerfers_Spawn, 1.3)
end

-- this function checks the circumstances under which the second NIS will play 
-- Note: if the nebelwerfers are destroyed (before the NIS is played), then the NIS and the objective will not play
-- the objective will be skipped
function OBJ_NW_PlayNISDelay()
	local sgroup
	local bln_dead = true
	
	for i=1, table.getn(nebelwerfers) do
		sgroup = nebelwerfers[i].group
		
		if SGroup_IsEmpty(sgroup) == false then
			bln_dead = false
			
			if Timer_GetRemaining(t_obj_nw_mgr.tmr_nis) <= 0 or SGroup_IsUnderAttack(sgroup, ANY, 10) then
				Util_StartNIS(EVENTS.NIS02)
				OBJ_NW_NISMods()
				Rule_AddInterval(OBJ_NW_AddNewObjDelay, 1)
				Rule_RemoveMe()
				return
			end
		end
	end
	
	if bln_dead == true then
		Rule_RemoveMe()
		Objective_Complete(OBJ_Nebelwerfers, false)
	end
end

function OBJ_NW_NISMods()
	-- first make all the soldiers go prone.
	local sector = World_GetTerritorySectorID(Util_GetPosition_EVEN_IF_EMPTY(eg_vp1))
	
	Player_GetAllSquadsNearMarker(player1, sg_temp, sector)
	SGroup_SuggestPosture(sg_temp, 0, 30)
	
	-- order everyone to stop attacking each other
	Player_GetAll(player1, sg_temp)
	Cmd_Stop(sg_temp)
	SGroup_SetInvulnerable(sg_temp, true, 30)
	
	Player_GetAll(player2, sg_temp)
	Cmd_Stop(sg_temp)
	SGroup_SetInvulnerable(sg_temp, true, 30)
	
	Player_GetAll(player4, sg_temp)
	Cmd_Stop(sg_temp)
	SGroup_SetInvulnerable(sg_temp, true, 30)
	
	Rule_AddInterval(OBJ_NW_NISRelease, 0.5)
end

function OBJ_NW_NISRelease()
	-- while NIS is running don't do anything
	if Event_IsRunning(EVENTS.NIS02) then
		return
	end
	
	-- order everyone to stop attacking each other
	Player_GetAll(player1, sg_temp)
	SGroup_SetInvulnerable(sg_temp, false)
	
	Player_GetAll(player2, sg_temp)
	SGroup_SetInvulnerable(sg_temp, false)
	
	Player_GetAll(player4, sg_temp)
	SGroup_SetInvulnerable(sg_temp, false)
	
	Rule_RemoveMe()
end

function OBJ_NW_AddNewObjDelay()
	if Event_IsAnyRunning() == false then
		Objective_Start(OBJ_Nebelwerfers, true)
		Rule_RemoveMe()
	end
end

-- kick off the nebelwerfers
function Nebelwerfers_Start()
	Rule_AddInterval(Nebelwerfers_Monitor, 5)
	Rule_AddInterval(Nebelwerfers_DoAttack, 10)
	Rule_AddInterval(Nebelwerfers_AllGone, 1)
	Rule_AddInterval(Nebelwerfers_Move, 2.5)
end

function Nebelwerfers_Spawn()
	-- if the player does not have any paratroopers (i.e. he can't buy them)
	-- if he has not repaired the bridge
	-- then do not spawn the nebelwerfers,
	Player_GetAll(player1, sg_temp)
	SGroup_Filter(sg_temp, SBP.ALLIES.PARATROOPERS, FILTER_KEEP)
	
	if Objective_IsComplete(OBJ_RepairBridge) == false
	and SGroup_IsEmpty(sg_temp) then
		return
	end
	
	-- any situation where the nebelwerfers will be spawned, then we can make the chateau attackable
	EGroup_SetInvulnerable(eg_chateau, false)
	
	local sgroup
	for i=1, table.getn(nebelwerfers) do
		sgroup = nebelwerfers[i].group
		Util_CreateSquadsAtMarker(player2, sgroup, SBP.AXIS.NEBELWERFER, nebelwerfers[i].mkr_backup, nebelwerfers[i].squad_num)
		SGroup_FacePosition(sgroup, Util_GetPosition_EVEN_IF_EMPTY(eg_rp_town))
		--Modify_WeaponDamage(sgroup, "hardpoint_01", 0.85)
	end
	Rule_RemoveMe()
end

function Nebelwerfers_Move()
	local mkr
	local sgroup
	local bln_all_moved = true
	
	for i=1, table.getn(nebelwerfers) do
		sgroup = nebelwerfers[i].group
		local this = nebelwerfers[i]
		
		local nebel_count = 0
		function CountNebels(gid, item, sid)
			if Squad_Count(sid) > 1 then
				nebel_count = nebel_count + 1
			end
		end
		SGroup_ForEach(sgroup, CountNebels)
		
		if this.at_marker == false 
		and nebel_count > 0 then
			if Player_OwnsEGroup(player1, nebelwerfers[i].eg_rp) then
				nebelwerfers[i].mkr_active = nebelwerfers[i].mkr_backup
				SGroup_FacePosition(sgroup, Util_GetPosition_EVEN_IF_EMPTY(eg_rp_town))
				this.at_marker = true
			elseif this.mkr_active ~= nil
			and Prox_AreSquadsNearMarker(this.group, Marker_GetPosition(this.mkr_active), ANY, 10) then
				this.at_marker = true
			elseif SGroup_IsMoving(sgroup, ANY) == false then
				mkr = nebelwerfers[i].mkr
				nebelwerfers[i].mkr_active = mkr
				Cmd_Move(sgroup, mkr)
			end
			bln_all_moved = false
		end
		
		Timer_Start(nebelwerfers[i].tmr_hq, nebelwerfers[i].tmr_hq_length)
	end
	
	if bln_all_moved then
		Rule_RemoveMe()
	end
end

-- trigger the next nebelwerfer in sequence to fire
function Nebelwerfers_DoAttack()
	local this = nebelwerfers[g_CURRENT_NEBEL]
	
	-- check to make sure that the nebel did not die while this funciton was running
	if this == nil or SGroup_IsEmpty(this.group) then
		g_CURRENT_NEBEL = 1
		return
	end
	
	if this.at_marker == false then
		-- prep the next one in the sequence
		print("Nebel"..g_CURRENT_NEBEL.." is not near the active marker")
		g_CURRENT_NEBEL = g_CURRENT_NEBEL + 1
		return
	end
	
	-- pick the target
	Player_GetAllSquadsNearMarker(player1, sg_temp, town_area)
	local countguys = SGroup_CountSpawned(sg_temp)
	local countmarkers = table.getn(mkr_nebel_targets)
	local rand = World_GetRand(1, countmarkers + countguys)
	local target = 1
	if Timer_GetRemaining(this.tmr_hq) <= 0 then
		print("Nebelwerfers_DoAttack: Target - HQ")
		target = Util_GetPosition_EVEN_IF_EMPTY(mkr_target_hq)
		Timer_Start(this.tmr_hq, this.tmr_hq_length)
	elseif (rand <= countmarkers) then
		print("Nebelwerfers_DoAttack: Target - Marker")
		target = Marker_GetPosition(mkr_nebel_targets[rand])
	else
		print("Nebelwerfers_DoAttack: Target - Squad")
		target = Squad_GetPosition(SGroup_GetSpawnedSquadAt(sg_temp, rand - countmarkers))
	end
	
	-- forced fudge factor
	target.x = target.x + World_GetRand(-25, 25)-- + World_GetRand(-55, 55)
	target.z = target.z + World_GetRand(-25, 25)-- + World_GetRand(-55, 55)
	
	-- set the target location for the event cue
	g_LAST_NEB_TARGET = target
	
	-- fire the nebelwerfer
	-- attacking the location twice to make more of an impact on the player
	if SGroup_IsEmpty(this.group) == false then
		Cmd_Ability(this.group, ABILITY.SP.SP_FIRENEBELWERFER, target, nil, true)
		--Cmd_Ability(player2, ABILITY.COMMANDER_TREE.AXIS.FIRESTORM, target, nil, true)
		
		Util_StartStinger(EVENTS.OBJ_NW_NebAttack)
		if OBJ_Nebelwerfers.UI_ID[g_CURRENT_NEBEL] == nil then
			OBJ_Nebelwerfers.UI_ID[g_CURRENT_NEBEL] = Objective_AddUIElements(OBJ_Nebelwerfers, this.group, true, 289042, true)
		end
		
		EventCue_Create(CUE.ATTACKED, 289043, 289043)
		
		if Rule_Exists(Nebelwerfers_TargetEvent) == false then
			Rule_AddOneShot(Nebelwerfers_TargetEvent, 12)
		end
	end
	
	-- prep the next one in the sequence
	g_CURRENT_NEBEL = g_CURRENT_NEBEL + 1
	
	if (g_CURRENT_NEBEL > table.getn(nebelwerfers)) then
		-- if that was the last nebelwerfer...
		g_CURRENT_NEBEL = 1
		if Rule_Exists(Nebelwerfers_DoAttack) then
			Rule_ChangeInterval(Nebelwerfers_DoAttack, g_NEB_ATTACK_INTERVAL - (10*table.getn(nebelwerfers)))
		end
	end
end

-- watch for when neb's first get spotted, and for when they're all gone
function Nebelwerfers_Monitor()
	for n=table.getn(nebelwerfers), 1, -1 do
		local this = nebelwerfers[n]
		local nebel_count = 0
		function CountNebels(gid, item, sid)
			if Squad_Count(sid) > 1 then
				nebel_count = nebel_count + 1
			end
		end
		SGroup_ForEach(this.group, CountNebels)
		if nebel_count > 0 then
			--[[ DIALOGUE ]]
			if this.spotted == false 
			and Player_CanSeeSGroup(player1, this.group, ANY) then
				Util_StartStinger(EVENTS.OBJ_NW_NebSpotted)
				if OBJ_Nebelwerfers.UI_ID[n] == nil then
					OBJ_Nebelwerfers.UI_ID[n] = Objective_AddUIElements(OBJ_Nebelwerfers, this.group, true, 289042, true)
				end
				this.spotted = true
				EventCue_Create(CUE.ATTACKED, 289044, 289044, this.group)
			end
			
			if this.reaction ~= false then
				local pos = SGroup_GetPosition_EVEN_IF_EMPTY(this.group)
				
				Player_GetAllSquadsNearMarker(player1, sg_temp, pos, 35)
				-- see if we should trigger the protectors when they first spot you
				if SGroup_IsEmpty(sg_temp) == false then
					-- send in some backup
					SGroup_Clear(sg_temp)
					Util_CreateSquadsAtMarker(player2, sg_temp, SBP.AXIS.GRENADIER, this.backupspawn, 1)
					Cmd_AttackMove(sg_temp, SGroup_GetPosition_EVEN_IF_EMPTY(this.group))
					
					-- if there's a reaction function associated, run it...
					if this.reaction ~= false then
						this.reaction(n)
						this.reaction = false
					end
				end
			end
		else
			print("Nebelwerfer Gone: "..SGroup_GetName(nebelwerfers[n].group))
			-- if the nebelwerfer has been destroyed
			
			Objective_RemoveUIElements(OBJ_Nebelwerfers, OBJ_Nebelwerfers.UI_ID[n])
			OBJ_Nebelwerfers.NebsDestroyed = OBJ_Nebelwerfers.NebsDestroyed + 1
			Objective_SetCounter(OBJ_Nebelwerfers, OBJ_Nebelwerfers.NebsDestroyed, OBJ_Nebelwerfers.TotalNebs)
			
			-- [[ START DIALOGUE ]]
			Util_StartStinger(EVENTS.OBJ_NW_NebDestroyed)
			
			table.remove(nebelwerfers, n)
		end
	end
	
	-- if all nebelwerfers are gone...
	if (table.getn(nebelwerfers) == 0) then
		Rule_RemoveMe()
	end
end

function Nebelwerfers_TargetEvent()
	EventCue_Create(CUE.NORMAL, 289046, 289046, g_LAST_NEB_TARGET)
end

-- triggers once all nebelwerfers are destroyed
function Nebelwerfers_AllGone()
	-- if all nebelwerfers are gone...
	if (table.getn(nebelwerfers) == 0) then
		Rule_RemoveMe()
		Rule_Remove(Nebelwerfers_DoAttack)
		
		-- [[ START DIALOGUE ]]
		Util_StartIntel(EVENTS.OBJ_NW_Complete)
		Objective_Complete(OBJ_Nebelwerfers, true)
	end
end

function OBJ_NW_SpawnDefense()
	if Objective_IsComplete(OBJ_Nebelwerfers) then
		Rule_RemoveMe()
		return
	end
	
	if Rule_Exists(Nebelwerfers_DoAttack) == false then
		return
	end
	
	for i=1, table.getn(nebelwerfers) do
		if nebelwerfers[i].def_spawned == false then
			if SGroup_IsEmpty(nebelwerfers[i].group) or Player_OwnsEGroup(player1, nebelwerfers[i].eg_rp) then
				nebelwerfers[i].def_spawned = true
				break
			end
			
			Player_GetAllSquadsNearMarker(player1, sg_temp, nebelwerfers[i].mkr)		
			
			if SGroup_IsEmpty(sg_temp) == false or nebelwerfers[i].at_marker == true then
				print("OBJ_NW_SpawnDefense: Respawning Units"..i)
				
				local def = nebelwerfers[i].t_def
				
				for j=1, table.getn(def) do
					local pos = World_GetHiddenPositionOnPath(player1, nebelwerfers[i].backupspawn, def[j].mkr_sp, CHECK_OFFCAMERA)
					
					if pos == nil then
						pos = def[j].mkr_sp
					end
					
					Util_CreateSquadsAtMarker(player2, def[j].sgroup, def[j].sbp, pos, 1)
					
					if pos ~= def[j].mkr_sp then
						Cmd_AttackMove(def[j].sgroup, def[j].mkr_sp)
					end
					
					if def[j].sbp == SBP.AXIS.HEAVY_MG then
						Cmd_InstantSetupTeamWeapon(def[j].sgroup, true)
					end
					
					if i == 1 and def[j].sbp == SBP.AXIS.SNIPER then
						Cmd_Garrison(def[j].sgroup, eg_nebel1)
					end
					
					nebelwerfers[i].def_spawned = true
				end
			end
		end
	end
end


-- reaction function for when Neb-1 is seen
function Nebelwerfers_Reaction1(idx)
	print("Nebelwerfers_Reaction1"..idx)
	if SGroup_IsEmpty(nebelwerfers[idx].group) then
		return
	end
	
	SGroup_Clear(sg_attacker)
	SGroup_GetLastAttacker(nebelwerfers[idx].group, sg_attacker)
	
	if SGroup_IsEmpty(sg_attacker) then
		return
	end
	
	local pos = SGroup_GetPosition_EVEN_IF_EMPTY(sg_attacker)
	
	for i=1, table.getn(nebelwerfers[idx].t_def) do
		local sg = nebelwerfers[idx].t_def[i].sgroup
		
		if SGroup_IsEmpty(sg) == false then
			Cmd_AttackMove(sg, pos)
		end
	end
end


-- reaction function for when Neb-2 is seen
function Nebelwerfers_Reaction2(idx)
	print("Nebelwerfers_Reaction2"..idx)
	if SGroup_IsEmpty(sg_patrol4) == false then
		Cmd_AttackMove(sg_patrol4, mkr_nebel2)
	end
	
	if SGroup_IsEmpty(nebelwerfers[idx].group) then
		return
	end
	
	SGroup_Clear(sg_attacker)
	SGroup_GetLastAttacker(nebelwerfers[idx].group, sg_attacker)
	
	if SGroup_IsEmpty(sg_attacker) then
		return
	end
	
	local pos = SGroup_GetPosition_EVEN_IF_EMPTY(sg_attacker)
	
	for i=1, table.getn(nebelwerfers[idx].t_def) do 
		local sg = nebelwerfers[idx].t_def[i].sgroup
		
		if SGroup_IsEmpty(sg) == false then
			Cmd_AttackMove(sg, pos)
		end
	end
end


-- reaction function for when Neb-3 is seen
function Nebelwerfers_Reaction3(idx)
	print("Nebelwerfers_Reaction3"..idx)
	if SGroup_IsEmpty(nebelwerfers[idx].group) then
		return
	end
	
	SGroup_Clear(sg_attacker)
	SGroup_GetLastAttacker(nebelwerfers[idx].group, sg_attacker)
	
	if SGroup_IsEmpty(sg_attacker) then
		return
	end
	
	local pos = SGroup_GetPosition_EVEN_IF_EMPTY(sg_attacker)
	
	for i=1, table.getn(nebelwerfers[idx].t_def) do 
		local sg = nebelwerfers[idx].t_def[i].sgroup
		
		if SGroup_IsEmpty(sg) == false then
			Cmd_AttackMove(sg, pos)
		end
	end
end


-------------------------------------------------------------
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- MEDAL OPPORTUNITY
-- Attack and Destroy the Chateau
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- 
-------------------------------------------------------------

function Initialize_OBJ_Chateau ()
	OBJ_Chateau =
	{
		SetupUI = function()
			local pos = Util_GetPosition_EVEN_IF_EMPTY(eg_chateau)
			OBJ_Chateau.UI_ID = Objective_AddUIElements(OBJ_Chateau, pos, true, 289052, true, 15)
		end,
		OnStart = function()
			Rule_AddInterval(Chateau_Destroyed, 3)

			-- [[ START DIALOGUE ]]
			Util_StartIntel(EVENTS.OBJ_DC_Start)
			EventCue_Create(CUE.NORMAL, 289053, 289053, eg_chateau)
			
			--[[ AUTOSAVE ]]
--~ 			g_AUTOSAVE = 289104
--~ 			if Rule_Exists(M08_AutosaveDelay) == false then
--~ 				Rule_AddOneShot(M08_AutosaveDelay, g_AUTOSAVE_DELAY)
--~ 			end
		end,
		OnComplete = function()
			-- award the player command points
			-- [[ START DIALOGUE ]]
			Util_StartIntel(EVENTS.OBJ_DC_Complete)
			
			--[[ AUTOSAVE ]]
--~ 			g_AUTOSAVE = 289105
--~ 			if Rule_Exists(M08_AutosaveDelay) == false then
--~ 				Rule_AddOneShot(M08_AutosaveDelay, g_AUTOSAVE_DELAY)
--~ 			end
		end,
		IsComplete = function()
			return false
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		
		Title 				= 289050,
		Description 		= 289051,
		Icon 				= IT_M_Default,
		Type 				= OT_Medal,
		MedalID 			= MEDALS.BRONZE_STAR_M08,
		CommandRewardAmount	= 1,
	}
	
	Objective_Register(OBJ_Chateau)
end

--------------------------------------------------------------------------------
-- CHATEAU
--------------------------------------------------------------------------------

-- checks to see if the player is near the chateau
function OBJ_DC_StartDelay()
	Player_GetAllSquadsNearMarker(player1, sg_temp, Util_GetPosition_EVEN_IF_EMPTY(mkr_chateau_exit), 80)
	if Event_IsAnyRunning() == false
	and (SGroup_IsEmpty(sg_temp) == false 
		 or EGroup_IsEmpty(eg_chateau)
		 or Player_CanSeeEGroup(player1, eg_chateau, ANY)) then
		
		OBJ_DC_SpawnDefenders()
		Objective_Start(OBJ_Chateau, true)
		Rule_RemoveMe()
	end
end

function Chateau_Destroyed()
	if (EGroup_Count(eg_chateau) == 0) then
		Rule_RemoveMe()
		Objective_Complete(OBJ_Chateau, true)
		
		if Objective_IsStarted(OBJ_DefendTownSquare) == false
		and OBJ_TownSquare.DefendTownActive ~= true then
			OBJ_TS_ChangeToOBJ_DTS()			
		end
	end
end

function OBJ_DC_CheckSpawnDefenders()
	if g_OBJ_DC_SPAWN_DEF == true then
		Rule_RemoveMe()
		return
	end
	
	-- check if the player has decided to attack the chateau
	for i=1, table.getn(t_chateau_sectors) do
		Player_GetAllSquadsNearMarker(player1, sg_temp, t_chateau_sectors[i])		
		if SGroup_IsEmpty(sg_temp) == false then
			M08_AIChangeAggression()
			OBJ_DC_SpawnDefenders()
			Rule_RemoveMe()
			return
		end
	end
end

function OBJ_DC_SpawnDefenders()
	-- if the defenders have already been spawned then
	-- don't respawn them again.
	if g_OBJ_DC_SPAWN_DEF == true then
		return
	end
	
	-- give the AI control of the patrolling panzers
	for i=1, table.getn(sg_panzer_patrol) do 
		if SGroup_IsEmpty(sg_panzer_patrol[i]) == false then
			SGroup_SetPlayerOwner(sg_panzer_patrol[i], player4)
		end
	end
	
	for i=1, table.getn(eg_chateau_aa) do
		local pos = World_GetHiddenPositionOnPath(player1, mkr_chateau_exit, mkr_sp_chateau_aa[i], CHECK_OFFCAMERA)
		
		if pos == nil then
			pos = mkr_sp_chateau_aa[i]
		end
		
		Util_CreateSquadsAtMarker(player2, sg_chateau_aa[i], SBP.AXIS.GRENADIER, pos, 1, 3)
		Cmd_CaptureTeamWeapon(sg_chateau_aa[i], eg_chateau_aa[i], false)
	end
	
	for i=1, table.getn(mkr_storm_def) do 
		if EGroup_IsEmpty(eg_chateau) == false then
			Util_CreateSquadsAndGarrisonExit(player4, sg_storm_def[i], SBP.AXIS.STORMTROOPER, eg_chateau, 1, mkr_chateau_exit, true)
			Cmd_AttackMove(sg_storm_def[i], mkr_storm_def[i], true)
		end
	end
	
	for i=1, table.getn(mkr_sp_pak) do 
		Util_CreateSquadsAtMarker(player2, sg_pak38[i], SBP.AXIS.PAK_38, mkr_sp_pak[i], 1)
	end
	
	OBJ_DTS_SpawnCounterattack()
	
	g_OBJ_DC_SPAWN_DEF = true
end

-------------------------------------------------------------
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- SECONDARY OBJECTIVE
-- Intercept Goliath Truck
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- A truck carrying Goliaths moves through town trying to get
-- to a predetermined location on the map (follows a path)
-- the player's goal is to intercept and destroy it to recover
-- some Goliaths.
-------------------------------------------------------------

function OBJ_GT_DelayStart()
	Rule_AddInterval(OBJ_GT_EventDelayStart, 2)
end

function OBJ_GT_EventDelayStart()
	if Event_IsAnyRunning() == false then
		Rule_RemoveMe()
		OBJ_GT_Start()
	end
end

function OBJ_GT_Init()
	-- doing this twice because it seems to be that the seed
	-- for the random path is always the same each time the mission
	-- is played.
	local rand = World_GetRand(1, table.getn(mkr_sp_goltruck))
	rand = World_GetRand(1, table.getn(mkr_sp_goltruck))
	
	local sbps = {
		SBP.AXIS.PANZER,
		SBP.AXIS.OPELBLITZ,
		SBP.AXIS.PUMA,
		SBP.AXIS.OPELBLITZ,
		SBP.AXIS.HALFTRACK,
		SBP.AXIS.OPELBLITZ,
		SBP.AXIS.PANZER,
	}
	
	t_gt_mgr = {
		tmr_sp			= "GOL PROT SPAWN TIMER",		-- note that this timer is shared by all protectors 
		tmr_sp_length 	= 20,							-- this is the length of time that occurs before next vehicle in convoy spawns
		cue_leaving		= false,
		tmr_recover		= "GOLIATH RECOVER TIMER",
		tmr_re_length	= 30,
		mod_speed		= 0.6,
		hint_button		= nil,
		time_start		= t_difficulty.convoy_time,
	}
	
	t_gt_convoy_mgr = {}
	for i=1, table.getn(sbps) do
	
		t_gt_convoy_mgr[i] = {
			sgroup 			= sg_gol_convoy[i],
			mkr_sp 			= mkr_sp_goltruck[rand],
			sbp				= sbps[i],
			upg				= nil,
			path 			= path_gol_truck[rand],
			mkr_end 		= mkr_gol_truck_path_end[rand],
			cue_leaving 	= false,
			state			= nil,
			sg_goliath		= false,
			sg_to_follow	= nil,
			last_pos		= mkr_sp_goltruck[rand],
		}
		
		if sbps[i] == SBP.AXIS.OPELBLITZ then
			t_gt_convoy_mgr[i].sg_goliath = sg_goliaths[i]
		end
		
		if i ~= 1 then
			t_gt_convoy_mgr[i].sg_to_follow = t_gt_convoy_mgr[i-1]
		end
		
	end
	
	t_gol_to_recover = {}
	
	g_CURRENT_SPAWN = 1
end

function OBJ_GT_Start()
	Rule_AddInterval(OBJ_GT_Spawn, 3)
	Rule_AddInterval(OBJ_GT_MoveConvoy, 5)
	Rule_AddInterval(OBJ_GT_CheckGoliathSpawn, 3)
	Rule_AddInterval(OBJ_GT_CheckFailureOrCompletion, 3)
	Rule_AddInterval(OBJ_GT_ExitMap, 3)
end

function OBJ_GT_Spawn()
	-- the intention of this function is to spawn the convoy in order
	-- from the first squad to the second squad, etc.
	
	if Timer_GetRemaining(t_gt_mgr.tmr_sp) > 0 then
		return
	end
	
	print("g_CURRENT_SPAWN: "..g_CURRENT_SPAWN)
	-- determine if we are making a protector or a truck
	this = t_gt_convoy_mgr[g_CURRENT_SPAWN]
	
	Util_CreateSquadsAtMarker(player2, this.sgroup, this.sbp, this.mkr_sp, 1)
	
	-- set the state to indicate that the squad has been spawned
	this.state = 0
	
	-- slow down the convoy
	Modify_UnitSpeed(this.sgroup, t_gt_mgr.mod_speed)
	
	if this.sbp == SBP.AXIS.HALFTRACK then
		Cmd_Upgrade(this.sgroup, UPG.AXIS.HALFTRACK_FLAMETHROWER)
	end
	
	if g_CURRENT_SPAWN == 1 then
		Cmd_SquadPath(this.sgroup, this.path, true, false, false, 0, this.end_mkr)
	elseif SGroup_IsEmpty(this.sg_to_follow.sgroup) == false then
		Cmd_Move(this.sgroup, this.sg_to_follow.last_pos)
	else
		Cmd_SquadPath(this.sgroup, this.path, true, false, false, 0, this.end_mkr)
	end
	
	g_CURRENT_SPAWN = g_CURRENT_SPAWN + 1
	Timer_Start(t_gt_mgr.tmr_sp, t_gt_mgr.tmr_sp_length)
	
	if g_CURRENT_SPAWN > table.getn(t_gt_convoy_mgr) then
		Rule_RemoveMe()
	end
end

function OBJ_GT_MoveConvoy()
	for i=1, table.getn(t_gt_convoy_mgr) do
		this = t_gt_convoy_mgr[i]
		if SGroup_IsEmpty(this.sgroup) == false then
			if SGroup_IsMoving(this.sgroup, ANY) == false 
			or (this.sg_to_follow ~= nil and SGroup_IsEmpty(this.sg_to_follow.sgroup)) then
				
				if this.sg_to_follow ~= nil 
				and SGroup_IsEmpty(this.sg_to_follow.sgroup) == false
				and SGroup_IsMoving(this.sg_to_follow.sgroup, ANY) then
					Cmd_Move(this.sgroup, this.sg_to_follow.last_pos)
				else
					Cmd_SquadPath(this.sgroup, this.path, true, false, false, 0, this.end_mkr)
				end
				
			end
		end
	end
end

function OBJ_GT_CheckGoliathSpawn()
	for i=1, table.getn(t_gt_convoy_mgr) do
		this = t_gt_convoy_mgr[i]
		if SGroup_IsEmpty(this.sgroup) == false then
			this.last_pos = Util_GetPosition_EVEN_IF_EMPTY(this.sgroup)
		elseif this.state == 0 then
			-- set state to indicate that the player destroyed this squad state
			this.state = 1
			
			-- spawn the goliath if available
			if this.sg_goliath ~= false then
				Util_CreateSquadsAtMarker(player3, this.sg_goliath, SBP.AXIS.GOLIATH, this.last_pos, 1)
				FOW_RevealSGroupOnly(this.sg_goliath, -1)
				
				table.insert(t_gol_to_recover, {
					sgroup = this.sg_goliath,
					hint_id = HintPoint_Add(this.sg_goliath, true, 289064),
					timer	= "GOLIATH CONVERT TIMER"..i,
				})
				
				Timer_Start("GOLIATH CONVERT TIMER"..i, 60)
				Timer_Start(t_gt_mgr.tmr_recover, t_gt_mgr.tmr_re_length)
				
				if Rule_Exists(OBJ_GT_GoliathRecovery) == false then
					Rule_AddInterval(OBJ_GT_GoliathRecovery, 1.5)
				end
				
				EventCue_Create(CUE.NORMAL, 289239, 289239, this.last_pos)
			end
		end
	end
end

function OBJ_GT_ExitMap()
	for i=1, table.getn(t_gt_convoy_mgr) do
		this = t_gt_convoy_mgr[i]
		
		if SGroup_IsEmpty(this.sgroup) == false then
			if t_gt_mgr.cue_leaving == false then
				Player_GetAllSquadsNearMarker(player2, sg_temp, this.mkr_end, 60)
				if SGroup_IsEmpty(sg_temp) == false  then
					t_gt_mgr.cue_leaving = true
				end
			end
			
			Player_GetAllSquadsNearMarker(player2, sg_temp, this.mkr_end, 10)
			
			if this.state == 0 
			and SGroup_IsEmpty(sg_temp) == false then
				SGroup_DestroyAllSquads(this.sgroup)
				
				-- set to the fact that this squad exited the map state
				this.state = 2
			end
		end
	end
end

function OBJ_GT_CheckFailureOrCompletion()
	local failed = false
	for i=1, table.getn(t_gt_convoy_mgr) do
		this = t_gt_convoy_mgr[i]
		
		if SGroup_IsEmpty(this.sgroup) == false then
			return
		elseif this.state == 2 then
			failed = true
		end
	end
	
	Rule_Remove(OBJ_GT_MoveConvoy)
	Rule_Remove(OBJ_GT_CheckGoliathSpawn)
	Rule_Remove(OBJ_GT_ExitMap)
	Rule_RemoveMe()
end

function OBJ_GT_GoliathRecovery()
	for i=table.getn(t_gol_to_recover), 1, -1 do
		local sgroup = t_gol_to_recover[i].sgroup
		
		if SGroup_IsEmpty(sgroup) then
			table.remove(t_gol_to_recover, i)
			break
		end
		
		if Misc_IsSGroupSelected(sgroup, ANY) or Timer_GetRemaining(t_gol_to_recover[i].timer) <= 0 then
			SGroup_SetPlayerOwner(sgroup, player1)
			HintPoint_Remove(t_gol_to_recover[i].hint_id)
			table.remove(t_gol_to_recover, i)
			
		elseif Timer_GetRemaining(t_gt_mgr.tmr_recover) <= 0 then
			UI_CreateMinimapBlip(sgroup, 0, BT_GeneralPing)
			EventCue_Create(CUE.NORMAL, 289240, 289240, sgroup)
			
			Timer_Start(t_gt_mgr.tmr_recover, t_gt_mgr.tmr_re_length)
		end
	end
	
	if table.getn(t_gol_to_recover) == 0 then
		Rule_RemoveMe()
	end
end


-----------------------------------------------------------
-- UTIL FUNCTIONS
-----------------------------------------------------------

-- performs the Instant Upgrade but uses a randomly selected weapon, but there is chance 
-- that no upgrade will be performed
function Util_GrantRandomUpgrade(sgroup)
	local upgrades = {UPG.AXIS.GREN_MG42, UPG.AXIS.GREN_PANZERSCHRECK, 0}
	local rand = World_GetRand(1, table.getn(upgrades))
	if upgrades[rand] ~=0 then
		Cmd_InstantUpgrade(sgroup, upgrades[rand])
	end
end

function M08_CheckPlayerFail()
	if Player_HasLost(player1, CRITICAL_BUILDINGS.ALLIES) then
		Game_EndSP(false, nil, true)
	end
end

-- checks to see if the player own 50% of all the resource points
-- that the AI originally held (doesn't include the ones that are automatically given to him) 
-- if he hold more than 50% then
function M08_CheckPlayerRPControl()
	if g_AI_AGGRESSIVE == true then
		Rule_RemoveMe()
		return
	end
	
	local threshold = g_RP_THRESHOLD * table.getn(eg_rp)
	local count = 0
	
	for i=1, table.getn(eg_rp) do
		if Player_OwnsEGroup(player1, eg_rp[i], ANY) then
			count = count + 1
		end
	end
	
	-- if the player owns more than or equal to 50% of all the resource points
	-- then make the AI aggressive
	if count >= threshold then
		M08_AIChangeAggression()
		Rule_RemoveMe()
	end
end

function M08_Autosave()
	if Event_IsAnyRunning() == false then
		Scar_Autosave(g_AUTOSAVE)
		Rule_RemoveMe()
	end
end
