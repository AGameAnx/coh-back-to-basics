
-------------------------------------------------------------------------
-------------------------------------------------------------------------
--
-- Script File for Mission 01 Test
--
-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")

-------------------------------------------------------------------------
-- GLOBAL VARIABLES
-------------------------------------------------------------------------

EVENTS={}

-------------------------------------------------------------------------
-- STARTUP SCRIPTS
-------------------------------------------------------------------------

-- Called immediately on startup, this just sets out some parameters for the mission
function OnGameSetup()
	-- set up the players
	player1 = Setup_Player(1, 219240,TRACE_ALLIES,1)
	player2 = Setup_Player(2, 219241,TRACE_AXIS,2)
	player3 = Setup_Player(3, 219242, TRACE_ALLIES, 1)
	player4 = Setup_Player(4, 219242, TRACE_ALLIES, 1)

	-- set up some global mission variables
	Allied_total_count	= 0
	Allied_current_count	= 0
	Allied_destroyed_count	= 0
	Axis_total_count	= 0
	Axis_current_count	= 0
	Axis_destroyed_count	= 0
	
	print ("-------------------------------------------------------------------------------------------------")
	print ("------------------------------------- MISSION 1 STARTED	-----------------------------------------")
	print ("-------------------------------------------------------------------------------------------------")
end


-- Called immediately on starting up a saved game
function OnGameRestore()
	-- assign player IDs again
	-- assign player IDs again
	player1 = World_GetPlayerAt(1)
	player2 = World_GetPlayerAt(2)
	player3 = World_GetPlayerAt(3)
	player4 = World_GetPlayerAt(4)
	
	-- function takes care of restoring all global mission parameters after a save/load
	Game_DefaultGameRestore()
	
	-- disables the intel officer sounds
	M01_DisableIntelOfficer()
	
	-- resets the variables to play the ambient Speech_SetGlobalStealthRead
	M01_AmbientSpeechSetup()
end


-- Called once things have been initialised proper, and is used to trigger off the game script
function OnInit()
	-- Set up sound path
	g_MissionSpeechPath = "Mission01"
	Sound_PreCacheSinglePlayerSpeech("mission01")
	
	g_AIControl_Enable = false
	g_AIControl_Pause = true
	
	-- mute the sound before the NIS plays
	Util_MuteAmbientSound(true)
	
	--[[ DEBUGGING CODE ]]
	g_DEBUG_MODE = false		-- set to true if you want debugging to occur for this map (shortens opening NIS)
	
--~ 	if g_DEBUG_MODE == true then
		Scar_DebugConsoleExecute("bind([[ALT+A]], [[Scar_DoString('Rule_DropArtilleryBarrage()')]])")
--~ 	end
	
	Scar_DebugConsoleExecute("bind([[ALT+1]], [[Scar_DoString('ReplayBeginningNIS01()')]])")
	Scar_DebugConsoleExecute("bind([[ALT+2]], [[Scar_DoString('WarpTo_AtTheShingle()')]])")
	Scar_DebugConsoleExecute("bind([[ALT+3]], [[Scar_DoString('WarpTo_BunkerTaken()')]])")
	Scar_DebugConsoleExecute("bind([[ALT+4]], [[Scar_DoString('WarpTo_End()')]])")

	--[[ MISSION OPEN ]]
	Game_FadeToBlack(FADE_OUT, 0)
	
	g_NORMAL_ASPECT_RATIO = Game_GetCinematicAspectRatio()
	g_NIS01_ASPECT_RATIO = 1.88
	
	Game_SetCinematicAspectRatio(g_NIS01_ASPECT_RATIO)
	Game_Letterbox(true, 0)
	
	-- need to initialize this table before the objectives
	eg_bunker_spawn = EGroup_GetWBTable("eg_bunker_spawn%d")
	
	--[[ CAMERA ]]
	-- clamping camera to specific area of the map to help with optimization
	Camera_ClampToMarker(mkr_camera_clamp)
	
	-- custom blueprints
	SBP_FLAK_88_SP_DDAY 			= BP_GetSquadBlueprint("sbps/races/axis/vehicles/88_flak_squad_sp_m01.lua")
	SBP_ALLIED_RIFLEMEN_M01			= BP_GetSquadBlueprint("sbps/races/allies/soldiers/rifleman_squad_sp_m01.lua")
	SBP_ALLIED_ENGINEER_M01			= BP_GetSquadBlueprint("sbps/races/allies/soldiers/engineer_infantry_sp_m01.lua")
	EBP_ALLIED_MEDIC				= BP_GetEntityBlueprint("ebps/races/allies/soldiers/medic.lua")
	ABILITY_SP_ANIMTEST				= BP_GetAbilityBlueprint("abilities/sp/sp_anim_movefaster")
	ABILITY_SP_MEDIC_KITACTIVE		= BP_GetAbilityBlueprint("abilities/sp/sp_anim_medic_kit_active.lua")
	ABILITY_SP_MEDIC_GIVEMORPHINE	= BP_GetAbilityBlueprint("abilities/sp/sp_anim_medic_kit_givemorphine.lua")
	ABILITY_SP_MORTARSTRIKE_M01		= BP_GetAbilityBlueprint("abilities/sp/sp_gen_single_mortar_strike_m01.lua")
	ABILITY_SP_ARTILLERY_M01_SINGLE	= BP_GetAbilityBlueprint("abilities/sp/sp_gen_single_instant_artillery_strike_m01.lua")
	
	-----------------------------------
	-- DIFFICULTY
	-----------------------------------
	M01_SetupDifficulty()
	
	-----------------------------------
	-- REGISTER OBJECTIVES 
	-----------------------------------
	Initialize_OBJECTIVE_MoveToShingle()
	Initialize_OBJECTIVE_RescueEngineers()
	Initialize_OBJECTIVE_DestroyBunker()
	Initialize_OBJECTIVE_Destroy88s()
	Initialize_OBJECTIVE_MilitaryBunkers()
	Initialize_OBJECTIVE_DogRed()

	--[[ TECH TREE ]]
	TechTreeSetup()
	
	UI_EnableEventCueType( GE_PlayerBeingAttacked, false )
	UI_EnableEventCueType( GE_SquadPinned, false)
	
	Camera_ResetToDefault()

	-- allow allied player squads to be selected with your own squads
	UI_SetAlliedBandBoxSelection( true )
	
	-- reveal Fog of War
	if g_DEBUG_MODE == true then
		FOW_Enable(true)
	end
	FOW_RevealMarker(Marker_FOWReveal, -1)				-- Reveal FOW on beach and cliffs but not beyond
	
	-- turn selection circles on by default
--~ 	UI_ShowUnselectedCircles(true)
	
	-- Player Upgrades
	Cmd_InstantUpgrade(player1, UPG.ALLIES.ASSAULT_ENGINEERS)

	-------------------------------	
	--[[ NIS VARIABLES ]]
	-------------------------------
	N01_01_LandingTransition = "sp/M01_D-Day/NIS/N01_01"
	N01_02_AtTheShingle = "sp/M01_D-Day/NIS/N01_02"
	N01_03_BunkerTaken = "sp/M01_D-Day/NIS/N01_03"
	N01_04 = "sp/M01_D-Day/NIS/NISLETS/NIS_01_04" -- not used
	N01_Higgins_01 = "sp/M01_D-Day/NIS/NISLETS/Higgins_04"
	N01_Higgins_03 = "sp/M01_D-Day/NIS/NISLETS/Higgins_03"
	N01_Higgins_02 = "sp/M01_D-Day/NIS/NISLETS/Higgins_02"
	N01_Higgins_04 = "sp/M01_D-Day/NIS/NISLETS/Higgins_01"
	nis_load(N01_01_LandingTransition)
	nis_load(N01_02_AtTheShingle)
	nis_load(N01_03_BunkerTaken)
	nis_load(N01_Higgins_01)
	nis_load(N01_Higgins_02)
	nis_load(N01_Higgins_03)
	nis_load(N01_Higgins_04)
--~ 	nis_load(N01_04)

	
	-- for the higgins NISes
	t_Higgins_NIS = {N01_Higgins_01, N01_Higgins_02, N01_Higgins_03, N01_Higgins_04}
	g_HIGGINS_NIS_COUNT = 1
	
	-------------------------------
	--[[ GLOBAL VARIABLES ]] 
	-------------------------------
	Allied_total_count = Player_GetEntityCount(player1)
	Axis_total_count = Player_GetEntityCount(player2)
	g_num88sKilled = 0
	g_numRiflemenAtShingle = 0
	g_numEngineersAtShingle = 0
	g_numSquadsAtShingle = 0
	g_useLBX = 0
	g_useLBX_ONCE = 1
	flag_mortarsAttackingPlayer = 0
	counter_NumRetreatersFromBunker = 0
	numRespawns_Player = 0
	numNPCMovers = 0
	numNPCsCurrentlyMoving = 0
	numNPCsDeadOrAtShingle = 0
	numNPCsKilled = 0
	numNPCsRespawned = 0
	countNPCMovers = 0
	g_PlayerIn88Area = 0
	g_numSpeechEventsPlayed = 0
	g_allObjectivesComplete = 0
	g_AtShingleEventHasFinished = 0
	g_BunkerTakenNIS_Finished = 0
	g_UseTrenchesEventHasPlayed = 0
	g_PlayFlankMGEvent = 0
	numSquadsUnderAttack = 0
	g_checkingForSatchel = 0
	g_sniperRescued = 0
	g_MGTrackRate = 0.006			-- how many metres per tick the MG fire creeps forward towards the squad
	g_MGTrackRateINCREASE = 0.001	-- how much the track rate is increased after the first squad makes it to the shingle
	g_MGCoverRatio = 0.4			-- what % of the squad has to be in cover before the MG will stop firing
	g_MGLeadDistance = 3			-- how far the squad has to move before the MG starts firing
	g_MGAttackProximity = 1.9		-- how close the MG fire has to be to the squad before it starts attacking it for real
	g_startNPCMortars = 0
	Timer_NPCMortars = 43743783
	g_openingNISFinished = 0
	g_OBJ_RE_STARTED	= false		-- checks if OBJ_RescueEngineers is in progress
	g_REINFORCE_MAX		= 2			-- number of reinforcements available to the player after shingle
	g_REINFORCE_ACTIVE  = false
	g_NIS02_TRANS_TIME = 0
	g_NIS03_TRANS_TIME = 0
	g_SELECT_ANY_SQUAD = true
	g_CURRENT_SQUAD_COUNT = 0
	g_88_UATTACK_TIMER = "g_88_UATTACK_TIMER"
	g_SHOW_ARROW_TIME	= 6
	g_AUTOSAVE_DELAY = 10			-- delay for the autosave, to let all objectives and other things complete
	
	--[[ MARKER TABLES ]]
	mkr_shingle_ui = Marker_GetTable("mkr_shingle_ui%d")
	mkr_bunker_reinforcement = Marker_GetTable("mkr_bunker_reinforcement%d")

	-- timers
	Timer_NPC_StartMoving = 1
	Timer_NPC_StopMoving = 2
	Timer_NPCWaveTimer = 3
	Timer_PlayerResources = 199
	Timer_BlowWire = 198
	timer_AxisMoveIntoPosition = 98376376
	
	-- set up SGroups
	Player_SetPopCapOverride(player3, 1000)		-- set pop cap super high for NPC player
	Player_SetPopCapOverride(player1, 50)
	
	-- set up Entity Groups
	EGroup_SetInvulnerable(Axis_Bunker, true, -1)														-- set bunker to invulnerable (destruction is faked in the NIS)
	
--	EGroup_SetInvulnerable(Player_AidStation, true)													-- make Aid station invulnerable
--	EGroup_SetSelectable(Player_AidStation, false)
	
	EGroup_Kill(BarbedWire_CraterDestroy)																	-- destroy barbed wire near crater so player can get to crater
	
	EGroup_Hide(eg_shingle_highlight, true)
	EGroup_SetInvulnerable(eg_shingle_highlight, true)
	EGroup_Hide(eg_hires_ground, true)
	
	-- temp egroup for misc use
	eg_temp = EGroup_CreateIfNotFound("eg_temp")
	
	-- set up Markers
	table_ShingleMarkers = {Marker_Shingle_01, Marker_Shingle_02, Marker_Shingle_03, Marker_Shingle_04, Marker_Shingle_05, Marker_Shingle_06, Marker_Shingle_07, Marker_Shingle_08, Marker_Shingle_09, Marker_Shingle_10, Marker_Shingle_11, Marker_Shingle_12, Marker_Shingle_13, Marker_Shingle_14}
	table_ShingleMarkers_Rect = {Marker_Shingle_Rect_01, Marker_Shingle_Rect_02, Marker_Shingle_Rect_03}
	table_MGFireMarkers = {Marker_MGFire_01, Marker_MGFire_02, Marker_MGFire_03, Marker_MGFire_04}
	table_WaveSpawnMarkers = {Marker_WaveSpawn_01, Marker_WaveSpawn_02, Marker_WaveSpawn_03, Marker_WaveSpawn_04, Marker_WaveSpawn_05, Marker_WaveSpawn_06}
	table_FlameMarkers = {Marker_Flamethrower_01, Marker_Flamethrower_02, Marker_Flamethrower_03, Marker_Flamethrower_04, Marker_Flamethrower_05, Marker_Flamethrower_06, Marker_Flamethrower_07}
	table_CraterSpeechTriggers = {Marker_CraterSpeechTrigger_01, Marker_CraterSpeechTrigger_02}
	table_AxisSpawnMarkers = {Axis_AmbientSpawn_01, Axis_AmbientSpawn_03, Axis_AmbientSpawn_04, Axis_AmbientSpawn_05, Axis_AmbientSpawn_06, Axis_AmbientSpawn_07, Axis_AmbientSpawn_08, Axis_AmbientSpawn_09}
	table_ShingleEngineers = Marker_GetTable("mkr_shingle_eng%d")

	-- set up Squads
	table_NPCFlamethrowers = {}
	table_NPCFlamethrowers[1] = {sgroup = NPC_Flamethrower_01, spawned = 1, underAttack = 0, jigODeath = 0, chanceToDie = 80, timer_underAttack = 89363, timer_JigODeath = 8363}
	table_NPCFlamethrowers[3] = {sgroup = NPC_Flamethrower_03, spawned = 1, underAttack = 0, jigODeath = 0, chanceToDie = 10, timer_underAttack = 4456, timer_JigODeath = 56431}
	table_NPCFlamethrowers[2] = {sgroup = NPC_Flamethrower_02, spawned = 1, underAttack = 0, jigODeath = 0, chanceToDie = 10, timer_underAttack = 654761, timer_JigODeath = 8455}
	
	for i = 1, table.getn(table_NPCFlamethrowers) do
		Cmd_InstantUpgrade(table_NPCFlamethrowers[i].sgroup, UPG.ALLIES.FLAMETHROWER_SP_M01)													-- upgrade all flamethrower crews with flamethrowers
--		SGroup_SetInvulnerable(table_NPCFlamethrowers[i].sgroup, true, -1)																										-- set flamethrowers to invulnerable so we can kill them when we want
		SGroup_EnableUIDecorator( table_NPCFlamethrowers[i].sgroup, false )																									-- turn off decorators on NPCs
		SGroup_EnableMinimapIndicator(table_NPCFlamethrowers[i].sgroup, false)
		SGroup_SetSelectable(table_NPCFlamethrowers[i].sgroup, false)																												-- make all NPCs un-selectable so player can find their own troops more easily
	end
	
	NPC_Higgins_01 = SGroup_CreateIfNotFound("NPC_Higgins_01")
	NPC_Higgins_02 = SGroup_CreateIfNotFound("NPC_Higgins_02")
	NPC_OnScreen = SGroup_CreateIfNotFound("NPC_OnScreen")											-- create a temp sgroup for onscreen squads
	NPC_OnScreen_CurrentTarget = SGroup_CreateIfNotFound("NPC_OnScreen_CurrentTarget")				-- create new sgroup for just the target to shoot at
	NPC_NearPlayer = SGroup_CreateIfNotFound("NPC_NearPlayer")										-- create new sgroup for all the NPCs near the player (we don't want to shoot at them because it's confusing)
	NPC_tempOnScreen = SGroup_CreateIfNotFound("NPC_tempOnScreen")
	sg_beach_squads = SGroup_CreateIfNotFound("sg_beach_squads")
	sg_at_shingle = SGroup_CreateIfNotFound("sg_at_shingle")
	
	t_HigginsNPCs = {NPC_Higgins_01, NPC_Higgins_02}
	NIS_HigginsBoat = EGroup_CreateIfNotFound("NIS_HigginsBoat")

	M01_SetupAxisMGs()
	
	Player_NIS_Riflemen_01 = SGroup_CreateIfNotFound("Player_NIS_Riflemen_01")
	Player_NIS_Engineers_01 = SGroup_CreateIfNotFound("Player_NIS_Engineers_01")

	Player_MoveIntoPos_Temp = SGroup_CreateIfNotFound("Player_MoveIntoPos_Temp")

	SGroup_SetInvulnerable(Axis_MGNest_DogRed, true, -1)												-- set MG nest to invulnerable until wire is blown
	SGroup_SetInvulnerable(Axis_MGNest_DogWhite, true, -1)											-- set MG nest to invulnerable until wire is blown
	SGroup_SetInvulnerable(Axis_MG42_Flee, true, -1)											-- set MG nest to invulnerable until wire is blown

	
	-- team weapons are not captureable
	SGroup_SetTeamWeaponCapturable(Axis_88Crew_01, false)
	SGroup_SetTeamWeaponCapturable(Axis_88Crew_02, false)
	SGroup_SetTeamWeaponCapturable(Axis_88Crew_03, false)

	-- set all Axis troops to tense
	Axis_ALL = SGroup_CreateIfNotFound("Axis_ALL")																		-- Create an sgroup for all Axis troops
	Player_GetAll(player2, Axis_ALL)																									-- put all Axis troops in it
	SGroup_SetMoodMode(Axis_ALL, MM_ForceTense)
	Player_SetDefaultSquadMoodMode( player1, MM_ForceTense)
	Player_SetDefaultSquadMoodMode( player2, MM_ForceTense)
	Player_SetDefaultSquadMoodMode( player3, MM_ForceTense)
	Player_SetDefaultSquadMoodMode( player4, MM_ForceTense)
	
	-- disable veterancy on enemies
	Modify_PlayerExperienceReceived(player2, 0)
	Modify_TargetPriority(Axis_BunkerMG42_Extra_02, -100)
	Modify_TargetPriority(Axis_BunkerMG42_03, -100)

	table_WeakerEnemies = {Axis_BunkerGuards_01, Axis_BunkerGuards_02, Axis_TrenchDefenders_03, Axis_TrenchDefenders_04, Axis_TrenchDefenders_06, Axis_TrenchDefenders_08, Axis_TrenchDefenders_09, Axis_TrenchDefenders_10, Axis_MG42_Flee, Axis_FallIntoTrench_01}
	for i = 1, table.getn(table_WeakerEnemies) do
		Modify_Vulnerability(table_WeakerEnemies[i], 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
		Modify_WeaponRange(table_WeakerEnemies[i], "hardpoint_01", 0.7)						-- reduce gun range on all the axis troops on clifftops/trenches
		Modify_WeaponAccuracy(table_WeakerEnemies[i], "hardpoint_01", 0.7)
	end

	table_SuperWeakEnemies = {Axis_CliffDefenders_01, Axis_CliffDefenders_01_Top, Axis_CliffDefenders_02, Axis_TrenchDefenders_15}
	for i = 1, table.getn(table_SuperWeakEnemies) do
		Modify_Vulnerability(table_SuperWeakEnemies[i], 4.0)									-- Make these enemies a lot weaker because they're in heavy cover
		Modify_WeaponRange(table_SuperWeakEnemies[i], "hardpoint_01", 0.7)						-- reduce gun range on all the axis troops on clifftops/trenches
		Modify_WeaponAccuracy(table_SuperWeakEnemies[i], "hardpoint_01", 0.7)
	end
	
	table_PinnedAndVulnerable = {Axis_BunkerGuards_01, Axis_CliffDefenders_01, Axis_CliffDefenders_02, Axis_CliffDefenders_01_Top, Axis_TrenchDefenders_03, Axis_TrenchDefenders_04, Axis_TrenchDefenders_06, Axis_TrenchDefenders_08, Axis_TrenchDefenders_09, Axis_TrenchDefenders_10, Axis_88Crew_Clifftop}
	Rule_AddInterval(Rule_CheckPinnedSquads, 1.4)
	
	-- reduce gun range on all axis troops on clifftops / trenches, to compress gameplay in that area
	for i = 1, table.getn(table_PinnedAndVulnerable) do
		Modify_WeaponAccuracy(table_SuperWeakEnemies[i], "hardpoint_01", 0.6)
	end

	SGroup_SetAvgHealth(Axis_88Crew_03, 0.2)
	-- Kill dead squads
	table_SquadsToKill = {NPC_Dead_ALL}
	for i = 1, table.getn(table_SquadsToKill) do														-- Kill all squads that should be dead
		SGroup_Kill( table_SquadsToKill[i] )
	end
	
	table_NPC_ALL = {}
	table_NPC_Movers = {}
	table_NPC_Cowering = {}

	shinglePos = Marker_GetPosition(Marker_Shingle_14)

	for i = 1, SGroup_Count(NPC_ALL) do
		groupid = SGroup_CreateIfNotFound("NPC_"..i)																								-- create separate sgroup for each squad in the master list of all NPC's
		SGroup_Clear(groupid)
--		Modify_Vulnerability(groupid, World_GetRand(2, 3))																						-- Make NPCs a lot weaker so the player sees more death and destruction
		squadid = SGroup_GetSpawnedSquadAt(NPC_ALL, i)
		SGroup_Add(groupid, squadid)																	-- add squad from master list of NPCs to target group
		Modify_WeaponCooldown(groupid, "hardpoint_01", 15)																					-- Make NPCs take longer to shoot so they don't make so much noise at the shingle
		Modify_WeaponAccuracy(groupid, "hardpoint_01", 0.0)																					-- NPCs can't hit fish in a barrel
		Cmd_Ability(groupid, ABILITY_SP_ANIMTEST, nil, nil, true)																						-- make NPCs move faster
		if World_GetRand(1, 100) > 50 then																											-- if more than half of NPC squad is in cover
			SGroup_SuggestPosture(groupid, 1, -1)																										-- tell them to be crouching
		else
			SGroup_SuggestPosture(groupid, 0, -1)																										-- otherwise, tell them to be prone
		end
		local groupPos = SGroup_GetPosition_EVEN_IF_EMPTY(groupid)
		
		if g_SELECT_ANY_SQUAD == false then
			SGroup_SetSelectable(groupid, false)																												-- make all NPCs un-selectable so player can find their own troops more easily
		end
		SGroup_SetMoveType(groupid, MOVETYPE.BEACH)																						-- set squad to special move type by default
		testMoveDistance = math.abs(groupPos.z - shinglePos.z) -- set up initial distance to test against when deciding which shingle marker to move to
		SGroup_EnableUIDecorator( groupid, false )																									-- turn off decorators on NPCs
		SGroup_EnableMinimapIndicator(groupid, false)
	
		local t_temp = {
			sgroup = groupid, 
			count = SGroup_TotalMembersCount(groupid), 
			startpos = SGroup_GetPosition_EVEN_IF_EMPTY(groupid), 
			flag_AtShingle = 0, 
			flag_MoveInWaves = 0, 
			flag_respawned = 1, 
			flag_IsMoving = 0, 
			flag_DeadOrAtShingle = 0, 
			moveDistance = testMoveDistance, 
			shinglepos = Marker_GetPosition(Marker_Shingle_14), 
			blueprint = Squad_GetBlueprint(squadid)
		}
		table.insert (table_NPC_ALL, t_temp)                                            
		
		-- figure out which squads are already at the shingle and don't need to be part of the movement waves
		for j = 1, table.getn(table_ShingleMarkers_Rect) do
			if Prox_AreSquadMembersNearMarker(groupid, table_ShingleMarkers_Rect[j], ANY) then
				table_NPC_ALL[i].flag_AtShingle = 1
				SGroup_SuggestPosture(table_NPC_ALL[i].sgroup, 0, -1)																										-- set squad to prone since it's at the shingle
				SGroup_SetSuppression(table_NPC_ALL[i].sgroup, 0.5)
			end
		end
	end
	
	-- set flags and determine which NPC squads that will be part of the movement waves
	-------------------------------------------
	-- AMBIENT NPC WAVE
	-------------------------------------------
	for i = 1, table.getn(table_NPC_ALL) do
		if ( World_GetRand(1, 100) > 50 or table_NPC_ALL[i].blueprint == SBP.ALLIES.OFFICER) 
		and table_NPC_ALL[i].blueprint ~= SBP_ALLIED_RIFLEMEN_M01
		and table_NPC_ALL[i].flag_MoveInWaves == 0 
		and table_NPC_ALL[i].flag_AtShingle == 0 then																												-- randomly choose a portion of NPCs to move up beach
			if flag_blah93783 ~= 1 then
				flag_blah93783 = 1
				NPC_MoversCounter = 0
				timerIncrement = 0
			end
			NPC_MoversCounter = NPC_MoversCounter + 1
			timerIncrement = timerIncrement + 1
			
			if table_NPC_ALL[i].blueprint == SBP.ALLIES.OFFICER then
				Modify_Vulnerability(table_NPC_ALL[i].sgroup, 0.2)																											-- Make Officers less vulnerable
				SGroup_SetAutoTargetting(table_NPC_ALL[i].sgroup, "hardpoint_01", false)
--				print("ŠŠŠŠŠŠŠŠŠ Setting Officer to invulnerable: "..i)
			end
			table_NPC_ALL[i].flag_MoveInWaves = 1																																-- set flag so they know to be part of the movers
			numNPCMovers = numNPCMovers + 1																																	-- keep track of how many NPC mover squads there are
			countNPCMovers = countNPCMovers + table_NPC_ALL[i].count																								-- keep track of how many individual NPC movers there are
			NPC_Movers = SGroup_CreateIfNotFound("NPC_Movers")																										-- create master group of all NPCs who are moving
			SGroup_AddGroup(NPC_Movers, table_NPC_ALL[i].sgroup)																									-- add current group to master list
			
			
			for j = 1, table.getn(table_ShingleMarkers) do
				-- figure out which is the closes shingle marker to move to for all the mover NPC squads (!)
				local shinglePos = Marker_GetPosition(table_ShingleMarkers[j])
				local moveDistance = math.abs(table_NPC_ALL[i].startpos.z - shinglePos.z)
				-- check the distance from each NPC squad to each shingle marker
				if moveDistance < table_NPC_ALL[i].moveDistance then																																						-- if distance is less than the default (starting distance) defined for each squad
					table_NPC_ALL[i].moveDistance = moveDistance																																								-- store the new distance in the table
					table_NPC_ALL[i].shinglepos = Marker_GetPosition(table_ShingleMarkers[j])																													-- store the new shingle position for each squad
				end
			end
			
			if g_SELECT_ANY_SQUAD == false then
				SGroup_SetSelectable(table_NPC_ALL[i].sgroup, false)																												-- make all NPCs un-selectable so player can find their own troops more easily
			end
			
			table.insert (table_NPC_Movers, {sgroup = table_NPC_ALL[i].sgroup, count = table_NPC_ALL[i].count, startpos = table_NPC_ALL[i].startpos, flag_AtShingle = 0, flag_MoveInWaves = 1, flag_respawned = 1, flag_IsMoving = 0, flag_DeadOrAtShingle = 0, moveDistance = testMoveDistance, shinglepos = table_NPC_ALL[i].shinglepos, blueprint = table_NPC_ALL[i].blueprint, timer_OfficerHeroicCharge = 82636 + timerIncrement, timer_OfficerHeroicCharge_GetMoving = 623637 + timerIncrement, flag_HeroicCharging = 0})
			table_NPC_Movers[NPC_MoversCounter].sgroup = SGroup_CreateIfNotFound("NPC_Movers_"..NPC_MoversCounter)
			SGroup_AddGroup(table_NPC_Movers[NPC_MoversCounter].sgroup, table_NPC_ALL[i].sgroup)
		else
			if flag_blah212 ~= 1 then
				flag_blah212 = 1
				NPC_CoweringCounter = 0
			end
			NPC_CoweringCounter = NPC_CoweringCounter + 1
			NPC_Cowering = SGroup_CreateIfNotFound("NPC_Cowering")																								-- create master group of all NPCs who are cowering (not moving)
			SGroup_AddGroup(NPC_Cowering, table_NPC_ALL[i].sgroup)																									-- add current group to master list
			table.insert (table_NPC_Cowering, {sgroup = nil, count = table_NPC_ALL[i].count, startpos = table_NPC_ALL[i].startpos, flag_AtShingle = 0, flag_MoveInWaves = 0, flag_respawned = 1, flag_IsMoving = 0, flag_DeadOrAtShingle = 0, flag_suppressedAtStart = 0, moveDistance = testMoveDistance, shinglepos = table_NPC_ALL[i].shinglepos, blueprint = table_NPC_ALL[i].blueprint})
			table_NPC_Cowering[NPC_CoweringCounter].sgroup = SGroup_CreateIfNotFound("NPC_Cowering_"..NPC_CoweringCounter)
			SGroup_AddGroup(table_NPC_Cowering[NPC_CoweringCounter].sgroup, table_NPC_ALL[i].sgroup)
			if World_GetRand(1, 100) < 30 then																																		-- set x % of cowering NPCs to suppressed
				SGroup_SuggestPosture(table_NPC_Cowering[NPC_CoweringCounter].sgroup, 0, -1)
				Modify_ReceivedAccuracy(table_NPC_Cowering[NPC_CoweringCounter].sgroup, 0.30)
				table_NPC_Cowering[NPC_CoweringCounter].flag_suppressedAtStart = 1
			end
		end
	end
	
	--------------------------------
	-- SNIPER SET UP
	--------------------------------
	-- Set up NPC Sniper
	SGroup_SetInvulnerable(NPC_Sniper, true)
	HintMouseover_Add(219547, NPC_Sniper, 10, true)
	g_SniperPing = UI_CreateMinimapBlip(NPC_Sniper, -1, BT_GeneralPing)
	SGroup_SetSuppression(NPC_Sniper, 100.0)
	Ceasefire_AddSGroup(NPC_Sniper)
	g_SniperPos = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Sniper)
	
	-- tell 88s not to fire
	Ceasefire_AddSGroup(Axis_88Crew_Clifftop)
	
	-- Kill off 88 that's destroyed with shell
	SGroup_Kill(Axis_88Crew_03)
	
	NPC_CurrentTarget = SGroup_CreateIfNotFound("NPC_CurrentTarget")									-- create temp sgroup for current target
	NPC_OnScreen_StartMoving = SGroup_CreateIfNotFound("NPC_OnScreen_StartMoving")						-- create new sgroup for NPCs that will move forward

	-- make MG nest near 88's have longer gun range and be deadlier
	Modify_WeaponRange(Axis_MGNestNear88s, "hardpoint_01", 0.85)
	Modify_WeaponRange(Axis_MGNestNear88s_02, "hardpoint_01", 0.85)
	

	-- tables for targets for the 88s to shoot at:
	mkr_881_target = Marker_GetTable("mkr_881_target%d")
	mkr_882_target = Marker_GetTable("mkr_882_target%d")
	
	-- crews for the 88s
	
	table_88s = {}
	table_88s[1] = {sgroup = Axis_88Crew_01, sgroup_guns = Axis_88_01, flag = 0, fireInAirMarker = Marker_88_01_FireAt, timer_88FireInAir = 3784894, timer_88FireAtTrenches = 2065731, mkr_trench_targets = mkr_882_target, sync_id = nil, hint_mkr = mkr_88_hint1}
	table_88s[2] = {sgroup = Axis_88Crew_02, sgroup_guns = Axis_88_02, flag = 0, fireInAirMarker = Marker_88_02_FireAt, timer_88FireInAir = 37494, timer_88FireAtTrenches = 2065732, mkr_trench_targets = mkr_881_target, sync_id = nil, hint_mkr = mkr_88_hint2}

	for i = 1, table.getn(table_88s) do
--		FOW_RevealSGroup(table_88s[i].sgroup, -1)																			-- reveal all 88s in FOW so player can see them firing
		if SGroup_IsEmpty(table_88s[i].sgroup) == false then
			table_88s[i].sync_id = SyncWeapon_GetFromSGroup(table_88s[i].sgroup)
		end
		
		FOW_RevealArea(SGroup_GetPosition_EVEN_IF_EMPTY(table_88s[i].sgroup), 10, -1)								-- reveal all 88s in FOW so player can see them firing
		Modify_WeaponAccuracy(table_88s[i].sgroup, "hardpoint_01", 10)
		Modify_WeaponRange(table_88s[i].sgroup, "hardpoint_01", 10)

		-- prevent the 88s from attacking the player on their own
		SGroup_SetAutoTargetting(table_88s[i].sgroup, "hardpoint_01", false)
	end

	table_88SpeechEvents = {}
	table_88SpeechEvents[1] = {flag = 0, numKilled = 1, event = EVENTS.First88Killed}
	table_88SpeechEvents[2] = {flag = 0, numKilled = 2, event = EVENTS.Second88Killed}
	
	table_ReinforcePositions = {}
	
	------------------------------------------------------------------------------------------------------------------------------
	-- STUPID HACK to fix scar error - this should be elsewhere in the script
	------------------------------------------------------------------------------------------------------------------------------

	-- moved out of the oninit function...

	------------------------------------------------------------------------------------------------------------------------------

	sg_temp = SGroup_CreateIfNotFound("sg_temp")
	sg_temp2 = SGroup_CreateIfNotFound("sg_temp2")
	sg_temp3 = SGroup_CreateIfNotFound("sg_temp3")
	sg_kill_squads = SGroup_CreateIfNotFound("sg_kill_squads")
	sg_total_playersquads = SGroup_CreateIfNotFound("sg_total_playersquads")
	sg_too_many_squads = SGroup_CreateIfNotFound("sg_too_many_squads")
	sg_no_player_squads = SGroup_CreateIfNotFound("sg_no_player_squads")
	Player_StartingGroup_01 = SGroup_CreateIfNotFound("Player_StartingGroup_01")
	Player_StartingGroup_02 = SGroup_CreateIfNotFound("Player_StartingGroup_02")
	Player_StartingGroup_03 = SGroup_CreateIfNotFound("Player_StartingGroup_03")
	Player_StartingGroup_04 = SGroup_CreateIfNotFound("Player_StartingGroup_04")
	Player_StartingGroup_05 = SGroup_CreateIfNotFound("Player_StartingGroup_05")
	Player_StartingGroup_06 = SGroup_CreateIfNotFound("Player_StartingGroup_06")
	Player_StartingGroup_07 = SGroup_CreateIfNotFound("Player_StartingGroup_07")

	EGroup_SetInvulnerable(BarbedWire_Destroy, true, -1)
--~ 	EGroup_SetInvulnerable(eg_barbed_wire_dr, true, -1)
	--------------------------------------------------------------------------
	-- TABLES SETUP
	--------------------------------------------------------------------------
	table_SGReinforcements = SGroup_CreateTable("SGReinforcements%d", g_REINFORCE_MAX)
	
	table_PlayerSquads = {}
	table_PlayerSquads[1] = {sgroup = Player_StartingGroup_01, mgAttackerGroup = Axis_BunkerMG42_01, flag_spawned = 0, squadcount = 6, flag_AtShingle = 0, flag_CheckRespawn = 0, flag_MGTrackingPlayer = 0, flag_MGAttackingPlayer = 0, flag_PlayerStoppedInCover = 0, flag_MGStopped = 0, oldTargetPos = SGroup_GetPosition_EVEN_IF_EMPTY(Player_StartingGroup_01), newTargetPos = nil, moveDelta = nil, distanceMultiplier = 0.1, Timer_MG_Delay = 2673, Timer_MG_StopFiring = 8263, flag_mortarTracking = 0, flag_mortarAttacking = 0, mortarTimer = 99, followerTimer = 90, flag_inMGFireMarkers = 0, flag_MGFireMarkersCOUNT = 0, blueprint = SBP_ALLIED_RIFLEMEN_M01, lastcount = 6, modifiers = nil, eventCueRule = PlayEventCue_NewSquadAvailable_Objective, respawnMarker = Marker_SquadRespawn_01, respawnSpeechEvent = EVENTS.SquadDead, respawnSpeechEventFOCUS = EVENTS.SquadDeadFocus, ping = Ping_NewSquad_Respawn_01, flag_invulnerable = 0, itemTable = nil}
	table_PlayerSquads[2] = {sgroup = Player_StartingGroup_02, mgAttackerGroup = Axis_BunkerMG42_01, flag_spawned = 0, squadcount = 6, flag_AtShingle = 0, flag_CheckRespawn = 0, flag_MGTrackingPlayer = 0, flag_MGAttackingPlayer = 0, flag_PlayerStoppedInCover = 0, flag_MGStopped = 0, oldTargetPos = SGroup_GetPosition_EVEN_IF_EMPTY(Player_StartingGroup_02), newTargetPos = nil, moveDelta = nil, distanceMultiplier = 0.1, Timer_MG_Delay = 836734, Timer_MG_StopFiring = 23734, flag_mortarTracking = 0, flag_mortarAttacking = 0, mortarTimer = 98, followerTimer = 89, flag_inMGFireMarkers = 0, flag_MGFireMarkersCOUNT = 0, blueprint = SBP_ALLIED_RIFLEMEN_M01, lastcount = 6, modifiers = nil, eventCueRule = PlayEventCue_NewSquadAvailable_Objective, respawnMarker = Marker_SquadRespawn_02, respawnSpeechEvent = EVENTS.SquadDead, respawnSpeechEventFOCUS = EVENTS.SquadDeadFocus, ping = Ping_NewSquad_Respawn_02, flag_invulnerable = 0, itemTable = nil}
	table_PlayerSquads[3] = {sgroup = Player_StartingGroup_03, mgAttackerGroup = Axis_BunkerMG42_02, flag_spawned = 0, squadcount = 6, flag_AtShingle = 0, flag_CheckRespawn = 0, flag_MGTrackingPlayer = 0, flag_MGAttackingPlayer = 0, flag_PlayerStoppedInCover = 0, flag_MGStopped = 0, oldTargetPos = SGroup_GetPosition_EVEN_IF_EMPTY(Player_StartingGroup_03), newTargetPos = nil, moveDelta = nil, distanceMultiplier = 0.1, Timer_MG_Delay = 936734, Timer_MG_StopFiring = 26842, flag_mortarTracking = 0, flag_mortarAttacking = 0, mortarTimer = 97, followerTimer = 88, flag_inMGFireMarkers = 0, flag_MGFireMarkersCOUNT = 0, blueprint = SBP_ALLIED_RIFLEMEN_M01, lastcount = 6, modifiers = nil, eventCueRule = PlayEventCue_NewSquadAvailable_Objective, respawnMarker = Marker_SquadRespawn_03, respawnSpeechEvent = EVENTS.SquadDead, respawnSpeechEventFOCUS = EVENTS.EngineerSquadDeadFocus, ping = Ping_EngineerSquad, flag_invulnerable = 0, itemTable = nil}
	table_PlayerSquads[4] = {sgroup = Player_StartingGroup_04, mgAttackerGroup = Axis_BunkerMG42_02, flag_spawned = 0, squadcount = 3, flag_AtShingle = 0, flag_CheckRespawn = 0, flag_MGTrackingPlayer = 0, flag_MGAttackingPlayer = 0, flag_PlayerStoppedInCover = 0, flag_MGStopped = 0, oldTargetPos = SGroup_GetPosition_EVEN_IF_EMPTY(Player_StartingGroup_07), newTargetPos = nil, moveDelta = nil, distanceMultiplier = 0.1, Timer_MG_Delay = 83765, Timer_MG_StopFiring = 937374, flag_mortarTracking = 0, flag_mortarAttacking = 0, mortarTimer = 93, followerTimer = 84, flag_inMGFireMarkers = 0, flag_MGFireMarkersCOUNT = 0, blueprint = SBP_ALLIED_ENGINEER_M01, lastcount = 3, modifiers = nil, eventCueRule = PlayEventCue_NewSquadAvailable_Engineer, respawnMarker = Marker_SquadRespawn_01, respawnSpeechEvent = EVENTS.EngineerSquadDead, respawnSpeechEventFOCUS = EVENTS.EngineerSquadDeadFocus, ping = Ping_EngineerSquad, flag_invulnerable = 0, itemTable = nil}
	table_PlayerSquads[5] = {sgroup = Player_StartingGroup_05, mgAttackerGroup = Axis_BunkerMG42_02, flag_spawned = 0, squadcount = 3, flag_AtShingle = 0, flag_CheckRespawn = 0, flag_MGTrackingPlayer = 0, flag_MGAttackingPlayer = 0, flag_PlayerStoppedInCover = 0, flag_MGStopped = 0, oldTargetPos = SGroup_GetPosition_EVEN_IF_EMPTY(Player_StartingGroup_04), newTargetPos = nil, moveDelta = nil, distanceMultiplier = 0.1, Timer_MG_Delay = 8376512, Timer_MG_StopFiring = 93737432, flag_mortarTracking = 0, flag_mortarAttacking = 0, mortarTimer = 94, followerTimer = 85, flag_inMGFireMarkers = 0, flag_MGFireMarkersCOUNT = 0, blueprint = SBP_ALLIED_ENGINEER_M01, lastcount = 3, modifiers = nil, eventCueRule = PlayEventCue_NewSquadAvailable_Engineer, respawnMarker = Marker_SquadRespawn_01, respawnSpeechEvent = EVENTS.EngineerSquadDead, respawnSpeechEventFOCUS = EVENTS.SquadDeadFocus, ping = Ping_NewSquad_Respawn_03, flag_invulnerable = 0, itemTable = nil}
	
	-- highlight the first squad that the player has continuously
	
	table_VulnerabilityModifiers = {0.7, 0.75, 0.8, 0.85, 0.9}
--	table_VulnerabilityModifiers_Easier = {0.25, 0.3, 0.4, 0.5, 0.6}
--	table_VulnerabilityModifiers_MuchEasier = {0.15, 0.2, 0.3, 0.4, 0.5}
	table_VulnerabilityModifiers_Harder = {0.7, 0.75, 0.8, 0.85, 0.9}

	table_AxisSquadsNearBunker = {Axis_CliffDefenders_01, Axis_CliffDefenders_01_Top, Axis_BunkerGuards_01, Axis_MGNest_DogWhite, Axis_FallIntoTrench_01, Axis_BunkerMG42_Extra_02}

	Axis_MapEntryPointPos = EGroup_GetPosition_EVEN_IF_EMPTY(Axis_MapEntryPoint)
	
	-- add hint points to shingle
	mkr_shingle_hint = Marker_GetTable("mkr_shingle_hint%d")
	
	----------------------------
	--[[ SETUP SPAWN BUNKERS ]]
	----------------------------
	-- setup the bunkers from which the trench defenders will respawn
	mkr_ax_trench_spawn = Marker_GetTable("mkr_ax_trench_spawn%d")
	table_SpawnBunkers = {}
	
	for i = 1, table.getn(eg_bunker_spawn) do 
		table_SpawnBunkers[i] = {
			egroup = eg_bunker_spawn[i],		-- bunker from which to spawn
			mkr_pt = mkr_ax_trench_spawn[i],	-- marker which they will go to after spawning
		}
	end
	
	-- tables for destroying barbed wire:
	eg_barbed_wire_destroy = EGroup_GetWBTable("eg_barbed_wire_destroy%d")
	
	-- table of artillery markers
	mkr_artillery = Marker_GetTable("mkr_artillery%d")
	
	table_AxisRetreaters = {}
	table_AxisRetreaters[1] = {sgroup = Axis_MGNestNear88s, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 1, blueprint = SBP.AXIS.HEAVYMG_M01_TRENCH, loadout = 3, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[2] = {sgroup = Axis_CliffDefenders_01, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 10, blueprint = SBP.AXIS.VOLKSGRENADIER, loadout = 2, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[3] = {sgroup = Axis_CliffDefenders_01_Top, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 3.5, blueprint = SBP.AXIS.VOLKSGRENADIER, loadout = 3, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[4] = {sgroup = Axis_CliffDefenders_02, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 10, blueprint = SBP.AXIS.VOLKSGRENADIER, loadout = 3, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[5] = {sgroup = Axis_88Crew_Clifftop, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 20, blueprint = SBP_FLAK_88_SP_DDAY, loadout = 1, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[6] = {sgroup = Axis_TrenchDefenders_01, flag_spawn = 1, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 5, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = Axis_AmbientSpawn_01, bunker_sp = table_SpawnBunkers[3],}
	table_AxisRetreaters[7] = {sgroup = Axis_TrenchDefenders_02, flag_spawn = 1, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 5, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = Axis_AmbientSpawn_04, bunker_sp = table_SpawnBunkers[4],}
	table_AxisRetreaters[8] = {sgroup = Axis_TrenchDefenders_03, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 1, blueprint = SBP.AXIS.GRENADIER, loadout = 4, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[9] = {sgroup = Axis_TrenchDefenders_04, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 5, blueprint = SBP.AXIS.GRENADIER, loadout = 2, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[10] = {sgroup = Axis_TrenchDefenders_05, flag_spawn = 1, retreatPos = Marker_GetPosition(Axis_TrenchDefenders_05_Retreat), flag_hasRetreated = 0, retreatProximity = 20, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = Axis_AmbientSpawn_06, bunker_sp = table_SpawnBunkers[3],}
	table_AxisRetreaters[11] = {sgroup = Axis_TrenchDefenders_06, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 5, blueprint = SBP.AXIS.GRENADIER, loadout = 2, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[12] = {sgroup = Axis_TrenchDefenders_07, flag_spawn = 1, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 5, blueprint = SBP.AXIS.GRENADIER, loadout = 2, spawnMarker = Axis_AmbientSpawn_10, bunker_sp = table_SpawnBunkers[2],}
	table_AxisRetreaters[13] = {sgroup = Axis_BunkerGuards_01, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 13, blueprint = SBP.AXIS.GRENADIER, loadout = 2, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[14] = {sgroup = Axis_TrenchDefenders_08, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 3, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[15] = {sgroup = Axis_TrenchDefenders_09, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 5, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[16] = {sgroup = Axis_TrenchDefenders_10, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 0, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[17] = {sgroup = Axis_TrenchDefenders_11, flag_spawn = 1, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 0, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = Axis_AmbientSpawn_08, bunker_sp = table_SpawnBunkers[5],}
	table_AxisRetreaters[18] = {sgroup = Axis_TrenchDefenders_12, flag_spawn = 1, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 3, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = Axis_AmbientSpawn_04, bunker_sp = table_SpawnBunkers[2],}
	table_AxisRetreaters[19] = {sgroup = Axis_MGNestNear88s_02, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 1, blueprint = SBP.AXIS.HEAVYMG_M01_TRENCH, loadout = 3, spawnMarker = nil, bunker_sp = nil,}
	table_AxisRetreaters[20] = {sgroup = Axis_TrenchDefenders_13, flag_spawn = 1, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 1, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = Axis_AmbientSpawn_08, bunker_sp = table_SpawnBunkers[5],}
	table_AxisRetreaters[21] = {sgroup = Axis_TrenchDefenders_14, flag_spawn = 1, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 1, blueprint = SBP.AXIS.GRENADIER, loadout = 3, spawnMarker = Axis_AmbientSpawn_07, bunker_sp = table_SpawnBunkers[4],}
	table_AxisRetreaters[22] = {sgroup = Axis_TrenchDefenders_15, flag_spawn = 0, retreatPos = Axis_MapEntryPointPos, flag_hasRetreated = 0, retreatProximity = 5, blueprint = SBP.AXIS.HEAVYMG_M01_TRENCH, loadout = 3, spawnMarker = nil, bunker_sp = nil,}

	for i = 1, table.getn(table_AxisRetreaters) do
		SGroup_SuggestPosture(table_AxisRetreaters[i].sgroup, 1, -1)																										-- tell them to be crouching
	end
	
	table_AxisFodderTriggers = {}
	table_AxisFodderTriggers[1] = {flag_Spawn = 0, counter_Spawn = 0, trigger1 = Marker_FodderBunker01_Trigger01, trigger2 = Marker_FodderBunker01_Trigger01, spawnmarker = Marker_FodderBunker01_Spawn01, retreatPos = Axis_MapEntryPointPos}
	table_AxisFodderTriggers[2] = {flag_Spawn = 0, counter_Spawn = 0, trigger1 = Marker_FodderBunker02_Trigger01, trigger2 = Marker_FodderBunker02_Trigger02, spawnmarker = Marker_FodderBunker02_Spawn01, retreatPos = Axis_MapEntryPointPos}

	table_MortarCountdown = {}
	table_MortarCountdown[1] = {flag_HasFired = 0, timer = 3, fudgefactor = 0, message = "~`~`~`~`~`~`player still stationary (table entry 1) - dropping mortar 0 metres from them!"}
	table_MortarCountdown[2] = {flag_HasFired = 0, timer = 7, fudgefactor = 0, message = "~`~`~`~`~`~`player still stationary (table entry 2) - dropping mortar 0 metres from them!"}
	table_MortarCountdown[3] = {flag_HasFired = 0, timer = 11, fudgefactor = 0, message = "~`~`~`~`~`~`player still stationary (table entry 3) - dropping mortar 0 metres from them!"}
	table_MortarCountdown[4] = {flag_HasFired = 0, timer = 15, fudgefactor = 0, message = "~`~`~`~`~`~`player still stationary (table entry 4) - dropping mortar 0 metres from them!"}
	table_MortarCountdown[5] = {flag_HasFired = 0, timer = 20, fudgefactor = 0, message = "~`~`~`~`~`~`player still stationary (table entry 5) - dropping mortar 0 metres from them!"}
	table_MortarCountdown[6] = {flag_HasFired = 0, timer = 26, fudgefactor = -3, message = "~`~`~`~`~`~`player still stationary (table entry 6) - dropping mortar -3 metres from them!"}
	table_MortarCountdown[7] = {flag_HasFired = 0, timer = 31, fudgefactor = -5, message = "~`~`~`~`~`~`player has been stationary for 16 seconds - dropping mortar -5 metres from them!"}
	table_MortarCountdown[8] = {flag_HasFired = 0, timer = 36, fudgefactor = -8, message = "~`~`~`~`~`~`player has been stationary for 14 seconds - dropping mortar -8 metres from them!"}
	table_MortarCountdown[9] = {flag_HasFired = 0, timer = 42, fudgefactor = -11, message = "~`~`~`~`~`~`player has been stationary for 11 seconds - dropping mortar -11 metres from them!"}
	table_MortarCountdown[10] = {flag_HasFired = 0, timer = 47, fudgefactor = -13, message = "~`~`~`~`~`~`player has been stationary for 8 seconds - dropping mortar -13 metres from them!"}
	table_MortarCountdown[11] = {flag_HasFired = 0, timer = 53, fudgefactor = -17, message = "~`~`~`~`~`~`player has been stationary for 5 seconds - dropping mortar -17 metres from them!"}
	table_MortarCountdown[12] = {flag_HasFired = 0, timer = 58, fudgefactor = -20, message = "~`~`~`~`~`~`player has been stationary for less than 2 seconds - dropping mortar -20 metres from them!"}

	table_NPCAttackers_Retreat = {}
	table_NPCAttackers_Retreat[1] = {sgroup = Axis_BunkerMG42_Extra_01, beachExitSGroup = Axis_MGNest_DogRed, flag_hasRetreated = 0, retreatPos = Axis_MapEntryPointPos}
	table_NPCAttackers_Retreat[2] = {sgroup = Axis_BunkerMG42_Extra_02, beachExitSGroup = Axis_MGNest_DogWhite, flag_hasRetreated = 0, retreatPos = Axis_MapEntryPointPos}

	table_MovingNPCs = {}

	NPCFollower1 = SGroup_CreateIfNotFound("NPCFollower1")
	NPCFollower2 = SGroup_CreateIfNotFound("NPCFollower2")
	NPCFollower3 = SGroup_CreateIfNotFound("NPCFollower3")
	NPCFollower4 = SGroup_CreateIfNotFound("NPCFollower4")
	
	table_NPC_Followers = {}
	table_NPC_Followers[1] = {sgroup = NPCFollower1, squad = nil, flag_Following = 0, flag_DiveForCover = 0, followingPlayerGroup = nil, xoffset = 5, zoffset = 0, moveToPos = nil}
	
	table_AxisKeepPressureOn = {}
	table_AxisKeepPressureOn[1] = {sgroup = Axis_KeepPressureOn_01, sgroupSTRING = "Axis_KeepPressureOn_01"}
	table_AxisKeepPressureOn[2] = {sgroup = Axis_KeepPressureOn_02, sgroupSTRING = "Axis_KeepPressureOn_02"}

	table_NPC_Medics = {}
	table_NPC_Medics[1] = {sgroup = NPC_Medic_01, startpos = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Medic_01), flag_KitActive = 0, flag_GiveMorphine = 0, flag_Moving = 0}
	table_NPC_Medics[2] = {sgroup = NPC_Medic_02, startpos = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Medic_02), flag_KitActive = 0, flag_GiveMorphine = 0, flag_Moving = 0}
	table_NPC_Medics[3] = {sgroup = NPC_Medic_03, startpos = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Medic_03), flag_KitActive = 0, flag_GiveMorphine = 0, flag_Moving = 0}
	table_NPC_Medics[4] = {sgroup = NPC_Medic_04, startpos = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Medic_04), flag_KitActive = 0, flag_GiveMorphine = 0, flag_Moving = 0}
	table_NPC_Medics[5] = {sgroup = NPC_Medic_05, startpos = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Medic_05), flag_KitActive = 0, flag_GiveMorphine = 0, flag_Moving = 0}
	
	for i = 1, table.getn(table_NPC_Medics) do
		SGroup_EnableSurprise(table_NPC_Medics[i].sgroup, false)																									-- turn off surprise so medics don't react to mortars
		SGroup_EnableUIDecorator(table_NPC_Medics[i].sgroup, false)
		SGroup_EnableMinimapIndicator(table_NPC_Medics[i].sgroup, false)
		SGroup_SetSelectable(table_NPC_Medics[i].sgroup, false)																												-- make all NPCs un-selectable so player can find their own troops more easily
		Modify_Vulnerability(table_NPC_Medics[i].sgroup, 0.2)
	end
	
	-- set player's resources
	Player_SetResource(player1, RT_Manpower, 0)
	Player_SetResource(player1, RT_Munition, 0)
	Player_SetResource(player1, RT_Fuel, 0)
	Player_SetResource(player1, RT_Action, 0)
	
	Rule_AddInterval(Rule_HintPoint_BeachCover, 1.4)	

	-- start some rules that need to be running before the first NIS ends
	Rule_AddInterval(Rule_Mortars_AttackNPCs_Start, 0.1)
	
	-- Start up the main game logic loop
	Rule_Add(M01_StartNIS01)
	
	M01_DisableIntelOfficer()
	M01_AmbientSpeechSetup()
	
	Player_GetAll(player3, sg_temp)
	SGroup_EnableMinimapIndicator(sg_temp, false)
end

-- function to play event cue (this is a separate function so it can be delayed using Rule_AddOneShot)
function PlayEventCue_NewSquadAvailable_Objective()
	EventCue_Create(CUE.NORMAL, 219460, 219460, Marker_Shingle_11)
end
	
-- function to play event cue (this is a separate function so it can be delayed using Rule_AddOneShot)
function PlayEventCue_NewSquadAvailable_Engineer()
	UI_CreateEventCueClickable( CUE.NORMAL.icon, CUE.NORMAL.sound, 219465, 219465, EventCue_NewSquadAvailable_Engineer, -1, false)		-- trigger an event cue about it
end
-- focus camera on newly spawned squad when the player clicks on the event cue
function EventCue_NewSquadAvailable_Engineer()
--	Camera_FocusOnTargetPos(SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[7].sgroup))
	if g_BunkerTakenNIS_Finished == 1 then
		Camera_FocusOnTargetMarker(Marker_Bunker, 0)
	elseif flag_AtTheShingle == 1 then
		Camera_FocusOnTargetMarker(Marker_Shingle_11, 0)
	end
end


Scar_AddInit(OnInit)


function M01_DisableIntelOfficer()
	-- these are indexes for all the various speech events for the various
	-- INTEL EVENTS (e.g. IE_SectorAttacked)
	for i=44, 60 do
		Sound_DisableSpeechEvent(i)
	end
end


function M01_SetupAxisMGs()
	table_AxisBunkerMGs = {}
	table_AxisBunkerMGs[1] = {sgroup = Axis_BunkerMG42_01, bunker = Axis_Bunker}
	table_AxisBunkerMGs[2] = {sgroup = Axis_BunkerMG42_02, bunker = Axis_Bunker}
	table_AxisBunkerMGs[3] = {sgroup = Axis_BunkerMG42_Extra_01, bunker = nil}
	table_AxisBunkerMGs[4] = {sgroup = Axis_BunkerMG42_Extra_02, bunker = nil}
	
	for i = 1, table.getn(table_AxisBunkerMGs) do
		Cmd_InstantSetupTeamWeapon(table_AxisBunkerMGs[i].sgroup, true)																-- make sure axis MG42's are all set up
		SGroup_SetInvulnerable(table_AxisBunkerMGs[i].sgroup, true, -1)											-- set MG nest to invulnerable until wire is blown
	end
	
	Cmd_InstantGarrison(Axis_BunkerMG42_01, Axis_Bunker)			-- garrison MG42 squad in bunker
	Cmd_InstantGarrison(Axis_BunkerMG42_02, Axis_Bunker)			-- garrison MG42 squad in bunker
	Modify_ReceivedAccuracy(Axis_BunkerMG42_01, 0.0)
	Modify_ReceivedAccuracy(Axis_BunkerMG42_02, 0.0)
	Modify_ReceivedAccuracy(Axis_BunkerMG42_03, 0.0)

	local temp = {
		Axis_MGNest_DogWhite,
		Axis_MGNest_DogRed,
		Axis_MG42_Flee,
		Axis_BunkerMG42_Extra_01,
		Axis_BunkerMG42_Extra_02,
		Axis_BunkerMG42_03,
		Axis_MGNestNear88s,
--~ 		Axis_TrenchDefenders_15,
		Axis_MGNestNear88s_02,
	}

	Cmd_InstantSetupTeamWeapon(Axis_MGNest_DogWhite, true)
	Cmd_InstantSetupTeamWeapon(Axis_MGNest_DogRed, true)
	Cmd_InstantSetupTeamWeapon(Axis_MGNestNear88s, true)
	Cmd_InstantSetupTeamWeapon(Axis_MGNestNear88s_02, true)
	Cmd_InstantSetupTeamWeapon(Axis_BunkerMG42_01, true)																
	Cmd_InstantSetupTeamWeapon(Axis_BunkerMG42_02, true)
	Cmd_InstantSetupTeamWeapon(Axis_TrenchDefenders_15, true)
	Cmd_InstantSetupTeamWeapon(Axis_MG42_Flee, true)
	
	table_MG42_SquadsInBunkers = {}
	table_MG42_SquadsInBunkers[1] = {sgroup = Axis_BunkerMG42_Extra_01, targetSGroup = MG42_SquadsInBunkers_Target1, targetSGroupSTRING = "MG42_SquadsInBunkers_Target1", pos = SGroup_GetPosition_EVEN_IF_EMPTY(Axis_BunkerMG42_Extra_01)}
	table_MG42_SquadsInBunkers[2] = {sgroup = Axis_BunkerMG42_Extra_02, targetSGroup = MG42_SquadsInBunkers_Target2, targetSGroupSTRING = "MG42_SquadsInBunkers_Target2", pos = SGroup_GetPosition_EVEN_IF_EMPTY(Axis_BunkerMG42_Extra_02)}
	table_MG42_SquadsInBunkers[3] = {sgroup = Axis_BunkerMG42_03, targetSGroup = MG42_SquadsInBunkers_Target3, targetSGroupSTRING = "MG42_SquadsInBunkers_Target3", pos = SGroup_GetPosition_EVEN_IF_EMPTY(Axis_BunkerMG42_03)}
	
	-- create the target sgroups and do other setup
	for i = 1, table.getn(table_MG42_SquadsInBunkers) do
		table_MG42_SquadsInBunkers[i].targetSGroup = SGroup_CreateIfNotFound(table_MG42_SquadsInBunkers[i].targetSGroupSTRING)
		Cmd_InstantSetupTeamWeapon(table_MG42_SquadsInBunkers[i].sgroup)
	end
	
	t_axis_mgs = {}
	for i = 1, table.getn(temp) do 
		t_axis_mgs[i] = {
			sgroup 	= temp[i],
			sw_id 	= SyncWeapon_GetFromSGroup(temp[i]),
		}
	
		SGroup_SetTeamWeaponCapturable(temp[i], false)
		Cmd_InstantSetupTeamWeapon(temp[i])
	end
	
	-- set up Tables
	table_MGNests = {}
	table_MGNests[1] = {sgroup1 = Axis_MGNest_DogWhite, sgroup2 = Axis_MG42_Flee, event = EVENTS.DogWhiteOpen, marker = Marker_DogWhite, territoryFlag = Flag_RH_BeachExit}
	
	-- difficulty handle for the MGs firing at the player on the beach
	Modify_WeaponAccuracy(Axis_BunkerMG42_01, "hardpoint_01", 0.8)
	Modify_WeaponAccuracy(Axis_BunkerMG42_02, "hardpoint_01", 0.8)
	
	Modify_WeaponDamage(Axis_BunkerMG42_01, "hardpoint_01", 0.8)
	Modify_WeaponDamage(Axis_BunkerMG42_02, "hardpoint_01", 0.8)
end

function M01_SetupDifficulty()
	-- get the difficulty
	g_dif = Game_GetSPDifficulty()
	
	-- set health bonus for player 1
	Setup_Difficulty(player1, g_dif) -- pass the player and difficulty global variable 
	Setup_Difficulty(player3, g_dif) -- pass the player and difficulty global variable 
	Setup_Difficulty(player4, g_dif) -- pass the player and difficulty global variable

	-- set health handicap for player 2
	Setup_Difficulty(player2, g_dif) -- do it for each player that you have defined
	
	t_difficulty = {
		ax_sp_loadout 		= Util_DifVar( {1, 2, 3, 4} ),			-- number of squads spawned for "Keep Pressure On Groups"
		ax_sp_loadout_inc 	= Util_DifVar( {2, 3, 4, 4} ),			-- number of squads spawned for "Keep Pressure On Groups" increased
		bunkers				= Util_DifVar( {2, 3, 4, 5} ),			-- number of bunkers required to complete bunker objective
	}
end



-------------------------------------------------------------------------
-- MISSION SCRIPTS
-------------------------------------------------------------------------
function M01_StartNIS01()
	Util_StartNIS(EVENTS.Opening)
	Rule_Add(Rule_StartMission)
	Rule_RemoveMe()
end


function Rule_StartMission()
	-- wait until the opening NIS is done...
	if Event_IsAnyRunning() == false then
		-------------------------------------------------------------------------
		-- GENERAL MISSION LOGIC
		-------------------------------------------------------------------------
		Rule_AddOneShot(Rule_AutoReinforce_NPCs, 0.1)
		Rule_AddInterval(Rule_RemoveInvulnerability, 1)
		Rule_AddInterval(Rule_Player_ReSetSuppression, 1.2)											-- start rule to remove suppression on player's squad so they can keep moving all the time
		
		Rule_AddInterval(Rule_NoPlayerSquadsExist, 2.2)
		Rule_AddInterval(Rule_KillNPCsAtShingle, 1.4)
		Rule_AddInterval(Rule_CheckTotalPlayerSquads, 5)
		Rule_AddInterval(Rule_NPC_JoinPlayerSquad, 1.6)
		Rule_AddOneShot(Rule_NPC_GetSuppressed, 0.4)
		Rule_AddInterval(Rule_NPC_PotShots, 3.5)
		Rule_AddInterval(Rule_NPC_Flamethrowers, 15)
		Rule_AddInterval(Rule_NPC_Medics, 0.1)
		Rule_AddInterval(Rule_SniperArtillery, 0.4)
		Rule_AddInterval(Rule_AmbientArtillery, 0.7)
		Rule_AddInterval(Rule_NISHigginsStart, 0.5)

		Rule_AddInterval(Rule_RescueSniper, 1.4)
		Rule_AddInterval(Rule_ShootAtSniper, 0.5)
		
		Rule_AddInterval(Rule_ReSetPlayerResources, 3)

		-------------------------------------------------------------------------
		-- OBJECTIVE FUNCTIONS
		-------------------------------------------------------------------------

		Rule_AddOneShot(OBJ_MTS_AddNewObjDelay, 5)
		Rule_AddInterval(OBJ_MTS_Rule_CheckSelectedSquads, 0.25)
		
		-------------------------------------------------------------------------
		-- SPEECH EVENTS
		-------------------------------------------------------------------------
		Rule_AddInterval(Rule_SpeechEvent_UnderAttack_LosingGuys, 0.8)
		Rule_AddInterval(Rule_SpeechEvent_FirstSelected, 0.1)
		Rule_AddInterval(Rule_PlayAmbientSpeech, 1.5)		
		
		-------------------------------------------------------------------------
		-- TERRITORY
		-------------------------------------------------------------------------

		Rule_RemoveMe()
	end
end

-------------------------------------------------------------------------
-- DEBUG FUNCTIONS FOR PLAYING NISES
-------------------------------------------------------------------------

function ReplayBeginningNIS01()
	Game_SetCinematicAspectRatio(g_NIS01_ASPECT_RATIO)
	AutoCinematic(true, 0)
	Util_StartNIS(EVENTS.Opening)
end

-- starts NIS "At The Shingle"
function WarpTo_AtTheShingle()
	Game_SetCinematicAspectRatio(g_NORMAL_ASPECT_RATIO)
	Rule_Remove(Rule_NISHigginsPlay)
	Rule_Remove(Rule_AddHigginsNPCs)
	Rule_Remove(Rule_NISHigginsStart)
	
--~ 	Rule_Add(HideNPCS, 0.5)
	NPCs_Stop()
	
	EGroup_Hide(eg_shingle_highlight, true)					-- hide shingle effect
	
	Util_StartNIS(EVENTS.AtTheShingle)	-- start NIS: at the shingle
	
	if Rule_Exists(Rule_ClearNPCs_N01_02) == false then
		Rule_AddInterval(Rule_ClearNPCs_N01_02, 0.3)
	end
	
	g_TimerStarted_BlowWire = 0
	g_blowWire = 0
	if Rule_Exists(Rule_Engineers_BlowWire) == false then
		Rule_AddInterval(Rule_Engineers_BlowWire, 0.5)
	end
	
	Rule_Remove(Rule_Mortars_FindPlayer)																										-- Remove rules targeting player with mortars
	Rule_Remove(Rule_Mortars_AttackPlayer)
	Rule_Remove(Rule_Mortars_AttackNPCs)																									-- Remove rules targeting NPCs with mortars
	Rule_Remove(Rule_Mortars_AttackNPCs_Restart)
end


-- starts NIS "Bunker Taken"
function WarpTo_BunkerTaken()
	Game_SetCinematicAspectRatio(g_NORMAL_ASPECT_RATIO)
	Rule_Remove(Rule_NISHigginsPlay)
	Rule_Remove(Rule_AddHigginsNPCs)
	Rule_Remove(Rule_NISHigginsStart)
	
	if Rule_Exists(Rule_MG_TrackPlayerMovt) then
		Rule_Remove(Rule_MG_TrackPlayerMovt)
	end
	
--~ 	Rule_Add(HideNPCS, 0.5)
	NPCs_Stop()
	
	SGroup_Kill(Axis_BunkerMG42_01)
	SGroup_Kill(Axis_BunkerMG42_02)
	SGroup_DestroyAllSquads(Axis_FallIntoTrench_01)
	SGroup_DestroyAllSquads(Axis_CliffDefenders_01_Top)
	SGroup_DestroyAllSquads(Axis_BunkerGuards_01)
	SGroup_DestroyAllSquads(Axis_BunkerMG42_03)
	SGroup_DestroyAllSquads(Axis_BunkerMG42_Extra_02)
	
	if Rule_Exists(Rule_88s_FireInAir) then
		Rule_Remove(Rule_88s_FireInAir)
		for i = 1, table.getn(table_88s) do
			Cmd_Stop(table_88s[i].sgroup)
			Ceasefire_AddSGroup(table_88s[i].sgroup)
		end
	end
	
	if Rule_Exists(Rule_ClearNPCs_N01_03) == false then
		Rule_AddInterval(Rule_ClearNPCs_N01_03, 0.3)
	end
	
	EGroup_Hide(eg_shingle_highlight, true)					-- hide shingle effect
	
	Util_StartNIS(EVENTS.BunkerDestroyed)																		-- play NIS: Bunker Taken
end

function WarpTo_End()
	Game_SetCinematicAspectRatio(g_NORMAL_ASPECT_RATIO)
	Rule_Remove(Rule_NISHigginsPlay)
	Rule_Remove(Rule_AddHigginsNPCs)
	Rule_Remove(Rule_NISHigginsStart)

	if Rule_Exists(Rule_NukePlayerSquads) == false then
		Rule_AddInterval(Rule_NukePlayerSquads, 0.3)																							-- start rule that removes unnecessary player squads
	end

	NPCs_Stop()

	Rule_Remove(Rule_Mortars_FindPlayer)																										-- Remove rules targeting player with mortars
	Rule_Remove(Rule_Mortars_AttackPlayer)
	Rule_Remove(Rule_Mortars_AttackNPCs)																									-- Remove rules targeting NPCs with mortars
	Rule_Remove(Rule_Mortars_AttackNPCs_Restart)
	
	Util_StartIntel(EVENTS.MissionComplete)
end

function Rule_DisableSatchels()
	Modifier_SatchelCharge_Disable = Modifier_Create(MAT_Squad, "modifiers\\ability_enable_modifier.lua", MUT_Enable, true, 0, "abilities/ally_throw_satchel_charge_no_requirements.lua")
	Modifier_ApplyToSquad(Modifier_SatchelCharge_Disable, SGroup_GetSpawnedSquadAt(table_PlayerSquads[4].sgroup, 1))
end

function Rule_EnableSatchels()
	Modifier_SatchelCharge_Enable = Modifier_Create(MAT_Squad, "modifiers\\ability_enable_modifier.lua", MUT_Enable, true, 1, "abilities/ally_throw_satchel_charge_no_requirements.lua")
	Modifier_ApplyToSquad(Modifier_SatchelCharge_Enable, SGroup_GetSpawnedSquadAt(table_PlayerSquads[4].sgroup, 1))
end


--------------------------------------------------------------------------------------------------------------------------------------------------
-- OBJECTIVE TABLES
--------------------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- MOVING SQUADS - BEACH OBJECTIVES
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------------------------------------------------------
-- PRIMARY OBJ: Move To Shingle
function Initialize_OBJECTIVE_MoveToShingle()
	OBJECTIVE_MoveToShingle =
	{
		SetupUI = function()

			-- center of shingle
			OBJECTIVE_MoveToShingle.WorldHighlightID[1] = Objective_AddUIElements(OBJECTIVE_MoveToShingle, Marker_Shingle_08, true, 219127, true)
			-- left of shingle
			OBJECTIVE_MoveToShingle.WorldHighlightID[2] = Objective_AddUIElements(OBJECTIVE_MoveToShingle, mkr_shingle_ui[2], false, 219127, true)
			-- right side of shingle
			OBJECTIVE_MoveToShingle.WorldHighlightID[3] = Objective_AddUIElements(OBJECTIVE_MoveToShingle, mkr_shingle_ui[5], false, 219127, true)
			
			Objective_SetCounter(OBJECTIVE_MoveToShingle, g_numSquadsAtShingle, OBJECTIVE_MoveToShingle.MaxRequired)
			
			EGroup_Hide(eg_shingle_highlight, false)
		end,
		OnStart = function()
			
		end,
	
		OnComplete = function()
			Objective_SetAlwaysShowDetails(OBJECTIVE_MoveToShingle, false, false)
			Rule_Remove(Rule_NoPlayerSquadsExist)
			
--~ 			UI_ShowUnselectedCircles(false)
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		
		Title 				= nil,
		Description 		= 219126,
		Type 				= OT_Primary,
		icon 				= IT_P_Move,
		WorldHighlightID 	= {},
		MaxRequired 		= 25,
		PercentAtShingle	= {0.01, 0.25, 0.5, 0.75},
		SoldiersAtShingle	= {5, 10, 15, 20},
	}
	
	-- *** TODO: Add difficulty handle that will change the max number of soldiers required at the shingle
	if g_DEBUG_MODE == true then
		OBJECTIVE_MoveToShingle.MaxRequired = 3
	end
	
	-- format the localized string to accept a number rather than hard code
	-- the required number of squads that are needed
	local text = Loc_FormatText(219125, Loc_ConvertNumber(OBJECTIVE_MoveToShingle.MaxRequired))
	OBJECTIVE_MoveToShingle.Title = text
	
	Objective_Register(OBJECTIVE_MoveToShingle)
end
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------------------------------------------------------

function OBJ_MTS_Start()
	-- Adding various player events and MG stuff after the objective starts
	Rule_AddInterval(Rule_StartMGFire, 0.2)
	Rule_AddInterval(Rule_Mortars_FindPlayer, 1.6)
	Rule_AddInterval(Rule_Mortars_AttackPlayer, 0.7)
	Rule_AddInterval(Rule_88s_FireInAir, 1.8)
	Rule_Remove(Rule_RespawnPlayerSquads)
end

function OBJ_MTS_PermanentArrow()
	Objective_SetAlwaysShowDetails(OBJECTIVE_MoveToShingle, true, true)
end

function OBJ_MTS_Rule_CheckSelectedSquads()
	SGroup_Clear(sg_temp)
	Misc_GetSelectedSquads(sg_temp, false)
	
	-- if the player owns the squads, then don't bother doing anything to it
	if SGroup_IsEmpty(sg_temp) 
	or Player_OwnsSGroup(player1, sg_temp)
	or SGroup_TotalMembersCount(sg_total_playersquads) >= 50 then
		return
	end
	
	--check to see if the player has selected a medic
	EGroup_Clear(eg_temp)
	Misc_GetSelectedEntities(eg_temp, false)	
	if g_MEDIC_SELECTED == nil and EGroup_IsEmpty(eg_temp) == false then
		local num = Util_GetEntityBlueprintID("ebps/races/allies/soldiers/medic")
		if num == Entity_GetBlueprintID(EGroup_GetSpawnedEntityAt(eg_temp, 1)) then
			Util_StartStinger(EVENTS.MedicSelected)
			g_MEDIC_SELECTED = true
		end
	end
	
	SGroup_Clear(sg_temp2)
	Player_GetAll(player2, sg_temp2)
	
	-- filter various squad groups from the mix
	SGroup_RemoveGroup(sg_temp, sg_temp2)
	SGroup_RemoveGroup(sg_temp, sg_beach_squads)
	SGroup_RemoveGroup(sg_temp, table_PlayerSquads[1].sgroup)
	SGroup_RemoveGroup(sg_temp, table_PlayerSquads[4].sgroup)
	
	-- premptive check to return early
	if SGroup_IsEmpty(sg_temp) then
		return
	end
	
	-- Removing various squads from their previous SGroups to prevent enemy behavior.
	-- brw 07/18/06 - player cannot select squads at the shingle any longer
--~ 	for i = 1, table.getn(table_ShingleMarkers_Rect) do
--~ 		Player_GetAllSquadsNearMarker(player1, sg_temp2, table_ShingleMarkers_Rect[i])
--~ 		SGroup_RemoveGroup(sg_temp, sg_temp2)
--~ 	end
	
	SGroup_RemoveGroup(NPC_ALL, sg_temp)
	SGroup_RemoveGroup(NPC_Movers, sg_temp)
	SGroup_RemoveGroup(NPC_Cowering, sg_temp)
	SGroup_RemoveGroup(NPC_CurrentTarget, sg_temp)
	SGroup_RemoveGroup(NPCFollower1, sg_temp)
	SGroup_RemoveGroup(NPCFollower2, sg_temp)
	SGroup_RemoveGroup(NPCFollower3, sg_temp)
	SGroup_RemoveGroup(NPCFollower4, sg_temp)
	
	if SGroup_IsEmpty(sg_temp) then
		return
	end
	
	if g_NO_PLAYER_SQUADS_HP ~= nil then
		SGroup_Clear(sg_no_player_squads)
		HintPoint_Remove(g_NO_PLAYER_SQUADS_HP)
		g_NO_PLAYER_SQUADS_HP = nil
	end
	
	Cmd_Stop(sg_temp)
	
	SGroup_SetPlayerOwner(sg_temp, player1)
	SGroup_EnableUIDecorator(sg_temp, true)
	SGroup_EnableMinimapIndicator(sg_temp, true)
	
	-- difficulty handle
	Modify_Vulnerability(sg_temp, 0.8)
	
	Rule_AddSGroupEvent(Rule_PlayerSquadKilled, sg_temp, GE_SquadKilled)
	SGroup_AddGroup(table_PlayerSquads[1].sgroup, sg_temp)
	M01_PlayAmbientSpeechSelect(sg_temp)
	SGroup_AddGroup(sg_beach_squads, sg_temp)
end

function Rule_PlayerSquadKilled()
	if g_SQUAD_KILLED == nil then
		g_SQUAD_KILLED = "SQUAD KILLED TIMER"
	end
	
	-- stop telling the player about the events if he has completed the objective
	if Objective_IsComplete(OBJECTIVE_MoveToShingle) then
		return
	end
	
	if Timer_GetRemaining(g_SQUAD_KILLED) <= 0 then
		Util_StartStinger(EVENTS.SquadDead)
		Timer_Start(g_SQUAD_KILLED, 15)
	end
end

----------------------------------------------------------------
-- VERSION 2 - checks the number of units that have reached the shingle.
----------------------------------------------------------------
function Rule_Objective_GetToShingle()
--~ 	g_numSquadsAtShingle = 0
	
	g_CURRENT_NUM_AT_SHINGLE = 0
	
	for i = 1, table.getn(table_ShingleMarkers_Rect) do
		SGroup_Clear(sg_temp2)
		Player_GetAllSquadsNearMarker(player1, sg_temp2, table_ShingleMarkers_Rect[i])
		if SGroup_IsEmpty(sg_temp2) == false then
			-- this removes all the members that are already at the shingle, so that they 
			-- are not being counted twice.
			SGroup_RemoveGroup(sg_temp2, sg_at_shingle)
			
			-- this should only be keeping track of new squads at the shingle, not ones that are
			-- already there.
			g_CURRENT_NUM_AT_SHINGLE = g_CURRENT_NUM_AT_SHINGLE + SGroup_TotalMembersCount(sg_temp2)
			
			SGroup_RemoveGroup(table_PlayerSquads[1].sgroup, sg_temp2)
			SGroup_AddGroup(sg_at_shingle, sg_temp2)
			SGroup_SetInvulnerable(sg_at_shingle, true, -1)			-- set squad to invulnerable while it's at the shingle
			SGroup_SetSelectable(sg_at_shingle, false)
		end
	end
	
	-- add all the new squads that have not been counted before to the total count of soldiers that the player 
	-- has gotten to the shingle.
	if g_CURRENT_NUM_AT_SHINGLE > 0 then
		g_numSquadsAtShingle = g_numSquadsAtShingle + g_CURRENT_NUM_AT_SHINGLE
		Objective_SetCounter(OBJECTIVE_MoveToShingle, g_numSquadsAtShingle, OBJECTIVE_MoveToShingle.MaxRequired)
	end
	
	-- if player has got one squad to the shingle, spawn three more
	if g_numSquadsAtShingle >= OBJECTIVE_MoveToShingle.MaxRequired then
		g_anySquadsAtShingle = 1
		Objective_Complete(OBJECTIVE_MoveToShingle, false)
		OBJ_RE_Setup()
		-- set this squad is invulnerable for the time being, so that they survive until the NIS
		Util_StartNIS(EVENTS.AllsSoldiersAtShingle)				-- play speech event about first squad making it to shingle		-- JULY 26: Changed from Util_StartIntel to Util_StartNIS so the event will pull you out of the Tac Map if you're in it at the time
		Rule_AddInterval(OBJ_RE_Rule_ArtilleryStrike, 0.5)
		Rule_RemoveMe()
		return
	end
	
	-- checks to see the percentage of squads at the shingle and compares it to a predetermined table, 
	-- then plays the progress message based on the percentage of soldiers at the shingle.
	if table.getn(OBJECTIVE_MoveToShingle.PercentAtShingle) > 0 
	and g_numSquadsAtShingle/OBJECTIVE_MoveToShingle.MaxRequired >= OBJECTIVE_MoveToShingle.PercentAtShingle[1] then
		Util_StartStinger(EVENTS.OBJ_MTS_Progress)
		table.remove(OBJECTIVE_MoveToShingle.PercentAtShingle, 1)
		
		if 	t_HintPoint_Shingle ~= nil then
			for i = 1, table.getn(t_HintPoint_Shingle) do 
				HintPoint_Remove(t_HintPoint_Shingle[i])
			end
			t_HintPoint_Shingle = nil
		end
	end
	
	-- checks to see the number of soldiers at the seawall and compares it to a predetermined table, 
	-- then kicks off an event cue with that number in it
	if table.getn(OBJECTIVE_MoveToShingle.SoldiersAtShingle) > 0 
	and g_numSquadsAtShingle >= OBJECTIVE_MoveToShingle.SoldiersAtShingle[1] then
		
		local num = Loc_ConvertNumber(OBJECTIVE_MoveToShingle.SoldiersAtShingle[1])
		local text = Loc_FormatText(219471, num)
		EventCue_Create(CUE.NORMAL, text, text)
		
		table.remove(OBJECTIVE_MoveToShingle.SoldiersAtShingle, 1)
	end
end

function OBJ_MTS_AddNewObjDelay()
	OBJ_MTS_Start()
	Rule_AddInterval(Rule_Objective_GetToShingle, 1.5)
	Rule_RemoveMe()
end

EVENTS.OBJ_MTS_Start = function()
	CTRL.Actor_PlaySpeech(ACTOR.McKay, 211500)
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech(ACTOR.McKay, 211510)
	CTRL.WAIT()
end

t_obj_mts_progress = {211520, 211522, 211524, 211526}
EVENTS.OBJ_MTS_Progress = function()
	if table.getn(t_obj_mts_progress) > 0 then
		local text = t_obj_mts_progress[1]
		CTRL.Actor_PlaySpeech(ACTOR.Conti, text)
		CTRL.WAIT()
		table.remove(t_obj_mts_progress, 1)
	end
end

-------------------------------------------------------------------------
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- PRIMARY OBJ: Rescue Engineers
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------------------------------------------------------
function Initialize_OBJECTIVE_RescueEngineers()
	OBJECTIVE_RescueEngineers = {
		SetupUI = function() 
			OBJECTIVE_RescueEngineers.WorldHighlightID = Objective_AddUIElements(OBJECTIVE_RescueEngineers, sg_rescue_engineers, true, 219516, true)
			Rule_AddOneShot(OBJ_RE_PermanentArrow, g_SHOW_ARROW_TIME)
		end,
		OnStart = function()
			
		end,
		OnComplete = function()
			Rule_Remove(OBJ_MTS_Rule_CheckSelectedSquads)			
			Rule_Remove(Rule_KillNPCsAtShingle)
			Rule_Remove(Rule_CheckTotalPlayerSquads)
			Objective_SetAlwaysShowDetails(OBJECTIVE_RescueEngineers, false, false, false)
			
			EGroup_Hide(eg_shingle_highlight, true)
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		
		Title 				= 219150,
		Description 		= 219160,
		Type 				= OT_Primary,
		Icon 				= IT_P_Move,
		WorldHighlightID 	= {},
	}
	
	Objective_Register(OBJECTIVE_RescueEngineers)
end
-------------------------------------------------------------------------

function OBJ_RE_PermanentArrow()
	if Rule_Exists(OBJ_RE_EngineersSelected) == true then
		Objective_SetAlwaysShowDetails(OBJECTIVE_RescueEngineers, true, true, true)
	else
		Objective_SetAlwaysShowDetails(OBJECTIVE_RescueEngineers, true, true, false)
	end
end

function OBJ_RE_AddNewObjDelay()
	if Event_IsAnyRunning() == false then
		Objective_Start(OBJECTIVE_RescueEngineers)
		OBJ_RE_Start()
		Rule_RemoveMe()
	end
end

function OBJ_RE_Setup()
	t_obj_re_mgr = {
		t_mkr_sp		= {mkr_eng_rescue_sp1,mkr_eng_rescue_sp2},	-- table of possible locations to spawn engineers
		t_mkr_pinned 	= {mkr_eng_rescue_pt1,mkr_eng_rescue_pt2},	-- table of possible locations for engineers to be pinned
		t_mkr_runto		= {Marker_CraterCover,Marker_Flamethrower_06}, -- table of possible locations for nearby squads to run to
		mkr_sp 			= Mark_EngineersSpawn,						-- current spawn location
		mkr_pinned 		= Marker_EngineersPinned,					-- current location to move to
		current_idx 	= 2,										-- next index in the table (starting on 2 because 1 is where they go when the map starts)
		first_death 	= nil,										-- is this the first death?
		mkr_origin		= mkr_sp_eng,								-- an origin marker that is away from the others
	}
	
	sg_rescue_engineers = SGroup_CreateIfNotFound("sg_rescue_engineers")
	
	local pos = World_GetHiddenPositionOnPath(player1, t_obj_re_mgr.mkr_origin, t_obj_re_mgr.mkr_sp, CHECK_OFFCAMERA)
	
	if pos ~= nil then
		Util_CreateSquadsAtMarker(player1, sg_rescue_engineers, SBP_ALLIED_ENGINEER_M01, pos, 1)
	else
		Util_CreateSquadsAtMarker(player1, sg_rescue_engineers, SBP_ALLIED_ENGINEER_M01, t_obj_re_mgr.mkr_sp, 1)
	end
	
	SGroup_SetInvulnerable(sg_rescue_engineers, true, -1)
	M01_SquadSetCustomAttributes(sg_rescue_engineers, false)
	-- timing is dependent on the EVENT to move engineers into position
	Rule_AddInterval(OBJ_RE_AddNewObjDelay, 2)
	
	SGroup_SetPlayerOwner(sg_rescue_engineers, player1)
	Rule_RemoveMe()
end

function OBJ_RE_Start()
	g_OBJ_RE_STARTED = true
	OBJ_RE_AddEngineerHelp()
	
	if Rule_Exists(Rule_OBJ_RE_CheckEngineersAtShingle) == false then
		Rule_AddInterval(Rule_OBJ_RE_CheckEngineersAtShingle, 0.25)
	end
	
	if Rule_Exists(Rule_OBJ_RE_CheckEngineerHealth) == false then
		Rule_AddInterval(Rule_OBJ_RE_CheckEngineerHealth, 2)
	end
	
	if Rule_Exists(OBJ_RE_RuleEngineerAdvice) == false then
		Rule_AddInterval(OBJ_RE_RuleEngineerAdvice, 4)
	end
	
	Rule_AddOneShot(OBJ_RE_DelayInvulnerabilityRemoval, 2.5)
end

function OBJ_RE_AddEngineerHelp()
	Objective_SetAlwaysShowDetails(OBJECTIVE_RescueEngineers, false, true, true)
	
	if Rule_Exists(OBJ_RE_EngineersSelected) == false then
		Rule_AddInterval(OBJ_RE_EngineersSelected, 1)
	end
	
	if Rule_Exists(OBJ_RE_KillNearbyNPCs) == false then
		Rule_AddInterval(OBJ_RE_KillNearbyNPCs, 1.5)
	end
end

function OBJ_RE_EngineersSelected()
	if Misc_IsSGroupSelected(sg_rescue_engineers, ANY) then
		Objective_RemoveUIElements(OBJECTIVE_RescueEngineers, OBJECTIVE_RescueEngineers.WorldHighlightID)
		OBJECTIVE_RescueEngineers.WorldHighlightID = Objective_AddUIElements(OBJECTIVE_RescueEngineers, sg_rescue_engineers, true, 219150, true)
		if Rule_Exists(OBJ_RE_PermanentArrow) then
			Objective_SetAlwaysShowDetails(OBJECTIVE_RescueEngineers, false, true, false)
		else
			Objective_SetAlwaysShowDetails(OBJECTIVE_RescueEngineers, true, true, false)
		end
		
		Rule_RemoveMe()
		Rule_Remove(OBJ_RE_KillNearbyNPCs)
	end
end

function OBJ_RE_MoveAwayNearbyNPCs()
	local num = t_obj_re_mgr.current_idx
	
	SGroup_Clear(sg_temp3)
	Misc_GetAllPlayerSquadsOnScreen(player3, sg_temp3)
	Cmd_Move(sg_temp3, t_obj_re_mgr.t_mkr_runto[num])
	
	SGroup_Clear(sg_temp3)
	Misc_GetAllPlayerSquadsOnScreen(player1, sg_temp3)
	SGroup_RemoveGroup(sg_temp3, sg_rescue_engineers)
	Cmd_Move(sg_temp3, t_obj_re_mgr.t_mkr_runto[num])
end

function OBJ_RE_KillNearbyNPCs()
	Player_GetAllSquadsNearMarker(player3, sg_temp3, Util_GetPosition_EVEN_IF_EMPTY(sg_rescue_engineers), 80)
	KillNPCsUnjustly(sg_temp3, false)
	
	Player_GetAllSquadsNearMarker(player1, sg_temp3, Util_GetPosition_EVEN_IF_EMPTY(sg_rescue_engineers), 80)
	SGroup_RemoveGroup(sg_temp3, sg_rescue_engineers)
	KillNPCsUnjustly(sg_temp3, false)
end

function Rule_OBJ_RE_CheckEngineersAtShingle()
	for i = 1, table.getn(table_ShingleEngineers) do 
		if Prox_AreSquadMembersNearMarker(sg_rescue_engineers, table_ShingleEngineers[i], ANY) then
			OBJ_DB_StartNIS02()
			Rule_RemoveMe()
			Objective_Complete(OBJECTIVE_RescueEngineers, false)
			-- turn off global parameters and other rules
			g_OBJ_RE_STARTED = false
			Rule_RemoveIfExist(Rule_OBJ_RE_CheckEngineerHealth)
			Rule_RemoveIfExist(OBJ_RE_EngineersSelected)
			Rule_RemoveIfExist(OBJ_RE_KillNearbyNPCs)
			
			-- Remove highlights and Player squad invulnerability
			M01_RemovePlayerSquadInvulnerability()
			break
		end
	end
end

function Rule_OBJ_RE_CheckEngineerHealth()
	if g_OBJ_RE_STARTED == false then
		Rule_RemoveMe()
	elseif SGroup_IsEmpty(sg_rescue_engineers) then
		OBJ_RE_SpawnEngineers()
	end
end

function OBJ_RE_SpawnEngineers()
	local index = t_obj_re_mgr.current_idx
	t_obj_re_mgr.current_idx = t_obj_re_mgr.current_idx + 1
	if t_obj_re_mgr.current_idx > table.getn(t_obj_re_mgr.t_mkr_sp) then
		t_obj_re_mgr.current_idx = 1
	end
	
	Util_StartIntel(EVENTS.EngineerSquadDead)
	
	t_obj_re_mgr.mkr_sp = t_obj_re_mgr.t_mkr_sp[index]
	t_obj_re_mgr.mkr_pinned = t_obj_re_mgr.t_mkr_pinned[index]
	
	local pos = World_GetHiddenPositionOnPath(player1, t_obj_re_mgr.mkr_origin, t_obj_re_mgr.mkr_sp, CHECK_OFFCAMERA)
	
	if pos ~= nil then
		Util_CreateSquadsAtMarker(player1, sg_rescue_engineers, SBP_ALLIED_ENGINEER_M01, pos, 1)
	else
		Util_CreateSquadsAtMarker(player1, sg_rescue_engineers, SBP_ALLIED_ENGINEER_M01, t_obj_re_mgr.mkr_sp, 1)
	end
	
	Cmd_Move(sg_rescue_engineers, t_obj_re_mgr.mkr_pinned)
	M01_SquadSetCustomAttributes(sg_rescue_engineers, false)
	
	-- difficulty handle
	Modify_Vulnerability(sg_rescue_engineers, 0.8)
	
	SGroup_AddGroup(table_PlayerSquads[4].sgroup, sg_rescue_engineers)
	table_PlayerSquads[4].flag_CheckRespawn = 1	-- start checking if squad is dead (for respawning)
	table_PlayerSquads[4].flag_spawned = 1	
	table_PlayerSquads[4].ping = UI_CreateMinimapBlip(table_PlayerSquads[4].sgroup, -1, BT_GeneralPing) -- create minimap ping on new squad
	
	UI_CreateEventCueClickable(CUE.NORMAL.icon, CUE.NORMAL.sound, 219465, 219465, OBJ_RE_FocusCameraOnEngineers, -1, false)
	
	Objective_RemoveUIElements(OBJECTIVE_RescueEngineers, OBJECTIVE_RescueEngineers.WorldHighlightID)
	OBJECTIVE_RescueEngineers.WorldHighlightID = Objective_AddUIElements(OBJECTIVE_RescueEngineers, sg_rescue_engineers, true, 219150, true)

	Camera_ResetToDefault()
	Camera_ResetToDefault()
	Camera_MoveToPosition(Util_GetPosition_EVEN_IF_EMPTY(t_obj_re_mgr.mkr_pinned), true, SLOW_CAMERA_PANNING)
	
	OBJ_RE_AddEngineerHelp()
end


function OBJ_RE_RuleEngineerAdvice()
	if g_OBJ_RE_STARTED == false then
		Rule_RemoveMe()
	end
	
	if g_ENGINEER_COUNT == nil then
		g_ENGINEER_COUNT = 3
		g_OBJ_RE_TIMER = "g_OBJ_RE_TIMER"
	end
	
	if SGroup_IsEmpty(sg_rescue_engineers) == false 
	and Timer_GetRemaining(g_OBJ_RE_TIMER) <= 0
	and (SGroup_IsMoving(sg_rescue_engineers, ANY) == false or SGroup_TotalMembersCount(sg_rescue_engineers) < g_ENGINEER_COUNT) then
		Timer_Start(g_OBJ_RE_TIMER, 20)
		g_ENGINEER_COUNT = SGroup_TotalMembersCount(sg_rescue_engineers)
		Util_StartStinger(EVENTS.OBJ_RE_EngineerAdvice)
	end
end

function OBJ_RE_FocusCameraOnEngineers()
	Camera_MoveToSGroup(sg_rescue_engineers, false)
end

function OBJ_RE_Rule_ArtilleryStrike()
	if Prox_AreSquadsNearMarker(sg_rescue_engineers, Util_GetPosition_EVEN_IF_EMPTY(mkr_artillery_engineer), ANY, 20) then
		Cmd_Ability(player1, ABILITY_SP_ARTILLERY_M01_SINGLE, Marker_GetPosition(mkr_artillery_engineer))
		Cmd_Stop(sg_rescue_engineers)
		Util_StartIntel(EVENTS.OBJ_RE_COVER_COMPROMISED)
		SGroup_SuggestPosture(sg_rescue_engineers, 0, -1)
		Rule_AddOneShot(OBJ_RE_ClearEngineerPosture, 5)
		EGroup_Kill(eg_eng_tank_traps)
		Rule_RemoveMe()
	end
end

function OBJ_RE_ClearEngineerPosture()
	SGroup_ClearPostureSuggestion(sg_rescue_engineers)															-- Daly: clear posture suggestion so Engineers can move normally after the player selects them
end

function OBJ_RE_DelayInvulnerabilityRemoval()
	SGroup_SetInvulnerable(sg_rescue_engineers, false)
	SGroup_AddGroup(table_PlayerSquads[4].sgroup, sg_rescue_engineers)
	-- give the units to the player
	table_PlayerSquads[4].flag_CheckRespawn = 1	-- start checking if squad is dead (for respawning)
	table_PlayerSquads[4].flag_spawned = 1		-- tell rest of script that new group has been spawned
end

EVENTS.OBJ_RE_COVER_COMPROMISED = function()
	CTRL.Event_Delay(1)
	CTRL.WAIT()
	Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, 210764)
	Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, 210766)
end

t_engineer_advice = {210290, 210300, 210301, 210302, 210303}
EVENTS.OBJ_RE_EngineerAdvice = function()
	local text = t_engineer_advice[World_GetRand(1, table.getn(t_engineer_advice))]
	Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, text)
end

-------------------------------------------------------------------------
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- PRIMARY OBJ: Destroy Bunker
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------------------------------------------------------

function Initialize_OBJECTIVE_DestroyBunker()
	OBJECTIVE_DestroyBunker =
	{
		SetupUI = function()
			OBJECTIVE_DestroyBunker.PingID = Objective_AddUIElements(OBJECTIVE_DestroyBunker, Axis_Bunker, true, false, true)
		end,
		OnStart = function()
			Rule_AddOneShot(OBJ_DB_PermanentArrow, g_SHOW_ARROW_TIME)
			Rule_AddInterval(M01_RuleDestroyMGs, 2)
			
			-- give the engineers the ability to throw satchel charges at the bunker
			Rule_AddInterval(Rule_SpeechEvent_UseSatchelCharges, 1.1)
		end,
		OnComplete = function()
			-- activates the reinforcement that should come from the squads behind player.
			M01_ReinforcementSetup()
			Objective_SetAlwaysShowDetails(OBJECTIVE_DestroyBunker, false, false, false)
			g_REINFORCE_ACTIVE = true
			
			-- start switching territory for the player up above the bunker.
			Rule_AddInterval(Rule_SwitchTerritory, 1.6)
			Player_SetDefaultSquadMoodMode( player1, MM_Auto)
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		
		Title = 219122,
		Description = 219470,
		Type = OT_Primary,
		icon = IT_P_Attack,
	}
	Objective_Register(OBJECTIVE_DestroyBunker)
end
-------------------------------------------------------------------------

function OBJ_DB_PermanentArrow()
	Objective_SetAlwaysShowDetails(OBJECTIVE_DestroyBunker, true, true, false)
end

function OBJ_DB_AddNewObjDelay()
	if Event_IsAnyRunning() == false then
		Objective_Start(OBJECTIVE_DestroyBunker, true)
		Rule_AddInterval(OBJ_DB_RuleMGAttackPlayer, 1.5)
		Rule_RemoveMe()
	end
end

function OBJ_DB_Setup()
	-- don't run this until the NIS is over
	if g_AtShingleEventHasFinished ~= 1 then
		return
	end

	SGroup_AddGroup(table_PlayerSquads[1].sgroup, Player_NIS_Riflemen_01)								-- add the Riflemen left behind by the NIS back into the player squads table
	SGroup_SetSuppression(table_PlayerSquads[1].sgroup, 0)
	Modify_ReceivedSuppression(table_PlayerSquads[1].sgroup, 0.5)
	table_PlayerSquads[1].flag_spawned = 1																-- set flags so script knows to start checking if squad's dead et al
	table_PlayerSquads[1].flag_CheckRespawn = 1
	Modify_TargetPriority(table_PlayerSquads[1].sgroup, 100)											-- increase target priority on player squads so MGs will always target them instead of NPCs

	SGroup_AddGroup(table_PlayerSquads[4].sgroup, Player_NIS_Engineers_01)								-- add the Engineers left behind by the NIS back into the player squads table
	Modify_ReceivedSuppression(table_PlayerSquads[4].sgroup, 0.5)
	table_PlayerSquads[4].flag_spawned = 1																-- set flags so script knows to start checking if squad's dead et al
	table_PlayerSquads[4].flag_CheckRespawn = 1
	Modify_TargetPriority(table_PlayerSquads[4].sgroup, 100)											-- increase target priority on player squads so MGs will always target them instead of NPCs
	if table_PlayerSquads[4].itemTable ~= nil then														-- if player picked up any weapons on the beach
		Squad_GiveSlotItemsFromTable(SGroup_GetSpawnedSquadAt(table_PlayerSquads[4].sgroup, 1), table_PlayerSquads[4].itemTable)		-- give them back to the squad
	end
	
	Rule_AddInterval(Rule_RespawnSniper, 0.5)
	
	-- mark everyone as being "not at the shingle"
	for i = 1, table.getn(table_PlayerSquads) do 
		table_PlayerSquads[i].at_shingle = nil
	end

	Rule_AddInterval(OBJ_DR_AddNewObj, 3)
	
	M01_SetVeterancyAndControlGroup()
	
	Rule_RemoveMe()
end

function OBJ_DB_RespawnMGNests()
	if Event_IsRunning(EVENTS.AtTheShingle) then
		return
	end

	Util_CreateSquads(player2, Axis_BunkerMG42_Extra_01, SBP.AXIS.HEAVYMG, table_MG42_SquadsInBunkers[1].pos, nil, nil, nil, nil, Marker_Shingle_11)
	table.insert(t_axis_mgs,  {sgroup = Axis_BunkerMG42_Extra_01, sw_id = SyncWeapon_GetFromSGroup(Axis_BunkerMG42_Extra_01) } )
	SGroup_SetTeamWeaponCapturable(Axis_BunkerMG42_Extra_01, false)
	SGroup_AddGroup(sg_dog_red_defense, Axis_BunkerMG42_Extra_01)
	
	Util_CreateSquads(player2, Axis_BunkerMG42_Extra_02, SBP.AXIS.HEAVYMG, table_MG42_SquadsInBunkers[2].pos, nil, nil, nil, nil, Marker_Shingle_04)
	table.insert(t_axis_mgs,  {sgroup = Axis_BunkerMG42_Extra_02, sw_id = SyncWeapon_GetFromSGroup(Axis_BunkerMG42_Extra_02) } )
	SGroup_SetTeamWeaponCapturable(Axis_BunkerMG42_Extra_02, false)
	
	Rule_RemoveMe()
end

---------------------------------------------------------------------------------------
-- STARTS NIS AT THE SHINGLE (NIS 02)
---------------------------------------------------------------------------------------
function OBJ_DB_StartNIS02()
	-- start checking for when to tell player to use satchel charges
	flag_AtTheShingle = 1		-- set flag
--~ 	Rule_Add(HideNPCS, 0.5)
	NPCs_Stop()
	
	Rule_Remove(Rule_NISHigginsPlay)
	Util_StartNIS(EVENTS.AtTheShingle)-- start NIS: at the shingle
--~ 	Rule_AddInterval(Rule_NIS02_UnhideNPCs, 0.7)
	
	for j = 1, table.getn(table_PlayerSquads) do
		SGroup_SetInvulnerable(table_PlayerSquads[j].sgroup, false, -1)															-- remove invulnerability on player squads
	end
	
	-- remove invulnerability on Axis MG squads in bunkers
	for k = 1, table.getn(table_AxisBunkerMGs) do
		SGroup_SetInvulnerable(table_AxisBunkerMGs[k].sgroup, false, -1)														-- turn off invulnerability on MG squads in bunkers
	end
	
	-- *** TODO Is there a solution to hiding this squad to help hide the gun during the NIS?
--~ 	SGroup_Hide(Axis_MGNest_DogWhite, true)
	
	Rule_AddInterval(Rule_DelayMGNestAttack, 0.5)
	Rule_AddInterval(OBJ_DB_RespawnMGNests, 0.5)
	Rule_AddInterval(OBJ_DB_Setup, g_NIS02_TRANS_TIME+5)
--~ 	Rule_AddInterval(Rule_NukePlayerSquads, g_NIS02_TRANS_TIME+1.2)																							-- start rule that removes unnecessary player squads
--~ 	Rule_AddInterval(Rule_ClearNPCs_N01_02, g_NIS02_TRANS_TIME+1.2)																						-- start rule that kills off NPC squads so they don't interfere with NIS
	EGroup_InstantCaptureStrategicPoint(Flag_Beach, player1)																		-- set territory sector for beach to player owned
	
	Rule_Remove(Rule_Mortars_FindPlayer)																										-- Remove rules targeting player with mortars
	Rule_Remove(Rule_Mortars_AttackPlayer)
	
	Rule_Remove(Rule_MG_TrackPlayerMovt)																									-- Remove rule telling MGs to attack player squads
	Rule_Remove(Rule_MGFire_NPC_CycleAttack)																							-- Remove rule telling NPC attackers to fire																				-- start checking for when to retreat from Bunker
	
	Rule_AddInterval(Rule_FallIntoTrench_Check, 0.8)																						-- start checking for when fall-into-trench squad should retreat

	Rule_AddInterval(Rule_Engineers_BlowWire, 0.5)
	Rule_AddInterval(Rule_Objective_DestroyMGNest, 1.2)																					-- start checking for MG nests to be destroyed
	Rule_AddInterval(Rule_PlayerIn88Area, 1.7)																								-- start checking for when player is near 88s, so they get respawned there if they die there
	Rule_AddInterval(Rule_Axis_KeepPressureOn, 1.3)																					-- start checking for when player is not under attack, so we can spawn more Axis squads and keep the pressure on
	-- add rule that will restart the respawn at the end of the NIS.
	
	
	Rule_AddInterval(Rule_OBJ_MTS_RestartRespawn, 0.5)
	
	-- resetting the availability to the grenade button
	Player_SetAbilityAvailability(player1, ABILITY.ALLIES.GRENADE_NOREQS, ITEM_DEFAULT)
	Player_SetAbilityAvailability(player1, ABILITY.AXIS.MEDICAL_KIT, ITEM_REMOVED)						-- For some reason this ability shows up on the Flak 88s when you take them over.  Removing it so it won't show up
	
	-- setting player's popcap to lower.
	Player_SetPopCapOverride(player1, 35)
	
	-- destroy the MG squads at the edges of the cliff to 
	SGroup_DestroyAllSquads(Axis_BunkerMG42_Extra_01)
	SGroup_DestroyAllSquads(Axis_BunkerMG42_Extra_02)
end

-- this function attacks the player if he wanders off of the shingle while trying to 
-- destroy the bunker.
function OBJ_DB_RuleMGAttackPlayer()
	local rand = World_GetRand(1, table.getn(table_PlayerSquads))
	local sg_player = table_PlayerSquads[rand].sgroup
	
	if SGroup_IsEmpty(sg_player) then
		return
	end
	
	for j = 1, table.getn(table_ShingleMarkers_Rect) do 
		if Prox_AreSquadsNearMarker(sg_player, table_ShingleMarkers_Rect[j], ANY) then
			return
		end
	end
	
	local guns = {Axis_BunkerMG42_01, Axis_BunkerMG42_02}
	local num = World_GetRand(1, table.getn(guns))
	local mg = guns[num]
	
	if SGroup_IsEmpty(mg) == false then
		Cmd_Attack(mg, sg_player)
	end
end

function Rule_OBJ_MTS_RestartRespawn()
	if flag_AtTheShingle == 1 and Event_IsAnyRunning() == false then
		M01_ReinforcementInitialShingleSquads()
		Rule_AddInterval(Rule_RespawnPlayerSquads, 0.5)
		Rule_RemoveMe()
	end
end

function Rule_Occupiable88Destroy()
	if Objective_IsComplete(OBJECTIVE_DestroyBunker) then
		Rule_RemoveMe()
		return
	end
	
	if SGroup_IsEmpty(Axis_88Crew_Clifftop) then
		if SyncWeapon_Exists(t_player_88.sw_id) then
			
		end
	end
end

function Rule_Objective_DestroyBunker_Delay(caster, abilityid, target )
	if abilityid == ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS then
		if (scartype(target) == ST_ENTITY and Entity_GetGameID(target) == Entity_GetGameID(EGroup_GetSpawnedEntityAt(Axis_Bunker, 1)))
		or (scartype(target) == ST_SCARPOS and World_DistanceEGroupToPoint(Axis_Bunker, target, true) < 12) then
			if Rule_Exists(Rule_Objective_DestroyBunker) == false and g_BunkerDestroyed ~= 1 then
				Rule_AddOneShot(Rule_Objective_DestroyBunker, 3)
			end
		end
	end
end

function Rule_OBJ_DB_SatchelProj(projectile, attacker, target)	
	if (scartype(target) == ST_ENTITY and Entity_GetGameID(target) == Entity_GetGameID(EGroup_GetSpawnedEntityAt(Axis_Bunker, 1)))
	or (scartype(target) == ST_SCARPOS and World_DistanceEGroupToPoint(Axis_Bunker, target, true) < 12.5) then
		Entity_SetProjectileCanExplode(projectile, false)
		return
	end
end


------------------------------------------------------------------------------------
-- STARTS NIS 03 - DESTROY BUNKER
-- checks to see when the player has thrown a satchel charge on the bunker guarding 
-- the bunker and has moved troops in there, then triggers the NIS "Bunker Taken"
------------------------------------------------------------------------------------
function Rule_Objective_DestroyBunker()
	print ("/\/\/\/\/\/\ Starting NIS - Bunker Taken!")
	HintMouseover_Remove(219515, mkr_db_hint)
	
	if g_SatchelHintID ~= nil then
		HintPoint_Remove(g_SatchelHintID)
	end
	
	if g_SatchelFlashID ~= nil then
		UI_StopFlashing(g_SatchelFlashID)
	end
	
	Rule_Remove(Rule_InfantryGrenadeHint)
	
	if g_GRENADE_HINT ~= nil then
		HintPoint_Remove(g_GRENADE_HINT)
	end
	
	if g_GRENADE_FLASH ~= nil then
		UI_StopFlashing(g_GRENADE_FLASH)
	end
	
	g_BunkerDestroyed = 1
	NPCs_Stop()
	SGroup_DestroyAllSquads(Axis_BunkerMG42_01)																				-- kill Axis MG gunners in bunker
	SGroup_DestroyAllSquads(Axis_BunkerMG42_02)
	
	Rule_Remove(OBJ_DB_RuleMGAttackPlayer)
	
	EGroup_InstantCaptureStrategicPoint(Flag_Beach, player1)											-- switch ownership of territory sectors
	EGroup_InstantCaptureStrategicPoint(Flag_RH_Clifftop, player1)									-- switch ownership of territory sectors
	EGroup_SetPlayerOwner(eg_reinforce_bunker, player1)
	g_nukePlayerSquads = 0										-- re-set flag so it can be set at the appropriate time during the event
	
	if Rule_Exists(Rule_NukePlayerSquads) == false then
		Rule_AddInterval(Rule_NukePlayerSquads, 0.3)				-- start rule that removes unnecessary player squads
	end
	
	-- remove the squad respawning so that the player doesn't get more units during the NIS.
	Rule_Remove(Rule_RespawnPlayerSquads)
	Rule_AddInterval(Rule_OBJ_DB_RestartRespawn, 0.5)
	OBJ_DB_DespawnBunkerSquads()
	
	Rule_Remove(Rule_88s_FireInAir)
	for i = 1, table.getn(table_88s) do
		Cmd_Stop(table_88s[i].sgroup)
		Ceasefire_AddSGroup(table_88s[i].sgroup)
	end
	Rule_AddInterval(Rule_ClearNPCs_N01_03, 0.3)
	if g_sniperRescued == 1 then
		SGroup_SetInvulnerable(NPC_Sniper, true)
	end
	
	Objective_Complete(OBJECTIVE_DestroyBunker, false)
	
	--[[ PLAY NIS01_03 ]]		
	Util_StartNIS(EVENTS.BunkerDestroyed)						-- play NIS: Bunker Taken
	Rule_AddInterval(OBJ_D88_AddObjDelay, 0.5)
	
	-- DESTROY THE BARBED WIRE
	EGroup_Kill(BarbedWire_Destroy)
	
	-- Disable the ability to occupy the bunker
	Modify_DisableHold(Axis_Bunker, true)
	EGroup_SetSelectable(Axis_Bunker, false)
	
	OBJ_DB_SpawnWeapons()
	Rule_Remove(Rule_NPC_GetSuppressed_Staggered)
	Rule_Remove(Rule_NPC_PotShots)
	Rule_AddInterval(Rule_Objective_Destroy88s, 1)				-- start checking for objective to destroy 88's
	Rule_AddInterval(Rule_AxisRetreat_MoveIntoPosition, 10)		-- start rule telling Axis trench defenders et al to move into defensive positions
	Rule_AddInterval(OBJ_DB_AxisMoveIntoPosition, 1.5)			-- move all the axis into the appropriate positions
	Rule_AddInterval(Rule_SpeechEvents_UseTrenches, 1.1)		-- play speech event telling player to use trenches
	Rule_AddInterval(Rule_SpeechEvents_FlankMGs, 1.4)			-- play speech event telling player to flank MG nests
	Rule_AddInterval(Rule_ReinforcementFirstMove, 3)			-- Move reinforcements up the beech to the bunker
	Rule_AddInterval(Rule_RespawnSniper, 0.8)					-- Respawn the sniper
	
	Rule_RemoveMe()
end

function Rule_OBJ_DB_RestartRespawn()
	if g_BunkerTakenNIS_Finished == 1 then
		Rule_AddInterval(Rule_RespawnPlayerSquads, 0.5)
		Rule_RemoveMe()
	end
end

function OBJ_DB_DespawnBunkerSquads()
	for i = 1, table.getn(table_AxisSquadsNearBunker) do 
		if SGroup_IsEmpty(table_AxisSquadsNearBunker[i]) == false then
			SGroup_DestroyAllSquads(table_AxisSquadsNearBunker[i])
		end
	end
end

function Rule_NIS02_UnhideNPCs()
	if Event_IsAnyRunning() == false then
		UnhideNPCS()
		if Rule_Exists(HideNPCS) then
			Rule_Remove(HideNPCS)
		end
		Rule_RemoveMe()
	end
end

function OBJ_DB_StopMGAttackPlayer()
	Cmd_Stop(Axis_BunkerMG42_01)
	Cmd_Stop(Axis_BunkerMG42_02)
	Cmd_Attack(Axis_BunkerMG42_01, table_PlayerSquads[3].sgroup, true)
	Cmd_Attack(Axis_BunkerMG42_02, table_PlayerSquads[4].sgroup, true)
end

function OBJ_DB_SpawnWeapons()
	mkr_sp_weapon = Marker_GetTable("eg_sp_weapon%d")
	eg_weapon_pickup = EGroup_CreateTable("eg_weapon_pickup%d", table.getn(mkr_sp_weapon))
	
	for i = 1, table.getn(mkr_sp_weapon) do 
		Util_CreateEntities(nil, eg_weapon_pickup[i],  EBP.PICKUP.AXIS.LMG_42, mkr_sp_weapon[i], 1)		
	end
end


-------------------------------------------------------------------------
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- PRIMARY OBJ: Destroy 88s
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------------------------------------------------------
function Initialize_OBJECTIVE_Destroy88s()
	OBJECTIVE_Destroy88s =
	{
		SetupUI = function()
			OBJECTIVE_Destroy88s.PingID[1] = Objective_AddUIElements(OBJECTIVE_Destroy88s, table_88s[1].sgroup, true, 219572, true)
			OBJECTIVE_Destroy88s.PingID[2] = Objective_AddUIElements(OBJECTIVE_Destroy88s, table_88s[2].sgroup, true, 219572, true)
			Rule_AddOneShot(OBJ_D88_PermanentArrow, g_SHOW_ARROW_TIME)
			Objective_SetCounter(OBJECTIVE_Destroy88s, 0, 2)
		end,
		OnStart = function()
			
		end,
		OnComplete = function()
--~ 			Util_MissionTitle(219608)
			Objective_SetAlwaysShowDetails(OBJECTIVE_Destroy88s, false, false)
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		Title 					= 219123,
		Description 			= 219131,
		Type 					= OT_Primary,
		icon 					= IT_P_Attack,
		PingID					= {},
	}
	Objective_Register(OBJECTIVE_Destroy88s)
	OBJ_D88_Setup()
end

function OBJ_D88_PermanentArrow()
	Objective_SetAlwaysShowDetails(OBJECTIVE_Destroy88s, true, true)
end

function OBJ_D88_Setup()
	t_player_88 = {
		sgroup 		= SGroup_CreateIfNotFound("sg_88_crew"),
		sw_id 		= SyncWeapon_GetFromSGroup(Axis_88Crew_Clifftop),
		owned 		= false,
		mods	 	= {},
		sbp			= {SBP_ALLIES_ENGINEERS_M01, SBP_ALLIED_RIFLEMEN_M01},
	}
end

function OBJ_D88_AddObjDelay()
	if g_BunkerTakenNIS_Finished == 1 then
		--[[ AUTOSAVE ]]
		g_AUTOSAVE = 219352
		if Rule_Exists(M01_AutosaveDelay) == false then
			Rule_AddOneShot(M01_AutosaveDelay, g_AUTOSAVE_DELAY)
		end
	
		Objective_Start(OBJECTIVE_Destroy88s)
		Rule_AddInterval(Rule_88s_FireAtTrenches, 3.5)
		Rule_AddInterval(OBJ_MB_StartCheck, 1.6)
		Rule_AddInterval(OBJ_D88_RuleOccupy88, 2)
		Rule_RemoveMe()
	end
end

-- check if player has destroyed all the 88mm gun crews
function Rule_Objective_Destroy88s()
	-- increments counter g_num88sKilled each time an 88 gun crew is destroyed
	for i=1,2 do
		if SGroup_IsEmpty(table_88s[i].sgroup) == false 
		and SGroup_IsUnderAttack(table_88s[i].sgroup, ANY, 5)
		and Timer_GetRemaining(g_88_UATTACK_TIMER) <= 0 then
			Util_StartStinger(EVENTS.OBJ_D88_UnderAttack)
			Timer_Start(g_88_UATTACK_TIMER, 30)
		end
		
		if SyncWeapon_Exists(table_88s[i].sync_id) then
			if (SGroup_IsEmpty(table_88s[i].sgroup) or SyncWeapon_IsOwnedByPlayer(table_88s[i].sync_id, player2) == false)then
				if table_88s[i].ping == nil then
					Objective_RemoveUIElements(OBJECTIVE_Destroy88s, OBJECTIVE_Destroy88s.PingID[i])
					OBJECTIVE_Destroy88s.PingID[i] = Objective_AddUIElements(OBJECTIVE_Destroy88s, SyncWeapon_GetEntity(table_88s[i].sync_id), true, 219572, true, 1)
					table_88s[i].ping = true
				end
			
				if g_88_CREW_KILLED_SPEECH == nil then
					Util_StartStinger(EVENTS.Gun88CrewKilled)
					g_88_CREW_KILLED_SPEECH = true
				end
			end

			if Entity_GetHealthPercentage(SyncWeapon_GetEntity(table_88s[i].sync_id)) <= 0.75 then
				Entity_Kill(SyncWeapon_GetEntity(table_88s[i].sync_id))
			end
		end
		
		if table_88s[i].flag == 0 and SyncWeapon_Exists(table_88s[i].sync_id) == false then
			table_88s[i].flag = 1
			g_num88sKilled = g_num88sKilled + 1
			
			if OBJECTIVE_Destroy88s.PingID[i] ~= nil then
				Objective_RemoveUIElements(OBJECTIVE_Destroy88s, OBJECTIVE_Destroy88s.PingID[i])
			end
			
--~ 			if g_num88sKilled == 1 then
--~ 				--[[ AUTOSAVE ]]
--~ 				g_AUTOSAVE = 219355
--~ 				if Rule_Exists(M01_AutosaveDelay) == false then
--~ 					Rule_AddOneShot(M01_AutosaveDelay, g_AUTOSAVE_DELAY)
--~ 				end				
--~ 			end
			
			EventCue_Create(CUE.NORMAL, 219133, 219133, table_88s[i].hint_mkr) 
			g_LAST_88_DESTROYED = table_88s[i].hint_mkr
			Objective_SetCounter(OBJECTIVE_Destroy88s, g_num88sKilled, 2)
		end
	end
	
	-- Play a speech event when each 88 gun crew is killed
	for i = 1, table.getn(table_88SpeechEvents) do
		if table_88SpeechEvents[i].flag == 0 and g_num88sKilled == table_88SpeechEvents[i].numKilled then
			table_88SpeechEvents[i].flag = 1
			Util_StartIntel(table_88SpeechEvents[i].event)
		end
	end
	
	-- if all guns are destroyed, start rule to end mission
	if g_num88sKilled == 2 then
		Rule_AddInterval(Rule_MissionComplete, 0.1)
		Rule_RemoveMe()
	end
end

function OBJ_D88_RuleOccupy88()
	if SyncWeapon_Exists(t_player_88.sw_id) == false then
		if t_player_88.hint_id ~= nil and t_player_88.hint_id ~= false then
			HintPoint_Remove(t_player_88.hint_id)
		end
		
		Rule_RemoveMe()
		return
	end
	
	if t_player_88.hint_id == nil
	and not SyncWeapon_IsOwnedByPlayer(t_player_88.sw_id, player1) 
	and not SyncWeapon_IsOwnedByPlayer(t_player_88.sw_id, player2) then
		t_player_88.hint_id = HintPoint_Add(mkr_capture_88, true, 219581)
		return
	end
	
	if SyncWeapon_IsOwnedByPlayer(t_player_88.sw_id, player1) 
	and t_player_88.owned == false then
		if t_player_88.hint_id ~= nil and t_player_88.hint_id ~= false then
			HintPoint_Remove(t_player_88.hint_id)
			t_player_88.hint_id = false
		end
		
		Player_GetAllSquadsNearMarker(player1, t_player_88.sgroup, SyncWeapon_GetPosition(t_player_88.sw_id), 5)
		SGroup_Filter(t_player_88.sgroup, t_player_88.sbp, FILTER_REMOVE)
		
		print("Player Owns 88")
		if SGroup_IsEmpty(t_player_88.sgroup) == false then
			t_player_88.mods[1] = Modify_WeaponDamage(t_player_88.sgroup, "hardpoint_01", 1.25)
			t_player_88.mods[2] = Modify_WeaponAccuracy(t_player_88.sgroup, "hardpoint_01", 1.25)
			t_player_88.mods[2] = Modify_WeaponRange(t_player_88.sgroup, "hardpoint_01", 1.2)
			t_player_88.owned = true
		end
	end

	if SyncWeapon_IsOwnedByPlayer(t_player_88.sw_id, player1) == false
	and t_player_88.owned == true then
		for i = 1, table.getn(t_player_88.mods) do
			Modifier_Remove(t_player_88.mods[i])
		end
		t_player_88.owned = false
	end
end

EVENTS.Ridge88s = function()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211231)		-- Listen up! 88s on the ridge!
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.Conti, 211241)		-- Target the crews and use Satchel Charges on those guns!
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.Conti, 211242)		-- You heard the LT, MOVE OUT!
	CTRL.WAIT()
end

EVENTS.Gun88CrewKilled = function()
	CTRL.Actor_PlaySpeech( ACTOR.Conti, 211264)
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.Conti, 211266)
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.Conti, 211268)
	CTRL.WAIT()
end

EVENTS.First88Killed = function()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211280)		-- Good job! One more to go.
	CTRL.WAIT()
end

EVENTS.Second88Killed = function()
	Objective_Complete(OBJECTIVE_Destroy88s, true)
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211300)		-- That does it!  88 battery destroyed.
	CTRL.WAIT()
end

t_88_uattack = {212202, 212203, 212204, 212205, 212206, 212207, 212208, 212209, 212210 }
EVENTS.OBJ_D88_UnderAttack = function()
	local text = t_88_uattack[World_GetRand(1, table.getn(t_88_uattack))]
	Actor_PlaySpeechWithoutPortrait(ACTOR.GenericAxis, text)		-- Good job! One more to go.
end

-------------------------------------------------------------------------


-------------------------------------------------------------------------
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- SECONDARY OBJECTIVE: Destroy Military Bunkers
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------------------------------------------------------
function Initialize_OBJECTIVE_MilitaryBunkers()
	OBJECTIVE_MilitaryBunkers =
	{
		SetupUI = function()
			Objective_SetCounter(OBJECTIVE_MilitaryBunkers, OBJECTIVE_MilitaryBunkers.BunkersDestroyed, t_obj_mb_mgr.total_bunkers)
			Rule_AddOneShot(OBJ_MB_PermanentTitle, g_SHOW_ARROW_TIME)
			
		end,
		OnStart = function()
			
		end,
		OnComplete = function()
			local text = Loc_FormatText(219354, Loc_ConvertNumber(t_obj_mb_mgr.total_bunkers))
			
			--[[ AUTOSAVE ]]
--~ 			g_AUTOSAVE = text
--~ 			if Rule_Exists(M01_AutosaveDelay) == false then
--~ 				Rule_AddOneShot(M01_AutosaveDelay, g_AUTOSAVE_DELAY)
--~ 			end
			
			Objective_SetAlwaysShowDetails(OBJECTIVE_MilitaryBunkers, false, false)
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		
		Title 				= nil,				
		Description 		= 219191,
		Type 				= OT_Secondary,
		Icon 				= IT_S_Default,
		PingID 				= {},
		BunkersDestroyed	= 0,
		TotalBunkers		= nil,				-- number of bunkers needed to destroy to complete objective
	}
	
	OBJ_MB_Setup()
	
	local text = Loc_FormatText(219190, Loc_ConvertNumber(t_obj_mb_mgr.total_bunkers))
	
	-- update the text with the correct number of bunkers to destroy
	OBJECTIVE_MilitaryBunkers.Title = text
	
	Objective_Register(OBJECTIVE_MilitaryBunkers)
end
-------------------------------------------------------------------------

function OBJ_MB_Setup()
	t_obj_mb_mgr = {
		egroups 		= eg_bunker_spawn,
		total_bunkers	= t_difficulty.bunkers,					-- difficulty handle, number of bunkers required to destroy (not less than 2)
		destroyed		= {},
		spotted 		= {},
		pos				= {},
		hint			= {},
	}
	for i = 1, table.getn(eg_bunker_spawn) do 
		t_obj_mb_mgr.destroyed[i] = false
		t_obj_mb_mgr.spotted[i] = false
		t_obj_mb_mgr.pos[i] = Util_GetPosition_EVEN_IF_EMPTY(eg_bunker_spawn[i])
	end
end

function OBJ_MB_PermanentTitle()
	Objective_SetAlwaysShowDetails(OBJECTIVE_MilitaryBunkers, true, false)
end

-- checks to see if the player is near a bunker and gives him help text
function OBJ_MB_StartCheck()
	for i = 1, table.getn(eg_bunker_spawn) do 
		if Player_CanSeeEGroup(player1, eg_bunker_spawn[i], ANY) 
		and g_BunkerTakenNIS_Finished == 1 
		and EGroup_IsOnScreen(player1, eg_bunker_spawn[i], ANY, 0.8) then
			HintMouseover_Add(219571, t_obj_mb_mgr.egroups[i], 8, true)
			Util_StartIntel(EVENTS.OBJ_MB_START)
			t_obj_mb_mgr.spotted[i] = true
			Rule_AddInterval(OBJ_MB_CompleteCheck, 1.2)
			Rule_AddInterval(OBJ_MB_CheckBunkerDestroyed, 0.7)
			Rule_RemoveMe()
			break
		end
	end
end



function OBJ_MB_AddNewObj()
	if Event_IsAnyRunning() == false then
		Objective_Start(OBJECTIVE_MilitaryBunkers, true)
		Rule_RemoveMe()
	end
end

function OBJ_MB_CheckBunkerDestroyed()
	for i = 1, table.getn(t_obj_mb_mgr.egroups) do 
		if t_obj_mb_mgr.destroyed[i] == false then
			if EGroup_IsEmpty(t_obj_mb_mgr.egroups[i]) then
				t_obj_mb_mgr.destroyed[i] = true
				OBJECTIVE_MilitaryBunkers.BunkersDestroyed = OBJECTIVE_MilitaryBunkers.BunkersDestroyed + 1
				
				-- if the objective is started then set the counter for the bunker destroyed, and remove the ping, otherwise start the objective
				-- after the first bunker is destroyed
				if Objective_IsStarted(OBJECTIVE_MilitaryBunkers) then
					Objective_SetCounter(OBJECTIVE_MilitaryBunkers, OBJECTIVE_MilitaryBunkers.BunkersDestroyed, t_obj_mb_mgr.total_bunkers)
					if OBJECTIVE_MilitaryBunkers.PingID[i] ~= nil then
						Objective_RemoveUIElements(OBJECTIVE_MilitaryBunkers, OBJECTIVE_MilitaryBunkers.PingID[i])
						HintMouseover_Remove(219571, t_obj_mb_mgr.egroups[i])
						EventCue_Create(CUE.NORMAL, 219196, 219196, t_obj_mb_mgr.pos[i])
					end
				elseif Rule_Exists(OBJ_MB_AddNewObj) == false then
					Rule_AddInterval(OBJ_MB_AddNewObj, 0.5)
				end
				
				-- tell the player that it was destroyed, since the building sometimes looks a bit "undestroyed,"
				-- but only if it isn't the last one that has been taken out.
				if OBJECTIVE_MilitaryBunkers.BunkersDestroyed < t_obj_mb_mgr.total_bunkers then
					Util_StartStinger(EVENTS.OBJ_MB_BUNKER_DESTROYED)
				end
			
			-- assuming that the egroup does exist because it is not empty...
			else
				if EGroup_GetAvgHealth(t_obj_mb_mgr.egroups[i]) < 0.8 then
					EGroup_Kill(t_obj_mb_mgr.egroups[i])
				elseif t_obj_mb_mgr.spotted[i] == false then
					if EGroup_IsOnScreen(player1, t_obj_mb_mgr.egroups[i], ANY, 0.8) then
				
						if Objective_IsStarted(OBJECTIVE_MilitaryBunkers) then
							OBJECTIVE_MilitaryBunkers.PingID[i] = Objective_AddUIElements(OBJECTIVE_MilitaryBunkers, t_obj_mb_mgr.egroups[i], true, 219571, true)
						end
						
						Util_StartStinger(EVENTS.OBJ_MB_BUNKER_SPOTTED)
						EventCue_Create(CUE.MAP, 219197, 219197, t_obj_mb_mgr.egroups[i])
						t_obj_mb_mgr.spotted[i] = true
					end
					
				-- add pings to any bunkers that have been spotted, but before the objective started (as long as they are not destroyed)
				else 
					if Objective_IsStarted(OBJECTIVE_MilitaryBunkers)
					and OBJECTIVE_MilitaryBunkers.PingID[i] == nil then
						OBJECTIVE_MilitaryBunkers.PingID[i] = Objective_AddUIElements(OBJECTIVE_MilitaryBunkers, t_obj_mb_mgr.egroups[i], true, 219571, true)
						-- remove any respective hint points
						HintMouseover_Remove(219571, t_obj_mb_mgr.egroups[i])
					end
				end
			end
		end
	end
end

function OBJ_MB_CompleteCheck()
	if Objective_IsStarted(OBJECTIVE_MilitaryBunkers) == false then
		return
	end
	if OBJECTIVE_MilitaryBunkers.BunkersDestroyed < t_obj_mb_mgr.total_bunkers then
		return
	end
	
	Objective_Complete(OBJECTIVE_MilitaryBunkers, true)
	Util_StartIntel(EVENTS.OBJ_MB_COMPLETE)
	
	Rule_RemoveMe()
	Rule_Remove(OBJ_MB_CheckBunkerDestroyed)
end

EVENTS.OBJ_MB_START = function()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211335)
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211338)
	CTRL.WAIT()
end

t_bunkers_spotted = {211324, 211326, 211328}
EVENTS.OBJ_MB_BUNKER_SPOTTED = function ()
	local speech = t_bunkers_spotted[World_GetRand(1, table.getn(t_bunkers_spotted))]
	Actor_PlaySpeechWithoutPortrait(ACTOR.GenericAlly, speech)
end

EVENTS.OBJ_MB_COMPLETE = function ()
	CTRL.Actor_PlaySpeech(ACTOR.Conti, 211322)
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech(ACTOR.Conti, 211323)
	CTRL.WAIT()
end

t_bdestroyed_axis = {212190, 212191, 212192, 212193, 212194, 212195, 212196, 212197, 212198, 212199, 212200, 212201}
EVENTS.OBJ_MB_BUNKER_DESTROYED = function ()
	local speech = t_bdestroyed_axis[World_GetRand(1, table.getn(t_bdestroyed_axis))]
	Actor_PlaySpeechWithoutPortrait(ACTOR.GenericAxis, speech)
end

-------------------------------------------------------------------------
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- MEDAL OPPORTUNITY: Clear Dog Red
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------------------------------------------------------
function Initialize_OBJECTIVE_DogRed()
	OBJECTIVE_DogRed =
	{
		SetupUI = function()
			Objective_AddUIElements(OBJECTIVE_DogRed, mkr_prox_dog_red, true, false)
			Rule_AddOneShot(OBJ_DR_PermanentTitle, g_SHOW_ARROW_TIME)
		end,
		OnStart = function()
			OBJ_DR_Start()
		end,
		OnComplete = function()
			--[[ AUTOSAVE ]]
--~ 			g_AUTOSAVE = 219353
--~ 			if Rule_Exists(M01_AutosaveDelay) == false then
--~ 				Rule_AddOneShot(M01_AutosaveDelay, g_AUTOSAVE_DELAY)
--~ 			end
			
			Objective_SetAlwaysShowDetails(OBJECTIVE_DogRed, false, false)
		end,
		OnFail = function()
			
		end,
		OnSitRep = function()
			
		end,
		
		Title 			= 219200,
		Description 	= 219201,
		Type 			= OT_Medal,
		MedalID			= MEDALS.EXPERT_INFANTRYMAN_BADGE,
		Icon 			= IT_M_Default,
		MarkerProx 		= Marker_GetTable("mkr_prox_dog_red%d"),
	}
	Objective_Register(OBJECTIVE_DogRed)
end
-------------------------------------------------------------------------

function OBJ_DR_PermanentTitle()
	Objective_SetAlwaysShowDetails(OBJECTIVE_DogRed, true, false)
end

function OBJ_DR_AddNewObj()
	for i = 1, table.getn(OBJECTIVE_DogRed.MarkerProx) do
		SGroup_Clear(sg_temp)
		Player_GetAllSquadsNearMarker(player1, sg_temp, OBJECTIVE_DogRed.MarkerProx[i])
		if SGroup_IsEmpty(sg_temp) == false then
			Rule_RemoveMe()
			Objective_Start(OBJECTIVE_DogRed, true)
			break
		end
	end
end

function OBJ_DR_Start()
	Util_StartIntel(EVENTS.OBJ_DR_START)
	Rule_AddInterval(OBJ_DR_ReinforcementsCheck, 4)
	Rule_AddInterval(OBJ_DR_CompleteCheck, 1.3)
end

function OBJ_DR_ReinforcementsCheck()
	Player_GetAllSquadsNearMarker(player1, sg_temp, mkr_prox_dog_red)
	if SGroup_IsEmpty(sg_temp) == false and SGroup_IsEmpty(sg_dr_mobile_def) == false then
		Cmd_AttackMove(sg_dr_mobile_def, mkr_prox_dog_red)
	end
end

function OBJ_DR_CompleteCheck()
	if SGroup_IsEmpty(Axis_MGNest_DogRed) then
		EGroup_InstantCaptureStrategicPoint(Flag_LG_BeachExit, player1)
	end
	
	if SGroup_IsEmpty(sg_dog_red_defense) then
		EGroup_InstantCaptureStrategicPoint(Flag_LH_Clifftop, player1)
	end
	
	if Player_OwnsEGroup(player1, Flag_LG_BeachExit) and Player_OwnsEGroup(player1, Flag_LH_Clifftop) then
		Objective_Complete(OBJECTIVE_DogRed, true)
		Util_StartIntel(EVENTS.OBJ_DR_COMPLETE)
		Rule_RemoveMe()
		Rule_Remove(OBJ_DR_ReinforcementsCheck)
		EGroup_InstantCaptureStrategicPoint(eg_reinforce_dog_red, player1)
	end
end

EVENTS.OBJ_DR_START = function()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211044)
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211046)
	CTRL.WAIT()
end

t_dr_complete = { 211050,  211052}
EVENTS.OBJ_DR_COMPLETE = function()
	CTRL.Actor_PlaySpeech(ACTOR.McKay, t_dr_complete[World_GetRand(1, table.getn(t_dr_complete))])
	CTRL.WAIT()
end


--------------------------------------------------------------------------------------------------------------------------------------------------
-- OBJECTIVE FUNCTIONS
--------------------------------------------------------------------------------------------------------------------------------------------------

function Rule_KillNPCsAtShingle()
	Player_GetAllSquadsNearMarker(player3, sg_temp3, mkr_npc_kill_zone)
	SGroup_RemoveGroup(sg_temp3, NPC_Cowering)
	KillNPCsUnjustly(sg_temp3, true)
	
	for i = 1, table.getn(table_ShingleMarkers_Rect) do
		Player_GetAllSquadsNearMarker(player3, sg_temp3, table_ShingleMarkers_Rect[i])
		KillNPCsUnjustly(sg_temp3, false)
	end		
end

-- this checks to make sure that the player is not hoarding squads on the beach
-- instead of completing the objective
function Rule_CheckTotalPlayerSquads()
	Player_GetAll(player1, sg_total_playersquads)
	SGroup_Filter(sg_total_playersquads, SBP_ALLIED_ENGINEER_M01, FILTER_REMOVE)
	
	-- check to see if the player has more than 50 squads
	if SGroup_TotalMembersCount(sg_total_playersquads) >= 50 then
		-- remove the squads that are already at the shingle so that they do not get killed
		-- as that would look bad to the player
		for i = 1, table.getn(table_ShingleMarkers_Rect) do
			Player_GetAllSquadsNearMarker(player1, sg_too_many_squads, table_ShingleMarkers_Rect[i])
			SGroup_RemoveGroup(sg_total_playersquads, sg_too_many_squads)
		end
		
		if Rule_Exists(Rule_KillRandomSquad) then
			return
		end
		
		SGroup_Clear(sg_kill_squads)
		SGroup_AddGroup(sg_kill_squads, sg_total_playersquads)
		
		-- get a random number of squads from the player and put them in a new sgroup;
		-- these are the squads that will be executed
		while SGroup_TotalMembersCount(sg_kill_squads) > 25 do
			SGroup_Remove(sg_kill_squads, SGroup_GetRandomSpawnedSquad(sg_kill_squads))
		end
		
		Rule_AddInterval(Rule_KillRandomSquad, 0.5)
	elseif Rule_Exists(Rule_KillRandomSquad) then
		Rule_Remove(Rule_KillRandomSquad)
	end
end

function Rule_KillRandomSquad()
	if SGroup_IsEmpty(sg_kill_squads) then
		Rule_RemoveMe()
		return
	end
	
	SGroup_Clear(sg_temp2)
	SGroup_Add(sg_temp2, SGroup_GetRandomSpawnedSquad(sg_kill_squads))
	KillNPCsUnjustly(sg_temp2, true)
	
	if Rule_Exists(Rule_KillRandomSquad) then
		Rule_ChangeInterval(Rule_KillRandomSquad, (World_GetRand(1, 1000)/1000) * 0.5 + 0.5)
	end
end

function KillNPCsUnjustly(sg, use_mortar)
	if SGroup_IsEmpty(sg) == false then
		if SGroup_IsOnScreen(player1, sg, ANY, 0.9) == false then
			SGroup_Kill(sg)
		elseif use_mortar then
			Cmd_Ability(player1, ABILITY_SP_MORTARSTRIKE_M01, Squad_GetPosition(SGroup_GetRandomSpawnedSquad(sg)))
		end
	end
end

function Rule_AttackPlayerSquadsWithMGNest()
	Cmd_Attack(Axis_MGNest_DogWhite, table_PlayerSquads[1].sgroup)
	Rule_ChangeInterval(Rule_AttackPlayerSquadsWithMGNest, World_GetRand(3, 5))
end

function Rule_DelayMGNestAttack()
	SGroup_SetAutoTargetting(Axis_MGNest_DogWhite, "hardpoint_01", false)
	if g_AtShingleEventHasFinished == 1 then
		SGroup_SetAutoTargetting(Axis_MGNest_DogWhite, "hardpoint_01", true)
		Rule_RemoveMe()
	end
end

-- remove player squads for NIS
function Rule_NukePlayerSquads()
	if g_nukePlayerSquads == 1 then
		for i = 1, table.getn(table_PlayerSquads) do
			table_PlayerSquads[i].flag_spawned = 0
			table_PlayerSquads[i].flag_CheckRespawn = 0
			if SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false then
				
				table_PlayerSquads[i].veterancy = SGroup_GetVeterancyRank(table_PlayerSquads[i].sgroup)
				if SGroup_GetRandomSpawnedSquad(table_PlayerSquads[i].sgroup) ~= 0 then
					table_PlayerSquads[i].control_group = Misc_GetSquadControlGroup(SGroup_GetRandomSpawnedSquad(table_PlayerSquads[i].sgroup))
				end
				
				SGroup_WarpToMarker(table_PlayerSquads[i].sgroup, Marker_Respawn)
				SGroup_DestroyAllSquads(table_PlayerSquads[i].sgroup)
				
				print("Nuking player squads #"..i)
			end
		end
		
		-- remove NPCs from shingle area for NIS
		if flag_removeNPCsOnce ~= 1 then
			flag_removeNPCsOnce = 1
			-- also remove any NPC squads that are nearby on the shingle so they don't clutter the area
			for j = 1, table.getn(table_NPC_ALL) do
				if Prox_AreSquadMembersNearMarker(table_NPC_ALL[j].sgroup, Marker_Shingle_09, ANY) or Prox_AreSquadMembersNearMarker(table_NPC_ALL[j].sgroup, Marker_Shingle_10, ANY) or Prox_AreSquadMembersNearMarker(table_NPC_ALL[j].sgroup, Marker_Shingle_11, ANY) or Prox_AreSquadMembersNearMarker(table_NPC_ALL[j].sgroup, Marker_Shingle_12, ANY) then
					SGroup_WarpToMarker(table_NPC_ALL[j].sgroup, table_WaveSpawnMarkers[World_GetRand(1, table.getn(table_WaveSpawnMarkers))])
				end
			end
		end
		
		-- remove Sniper if the player has rescued him
		if g_sniperRescued == 1 then
			
			if SGroup_IsEmpty(NPC_Sniper) == false then
				g_SNIPER_VET = SGroup_GetVeterancyRank(NPC_Sniper)
				g_SNIPER_CGROUP = Misc_GetSquadControlGroup(SGroup_GetRandomSpawnedSquad(NPC_Sniper))
				
				if g_BunkerDestroyed ~= 1 then
					g_SniperPos = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Sniper)
					SGroup_DestroyAllSquads(NPC_Sniper)
				end
			end
		end
		
		-- destroy all of the player's squads, so that we can start fresh again
		SGroup_Clear(sg_temp)
		Player_GetAll(player1, sg_temp)
		SGroup_Filter(sg_temp, SBP.ALLIES.CAPTURE_88, FILTER_REMOVE)
		SGroup_DestroyAllSquads(sg_temp)
		
		if Rule_Exists(Rule_NukePlayerSquads) then
			Rule_RemoveMe()	
		end
	end
end

function M01_SetVeterancyAndControlGroup()

	for i = 1, table.getn(table_PlayerSquads) do 

		if SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false then
		
			if table_PlayerSquads[i].veterancy ~= nil 
			and table_PlayerSquads[i].veterancy ~= 0 then
				SGroup_IncreaseVeterancyRank(table_PlayerSquads[i].sgroup, table_PlayerSquads[i].veterancy, true)
			end
			
			if table_PlayerSquads[i].control_group ~= nil
			and table_PlayerSquads[i].control_group ~= -1 then
				Misc_SetSquadControlGroup(SGroup_GetRandomSpawnedSquad(table_PlayerSquads[i].sgroup), table_PlayerSquads[i].control_group)
			end
		end
		
	end

end

-- checks to see when the player has destroyed either of the Axis squads at the MG nests
function Rule_Objective_DestroyMGNest()
	for i = 1, table.getn(table_MGNests) do
		if flag_MGNestDestroyed ~= 1 and SGroup_TotalMembersCount(table_MGNests[i].sgroup1) == 0 and SGroup_IsEmpty(Axis_MG42_Flee) then
			HintMouseover_Remove(219505, Axis_MGNest_DogWhite)
			
			if g_GRENADE_HINT ~= nil then
				HintPoint_Remove(g_GRENADE_HINT)
				g_GRENADE_HINT = nil
			end
			
			if g_GRENADE_FLASH ~= nil then
				UI_StopFlashing(g_GRENADE_FLASH)
				g_GRENADE_FLASH = nil
			end
			
			flag_MGNestDestroyed = 1
			EGroup_InstantCaptureStrategicPoint(table_MGNests[i].territoryFlag, player1)			-- give player territory sector for clearing a beach exit
			Util_StartIntel(table_MGNests[i].event)																		-- play event - Dog Red/White is open!
			Rule_RemoveMe()
		end
	end
end

function runAbilityExecute()
	local squad = SGroup_GetSpawnedSquadAt( table_PlayerSquads[4].sgroup, 1 )
	
	Rule_AddSquadEvent( Rule_Objective_DestroyBunker_Delay, squad, GE_AbilityExecuted )
	for i = 1, Squad_Count(squad) do
		local entity = Squad_EntityAt(squad, i - 1)
		Rule_AddEntityEvent(Rule_OBJ_DB_SatchelProj, entity, GE_ProjectileFired)
	end
	g_checkingForSatchel = 1
end


--------------------------------------
-- UI FUNCTIONS
--------------------------------------
function Toggle_UnitHighlight(sgroup, bln_value)
	if t_sg_highlight == nil then
		t_sg_highlight = {}
	end
	
	local found = false
	local i = 1
	while( i <= table.getn(t_sg_highlight) ) do
		local removed = false
		if t_sg_highlight[i] == sgroup then
			if bln_value then
				found = true
			else
				print("Removing Squad from List")
				table.remove(t_sg_highlight, i)
				
				removed = true
			end
		end
		
		if( not removed) then
			i = i + 1
		end
	end
	
	if not found and bln_value then
		table.insert(t_sg_highlight, sgroup)
	end
	
	if Rule_Exists(Rule_UnitHighlight) == false then
		Rule_AddInterval(Rule_UnitHighlight, 5)
	end
end

function Rule_UnitHighlight()
	if table.getn(t_sg_highlight) == 0 then
		Rule_RemoveMe()
	end
	for i = 1, table.getn(t_sg_highlight) do 
		UI_HighlightSGroup(t_sg_highlight[i], 7)
	end
end


function Rule_ClearNPCs_N01_03()
	if g_BunkerTakenNIS_Finished == 1 then
		if g_sniperRescued == 1 then
			SGroup_SetInvulnerable(NPC_Sniper, false)
		end
		Rule_RemoveMe()
	else
		NPC_N01_N03_Clear = SGroup_CreateIfNotFound("NPC_N01_N03_Clear")
		Player_GetAllSquadsNearMarker(player3, NPC_N01_N03_Clear, Marker_N01_03_Clear)
--		SGroup_Kill(NPC_N01_N03_Clear)
		SGroup_DestroyAllSquads(NPC_N01_N03_Clear)
	end
end

function Rule_ClearNPCs_N01_02()
	if g_AtShingleEventHasFinished == 1 then
		Rule_RemoveMe()
	else
		NPC_N01_02_Clear = SGroup_CreateIfNotFound("NPC_N01_02_Clear")
		Player_GetAllSquadsNearMarker(player3, NPC_N01_02_Clear, Marker_N01_03_Clear)
		if SGroup_ContainsSGroup(NPC_N01_02_Clear, Player_NIS_Engineers_01, ANY) then
			print("Removing Engineers from NPC_N01_02_Clear group!")
			SGroup_RemoveGroup(NPC_N01_02_Clear, Player_NIS_Engineers_01)
		end
--		SGroup_Kill(NPC_N01_N02_Clear)
		if SGroup_IsEmpty(NPC_N01_02_Clear) == false then
			print("Despawning NPCs in NIS area!")
			SGroup_DestroyAllSquads(NPC_N01_02_Clear)
		end
	end
end

-- after all 88's are destroyed and bunker is destroyed, mission is over
function Rule_MissionComplete()
	if g_allObjectivesComplete == 0 
	and Objective_IsComplete(OBJECTIVE_Destroy88s) then
		g_allObjectivesComplete = 1
		
		Util_StartNIS(EVENTS.MissionComplete)
		Rule_Add(M01_EndMission)
		
		if Objective_IsStarted(OBJECTIVE_DogRed) == false 
		or Objective_IsComplete(OBJECTIVE_DogRed) == false then
			Objective_Fail(OBJECTIVE_DogRed, false)
		end
		
		if Objective_IsStarted(OBJECTIVE_MilitaryBunkers) == false
		or Objective_IsComplete(OBJECTIVE_MilitaryBunkers) == false then
			Objective_Fail(OBJECTIVE_MilitaryBunkers, false)
		end
		
		-- get all player2 squads and tell them to retreat to the edge of the map
		Player_GetAll(player2, Axis_ALL)
		Cmd_Retreat(Axis_ALL, EGroup_GetPosition_EVEN_IF_EMPTY(Axis_MapEntryPoint))
		Rule_Remove(Rule_Axis_KeepPressureOn)

		-- disable the fow, so that the player can see what's going on 
		-- around the 88.
		FOW_Enable(false)

		for i = 1, table.getn(table_PlayerSquads) do 
			if SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false then
				Cmd_Stop(table_PlayerSquads[i].sgroup)																		-- tell player squads to stop attacking if they are
				Ceasefire_AddSGroup(table_PlayerSquads[i].sgroup)																-- tell Player Squads not to fire either
			end
		end
	end
end

function M01_EndMission()
	if g_MissionComplete == true then
		Player_GetAll(player2, Axis_ALL)
		SGroup_DestroyAllSquads(Axis_ALL)
		
		-- Count up Allied casualties for mission win screen
		g_totalAlliedCasualties = Stats_InfantryLost( player1 )														-- tally player 1 deaths
		g_totalAlliedCasualties = g_totalAlliedCasualties + Stats_InfantryLost( player3 )							-- tally player 3 deaths
		local text = Loc_FormatText(219600, Loc_ConvertNumber(g_totalAlliedCasualties))
		
		Game_EndSP(true, text, true)
		Rule_RemoveAll()
	end
end

-- checks to see when player is near 88s, so squad can be respawned
function Rule_PlayerIn88Area()
	if Player_AreSquadsNearMarker(player1, Marker_Near88s) then
		g_PlayerIn88Area = 1
		Util_StartIntel(EVENTS.Ridge88s)
		Rule_RemoveMe()
	end
end

--------------------------------------------------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------------------------------------------
-- ENGINEERS BLOW WIRE AT SHINGLE
--------------------------------------------------------------------------------------------------------------------------------------------------

-- blow up wire at the right time in NIS (or right away if player has skipped NIS)
function Rule_Engineers_BlowWire()
	if g_TimerStarted_BlowWire == 1 and ( Timer_GetRemaining(Timer_BlowWire) == 0 or g_blowWire == 1) then
--	if g_blowWire == 1 then
	-- brw 04/27/06 removed at request of NIS team (wall should be destroyed in NIS)
--~ 		Cmd_Ability(player1, ABILITY_SP_ARTILLERY_M01_SINGLE, Marker_GetPosition(Marker_ShingleArtillery))		-- call in mortar strike in place of bangalores
		
		g_wireBlown = 1
		
		HintMouseover_Add(219505, Axis_MGNest_DogWhite, 10, true)
--~ 		HintPoint_MGNest_DogWhite = HintPoint_Add(Axis_MGNest_DogWhite, true, 219505)
		
		SGroup_SetInvulnerable(Axis_MGNest_DogRed, false, -1)																			-- remove invulnerability on MG nest

		Modify_Vulnerability(Axis_MGNest_DogRed, 2.5)																				-- start rule to make an NPC squad rush the MG nest and get slaughtered (to show player why rushing MGs is baaad)
		print("blowing wire now!")																						-- start reinforcing/respawning Engineer squad
		if Rule_Exists(Rule_Start_Objective_DestroyMGNest) == false then
			Rule_AddInterval(Rule_Start_Objective_DestroyMGNest, 1)																		-- give Engineers back to player now that wire is blown
		end
	
		Rule_BlowLeftShingle()																							-- start rule to blow left hand side of shingle after player has blown theirs
		Rule_RemoveMe()
	end
end

-- calls artillery down on left hand side of shingle to blow that open after player has blown theirs
function Rule_BlowLeftShingle()
--~ 	Cmd_Ability(player1, ABILITY_SP_ARTILLERY_M01_SINGLE, Marker_GetPosition(Marker_ShingleArtillery_02))		-- call in mortar strike in place of bangalores
	World_DestroyWallsNearMarker(Marker_ShingleArtillery_02)
	EGroup_Kill(eg_dr_barbed_wire)
end


-- add objective to destroy MG nest
function Rule_Start_Objective_DestroyMGNest()
	if g_AtShingleEventHasFinished == 1 and SGroup_IsEmpty(table_PlayerSquads[1].sgroup) == false then
		--[[ AUTOSAVE ]]
--~ 		g_AUTOSAVE = 219351
--~ 		if Rule_Exists(M01_AutosaveDelay) == false then
--~ 			Rule_AddOneShot(M01_AutosaveDelay, g_AUTOSAVE_DELAY)
--~ 		end	
		
		-- start checking for the player's grenade ability, and give them a flashing button and hint
		if Rule_Exists(Rule_InfantryGrenadeHint) == false then
			Rule_AddInterval(Rule_InfantryGrenadeHint, 1.2)
		end
--~ 		runAbilityExecute_Grenades()			
		SGroup_SetInvulnerable(Axis_MGNest_DogWhite, false, -1)	-- remove invulnerability on MG nest
		SGroup_SetInvulnerable(Axis_MG42_Flee, false, -1)		-- remove invulnerability on MG nest
		Util_StartIntel(EVENTS.AssaultMGNest)
		Rule_Add(OBJ_DB_AddNewObjDelay)
		Rule_RemoveMe()
	end
end


function Rule_ReSetPlayerResources()
	-- start a timer for when to add more munitions
	if flag_startTimer_PlayerResourcesOnce ~= 1 then
		flag_startTimer_PlayerResourcesOnce = 1
		Timer_Start(Timer_PlayerResources, 15)
	end
	
	-- if player has no munitions and hasn't received any free in the last x seconds, give them another 100
	if Player_GetResource(player1, RT_Munition) <= 100 and Timer_GetRemaining(Timer_PlayerResources) == 0 then
		
		Timer_Start(Timer_PlayerResources, 12)
		Player_SetResource(player1, RT_Munition, 100)
		
		-- if player is attacking 88s and needs to use a satchel charge, make sure they have enough munitions to do so
		if g_BunkerDestroyed == 1 then
			Player_SetResource(player1, RT_Munition, 200)
		end
	
	end
	
	-- if player is at the bunker and needs to use a satchel charge, make sure they have enough munitions to do so
	if g_BunkerDestroyed ~= 1 and Player_GetResource(player1, RT_Munition) < 200 then
		Player_SetResource(player1, RT_Munition, 200)
	end
end


--------------------------------------------------------------------------------------------------------------------------------------------------














-------------------------------------------------------------------------------------------------------------------------------------------------
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- REINFORCEMENT
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-------------------------------------------------------------------------------------------------------------------------------------------------

function Rule_NoPlayerSquadsExist()
	if g_NO_SQUADS_EXIST == nil then
		g_NO_SQUADS_EXIST = "Rule_NoPlayerSquadsExist"
	end
	
	if SGroup_IsEmpty(table_PlayerSquads[1].sgroup) 
	and Timer_GetRemaining(g_NO_SQUADS_EXIST) <= 0 then
		--[[ DIALOGUE ]]
		Util_StartIntel(EVENTS.NoPlayerSquads)
		Timer_Start(g_NO_SQUADS_EXIST, 30)
	end
	
	-- this code checks to see if the player has lost all his squads
	-- and looks at the player's camera to see if an existing squad is onscreen
	-- then highlights that squad for the player
	if SGroup_IsEmpty(table_PlayerSquads[1].sgroup) 
	and g_NO_PLAYER_SQUADS_HP == nil 
	and SGroup_IsEmpty(sg_no_player_squads) then
		SGroup_Clear(sg_temp3)
		
		local pos = Camera_GetTargetPos()
		Player_GetAllSquadsNearMarker(player3, sg_temp3, pos, 15)
		SGroup_RemoveGroup(sg_temp3, NPC_Flamethrower_01)
		SGroup_RemoveGroup(sg_temp3, NPC_Flamethrower_02)
		SGroup_RemoveGroup(sg_temp3, NPC_Flamethrower_03)
		
		-- if nobody is on screen that we can use, then stop
		if SGroup_IsEmpty(sg_temp3)  then
			return
		end
			
		SGroup_Add(sg_no_player_squads, SGroup_GetRandomSpawnedSquad(sg_temp3))
		
		if SGroup_IsEmpty(sg_no_player_squads) == false then
			print("Rule_NoPlayerSquadsExist: Found a Squad!")
			g_NO_PLAYER_SQUADS_HP = HintPoint_Add(sg_no_player_squads, true, 219502)
			SGroup_SetInvulnerable(sg_no_player_squads, true, 10)
			Cmd_Stop(sg_no_player_squads)
			Camera_MoveToSGroup(sg_no_player_squads, true, SLOW_CAMERA_PANNING)
			UI_HighlightSGroup(sg_no_player_squads, 10)
			
--~ 			Rule_RemoveMe()
		end
	end
end

EVENTS.NoPlayerSquads = function()
	CTRL.Actor_PlaySpeech(ACTOR.Conti, 210885)
	CTRL.WAIT()
end

-- respawn player's squads if killed
function Rule_RespawnPlayerSquads()
	-- check if we should actually commission an additional squad, there should never be more than "7" squads
	-- unless there aren't any engineers for some reason
	if M01_ReinforcementTooManySquads() then
		return
	end
	
	-- modify vulnerability of squad based on how many members it has (to make it easier for the player to keep squads alive)
	for i = 1, table.getn(table_PlayerSquads) do
		local currentcount = SGroup_TotalMembersCount(table_PlayerSquads[i].sgroup)
		
		-- if the squad count has dropped...
		if flag_AtTheShingle ~= 1 
		and table_PlayerSquads[i].flag_spawned == 1 
		and table_PlayerSquads[i].flag_CheckRespawn == 1 
		and (currentcount < table_PlayerSquads[i].lastcount) and currentcount ~= 0 then
			
			-- remove any previous modifiers
			if table_PlayerSquads[i].modifiers ~= nil then
--~ 					Modifier_Remove(table_PlayerSquads[i].modifiers)											-- UNCOMMENT WHEN BUG FIXED
--~ 					Modifier_RemoveAllFromSGroup(table_PlayerSquads[i].sgroup) 
			end
			
			-- apply the new modifiers (and store the ModIDs for later), varying the modifiers based on the number of times the player has respawned
			if g_anySquadsAtShingle ~= 1 then
				table_PlayerSquads[i].modifiers = Modify_ReceivedAccuracy(table_PlayerSquads[i].sgroup, table_VulnerabilityModifiers[currentcount])
			elseif g_anySquadsAtShingle == 1 then
				table_PlayerSquads[i].modifiers = Modify_ReceivedAccuracy(table_PlayerSquads[i].sgroup, table_VulnerabilityModifiers_Harder[currentcount])
			end
			
			-- make a note of the new member count
			table_PlayerSquads[i].lastcount = currentcount	
		end
		
		-- if player is at the shingle, stop respawning their squad and modifying vulnerability
		if flag_RemoveRuleOnce ~= 1 and flag_AtTheShingle == 1 then
			for i = 1, table.getn(table_PlayerSquads) do
				if table_PlayerSquads[i].modifiers ~= nil then
					Modifier_Remove(table_PlayerSquads[i].modifiers)							-- UNCOMMENT WHEN BUG FIXED
				end
			end
			flag_RemoveRuleOnce = 1
--				Rule_RemoveMe()
		end
		
		-- if one of the player's squads dies, respawn it back at the start
		if table_PlayerSquads[i].flag_CheckRespawn == 1 
		and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) then
			print("<>!<>!<>! Running through the list of squads to respawn")
			-- figure out where to respawn player based on how far they've made it so far
			if g_REINFORCE_ACTIVE == true then
				if i == 4 or i == 5 then
					M01_ReinforcementCommissionSquad(i, TYPE_ENGINEER)
				else
					M01_ReinforcementCommissionSquad(i, TYPE_RIFLEMAN)
				end
				print("<>!<>!<>! RUNNING REINFORCMENT VERSION 2")
			elseif g_OBJ_RE_STARTED == true and i == 4 then
				-- do nothing (hopefully) to the engineers
				-- let that be controlled by a different function altogether
			-- if near 88s, respawn near 88s
			elseif flag_AtTheShingle == 1 then
				print("<><> Player died between shingle and bunker, respawning behind camera and moving to Marker_Shingle_11, table entry: "..i)
				local pos = World_GetHiddenPositionOnPath(player1, Marker_Respawn, Marker_Shingle_11, CHECK_OFFCAMERA)
				if pos ~= nil then
					Util_CreateSquadsAtMarkerFacing(player1, table_PlayerSquads[i].sgroup, table_PlayerSquads[i].blueprint, pos, Marker_88s, 1)			-- spawn behind the camera and move to the shingle
--						Cmd_Move(table_PlayerSquads[i].sgroup, pos, true)
					Cmd_Move(table_PlayerSquads[i].sgroup, Marker_Shingle_11, true)
					print("<><> Player died between shingle and bunker, respawning behind camera and moving to Marker_Shingle_11, table entry: "..i) 
				else
					Util_CreateSquadsAtMarkerFacing(player1, table_PlayerSquads[i].sgroup, table_PlayerSquads[i].blueprint, Marker_Shingle_11, Marker_88s, 1)			-- spawn at the shingle
					print("<><> Player died between shingle and bunker, respawning at Marker_Shingle_11") 
				end
			end
			
			-- if there are any followers on this squad, remove them and tell them to stop moving (so they don't follow player squad back to spawn point)
			for j = 1, table.getn(table_NPC_Followers) do
				if table_NPC_Followers[j].flag_Following == 1 then
--						print("#### Player squad is dead, removing follower ####: "..j)
					Cmd_Stop(table_NPC_Followers[j].sgroup)
					SGroup_Clear(table_NPC_Followers[j].sgroup)
					table_NPC_Followers[j].flag_Following = 0
				end
			end
			
			-- create ping, set invulnerability, etc.
			table_PlayerSquads[i].ping = UI_CreateMinimapBlip(table_PlayerSquads[i].sgroup, 0, BT_GeneralPing)																		-- create minimap ping on new squad
			UI_HighlightSGroup(table_PlayerSquads[i].sgroup, 10)																																										-- flash selection circles to draw attention to squads																																			
			Cmd_Ability(table_PlayerSquads[i].sgroup, ABILITY_SP_ANIMTEST, nil, nil, true)																						-- make squad move faster
			-- increment counter, set move type and invulnerability
			numRespawns_Player = numRespawns_Player + 1																													-- increment counter for number of times the player's squad has respawned
			SGroup_SetMoveType(table_PlayerSquads[i].sgroup, MOVETYPE.FAST)																					-- set move type to fast
			SGroup_EnableSurprise(table_PlayerSquads[i].sgroup, false)																									-- turn off surprise so player's squads don't run backwards
			SGroup_SetInvulnerable(table_PlayerSquads[i].sgroup, false, -1)																								-- set SGroup to invulnerable
			
			if i == 4 then
				table_PlayerSquads[i].lastcount = 3																																			-- re-set count variable used for vulnerability modifier
			else
				table_PlayerSquads[i].lastcount = 6																																			-- re-set count variable used for vulnerability modifier
			end
			
			-- ignore this code if the Rescue Engineers objective is playing
			-- or if the secondary reinforcement rule is in effect.
			if g_OBJ_RE_STARTED == true or g_REINFORCE_ACTIVE == true then
				return
			end
			
			print("Rule_RespawnPlayerSquads: Engineers Died?")
			-- if this is the first time a player squad has respawned, yank the camera back to the spawn point
			if numRespawns_Player > 0 and flag_showRespawnOnce ~= 1 and g_anySquadsAtShingle ~= 1 then -- flag_AtTheShingle ~= 1 then
				Util_StartIntel(table_PlayerSquads[i].respawnSpeechEventFOCUS)																						-- play a speech event about it and focus on it
				flag_showRespawnOnce = 1
			else
				Util_StartIntel(table_PlayerSquads[i].respawnSpeechEvent)																									-- play a speech event about it
				
				if Rule_Exists(table_PlayerSquads[i].eventCueRule) == false and g_BunkerDestroyed ~= 1 then
					Rule_AddOneShot(table_PlayerSquads[i].eventCueRule, 4)
				end
				
				if i == 4 and g_checkingForSatchel == 1 then																															-- if the Engineers were died and we're waiting for them to throw a satchel
					if Rule_Exists(Rule_Objective_DestroyBunker_Delay) then
						Rule_Remove(Rule_Objective_DestroyBunker_Delay)
					end
					
					local squad = SGroup_GetRandomSpawnedSquad(table_PlayerSquads[i].sgroup, 1)
					Rule_AddSquadEvent( Rule_Objective_DestroyBunker_Delay, squad, GE_AbilityExecuted )
					
					for i = 1, Squad_Count(squad) do
						local entity = Squad_EntityAt(squad, i - 1)
						Rule_AddEntityEvent(Rule_OBJ_DB_SatchelProj, entity, GE_ProjectileFired)
					end
				end
			end
		end
	end
end



-- function to play event cue (this is a separate function so it can be delayed using Rule_AddOneShot)
function PlayEventCue_NewSquadAvailable()
	EventCue_Create(CUE.NORMAL, 219460, 219460, Marker_Shingle_11)
end

-- focus camera on newly spawned squad when the player clicks on the event cue
function EventCue_NewSquadAvailable()
	if g_anySquadsAtShingle ~= 1 then
		Camera_FocusOnTargetMarker(Marker_Respawn, 0)
	elseif flag_AtTheShingle ~= 1 then
		Camera_FocusOnTargetMarker(Marker_SquadRespawn_Focus, 0)
	elseif g_BunkerTakenNIS_Finished == 1 then
		Camera_FocusOnTargetMarker(Marker_Bunker, 0)
	elseif flag_AtTheShingle == 1 then
		Camera_FocusOnTargetMarker(Marker_DogWhite, 0)
	end
end


-- Auto Reinforce player squads  (used after the player gets to the shingle)
function Rule_AutoReinforce()
	function Rule_AutoReinforce_Staggered()
		local curr_i = 1
		for i = curr_i, table.getn(table_PlayerSquads) do
			-- store position of squad while its alive (used if entire squad is wiped out
			if table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_CheckRespawn == 1 and SGroup_TotalMembersCount(table_PlayerSquads[i].sgroup) > 0 then 
				table_ReinforcePositions[i] = SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup)
			end
			
			-- reinforce squad if less than max squad count
			if table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_CheckRespawn == 1 and table_PlayerSquads[i].flag_AtShingle == 1 and SGroup_TotalMembersCount(table_PlayerSquads[i].sgroup) < table_PlayerSquads[i].squadcount and SGroup_TotalMembersCount(table_PlayerSquads[i].sgroup) ~= 0 then
				local pos = World_GetHiddenPositionOnPath(player1, Marker_GetPosition(Marker_Respawn), SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup), CHECK_OFFCAMERA)
				if (pos ~= nil) then
					Cmd_InstantReinforceUnitPos(table_PlayerSquads[i].sgroup, 1, pos)
					print("reinforcing player squad:"..i)
					curr_i = i
				else
					Cmd_InstantReinforceUnitPos(table_PlayerSquads[i].sgroup, 1, Marker_GetPosition(Marker_Shingle_11))
					print("reinforcing player squad from Marker_Shingle_11: "..i)
					curr_i = i
				end
				
				-- set the interval until the rule would run next time
				if flag_RetreatFromBunker ~= 1 and flag_AtTheShingle == 1 then
					Rule_ChangeInterval(Rule_AutoReinforce_Staggered, World_GetRand(3, 5)/10)
				end
				
				-- stop the for loop now
				break
			end
		end
	end
	
	-- start the rule again
	Rule_AddInterval( Rule_AutoReinforce_Staggered, World_GetRand(3, 7) )
end

------------------------------------------------------------------
-- REINFORCEMENT Version 2 - bwood 04/20/06
------------------------------------------------------------------
-- Spawn squads at the beach, tell them to run up to the shingle
-- Make squads invulnerable while they are at and going to the shingle
-- If a player's squad dies, then take the current squad and bring him to the player's current playing point.
-- Fill in that squad's position from the sea (this should be easy to turn off)

function M01_ReinforcementSetup()
	TYPE_RIFLEMAN = 1
	TYPE_ENGINEER = 2
	
	t_reinforcement_mgr = {
		amount = g_REINFORCE_MAX,				-- number of available reinforcements at the shingle
		eng_percent = 0.55,						-- percentage that are engineers
		t_sgroup = table_SGReinforcements,		-- reinforcment table of sgroups
		t_sbp = {},								-- sbps to use for the reinforcements
		mkr_sp		= Marker_Shingle_11,			-- specific marker to spawn from the sea
		past_shingle = false,					-- if the player is at the shingle, then we don't want to move reinforcements there yet.
		reinforce_low = 1,						-- the threshold at which the reinforcements respawn
		mkr_npc_shingle = {},					-- the locations each of the sgroups occupy while at the shingle
		class = {},								-- type of sgroup stored at this location
		mkr_reinforce = mkr_bunker_reinforcement, -- markers the squads hang out at for reinforcement purposes
		event_cue_func = nil,					-- function that is called when the event cue is fired
		curr_squad_num = 1,						-- current squad number
		max_squads 		= 6						-- the number of squads the player is allowed to control after bunker is destroyed
	}
	
	local markers = Marker_GetTable("Marker_Shingle_%02d")
	for i=1, g_REINFORCE_MAX do 
		t_reinforcement_mgr.mkr_npc_shingle[i] = markers[(i*3)+2]
	end
	
	-- determines the number/type of SBPS based on a percent
	for i = 1, table.getn(t_reinforcement_mgr.t_sgroup) do 
		if i/table.getn(t_reinforcement_mgr.t_sgroup) < t_reinforcement_mgr.eng_percent then
			t_reinforcement_mgr.t_sbp[i] = SBP_ALLIED_ENGINEER_M01
			t_reinforcement_mgr.class[i] = TYPE_ENGINEER
		else
			t_reinforcement_mgr.t_sbp[i] = SBP_ALLIED_RIFLEMEN_M01
			t_reinforcement_mgr.class[i] = TYPE_RIFLEMAN
		end
		
		-- create the squads at the various locations along the shingle.
		Util_CreateSquadsAtMarkerFacing(player1, t_reinforcement_mgr.t_sgroup[i], t_reinforcement_mgr.t_sbp[i], t_reinforcement_mgr.mkr_npc_shingle[i], Marker_Bunker, 1)
	end
end

-- creates an additional two squads for the player to play with up at the shingle
function M01_ReinforcementInitialShingleSquads()
	local sbp = SBP_ALLIED_RIFLEMEN_M01
	local pos = World_GetHiddenPositionOnPath(player1, Marker_Respawn, Marker_Shingle_04, CHECK_OFFCAMERA)
	
	if pos ~= nil then
		Util_CreateSquadsAtMarker(player1, table_PlayerSquads[2].sgroup, sbp, pos, 1)
	else
		Util_CreateSquadsAtMarker(player1, table_PlayerSquads[2].sgroup, sbp, Marker_Shingle_04, 1)
	end
	
	M01_SquadSetCustomAttributes(table_PlayerSquads[2].sgroup, false)
	table_PlayerSquads[2].flag_CheckRespawn = 1
	table_PlayerSquads[2].flag_spawned = 1
end

function M01_ReinforcementInitialBunkerSquads()
	-- this is a total hack.  Basically, we're trying to create 5 squads that move up to the bunker
	-- and two of them need to be engineers squads.
	local sbp
	
	for i=2, 5 do
		-- we know it's the last one, so change their sbp to engineers
		if i == 5 then
			sbp = SBP_ALLIED_ENGINEER_M01
		else
			sbp = SBP_ALLIED_RIFLEMEN_M01
		end
		
		if i ~= 4 then
			local pos = World_GetHiddenPositionOnPath(player1, Marker_Respawn, Marker_Shingle_11, CHECK_OFFCAMERA)
			
			if pos ~= nil then
				Util_CreateSquadsAtMarker(player1, table_PlayerSquads[i].sgroup, sbp, pos, 1)
			else
				Util_CreateSquadsAtMarker(player1, table_PlayerSquads[i].sgroup, sbp, Marker_Shingle_11, 1)
			end
			
			M01_SquadSetCustomAttributes(table_PlayerSquads[i].sgroup, false)
			table_PlayerSquads[i].flag_CheckRespawn = 1
			table_PlayerSquads[i].flag_spawned = 1
		end
	end

	Cmd_Move(table_PlayerSquads[2].sgroup, mkr_bunker_reinforcement[1])
	Cmd_Move(table_PlayerSquads[3].sgroup, Marker_Shingle_04)
	Cmd_Move(table_PlayerSquads[5].sgroup, mkr_bunker_reinforcement[3])
	
	-- reset the veterancy and the control groups for all of the appropriate squads
	M01_SetVeterancyAndControlGroup()
end

function Rule_ReinforcementFirstMove()
	if Event_IsAnyRunning() == false then
		M01_ReinforcementInitialBunkerSquads()
		Rule_RemoveMe()
	end
end

function M01_ReinforcementCommissionSquad(player_squad_num, squad_type)
	local rand = World_GetRand(1, table.getn(t_reinforcement_mgr.t_sgroup))
	local sgroup = t_reinforcement_mgr.t_sgroup[rand]
	local sbp = SBP_ALLIED_RIFLEMEN_M01
	if squad_type == TYPE_ENGINEER then
		sbp = SBP_ALLIED_ENGINEER_M01
	end
	
	local sg_player = table_PlayerSquads[player_squad_num].sgroup
	t_reinforcement_mgr.curr_squad_num = player_squad_num
	
	local pos = World_GetHiddenPositionOnPath(player1, Marker_Beach_MoveTo, Marker_Shingle_11, CHECK_OFFCAMERA)
	
	if pos ~= nil then
		Util_CreateSquadsAtMarker(player1, sgroup, sbp, pos, 1)
	else
		Util_CreateSquadsAtMarker(player1, sgroup, sbp, Marker_Shingle_11, 1)
	end
	
	-- special case for squad that sits and waits at dog red
	if player_squad_num == 3 then
		Cmd_Move(sgroup, Marker_Shingle_04)
	else
		Cmd_Move(sgroup, mkr_bunker_reinforcement[2])
	end
	
	SGroup_SetPlayerOwner(sgroup, player1)
	
	-- orders the squad to move to a progressive location.
	SGroup_SetInvulnerable(sgroup, false)
	M01_ReinforcementSetAttributes(sgroup, true)
	SGroup_AddGroup(sg_player, sgroup)
	SGroup_Clear(sgroup)
	
	local text_num
	local funct
	if squad_type == TYPE_RIFLEMAN then
		text_num = 219460
	else
		text_num = 219465
	end
	
	-- create an event cue and give them a speech event as well
	UI_CreateEventCueClickable(CUE.NORMAL.icon, CUE.NORMAL.sound, text_num, text_num, M01_Reinforcement_CameraEvent, -1, false)		-- trigger an event cue about it
	Util_StartIntel(table_PlayerSquads[player_squad_num].respawnSpeechEvent)
end

function M01_Reinforcement_CameraEvent()
	local num = t_reinforcement_mgr.curr_squad_num
	Camera_MoveToSGroup(table_PlayerSquads[num].sgroup, false)
end

function M01_ReinforcementSetAttributes(sgroup, bUIIndicator)
	SGroup_SetSelectable(sgroup, bUIIndicator)
	SGroup_EnableUIDecorator(sgroup, bUIIndicator )
	SGroup_EnableMinimapIndicator(sgroup, bUIIndicator)
end

function M01_ReinforcementTooManySquads()
	if g_REINFORCE_ACTIVE == false then
		return false
	end

	sg_allsquads = SGroup_CreateIfNotFound("sg_allsquads")
	Player_GetAll(player1, sg_allsquads)
	
	if SGroup_IsEmpty(sg_allsquads) then
		return false
	end
	
	if SGroup_IsEmpty(sg_allsquads) == false then
		if SGroup_CountSpawned(sg_allsquads) < t_reinforcement_mgr.max_squads then
			return false
		end
		
		SGroup_Filter(sg_allsquads, SBP.ALLIES.SNIPER, FILTER_REMOVE)
		SGroup_Filter(sg_allsquads, SBP_ALLIED_ENGINEER_M01, FILTER_KEEP)
		if SGroup_IsEmpty(sg_allsquads) then
			return false
		end
	end
	
	return true
end


--------------------------------------------------
-- NPC Reinforcement
--------------------------------------------------

function NPCs_Stop()
	Player_GetAll(player3, sg_temp)
	SGroup_DestroyAllSquads(sg_temp)
	
	-- destroy all the medics that are on screen
	Player_GetAll(player3, eg_temp)
	EGroup_Filter(eg_temp, EBP_ALLIED_MEDIC, FILTER_KEEP)
	EGroup_DestroyAllEntities(eg_temp)
	
	-- Remove rules that would be running regarding the NPCs
	Rule_Remove(Rule_AutoReinforce_NPCs)
	Rule_Remove(Rule_AutoReinforce_NPCs_Staggered)
	Rule_Remove(Rule_NPC_Flamethrowers)
	Rule_Remove(Rule_NPC_FollowersMove)
	Rule_Remove(Rule_NPC_GetSuppressed)
	Rule_Remove(Rule_NPC_GetSuppressed_Staggered)
	Rule_Remove(Rule_NPC_JoinPlayerSquad)
	Rule_Remove(Rule_Player_ReSetSuppression)
	Rule_Remove(Rule_NPC_Medics)
	Rule_Remove(Rule_NPC_MoveUpInWaves)
	Rule_Remove(Rule_NPC_PotShots)
	Rule_Remove(Rule_NPC_PotShots_Movers)
	Rule_Remove(Rule_NPC_PotShots_ResumeMoving)
	Rule_Remove(Rule_NPC_PotShots_StopFiring)
	Rule_Remove(Rule_NPC_RestartWave_01)
	Rule_Remove(Rule_NPC_RestartWave_01_Staggered)
	Rule_Remove(Rule_NPC_RestartWave_02)
	Rule_Remove(Rule_NPC_RestartWave_03)
	Rule_Remove(Rule_NPC_SwitchAttackToPlayer)
	Rule_Remove(Rule_MGFire_NPC_CycleAttack)
	Rule_Remove(Rule_Mortars_AttackNPCs)
	Rule_Remove(Rule_Mortars_AttackNPCs_Restart)
	Rule_Remove(Rule_Mortars_AttackNPCs_Start)
	Rule_Remove(Rule_PlayAmbientSpeech)
	Rule_Remove(Rule_AmbientArtillery)
	Rule_Remove(Rule_SpeechEvent_FirstSelected)
	Rule_Remove(Rule_RemoveInvulnerability)
	
	-- stop the MGs from attacking the player.
	OBJ_DB_StopMGAttackPlayer()
end

-- reinforce all NPC squads as they get killed
function Rule_AutoReinforce_NPCs()
	NPC_AutoReinforce_Index = 1
	Rule_Add(Rule_AutoReinforce_NPCs_Staggered)
end
	
function Rule_AutoReinforce_NPCs_Staggered()
--~ 	print ("Checking reinforcement on: "..NPC_AutoReinforce_Index)
	
	if SGroup_IsEmpty(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup) == false
	and Squad_GetPlayerOwner(SGroup_GetSpawnedSquadAt(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, 1)) == player1 then
		print("Rule_AutoReinforce_NPCs_Staggered: Removing the NPC Group because it is owned by PLAYER ONE")
		SGroup_Clear(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup)
	end

	if SGroup_IsEmpty(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup) == false 
	and SGroup_TotalMembersCount(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup) < table_NPC_Cowering[NPC_AutoReinforce_Index].count then
		local pos = World_GetHiddenPositionOnPath(player1, Marker_GetPosition(Marker_Respawn), SGroup_GetPosition_EVEN_IF_EMPTY(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup), CHECK_OFFCAMERA)
		if (pos ~= nil) then
--			print ("@@@@ reinforcing NPC group from offscreen: "..NPC_AutoReinforce_Index)
			Cmd_InstantReinforceUnitPos(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, 1, pos)
		else
--			print ("@@@@ reinforcing NPC group at its position: "..NPC_AutoReinforce_Index)
			Cmd_InstantReinforceUnitPos(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, 1, SGroup_GetPosition_EVEN_IF_EMPTY(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup))
		end
	elseif SGroup_IsEmpty(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup) then																-- if the squad has been totally wiped out
		
	-- sometimes respawn from offscreen, sometimes all the way back at start marker
		local pos2 = World_GetHiddenPositionOnPath(player1, Marker_GetPosition(Marker_Respawn), table_NPC_Cowering[NPC_AutoReinforce_Index].startpos, CHECK_OFFCAMERA)

		if pos2 == nil then
			pos2 = table_NPC_Cowering[NPC_AutoReinforce_Index].startpos
		end
		
		Util_CreateSquadsAtMarker(player3, table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, table_NPC_Cowering[NPC_AutoReinforce_Index].blueprint, pos2, 1, table_NPC_Cowering[NPC_AutoReinforce_Index].count)			-- spawn a whole new one
		
		Cmd_Move(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, table_NPC_Cowering[NPC_AutoReinforce_Index].startpos)										-- give them a move order to the position it started at
		SGroup_SetMoveType(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, MOVETYPE.BEACH)																						-- set squad to special move type by default
		Modify_WeaponCooldown(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, "hardpoint_01", 15)																					-- Make NPCs take longer to shoot so they don't make so much noise at the shingle
		Modify_WeaponAccuracy(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, "hardpoint_01", 0.0)																					-- NPCs can't hit fish in a barrel
		Cmd_Ability(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, ABILITY_SP_ANIMTEST, nil, nil, true)																						-- make squad move faster
		SGroup_EnableUIDecorator( table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, false )																									-- turn off decorators on NPCs
		SGroup_EnableMinimapIndicator(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, false)
		
		if g_SELECT_ANY_SQUAD == false then
			SGroup_SetSelectable(table_NPC_Cowering[NPC_AutoReinforce_Index].sgroup, false)																					-- make all NPCs un-selectable so player can find their own troops more easily
		end
	end

	-- set the interval until the rule would run next time
--	Rule_ChangeInterval(Rule_AutoReinforce_NPCs_Staggered, World_GetRand(5, 1)/100)

	-- increase the index counter, and loop it if you reach the end of the table
	NPC_AutoReinforce_Index = NPC_AutoReinforce_Index + 1
	if (NPC_AutoReinforce_Index > table.getn(table_NPC_Cowering)) then
		NPC_AutoReinforce_Index = 1
	end
end

-- Continuously re-set the suppression on the player's squads to 0 so they can never be pinned
function Rule_Player_ReSetSuppression()
	for i = 1, table.getn(table_PlayerSquads) do
		if table_PlayerSquads[i].flag_spawned == 1 
		and table_PlayerSquads[i].flag_CheckRespawn == 1 
		and SGroup_GetSuppression(table_PlayerSquads[i].sgroup) >= 0.01 then					-- if player's squad is pinned
			SGroup_SetSuppression( table_PlayerSquads[i].sgroup, 0.0 )							-- lower suppression so they're not pinned anymore
		end
	end
	
	-- also re-set suppression on Dog White MG nest so it doesn't get suppressed by all the NPCs at the shingle
	if SGroup_IsEmpty(Axis_MGNest_DogWhite) == false and SGroup_GetSuppression(Axis_MGNest_DogWhite) > 0.01 then
		SGroup_SetSuppression(Axis_MGNest_DogWhite, 0.0)
	end
end

-- check suppression of enemy squads and increase vulnerability if pinned to offset the pinning bonuses
function Rule_CheckPinnedSquads()
	for i = 1, table.getn(table_PinnedAndVulnerable) do
		if SGroup_IsEmpty(table_PinnedAndVulnerable[i]) == false and SGroup_GetSuppression(table_PinnedAndVulnerable[i]) >= 0.37	then						-- if group is alive and pinned
			Modify_Vulnerability(table_PinnedAndVulnerable[i], 13.0)										-- jack up the vulnerability so squad dies faster
		end
	end
end

-- re-set suppression on cowering NPCs
function Rule_NPC_GetSuppressed()
	NPC_GetSuppressed_Index = 1
	Rule_AddInterval(Rule_NPC_GetSuppressed_Staggered,  World_GetRand(1, 3)/10)
end
	

function Rule_NPC_GetSuppressed_Staggered()
--	print ("Checking Suppression on: "..NPC_GetSuppressed_Index)
	if SGroup_IsEmpty(table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup) == false
	and Player_OwnsSGroup(player1, table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup) then
		print("Rule_NPC_GetSuppressed_Staggered: Removing the NPC Group because it is owned by PLAYER ONE")
		SGroup_Clear(table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup)
	end
	
	if table_NPC_Cowering[NPC_GetSuppressed_Index].flag_suppressedAtStart == 1 
	and SGroup_IsEmpty(table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup) == false 
	and SGroup_IsMoving(table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup, ANY) == false 
	and SGroup_GetSuppression(table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup) < 0.5 
	and Player_OwnsSGroup(player1, table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup) == false then
--~ 		SGroup_SetSuppression(table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup, 0.8)
		SGroup_SuggestPosture(table_NPC_Cowering[NPC_GetSuppressed_Index].sgroup, 0, 10)
--		print("re-setting suppression on NPC cowering squad: "..NPC_GetSuppressed_Index)
	end
	
	Rule_ChangeInterval(Rule_NPC_GetSuppressed_Staggered, World_GetRand(1, 3)/10)
		
	-- increase the index counter, and loop it if you reach the end of the table
	NPC_GetSuppressed_Index = NPC_GetSuppressed_Index + 1
	if (NPC_GetSuppressed_Index > table.getn(table_NPC_Cowering)) then
		NPC_GetSuppressed_Index = 1
	end
end


-- kills off additional NPC squads when they get close to shingle so 95% of NPCs don't make it to the shingle
function Rule_KillMoreNPCs()
	KillMoreNPCs_Index = 1
	Rule_AddInterval(Rule_KillMoreNPCs_Staggered, World_GetRand(1, 3)/10)
end

function Rule_KillMoreNPCs_Staggered()
	if g_BunkerTakenNIS_Finished == 1 then
		print ("player has destroyed bunker, stopping Rule_KillMoreNPCs_Staggered")
		Rule_RemoveMe()
		return
	end

	if table_NPC_Movers[KillMoreNPCs_Index].flag_DeadOrAtShingle == 0 and table_NPC_Movers[KillMoreNPCs_Index].flag_IsMoving == 1 then															-- if squad is still alive and moving
		local groupPos = SGroup_GetPosition_EVEN_IF_EMPTY(table_NPC_Movers[KillMoreNPCs_Index].sgroup)																												-- get current position
		local distanceToShingle = math.abs(groupPos.z - table_NPC_Movers[KillMoreNPCs_Index].shinglepos.z)																					-- compare distance to shingle

		if distanceToShingle < 10 and SGroup_IsOnScreen(player1, table_NPC_Movers[KillMoreNPCs_Index].sgroup, ANY) == false then											-- if squad is close to shingle and offscreen
			table_NPC_Movers[KillMoreNPCs_Index].flag_IsMoving = 0
			table_NPC_Movers[KillMoreNPCs_Index].flag_DeadOrAtShingle = 0
			table_NPC_Movers[KillMoreNPCs_Index].flag_respawned = 0
			numNPCsKilled = numNPCsKilled + 1
			SGroup_DestroyAllSquads(table_NPC_Movers[KillMoreNPCs_Index].sgroup)																																					-- kill it
--			print("Killing more NPCs - squad: "..KillMoreNPCs_Index)
		end
	end
	
	-- change interval so everyone doesn't move at once - slightly staggered movement
	Rule_ChangeInterval(Rule_KillMoreNPCs_Staggered, World_GetRand(2, 5)/100)
	
	-- increase the index counter, and loop it if you reach the end of the table
	KillMoreNPCs_Index = KillMoreNPCs_Index + 1
	if (KillMoreNPCs_Index > table.getn(table_NPC_Movers)) then
		KillMoreNPCs_Index = 1
	end
end

-- pick random cowering NPCs to fire back at bunker
function Rule_NPC_PotShots()
	-- choose random onscreen NPC random squad that's cowering
	NPC_Cowering_OnScreen = SGroup_CreateIfNotFound("NPC_Cowering_OnScreen")							-- create a temp sgroup for onscreen squads
	SGroup_Clear(NPC_Cowering_OnScreen)																								-- clear it to ensure it's empty
	Misc_GetAllPlayerSquadsOnScreen(player3, NPC_Cowering_OnScreen)													-- put all NPCs onscreen into a group
	SGroup_Intersection(NPC_Cowering_OnScreen, NPC_Cowering)															-- filter out everything except the cowering ones onscreen
	
	if SGroup_IsEmpty(NPC_Cowering_OnScreen) == false then
		PotShot_squadID = SGroup_GetRandomSpawnedSquad(NPC_Cowering_OnScreen)							-- pick random squad from the cowering NPCs onscreen
		NPC_PotShot = SGroup_CreateIfNotFound("NPC_PotShot")																	-- create temp group for this squad
		SGroup_Clear(NPC_PotShot)																													-- clear it to ensure it's empty
		SGroup_Add(NPC_PotShot, PotShot_squadID)																						-- add randomly picked squad
		
		-- if sgroup is stationary, shoot at a position in the air in the direction of the bunker
		if SGroup_IsMoving(NPC_PotShot, ANY) == false then
			local pos = Util_GetPositionFromAtoB(SGroup_GetPosition_EVEN_IF_EMPTY(NPC_PotShot), EGroup_GetPosition_EVEN_IF_EMPTY(Axis_Bunker), 20)
			pos.y = pos.y + 10
			NPC_PotShot_Suppression = SGroup_GetSuppression(NPC_PotShot)
			SGroup_SetSuppression(NPC_PotShot, 0.0)																					-- remove suppression so squad can always fire
			Command_SquadPos(player2, NPC_PotShot, SCMD_Attack, pos, false)
			Rule_AddOneShot(Rule_NPC_PotShots_StopFiring, 4.0)
			Rule_ChangeInterval(Rule_NPC_PotShots, World_GetRand(42, 45)/10)
--			print("ººººººº telling NPC squad to take a pot shot")
		end
	end
end
function Rule_NPC_PotShots_StopFiring()
	Cmd_Stop(NPC_PotShot)
	SGroup_SetSuppression(NPC_PotShot, NPC_PotShot_Suppression)														-- re-set suppression to whatever it was before
end


-- picks random moving NPCs to fire back at bunker
function Rule_NPC_PotShots_Movers()
	-- choose random onscreen NPC random squad that's moving
	NPC_Moving_OnScreen = SGroup_CreateIfNotFound("NPC_Moving_OnScreen")							-- create a temp sgroup for onscreen squads
	SGroup_Clear(NPC_Moving_OnScreen)																							-- clear it to ensure it's empty
	Misc_GetAllPlayerSquadsOnScreen(player3, NPC_Moving_OnScreen)												-- put all NPCs onscreen into a group
	SGroup_Intersection(NPC_Moving_OnScreen, NPC_Movers)															-- filter out everything except the moving ones onscreen
	
	if SGroup_IsEmpty(NPC_Moving_OnScreen) == false then
--		print ("ººººººº NPC_Moving_OnScreen has guys in it")
		PotShot_Mover_squadID = SGroup_GetRandomSpawnedSquad(NPC_Moving_OnScreen)							-- pick random squad from the cowering NPCs onscreen
		NPC_PotShot_Mover = SGroup_CreateIfNotFound("NPC_PotShot_Mover")																	-- create temp group for this squad
		SGroup_Clear(NPC_PotShot_Mover)																													-- clear it to ensure it's empty
		SGroup_Add(NPC_PotShot_Mover, PotShot_Mover_squadID)																						-- add randomly picked squad
		NPC_PotShot_Mover_Count = SGroup_TotalMembersCount(NPC_PotShot_Mover)
--		print("ººººººº SGroup count of NPC_PotShot_Mover is: "..NPC_PotShot_Mover_Count)
		
		-- if sgroup is stationary, shoot at a position in the air in the direction of the bunker
		local pos = Util_GetPositionFromAtoB(SGroup_GetPosition_EVEN_IF_EMPTY(NPC_PotShot_Mover), EGroup_GetPosition_EVEN_IF_EMPTY(Axis_Bunker), 20)
		pos.y = pos.y + 10
		Command_SquadPos(player2, NPC_PotShot_Mover, SCMD_Attack, pos, false)
		Rule_AddOneShot(Rule_NPC_PotShots_ResumeMoving, 4.0)
		Rule_ChangeInterval(Rule_NPC_PotShots_Movers, World_GetRand(42, 45)/10)
--		print("ººººººº telling NPC MOVER squad to take a pot shot")
	end
end
function Rule_NPC_PotShots_ResumeMoving()
	for i = 1, table.getn(table_NPC_Movers) do
		if SGroup_ContainsSGroup(NPC_PotShot_Mover, table_NPC_Movers[i].sgroup, ANY) then
			Cmd_Move(table_NPC_Movers[i].sgroup, table_NPC_Movers[i].shinglepos)													-- move to the shingle position you were moving to before we interruped you to fire a shot
		end
	end
end

-------------------------------------------------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------------------------------------------
-- BEACH ARTILLERY
--------------------------------------------------------------------------------------------------------------------------------------------------
-- debug function to drop barrage from hotkey at mouse cursor position
function Rule_DropArtilleryBarrage()
	print ("dropping artillery now!")
--	Cmd_Ability(player1, ABILITY_ARTILLERY, Misc_GetMouseOnTerrain())
--	Cmd_Ability(player1, ABILITY.SP_ARTILLERY_M01, Misc_GetMouseOnTerrain())
	Cmd_Ability(player1, ABILITY_SP_MORTARSTRIKE_M01, Misc_GetMouseOnTerrain())
end


-- starts mortar fire before first NIS ends
function Rule_Mortars_AttackNPCs_Start()
	if g_startNPCMortars == 1 and blah937348349 ~= 1 then
		print("Rule_Mortars_AttackNPCs_Start: Mortars")
		Timer_Start(Timer_NPCMortars, 10) -- start timer for when mortar and MG fire should start]
		Rule_AddInterval(Rule_StartMGNPCAttack, 2)
		table_StartMortars = {Marker_MortarStart_01, Marker_MortarStart_01, Marker_MortarStart_02, Marker_MortarStart_02, Marker_MortarStart_03, Marker_MortarStart_03, Marker_MortarStart_04, Marker_MortarStart_05, Marker_MortarStart_06}		-- create table of markers around player's starting position
		blah937348349 = 1
	end
	
	-- drop some mortars around player start position while letterbox is still on
	if g_startNPCMortars == 1 and Timer_GetRemaining(Timer_NPCMortars) == 0 and g_openingNISFinished ~= 1 then
		print("Rule_Mortars_AttackNPCs_Start: Dropping mortar near player start position!")
		Cmd_Ability(player1, ABILITY_SP_MORTARSTRIKE_M01, Marker_GetPosition(table_StartMortars[World_GetRand(1, table.getn(table_StartMortars))]))
		Rule_ChangeInterval(Rule_Mortars_AttackNPCs_Start, World_GetRand(15, 25)/10)
	end
	
	-- if opening NIS and titlecards are done, start real mortar fire vs. NPCs
	if g_openingNISFinished == 1 then
		print("Rule_Mortars_AttackNPCs_Start: g_openingNISFinished")
		Rule_AddInterval(Rule_Mortars_RandomWaterHits, 0.1)
		Rule_AddInterval(Rule_Mortars_AttackNPCs, 0.1)		
		Rule_RemoveMe()
	end
end


function Rule_StartMGNPCAttack()
	-- start MG fire vs. NPCs early - before NIS ends
	if g_startNPCMortars == 1 and Timer_GetRemaining(Timer_NPCMortars) == 0 then
		print("Rule_Mortars_AttackNPCs_Start: Starting MG fire now!")
		Rule_AddInterval(Rule_MGFire_NPC_CycleAttack, 0.1)																						-- start rule telling other bunkers to attack NPC's  <<<< RE-ADD after testing player mg fire
		Rule_RemoveMe()
	end
end

function Rule_Mortars_AttackNPCs()
	temp5 = SGroup_CreateIfNotFound("temp5")
	NPC_MortarTargets = SGroup_CreateIfNotFound("NPC_MortarTargets")
	NPC_Mortar_CurrentTarget = SGroup_CreateIfNotFound("NPC_Mortar_CurrentTarget")
	NPC_OnScreen_Mortars = SGroup_CreateIfNotFound("NPC_OnScreen_Mortars")																	-- create a temp sgroup for onscreen squads

	-- get all NPCs on screen
	SGroup_Clear(NPC_OnScreen_Mortars)																														-- clear it to ensure it's empty
	Misc_GetAllPlayerSquadsOnScreen(player3, NPC_OnScreen_Mortars)
		
	-- get all the NPCs inside the markers
	Player_GetAllSquadsNearMarker(player3, temp5, Marker_MortarZone)
	
	-- filter out only the NPCs that are onscreen and inside the markers
	SGroup_Intersection(temp5, NPC_OnScreen_Mortars)
	
	-- add these to a master list of all NPCs onscreen and inside markers
	SGroup_AddGroup(NPC_MortarTargets, temp5)
	
	-- pick a random squad from this master list (to fire the mortar at)
	if SGroup_IsEmpty(NPC_MortarTargets) == false then
		temp6 = SGroup_GetSpawnedSquadAt(NPC_MortarTargets, World_GetRand(1, SGroup_Count(NPC_MortarTargets)))
		SGroup_Clear(NPC_Mortar_CurrentTarget)
		SGroup_Add(NPC_Mortar_CurrentTarget, temp6)
	end
	
	-- if we've found a target, fire a mortar at him
	if flag_foundMortarTarget ~= 1 and SGroup_IsEmpty(NPC_Mortar_CurrentTarget) == false then
		flag_foundMortarTarget = 1
		if World_GetRand(1, 100) > 25 then																															-- occasionally decide to..
			mortarPos_NPC = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Mortar_CurrentTarget)																		-- adjust position of mortar strike by random fudge factor
			mortarPos_NPC.x = mortarPos_NPC.x + World_GetRand(-10, 10)
			mortarPos_NPC.z = mortarPos_NPC.z + World_GetRand(-10, 10)
		else
			mortarPos_NPC = SGroup_GetPosition_EVEN_IF_EMPTY(NPC_Mortar_CurrentTarget)																		-- otherwise, drop mortar right on squad
		end
		
		-- check to make sure NPC mortar is not going to land on top of a player squad
		for k = 1, table.getn(table_PlayerSquads) do
			if table_PlayerSquads[k].flag_spawned == 1 and table_PlayerSquads[k].flag_CheckRespawn == 1 and table_PlayerSquads[k].flag_AtShingle == 0 and World_DistancePointToPoint(mortarPos_NPC, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[k].sgroup)) < 10 then	-- if mortar is going to land too close to a player squad
				print("((((((( NPC mortar is going to land on player squad - adding more fudge factor! ))))))))")
				mortarPos_NPC.x = mortarPos_NPC.x + World_GetRand(-40, -20)
			end
		end
		
		Cmd_Ability(player1, ABILITY_SP_MORTARSTRIKE_M01, mortarPos_NPC)																		-- call in mortar strike on NPC squad
--~ 				print("_____________ dropping mortar now!!!!!")

		Rule_RemoveMe()
		local randomInterval = World_GetRand(15, 45)/10
		Rule_AddOneShot(Rule_Mortars_AttackNPCs_Restart, randomInterval)
	
	-- if we don't have a target, pick a random point onscreen to fire at (but only fire if point is also within mortar target zone)
	else
		local pos = Camera_GetTargetPos()
		if flag_dropMortarOnce == 0 and Marker_InProximity(Marker_MortarZone, pos) then
			flag_dropMortarOnce = 1
			pos.x = pos.x + World_GetRand(-30, 30)
			pos.z = pos.z + World_GetRand(-30, 30)
			
			-- check to make sure NPC mortar is not going to land on top of a player squad
			for k = 1, table.getn(table_PlayerSquads) do
				if table_PlayerSquads[k].flag_spawned == 1 and table_PlayerSquads[k].flag_CheckRespawn == 1 and table_PlayerSquads[k].flag_AtShingle == 0 and World_DistancePointToPoint(pos, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[k].sgroup)) < 10 then	-- if mortar is going to land too close to a player squad
					print("((((((( NPC mortar is going to land on player squad - adding more fudge factor! ))))))))")
					pos.x = pos.x + World_GetRand(-20, -8)
				end
			end

			Cmd_Ability(player1, ABILITY_SP_MORTARSTRIKE_M01, pos)																		-- call in mortar strike on random position
		
			Rule_RemoveMe()
			local randomInterval = World_GetRand(15, 45)/10
			Rule_AddOneShot(Rule_Mortars_AttackNPCs_Restart, randomInterval)
		end
	end
end


function Rule_Mortars_AttackNPCs_Restart()
	SGroup_Clear(NPC_MortarTargets)
	flag_foundMortarTarget = 0
	flag_dropMortarOnce = 0
	Rule_AddInterval(Rule_Mortars_AttackNPCs, 0.5)
end


-- look for stationary player squads to fire mortars at
function Rule_Mortars_FindPlayer()
	-- first check if player is in the mortar attack zone
	for i = 1, table.getn(table_PlayerSquads) do
		if table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_AtShingle == 0 and table_PlayerSquads[i].flag_CheckRespawn == 1 then
			if Prox_AreSquadMembersNearMarker(table_PlayerSquads[i].sgroup, Marker_MortarZone, ANY) then
--				print("Found a player squad in the Mortar Zone, squad number: "..i)
				table_PlayerSquads[i].flag_inMGFireMarkers = 1
			else
--				print("Player not in Mortar Zone, squad number: "..i)
				table_PlayerSquads[i].flag_inMGFireMarkers = 0
			end
		end
	end
	
	-- if player is in any of the mortar attack zones, then turn on the flag so the other rule can attack them
	for i = 1, table.getn(table_PlayerSquads) do
		-- if player is stationary inside the mortar zone, start firing mortars and start a timer used to make mortars home in
		if table_PlayerSquads[i].flag_inMGFireMarkers == 1 and table_PlayerSquads[i].flag_mortarTracking == 0 and table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_AtShingle == 0 and table_PlayerSquads[i].flag_CheckRespawn == 1 and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false and SGroup_IsMoving(table_PlayerSquads[i].sgroup, ANY) == false and SGroup_IsAttackMoving(table_PlayerSquads[i].sgroup, ANY) == false then
			table_PlayerSquads[i].flag_mortarTracking = 1														-- set flag so for loop doesn't start timer again
			Timer_Start(table_PlayerSquads[i].mortarTimer, 70)												-- start a timer if player is in the mortar zone
--~ 			print("flag_mortarTracking ="..table_PlayerSquads[i].flag_mortarTracking)
--~ 			print("~~~~ MORTARS TRACKING PLAYER ~~~~, table entry: "..i)
		
		-- if player is moving again, stop timer
		elseif table_PlayerSquads[i].flag_mortarTracking == 1 and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false and ( SGroup_IsMoving(table_PlayerSquads[i].sgroup, ANY) or SGroup_IsAttackMoving(table_PlayerSquads[i].sgroup, ANY) or table_PlayerSquads[i].flag_inMGFireMarkers == 0 ) then
			table_PlayerSquads[i].flag_mortarTracking = 0														-- turn off tracking flag
			Timer_End(table_PlayerSquads[i].mortarTimer)														-- stop timer
--~ 			print("~~~~ STOPPING MORTARS TRACKING PLAYER ~~~~, table entry: "..i)
--~ 			print("flag_mortarTracking ="..table_PlayerSquads[i].flag_mortarTracking)
--~ 			print("for squad: "..i)
		end
	end
	
	-- if player was in a mortar attack zone but is not anymore, turn off the flag
end


-- slowly home in mortars on player if they stand still too long
function Rule_Mortars_AttackPlayer()
	for i = 1, table.getn(table_PlayerSquads) do
		-- make sure mortars are only attacking one of the player's squads at any given time
		if table_PlayerSquads[i].flag_mortarAttacking == 1 then
			numSquadsUnderAttack = numSquadsUnderAttack + 1
			if numSquadsUnderAttack > 1 then
				table_PlayerSquads[i].flag_mortarAttacking = 0
				numSquadsUnderAttack = numSquadsUnderAttack - 1
			end
		end
		
		for j = 1, table.getn(table_MortarCountdown) do
			-- if player squad is being tracker by mortar and timer is below the threshold to fire, launch a mortar
			if numSquadsUnderAttack < 2 and table_MortarCountdown[j].flag_HasFired == 0 and table_PlayerSquads[i].flag_mortarTracking == 1 and table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_AtShingle == 0 and table_PlayerSquads[i].flag_CheckRespawn == 1 and Timer_GetRemaining(table_PlayerSquads[i].mortarTimer) <= table_MortarCountdown[j].timer then
				table_PlayerSquads[i].flag_mortarAttacking = 1																															-- set flag so we know that mortars are attacking this squad
				table_MortarCountdown[j].flag_HasFired = 1
--~ 				print("mortar timer reports: "..Timer_GetRemaining(table_PlayerSquads[i].mortarTimer))
				mortarPos_player = SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup)																					-- get position of player squad
				mortarPos_player.x = mortarPos_player.x + table_MortarCountdown[j].fudgefactor																	-- modify position by fudge factor
				if j > 6 then																																													-- if we're not firing directly on top of the player yet
					mortarPos_player.z = mortarPos_player.z + World_GetRand(-4, 4)																						-- modify z position by additional fudge factor
				end
--~ 				print("dropping mortar on squad: "..i)
				if blah923737 ~= 1 and j < 8 and SGroup_IsOnScreen(player1, table_PlayerSquads[i].sgroup, ANY) then
					blah923737 = 1
					Rule_AddOneShot(Rule_SpeechEvent_MortarsIncoming, 0.5)																								-- if mortars are about to drop on player and squad is onscreen, play speech event about it
				end
				if j < 4 then
					if SGroup_GetInvulnerable(table_PlayerSquads[i].sgroup, ANY) == true then
						SGroup_SetInvulnerable(table_PlayerSquads[i].sgroup, false, -1)
					end
--~ 					Modifier_RemoveAllFromSGroup(table_PlayerSquads[i].sgroup)								-- UNCOMMENT WHEN BUG FIXED																-- if we're dropping a mortar right on top of the squad, remove all modifiers so the squad really gets killed
				end
				Cmd_Ability(player1, ABILITY_SP_MORTARSTRIKE_M01, mortarPos_player)																		-- call in mortar strike on player squad
				print(table_MortarCountdown[j].message)

			-- if player is no longer being tracked by the mortar, reset flag so mortar can fire again next time player is tracked
			elseif table_MortarCountdown[j].flag_HasFired == 1 and table_PlayerSquads[i].flag_mortarAttacking == 1 and table_PlayerSquads[i].flag_mortarTracking == 0 and table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_AtShingle == 0 and table_PlayerSquads[i].flag_CheckRespawn == 1 then
--~ 				print("table_PlayerSquads_flag_mortarTracking = "..table_PlayerSquads[i].flag_mortarTracking)
				table_PlayerSquads[i].flag_mortarAttacking = 0																															-- re-set flag so script can attack other player squads
				table_MortarCountdown[j].flag_HasFired = 0
--~ 					print("resetting flag_HasFired for table_MortarCountdown: "..j)
--~ 					print("and player squad: "..i)
			end
		end
	end
end


-- drop some mortars in the water area of the map
function Rule_Mortars_RandomWaterHits()
	local pos = Camera_GetTargetPos()																															-- get camera position
	if Marker_InProximity(Marker_WaterMortarZone, pos) then					-- if the player is looking at the water area
		local rand_neg_x = World_GetRand(-21, -8)
		local rand_pos_x = World_GetRand(0, 15)
		local rand_neg_z = World_GetRand(-21, -8)
		local rand_pos_z = World_GetRand(7, 21)
		
		if World_GetRand(1, 100) > 50 then
			pos.x = pos.x + rand_neg_x																											-- offset target position by random fudge factor
		else
			pos.x = pos.x + rand_pos_x																											-- offset target position by random fudge factor
		end
		
		if World_GetRand(1, 100) > 50 then
			pos.z = pos.z + rand_neg_z																											-- offset target position by random fudge factor
		else
			pos.z = pos.z + rand_pos_z																											-- offset target position by random fudge factor
		end
		
		-- check to make sure NPC mortar is not going to land on top of a player squad
		for k = 1, table.getn(table_PlayerSquads) do
			if table_PlayerSquads[k].flag_spawned == 1 and table_PlayerSquads[k].flag_CheckRespawn == 1 and table_PlayerSquads[k].flag_AtShingle == 0 and World_DistancePointToPoint(pos, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[k].sgroup)) < 10 then	-- if mortar is going to land too close to a player squad
				print("((((((( Water mortar is going to land on player squad - adding more fudge factor! ))))))))")
				pos.x = pos.x + World_GetRand(-20, -8)
			end
		end

--~ 			print("~~~~~ START - Dropping mortar in water!")
		print("~~~~~ Dropping mortar in water!")
		Cmd_Ability(player1, ABILITY_SP_MORTARSTRIKE_M01, pos)																		-- call in mortar strike on random position
	end
	
	Rule_ChangeInterval(Rule_Mortars_RandomWaterHits, World_GetRand(26, 75)/10)
	
	if Objective_IsStarted(OBJECTIVE_Destroy88s) and Objective_IsComplete(OBJECTIVE_Destroy88s) == true then
		Rule_RemoveMe()
	end
end
--------------------------------------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------------------------------------
-- MG FIRE ON BEACH
--------------------------------------------------------------------------------------------------------------------------------------------------

-- start the MG fire vs. the player and NPCs
function Rule_StartMGFire()
--	for i = 1, table.getn(table_MGFireMarkers) do
	g_RealMGFireStarted = 1
	print ("starting MG fire on player squad")

	SGroup_SetInvulnerable(table_PlayerSquads[1].sgroup, true, -1)												-- make player's first squad invulnerable until it starts moving

	Cmd_Attack(Axis_BunkerMG42_01, table_PlayerSquads[1].sgroup, true)																	-- tell MG nest to start attacking

	Util_StartIntel(EVENTS.MGFire_Start)																												-- play speech event telling player to get to cover
	Rule_AddOneShot(Rule_MGStopAttackingPlayer, 4)
	Rule_AddInterval(Rule_NPC_MoveUpInWaves, World_GetRand(3, 5))
--			print("Adding Rule_NPC_MoveUpInWaves now!")
	flag_NPCWave_Start = 0

	Rule_Remove(Rule_StartMGFire)
end

function SquadInCoverKicker(gid, itemid, squadid)
	local count = Squad_Count(squadid)
	local totalincover = 0
	
	for n = 1, count do
		if (Entity_GetCoverValue(Squad_EntityAt(squadid, n-1)) > 0) then
			totalincover = totalincover + 1
		end
	end
	
	if totalincover >= 0.5 * count then
		UI_CreateSquadKickerMessage(player1, squadid, 219750)
	end
end

-- tracks player movement and only starts MG fire when they're moving; stops MG fire when they're stopped and in cover


function Rule_MG_TrackPlayerMovt()
	for i = 1, table.getn(table_PlayerSquads) do
		-- check if this is a squad we want to shoot at
		if table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_AtShingle == 0 and table_PlayerSquads[i].flag_CheckRespawn == 1 then
			-- constantly update moveDelta to track if player is moving
			if table_PlayerSquads[i].oldTargetPos ~= nil then
				table_PlayerSquads[i].moveDelta = World_DistancePointToPoint(SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup), table_PlayerSquads[i].oldTargetPos)
			end
			
			-- constantly store old squad position (so MG knows where to start firing)
			if table_PlayerSquads[i].flag_MGAttackingPlayer == 0 
			and table_PlayerSquads[i].flag_MGTrackingPlayer == 0 
			and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false 
			and SGroup_IsMoving(table_PlayerSquads[i].sgroup, ANY) == false then
				table_PlayerSquads[i].oldTargetPos = SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup)																				-- constantly store old squad position (so MG knows where to start firing)
			end
			
			-- check when player starts moving and start timer for when to start firing MG (to give the player a 2-second lead)
			if table_PlayerSquads[i].flag_MGAttackingPlayer == 0 
			and table_PlayerSquads[i].flag_MGTrackingPlayer == 0 
			and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false 
			and World_DistancePointToPoint(table_PlayerSquads[i].oldTargetPos, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup)) > g_MGLeadDistance then
				table_PlayerSquads[i].flag_MGKilledPlayer = 0
				table_PlayerSquads[i].flag_MGTrackingPlayer = 1
				table_PlayerSquads[i].distanceMultiplier = 0.1
				if SGroup_GetInvulnerable(table_PlayerSquads[i].sgroup, ANY) == false then
					SGroup_SetInvulnerable(table_PlayerSquads[i].sgroup, true, -1)																	-- set player's squad to invulnerable so we don't accidentally shoot them while firing at the ground
				end
				print("Player is on the move, giving them a short lead: "..i)
			end
			
			-- start firing MG at ground near player
			if table_PlayerSquads[i].flag_MGAttackingPlayer == 0 
			and table_PlayerSquads[i].flag_MGTrackingPlayer == 1 
			and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false 
			and table_PlayerSquads[i].moveDelta > 2 then   
				table_PlayerSquads[i].newTargetPos = Util_GetPositionFromAtoB(table_PlayerSquads[i].oldTargetPos, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup), table_PlayerSquads[i].distanceMultiplier)
				table_PlayerSquads[i].oldTargetPos = table_PlayerSquads[i].newTargetPos
				
				if table_PlayerSquads[i].distanceMultiplier < 1.0 then
					table_PlayerSquads[i].distanceMultiplier = table_PlayerSquads[i].distanceMultiplier + g_MGTrackRate
				end
				if SGroup_IsEmpty(table_PlayerSquads[i].mgAttackerGroup) == false then
					Command_SquadPos(player2, table_PlayerSquads[i].mgAttackerGroup, SCMD_Attack, table_PlayerSquads[i].newTargetPos, false)
				end
--~ 				print ("Telling MG to fire near player: "..i)
			end
			
			-- attack player for real when gunfire is close enough to player
			if table_PlayerSquads[i].flag_MGAttackingPlayer == 0 
			and table_PlayerSquads[i].flag_MGTrackingPlayer == 1 
			and table_PlayerSquads[i].newTargetPos ~= nil 
			and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false 
			and World_DistancePointToPoint(table_PlayerSquads[i].newTargetPos, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup)) < g_MGAttackProximity 
			then
				table_PlayerSquads[i].oldTargetPos = SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup)														-- keep updating target position (used to determine when squad has stopped moving)
				
				Cmd_Attack(table_PlayerSquads[i].mgAttackerGroup, table_PlayerSquads[i].sgroup)
				table_PlayerSquads[i].flag_MGAttackingPlayer = 1
				SGroup_SetInvulnerable(table_PlayerSquads[i].sgroup, false, -1)
				if g_UnderAttackFromBunkerEvent ~= 1 then
					g_UnderAttackFromBunkerEvent = 1
					Rule_AddOneShot(Rule_SpeechEvent_UnderAttackFromBunker, 1)
				end
				print("Telling MG to attack: "..i)
			end
			
			-- keep updating old target position when MG is firing so move delta will get updating
			if table_PlayerSquads[i].flag_MGAttackingPlayer == 1 and table_PlayerSquads[i].flag_MGTrackingPlayer == 1 and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false then
				table_PlayerSquads[i].oldTargetPos = SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup)
			end
			
			-- if player is stopped and in cover, start timer to determine when to stop firing
			if table_PlayerSquads[i].flag_PlayerStoppedInCover == 0 
			and (table_PlayerSquads[i].flag_MGAttackingPlayer == 1 
			or table_PlayerSquads[i].flag_MGTrackingPlayer == 1) 
			and SGroup_IsMoving(table_PlayerSquads[i].sgroup, ANY) == false 
			and SGroup_IsInCover(table_PlayerSquads[i].sgroup, ANY) then
				table_PlayerSquads[i].flag_PlayerStoppedInCover = 1
				Timer_Start(table_PlayerSquads[i].Timer_MG_StopFiring, 1/10)
				
--~ 				SGroup_ForEach(table_PlayerSquads[i].sgroup, SquadInCoverKicker)
				print("Player is stopped and in cover, starting Timer_MG_StopFiring: "..i)
			end
			
			-- if player is stopped and in cover, keep the MG firing at them for a little bit before stopping
			if table_PlayerSquads[i].flag_PlayerStoppedInCover == 1 
			and Timer_GetRemaining(table_PlayerSquads[i].Timer_MG_StopFiring) > 0 
			and (table_PlayerSquads[i].flag_MGAttackingPlayer == 1 
			or table_PlayerSquads[i].flag_MGTrackingPlayer == 1) 
			and table_PlayerSquads[i].moveDelta < 2 
			and SGroup_IsInCover(table_PlayerSquads[i].sgroup, ANY) == true then
				table_PlayerSquads[i].newTargetPos = Util_GetPositionFromAtoB(table_PlayerSquads[i].oldTargetPos, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup), table_PlayerSquads[i].distanceMultiplier)
				table_PlayerSquads[i].oldTargetPos = table_PlayerSquads[i].newTargetPos
	
				if table_PlayerSquads[i].distanceMultiplier < 1.0 then
					table_PlayerSquads[i].distanceMultiplier = table_PlayerSquads[i].distanceMultiplier + g_MGTrackRate
				end
				if SGroup_IsEmpty(table_PlayerSquads[i].mgAttackerGroup) == false then
					Command_SquadPos(player2, table_PlayerSquads[i].mgAttackerGroup, SCMD_Attack, table_PlayerSquads[i].newTargetPos, false)
				end
			end
			
			-- if player is stopped and in cover for long enough, stop firing at them
--			if table_PlayerSquads[i].flag_PlayerStoppedInCover == 1 and table_PlayerSquads[i].flag_MGTrackingPlayer == 1 and Timer_GetRemaining(table_PlayerSquads[i].Timer_MG_StopFiring) == 0 and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false and SGroup_IsMoving(table_PlayerSquads[i].sgroup, ANY) == false and SGroup_IsInCover(table_PlayerSquads[i].sgroup) >= g_MGCoverRatio then
			if table_PlayerSquads[i].flag_PlayerStoppedInCover == 1 
			and table_PlayerSquads[i].flag_MGTrackingPlayer == 1 
			and Timer_GetRemaining(table_PlayerSquads[i].Timer_MG_StopFiring) == 0 
			and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false 
			and table_PlayerSquads[i].moveDelta < 2 
			and SGroup_IsInCover(table_PlayerSquads[i].sgroup, ANY) == true then
				Cmd_Stop(table_PlayerSquads[i].mgAttackerGroup)
				table_PlayerSquads[i].distanceMultiplier = 0.1
				table_PlayerSquads[i].flag_MGAttackingPlayer = 0
				table_PlayerSquads[i].flag_MGTrackingPlayer = 0
				table_PlayerSquads[i].flag_PlayerStoppedInCover = 0
				
				if flag_MGFire_Reload2 ~= 1 and Rule_Exists(Rule_SpeechEvent_MGFire_Reload) == false then
					Rule_AddOneShot(Rule_SpeechEvent_MGFire_Reload, 0.3)																					-- play speech event telling player MG is reloading and to move up the beach
					flag_MGFire_Reload2 = 1
				elseif flag_MGFire_Reload3 ~= 1 and Rule_Exists(Rule_SpeechEvent_MGFire_Reload) == false then
					Rule_AddOneShot(Rule_SpeechEvent_MGFire_Reload, 0.3)																					-- play speech event telling player MG is reloading and to move up the beach
					flag_MGFire_Reload3 = 1
				elseif flag_MGFire_Reload4 ~= 1 and Rule_Exists(Rule_SpeechEvent_MGFire_Reload) == false then
					Rule_AddOneShot(Rule_SpeechEvent_MGFire_Reload, 0.3)																					-- play speech event telling player MG is reloading and to move up the beach
					flag_MGFire_Reload4 = 1
				elseif flag_MGFire_Reload5 ~= 1 and Rule_Exists(Rule_SpeechEvent_MGFire_Reload) == false then
					Rule_AddOneShot(Rule_SpeechEvent_MGFire_Reload, 0.3)																					-- play speech event telling player MG is reloading and to move up the beach
					flag_MGFire_Reload5 = 1
				end
				
				print("Player stopped and in cover, telling MG to stop attacking: "..i)
			end
			
			-- if you've killed the player squad, stop firing
			if table_PlayerSquads[i].flag_MGKilledPlayer == 0 
			and (SGroup_IsEmpty(table_PlayerSquads[i].sgroup) or g_CURRENT_SQUAD_COUNT > SGroup_CountSpawned(table_PlayerSquads[i].sgroup)) then
				g_CURRENT_SQUAD_COUNT = SGroup_CountSpawned(table_PlayerSquads[i].sgroup)
				Cmd_Stop(table_PlayerSquads[i].mgAttackerGroup)
				table_PlayerSquads[i].flag_MGAttackingPlayer = 0
				table_PlayerSquads[i].flag_MGTrackingPlayer = 0
				table_PlayerSquads[i].flag_PlayerStoppedInCover = 0
				table_PlayerSquads[i].flag_MGKilledPlayer = 1
				print("Squad dead, telling MG to stop attacking: "..i)
			end
			
		-- if the squad has reached the shingle, stop firing
		elseif table_PlayerSquads[i].flag_MGStopped == 0 and table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_AtShingle == 1 and table_PlayerSquads[i].flag_CheckRespawn == 1 and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false then
			Cmd_Stop(table_PlayerSquads[i].mgAttackerGroup)
			table_PlayerSquads[i].flag_MGStopped = 1
			print("Squad at shingle, telling MG to stop attacking: "..i)
		end
	end
end


function Rule_PlayMG42Sound()
	if flag_AtTheShingle ~= 1 then
		if Rule_Exists(Rule_PlayMG42Sound) then
			Rule_ChangeInterval(Rule_PlayMG42Sound, World_GetRand(3, 4)/10)
		end
	else
		Rule_RemoveMe()
	end
end

function Rule_MGAttackPlayer()
	if flag_AtTheShingle ~= 1 then
		for i = 1, table.getn(table_PlayerSquads) do
			if table_PlayerSquads[i].flag_spawned == 1 
			and table_PlayerSquads[i].flag_AtShingle == 0 
			and table_PlayerSquads[i].flag_CheckRespawn == 1 then
				print ("Attacking player with MG nest!")
				Cmd_Attack(table_PlayerSquads[i].mgAttackerGroup, table_PlayerSquads[i].sgroup)																	-- tell MG nest to start attacking
		
				if flag_MGFire_TakingFire ~= 1 then
					Util_StartIntel(EVENTS.MGFire_TakingFire)																											-- play speech event telling player they're getting killed and to get to cover
					flag_MGFire_TakingFire = 1
				elseif flag_MGFire_TakingFire2 ~= 1 then
					Util_StartIntel(EVENTS.MGFire_TakingFire)																											-- play speech event telling player they're getting killed and to get to cover
					flag_MGFire_TakingFire2 = 1
				end
				if Rule_Exists(Rule_MGStopAttackingPlayer) == false then
					Rule_AddOneShot(Rule_MGStopAttackingPlayer, World_GetRand(6, 8))																-- stop firing MG after a short time
				end
			end
		end
	else
		Rule_RemoveMe()
	end
end

function Rule_MGStopAttackingPlayer()
	if flag_AtTheShingle ~= 1 then
--		print ("telling MG nest to stop attacking!")
		Cmd_Stop(Axis_BunkerMG42_01)
		Cmd_Stop(Axis_BunkerMG42_02)
		Cmd_Stop(Axis_BunkerMG42_03)

		-- when MG fire stops, play a speech event (semi-randomly) telling player to move up the beach
		if flag_MGFire_Reload ~= 1 then
			
			Rule_AddOneShot(Rule_SpeechEvent_MGFire_Reload, 1)																					-- play speech event telling player MG is reloading and to move up the beach
			flag_MGFire_Reload = 1
		elseif flag_MGFire_Reload2 ~= 1 then
			Rule_AddOneShot(Rule_SpeechEvent_MGFire_Reload, 1)																					-- play speech event telling player MG is reloading and to move up the beach
			flag_MGFire_Reload2 = 1
		elseif flag_MGFire_Reload3 ~= 1 then
			Rule_AddOneShot(Rule_SpeechEvent_MGFire_Reload, 1)																					-- play speech event telling player MG is reloading and to move up the beach
			flag_MGFire_Reload3 = 1
		end
		
		SGroup_SetInvulnerable(table_PlayerSquads[1].sgroup, false, -1)												-- turn off invulnerability now that real MG fire has started
		Rule_Add(Rule_MG_TrackPlayerMovt)																							-- start rule to track player movement and fire MGs at them
	end
end

function Rule_SpeechEvent_MGFire_Reload()
	Util_StartIntel(EVENTS.MGFire_Reload)																												-- play speech event telling player MG is reloading and to move up the beach
end


-- picks a random NPC target for the two bunkers not firing at the player to fire at
function Rule_MGFire_NPC_CycleAttack()
	SGroup_Clear(NPC_OnScreen)																		-- clear it to ensure it's empty
	Misc_GetAllPlayerSquadsOnScreen(player3, NPC_OnScreen)											-- fill it with all the player 3 squads onscreen
	
	for i = 1, table.getn(table_MG42_SquadsInBunkers) do
--~ 		print("Processing table_MG42_SquadsInBunkers, table entry: "..i)
		
		-- if the guy you're shooting at is dead or off-screen, pick a new target
		if SGroup_IsEmpty(table_MG42_SquadsInBunkers[i].targetSGroup) 
		or SGroup_IsOnScreen(player1, table_MG42_SquadsInBunkers[i].targetSGroup, ALL, 0.9) == false then
			if SGroup_CountSpawned(NPC_ALL) > 0 then
				-- pick some random NPCs to fire at
				SGroup_Clear(NPC_CurrentTarget)																												-- clear target group
				SGroup_Add(NPC_CurrentTarget, SGroup_GetRandomSpawnedSquad(NPC_ALL))									-- add random squad from entire list of NPCs to target group
				
				if SGroup_TotalMembersCount(NPC_OnScreen) > 0 then																			-- if there are any NPC's on screen
					SGroup_Clear(NPC_OnScreen_CurrentTarget)																							-- clear it to ensure it's empty
--~ 						SGroup_Clear(NPC_NearPlayer)
					SGroup_Clear(NPC_tempOnScreen)
					
--~ 						-- remove all NPCs near player squads so we don't shoot at them (it's confusing)
						-- brw 07/18/06 too costly, removed this to increase optimization.  Since the player controls everyone, he
						-- doesn't really care who's shooting at what.
--~ 						for j = 1, table.getn(table_PlayerSquads) do
--~ 							if g_AtShingleEventHasFinished ~= 1 
--~ 							and table_PlayerSquads[j].flag_spawned == 1 
--~ 							and table_PlayerSquads[j].flag_AtShingle == 0 
--~ 							and table_PlayerSquads[j].flag_CheckRespawn == 1 then
--~ 								Player_GetAllSquadsNearPos(player3, NPC_tempOnScreen, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[j].sgroup), 15)
--~ 								if SGroup_TotalMembersCount(NPC_tempOnScreen) > 0 then
--~ 									SGroup_AddGroup(NPC_NearPlayer, NPC_tempOnScreen)
--~ 								end
--~ 							end
--~ 						end
--~ 						
--~ 						if SGroup_TotalMembersCount(NPC_NearPlayer) > 0 then
--~ 							SGroup_RemoveGroup(NPC_OnScreen, NPC_NearPlayer)
--~ 						end
					
					-- remove any NPCs that are already being attacked by the other MG squads, so we don't get multiple MGs shooting at the same target
					if SGroup_TotalMembersCount(NPC_OnScreen) > 0 then
						for k = 1, table.getn(table_MG42_SquadsInBunkers) do
							if SGroup_TotalMembersCount(table_MG42_SquadsInBunkers[k].targetSGroup) > 0 
							and SGroup_ContainsSGroup(NPC_OnScreen, table_MG42_SquadsInBunkers[k].targetSGroup, ANY) then
								SGroup_RemoveGroup(NPC_OnScreen, table_MG42_SquadsInBunkers[k].targetSGroup)
							end
						end
					end
					
					if SGroup_TotalMembersCount(NPC_OnScreen) > 0 then
						local NPC_temp = SGroup_GetSpawnedSquadAt(NPC_OnScreen, World_GetRand(1, SGroup_Count(NPC_OnScreen)))		-- pick one of the NPCs on screen to attack
						SGroup_Add(NPC_OnScreen_CurrentTarget, NPC_temp)																										-- add it to target group
					end
				end
				
				-- tell MG nest to start attacking NPC who's moving
				if SGroup_IsEmpty(NPC_OnScreen_CurrentTarget) == false then 											
					SGroup_Clear(table_MG42_SquadsInBunkers[i].targetSGroup)
					SGroup_AddGroup(table_MG42_SquadsInBunkers[i].targetSGroup, NPC_OnScreen_CurrentTarget)
					Cmd_Attack(table_MG42_SquadsInBunkers[i].sgroup, NPC_OnScreen_CurrentTarget, nil, true)
--~ 						print("MG Firing at NPCs onscreen, table entry: "..i)
				else
					SGroup_Clear(table_MG42_SquadsInBunkers[i].targetSGroup)
					SGroup_AddGroup(table_MG42_SquadsInBunkers[i].targetSGroup, NPC_CurrentTarget)
					Cmd_Attack(table_MG42_SquadsInBunkers[i].sgroup, NPC_CurrentTarget, nil, true)
--~ 						print("MG Firing at random NPCs, table entry: "..i)
				end
				
				Rule_ChangeInterval(Rule_MGFire_NPC_CycleAttack, World_GetRand(3, 5)/10)												-- change interval to further randomize target cycling
			end
		end
	end
end

--------------------------------------------------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------------------------------------------
-- NPC BEHAVIOUR
--------------------------------------------------------------------------------------------------------------------------------------------------

-- moves NPCs up to shingle
function Rule_NPC_MoveUpInWaves()
	if Event_IsRunning(EVENTS.AtTheShingle) then
		return
	end
	
	-- start timer for restarting NPC wave
	if flag_NPCWaveTimer ~= 1 then
		Timer_Start(Timer_NPCWaveTimer, 120)
		flag_NPCWaveTimer = 1
	end
	
	for i = table.getn(table_NPC_Movers), 1, -1 do
		-- if the NPC squad is alive and not at the shingle, give it a move order to the shingle
		if table_NPC_Movers[i].flag_MoveInWaves == 1 and table_NPC_Movers[i].flag_IsMoving == 0 then
			if SGroup_IsEmpty(table_NPC_Movers[i].sgroup) == false then
				Cmd_Move(table_NPC_Movers[i].sgroup, table_NPC_Movers[i].shinglepos)		-- move to your nearest shingle position
	--				print("+++++ NPCs: start moving up the beach! ++++++, squad: "..i)
				table_NPC_Movers[i].flag_IsMoving = 1																												-- set isMoving flag so this squad doesn't get checked again
				numNPCsCurrentlyMoving = numNPCsCurrentlyMoving + 1																			-- increment counter so we can know when everyone is moving and rule can be removed
				
				-- change interval so everyone doesn't move at once - slightly staggered movement
				Rule_ChangeInterval(Rule_NPC_MoveUpInWaves, World_GetRand(1, 3)/10)
	
				-- add rule to take pot shots as you're moving (if rule isn't already added)
				if Rule_Exists(Rule_NPC_PotShots_Movers) == false then
					Rule_AddInterval(Rule_NPC_PotShots_Movers, 7.5)
				end
				
				-- stop the for loop so we can stagger movement
				return
			end
		end
	end
	
	-- if everyone who should be moving has moved, remove the rule
	if numNPCsCurrentlyMoving == numNPCMovers then
		Rule_RemoveMe()
		Rule_AddOneShot(Rule_NPC_RestartWave_01, 10)
		Rule_AddOneShot(Rule_KillMoreNPCs, 10)
--		print("adding Rule_NPC_RestartWave_01")
	end
end

-- checks when NPCs have reached shingle or are dead
function Rule_NPC_RestartWave_01()	-- CHECK IF AT SHINGLE OR DEAD
--	print("Running Rule_NPC_RestartWave_01")
	g_curr_i = 1
	Rule_AddInterval(Rule_NPC_RestartWave_01_Staggered, World_GetRand(5, 10)/100)
end

function Rule_NPC_RestartWave_01_Staggered()
	if Event_IsRunning(EVENTS.AtTheShingle) then
		return
	end
	
	if g_BunkerTakenNIS_Finished == 1 then
		print ("player has destroyed bunker, stopping NPC waves")
		if Rule_Exists(Rule_88s_FireInAir) == false then
			Rule_AddInterval(Rule_88s_FireInAir, 1.8)
		end
		Rule_RemoveMe()
		return
	end
	
	-- if squad is dead or has reached the shingle, mark it so 
	for i = g_curr_i, table.getn(table_NPC_Movers) do
		if table_NPC_Movers[i].flag_DeadOrAtShingle == 0 and table_NPC_Movers[i].flag_IsMoving == 1 then
			-- if squad is nearing the shingle, increase it's vulnerability so it's more likely to die
			if Prox_AreSquadsNearMarker(table_NPC_Movers[i].sgroup, mkr_npc_kill_zone, ANY) then
				Modify_Vulnerability(table_NPC_Movers[i].sgroup, 100)
			end
			
			-- if squad is dead or has reached the shingle, mark it so
			if SGroup_IsEmpty(table_NPC_Movers[i].sgroup) 
			or  SGroup_IsMoving(table_NPC_Movers[i].sgroup, ANY) == false 
			or Squad_GetPlayerOwner(SGroup_GetSpawnedSquadAt(table_NPC_Movers[i].sgroup, 1)) == player1 then
				table_NPC_Movers[i].flag_DeadOrAtShingle = 1
	--				print("NPC mover squad dead or at shingle: "..i)
				numNPCsDeadOrAtShingle = numNPCsDeadOrAtShingle + 1																						-- increment counter of NPCs that have moved up
				
				g_curr_i = i
				-- change interval so everyone doesn't move at once - slightly staggered movement
				Rule_ChangeInterval(Rule_NPC_RestartWave_01_Staggered, World_GetRand(5, 10)/100)
				
				-- stop the loop so we can stagger checking and not slow the game down as much
				break
			end
		end
	end
	
	-- check how many squads are dead or have reached the shingle
	if numNPCsDeadOrAtShingle/numNPCMovers > 0.75 or Timer_GetRemaining(Timer_NPCWaveTimer) == 0 then
		Rule_RemoveMe()
		Rule_AddInterval(Rule_NPC_RestartWave_02, World_GetRand(5, 10)/100)
	end
end

function Rule_OfficerTest()
	if table_NPC_ALL[104].blueprint == SBP.ALLIES.OFFICER then
		Modify_Vulnerability(table_NPC_ALL[i].sgroup, 0.5)																											-- Make Officers less vulnerable
		SGroup_SetInvulnerable(table_NPC_ALL[i].sgroup, true, -1)
		print("Setting Officer to invulnerable: ")
	end
end

-- kills off NPC squads that are offscreen
function Rule_NPC_RestartWave_02()	-- KILL NPCs
	if Event_IsRunning(EVENTS.AtTheShingle) then
		return
	end
	
	for i = 1, table.getn(table_NPC_Movers) do
		if table_NPC_Movers[i].flag_DeadOrAtShingle == 1 and table_NPC_Movers[i].flag_IsMoving == 1 and SGroup_IsOnScreen(player1, table_NPC_Movers[i].sgroup, ANY) == false then
			table_NPC_Movers[i].flag_IsMoving = 0
			table_NPC_Movers[i].flag_DeadOrAtShingle = 0
			table_NPC_Movers[i].flag_respawned = 0
			numNPCsKilled = numNPCsKilled + 1
			SGroup_Kill(table_NPC_Movers[i].sgroup)
--			print("Resetting flags and killing NPC squad: "..i)
			
			-- change interval so everyone doesn't move at once - slightly staggered movement
			Rule_ChangeInterval(Rule_NPC_RestartWave_02, World_GetRand(5, 10)/100)
			
			-- stop the loop so we can stagger the killing of guys
			return
		end
	end
	
	-- if we've killed most of the NPCs, add rule to start respawning them back at the start of the water
	if numNPCsKilled/numNPCsDeadOrAtShingle > 0.95 then
--		print("We've killed enough NPCs, starting Rule_NPC_RestartWave_03")
		Rule_Remove(Rule_KillMoreNPCs)
		Rule_Remove(Rule_KillMoreNPCs_Staggered)
		Rule_RemoveMe()
		numNPCMovers = 0																																	-- reset counter for number of squads who will be moving up the beach
		if g_BunkerTakenNIS_Finished ~= 1 then
			Rule_AddInterval(Rule_NPC_RestartWave_03, World_GetRand(5, 10)/100)
		elseif g_BunkerTakenNIS_Finished == 1 then
			Rule_RemoveMe()
		end
	end
end


-- respawn NPC squads all the way back at start of water
function Rule_NPC_RestartWave_03()	-- RESPAWN
	if Event_IsRunning(EVENTS.AtTheShingle) then
		return
	end
	
	for i = 1, table.getn(table_NPC_Movers) do
		if table_NPC_Movers[i].flag_respawned == 0 and table_NPC_Movers[i].flag_IsMoving == 0 and table_NPC_Movers[i].flag_DeadOrAtShingle == 0 then
			-- calculate spawn position
			local pos = Marker_GetPosition(table_WaveSpawnMarkers[World_GetRand(1, table.getn(table_WaveSpawnMarkers))])											-- pick random spawn marker
			pos.x = pos.x + World_GetRand(-110, -50)																																										-- add random fudge factor
			pos.z = pos.z + World_GetRand(-20, 20)																																										-- add more random fudge factor
			
			-- only spawn squad is spawn position is offscreen
			if Misc_IsPosOnScreen(pos) == false then
				-- spawn the squad
--				Util_CreateSquadsAtMarkerFacing(player3, table_NPC_Movers[i].sgroup, ALLIED_RIFLEMEN, pos, Marker_Shingle_08, 1, table_NPC_Movers[i].count)
				Util_CreateSquadsAtMarkerFacing(player3, table_NPC_Movers[i].sgroup, table_NPC_Movers[i].blueprint, pos, Marker_Shingle_08, 1, table_NPC_Movers[i].count)
				SGroup_SetMoveType(table_NPC_Movers[i].sgroup, MOVETYPE.BEACH)																						-- set squad to special move type by default
				Modify_WeaponCooldown(table_NPC_Movers[i].sgroup, "hardpoint_01", 15)																					-- Make NPCs take longer to shoot so they don't make so much noise at the shingle
				Modify_WeaponAccuracy(table_NPC_Movers[i].sgroup, "hardpoint_01", 0.0)																					-- NPCs can't hit fish in a barrel
				Cmd_Ability(table_NPC_Movers[i].sgroup, ABILITY_SP_ANIMTEST, nil, nil, true)																						-- make squad move faster
				SGroup_EnableUIDecorator( table_NPC_Movers[i].sgroup, false )																									-- turn off decorators on NPCs
				SGroup_EnableMinimapIndicator(table_NPC_Movers[i].sgroup, false)
				
				if g_SELECT_ANY_SQUAD == false then
					SGroup_SetSelectable(table_NPC_Movers[i].sgroup, false)			-- make all NPCs un-selectable so player can find their own troops more easily
				end
				
				Modifier_RemoveAllFromSGroup(table_NPC_Movers[i].sgroup)																											-- remove any old modifiers that may have been applied
				table_NPC_Movers[i].startpos = pos																																													-- set new spawn position to startpos
	--			print("respawning NPC squad: "..i)
				SGroup_AddGroup(NPC_Movers, table_NPC_Movers[i].sgroup)																																			-- add to master list of NPC movers
				
				-- set flags / increment counter
				table_NPC_Movers[i].flag_respawned = 1
				numNPCsRespawned = numNPCsRespawned + 1																																							-- increment counter of number of NPCs respawned
				numNPCMovers = numNPCMovers + 1
				
				-- modify vulnerability on officers
				if table_NPC_Movers[i].blueprint == SBP.ALLIES.OFFICER then
					Modify_Vulnerability(table_NPC_Movers[i].sgroup, 0.2)																											-- Make Officers less vulnerable
					SGroup_SetAutoTargetting(table_NPC_ALL[i].sgroup, "hardpoint_01", false)
				end
				
				-- calculate closest shingle marker to move to
				for j = 1, table.getn(table_ShingleMarkers) do
					local shinglePos = Marker_GetPosition(table_ShingleMarkers[j])
					local moveDistance = math.abs(table_NPC_Movers[i].startpos.z - shinglePos.z)
					-- check the distance from NPC squad to each shingle marker
					if moveDistance < table_NPC_Movers[i].moveDistance then																																						-- if distance is less than the default (starting distance) defined for each squad
						table_NPC_Movers[i].moveDistance = moveDistance																																								-- store the new distance in the table
						table_NPC_Movers[i].shinglepos = Marker_GetPosition(table_ShingleMarkers[j])																													-- store the new shingle position for each squad
					end
				end
			end
			
			-- change interval so everyone doesn't move at once - slightly staggered movement
			Rule_ChangeInterval(Rule_NPC_RestartWave_03, World_GetRand(2, 3)/10)
			
			-- stop the loop so we can stagger the respawning of guys
			return
		end
	end
	
	-- if we've respawned all the squads we need to, add rule to start moving them up the beach again
	if numNPCsRespawned == numNPCsKilled then
		-- variables to reset after all squads are re-spawned
		numNPCsCurrentlyMoving = 0
		numNPCsDeadOrAtShingle = 0
		numNPCsRespawned = 0
		numNPCsKilled = 0
		flag_NPCWaveTimer= 0
		
		Rule_RemoveMe()
		Rule_AddInterval(Rule_NPC_MoveUpInWaves, 1)
--		print("Enough NPCs respawned - starting the wave again!")
--		print("Removing cooldown modifiers on NPC attackers")
	end
end

-- when NPC fodder squad is dead, start attacking player
function Rule_NPC_SwitchAttackToPlayer()
	if SGroup_IsEmpty(NPC_RushMG_DogWhite) then
--		Rule_AddInterval(Rule_AttackPlayerSquadsWithMGNest, 1)
		Rule_RemoveMe()
	end
end

function HideNPCS()
	SGroup_Clear(sg_temp)
	Player_GetAll(player3, sg_temp)
	SGroup_Clear(sg_temp2)
	Player_GetAll(player4, sg_temp2)
	SGroup_Hide(sg_temp, true)
	SGroup_Hide(sg_temp2, true)
end

function UnhideNPCS()
	SGroup_Clear(sg_temp)
	Player_GetAll(player3, sg_temp)
	SGroup_Clear(sg_temp2)
	Player_GetAll(player4, sg_temp2)
	SGroup_Hide(sg_temp, false)
	SGroup_SetSelectable(sg_temp, false)
	SGroup_Hide(sg_temp2, false)
end



function Rule_NPC_JoinPlayerSquad()
	for i = 1, table.getn(table_PlayerSquads) do
		local needFollower = false
		
		if ( table_PlayerSquads[i].flag_spawned == 1 and 
			 table_PlayerSquads[i].flag_AtShingle == 0 and 
			 table_PlayerSquads[i].flag_CheckRespawn == 1 and 
			 Timer_GetRemaining(table_PlayerSquads[i].followerTimer) == 0 and 
			 ( SGroup_IsMoving(table_PlayerSquads[i].sgroup, ANY) or SGroup_IsAttackMoving(table_PlayerSquads[i].sgroup, ANY) ) ) then
			
			for j = 1, table.getn(table_NPC_Followers) do
				if ( table_NPC_Followers[j].flag_Following == 0 ) then
--					print("#### Trying to find a suitable follower squad ####")
					
					-- create list of NPCs close to the player
					NPC_Followers_NearPlayer = SGroup_CreateIfNotFound("NPC_Followers_NearPlayer")
					NPC_Followers_NearPlayer_Random = SGroup_CreateIfNotFound("NPC_Followers_NearPlayer_Random")
					SGroup_Clear(NPC_Followers_NearPlayer)
					SGroup_Clear(NPC_Followers_NearPlayer_Random)
					World_GetSquadsNearPoint(player3, NPC_Followers_NearPlayer, SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup), 10, OT_Player)
					SGroup_Intersection(NPC_Followers_NearPlayer, NPC_Cowering)																										-- remove guys running up the beach - only cowering NPCs should join the player's squad
					
					-- remove all existing followers from list of squads near player
					for k = 1, table.getn(table_NPC_Followers) do
						if SGroup_IsEmpty(table_NPC_Followers[k].sgroup) == false and SGroup_IsEmpty(NPC_Followers_NearPlayer) == false and SGroup_ContainsSGroup(NPC_Followers_NearPlayer, table_NPC_Followers[k].sgroup, ANY) then
							SGroup_RemoveGroup(NPC_Followers_NearPlayer, table_NPC_Followers[k].sgroup)
						end
					end
					
					-- if there is anyone left in the list, choose one randomly to be the follower
					if SGroup_IsEmpty(NPC_Followers_NearPlayer) == false then
						table_NPC_Followers[j].squad = SGroup_GetSpawnedSquadAt(NPC_Followers_NearPlayer, World_GetRand(1, SGroup_Count(NPC_Followers_NearPlayer)))
						SGroup_Add(NPC_Followers_NearPlayer_Random, table_NPC_Followers[j].squad)
					end
					
					-- add random pick to the follower group
					if SGroup_IsEmpty(NPC_Followers_NearPlayer_Random) == false then
						SGroup_AddGroup(table_NPC_Followers[j].sgroup, NPC_Followers_NearPlayer_Random)
						table_NPC_Followers[j].flag_Following = 1																														-- set flag so script knows this follower squad is active
						table_NPC_Followers[j].followingPlayerGroup = i																											-- record which player group we're following so we know which position to track
						
						print("#### Adding Follower squad to player group #####: "..j)
						
						if Rule_Exists(Rule_NPC_FollowersMove) == false then																									-- start rule telling followers to keep moving
							Rule_AddInterval(Rule_NPC_FollowersMove, 0.6)
						end
						
						-- start timer for when to choose next follower
						Timer_Start(table_PlayerSquads[i].followerTimer, World_GetRand(5, 7))
					end
				end
				
				-- do cleanup on squads following player that have been killed
				if table_NPC_Followers[j].flag_Following == 1 and SGroup_IsEmpty(table_NPC_Followers[j].sgroup) then
--					print("#### Follower squad is dead ####: "..j)
					table_NPC_Followers[j].flag_Following = 0
				end
			end
		end
	end
	
	if flag_AtTheShingle == 1 then
		Rule_RemoveMe()
	end
end

-- keep telling followers to follow player squad 
function Rule_NPC_FollowersMove()
	for i = 1, table.getn(table_NPC_Followers) do
		-- if player squad you're following has reached the shingle, then move to where the player is and stay there
		if table_NPC_Followers[i].flag_Following == 1 and table_PlayerSquads[table_NPC_Followers[i].followingPlayerGroup].flag_AtShingle == 1 then
			local pos = SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[table_NPC_Followers[i].followingPlayerGroup].sgroup)					-- find position of player squad you're following
			pos.x = pos.x + World_GetRand(-15, -10)																															-- offset by fudge factor so follower tries to move right up to shingle
			Cmd_Move(table_NPC_Followers[i].sgroup, pos)																										-- move to position on/near shingle
			SGroup_Clear(table_NPC_Followers[i].sgroup)																													-- clear the follower's sgroup
			table_NPC_Followers[i].flag_Following = 0																															-- remove flag so group is no longer considered a follower
		end
		
		-- keep tracking player squad if it's moving
		if table_NPC_Followers[i].flag_Following == 1 and ( SGroup_IsMoving(table_PlayerSquads[table_NPC_Followers[i].followingPlayerGroup].sgroup, ANY) or SGroup_IsAttackMoving(table_PlayerSquads[table_NPC_Followers[i].followingPlayerGroup].sgroup, ANY) ) then
			local pos = SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[table_NPC_Followers[i].followingPlayerGroup].sgroup)					-- get position of player squad we're following
			pos.x = pos.x + table_NPC_Followers[i].xoffset																													-- modify by offset
			pos.z = pos.z + table_NPC_Followers[i].zoffset																													-- modify by offset
			
			Cmd_Move(table_NPC_Followers[i].sgroup, pos)																										-- constantly move squad to position behind player's squad
			table_NPC_Followers[i].moveToPos = pos																															-- update position in table so rest of function can reference it
			table_NPC_Followers[i].flag_DiveForCover = 0																													-- set flag so we don't keep calling dive for cover repeatedly
		end
		
		-- if followers have stopped moving, tell them to dive for cover
		if table_NPC_Followers[i].flag_Following == 1 and table_NPC_Followers[i].flag_DiveForCover == 0 and table_NPC_Followers[i].moveToPos ~= nil and Prox_AreSquadMembersNearMarker(table_NPC_Followers[i].sgroup, table_NPC_Followers[i].moveToPos, ANY, 1) then		
			table_NPC_Followers[i].flag_DiveForCover = 1																													-- set flag so we don't keep calling dive for cover repeatedly
			local pos = SGroup_GetPosition_EVEN_IF_EMPTY(table_NPC_Followers[i].sgroup)																						-- get position so we can offset it behind squad and dive away from it
			pos.x = pos.x + 20
			Cmd_DoPlan(table_NPC_Followers[i].sgroup, "reaction-plan_dive_for_cover", pos, false)
			print("Telling followers to dive for cover: "..i)
		end
	end
end

-- checks when flamethrower squads are on screen and randomly decides when to make them die in a spectacularly fiery death
function Rule_NPC_Flamethrowers()
	for i = 1, table.getn(table_NPCFlamethrowers) do
		-- if Flamethrower crew is alive and on-screen, decide whether to attack them
		if table_NPCFlamethrowers[i].underAttack == 0 
		and table_NPCFlamethrowers[i].spawned == 1 
		and table_MG42_SquadsInBunkers ~= nil 
		and SGroup_IsEmpty(table_NPCFlamethrowers[i].sgroup) == false 
		and SGroup_IsOnScreen(player1, table_NPCFlamethrowers[i].sgroup, ANY, 0.8) then
			if World_GetRand(1, 100) < table_NPCFlamethrowers[i].chanceToDie then
				table_NPCFlamethrowers[i].underAttack = 1
				Cmd_Move(table_NPCFlamethrowers[i].sgroup, Marker_Shingle_07)														-- tell flamethrower to start moving so he's running when he gets hit

				local rand = World_GetRand(1, table.getn(table_MG42_SquadsInBunkers))
				Cmd_Stop(table_MG42_SquadsInBunkers[rand].sgroup)
				Cmd_Stop(table_MG42_SquadsInBunkers[rand].sgroup)
				Cmd_Attack(table_MG42_SquadsInBunkers[rand].sgroup, table_NPCFlamethrowers[i].sgroup)
				print("¿¿¿¿¿¿¿ Shooting at flamethrower squad now: "..i)
			end
		end
		
		-- randomly decide when to respawn flamethrower squad
		if table_NPCFlamethrowers[i].spawned == 0 and World_GetRand(1, 100) < 5 then
			local rand = World_GetRand(1, table.getn(table_FlameMarkers))
			local pos = World_GetHiddenPositionOnPath(player1, Marker_GetPosition(Marker_Respawn), Marker_GetPosition(table_FlameMarkers[rand]), CHECK_OFFCAMERA)
			if pos == nil then
				pos = Marker_GetPosition(table_FlameMarkers[rand])
			end
			Util_CreateSquadsAtMarkerFacing(player3, table_NPCFlamethrowers[i].sgroup, SBP.ALLIES.ENGINEER, pos, Marker_Shingle_07, 1, 1)
			Cmd_InstantUpgrade(table_NPCFlamethrowers[i].sgroup, UPG.ALLIES.FLAMETHROWER_SP_M01)													-- upgrade all flamethrower crews with flamethrowers
			SGroup_SetInvulnerable(table_NPCFlamethrowers[i].sgroup, true, -1)																			-- set flamethrowers to invulnerable so we can kill them when we want
			SGroup_EnableUIDecorator(table_NPCFlamethrowers[i].sgroup, false)
			SGroup_EnableMinimapIndicator(table_NPCFlamethrowers[i].sgroup, false)
			
			if g_SELECT_ANY_SQUAD == false then
				SGroup_SetSelectable(table_NPCFlamethrowers[i].sgroup, false)
			end
			
			table_NPCFlamethrowers[i].spawned = 1
			table_NPCFlamethrowers[i].underAttack = 0 
			table_NPCFlamethrowers[i].jigODeath = 0
			print("¿¿¿¿¿¿¿ Respawning flamethrower squad now: "..i)
		end
	end
	
	Rule_ChangeInterval(Rule_NPC_Flamethrowers, World_GetRand(20, 30)/10)
end


-- tells Medics to play their animations and respawns them if they die
function Rule_NPC_Medics()
	if blah879823089 ~= 1 then
		for i = 1, table.getn(table_NPC_Medics) do
			SGroup_EnableSurprise(table_NPC_Medics[i].sgroup, false)																									-- turn off surprise so medics don't react to mortars
			Cmd_Ability(table_NPC_Medics[i].sgroup, ABILITY_SP_MEDIC_KITACTIVE, nil, nil, true)
			Cmd_Ability(table_NPC_Medics[i].sgroup, ABILITY_SP_MEDIC_GIVEMORPHINE, nil, nil, true)
			table_NPC_Medics[i].flag_KitActive = 1
			table_NPC_Medics[i].flag_GiveMorphine = 1
		end
		blah879823089 = 1
	end
	
	for i = 1, table.getn(table_NPC_Medics) do
		-- at start of mission, tell Medics to start working on wounded
		
		-- if Medic is dead, respawn him
		if SGroup_IsEmpty(table_NPC_Medics[i].sgroup) then
			local pos = World_GetHiddenPositionOnPath(player1, Marker_GetPosition(Marker_Respawn), table_NPC_Medics[i].startpos, CHECK_OFFCAMERA)
			
			if pos == nil then
				pos = table_NPC_Medics[i].startpos
			end
			
			Util_CreateSquadsAtMarker(player4, table_NPC_Medics[i].sgroup, SBP.ALLIES.MEDIC_SP, pos, 1)
			print("ŠŠŠŠŠŠŠŠŠ Medic dead, respawning: "..i)
			Cmd_Move(table_NPC_Medics[i].sgroup, table_NPC_Medics[i].startpos)
			SGroup_EnableSurprise(table_NPC_Medics[i].sgroup, false)																									-- turn off surprise so medics don't react to mortars
			SGroup_EnableUIDecorator(table_NPC_Medics[i].sgroup, false)
			SGroup_EnableMinimapIndicator(table_NPC_Medics[i].sgroup, false)
			SGroup_SetSelectable(table_NPC_Medics[i].sgroup, false)																												-- make all NPCs un-selectable so player can find their own troops more easily
			Modify_Vulnerability(table_NPC_Medics[i].sgroup, 0.2)
			table_NPC_Medics[i].flag_KitActive = 0
			table_NPC_Medics[i].flag_GiveMorphine = 0
			table_NPC_Medics[i].flag_Moving = 1
		end
		
		-- if Medic has moved into position, tell him to start giving morphine
		if table_NPC_Medics[i].flag_Moving == 1 and SGroup_IsEmpty(table_NPC_Medics[i].sgroup) == false and SGroup_IsMoving(table_NPC_Medics[i].sgroup, ANY) == false and Prox_AreSquadMembersNearMarker(table_NPC_Medics[i].sgroup, table_NPC_Medics[i].startpos, ANY, 3) then
			Cmd_Stop(table_NPC_Medics[i].sgroup)
			table_NPC_Medics[i].flag_Moving = 0
			Cmd_Ability(table_NPC_Medics[i].sgroup, ABILITY_SP_MEDIC_KITACTIVE, nil, nil, true)
			Cmd_Ability(table_NPC_Medics[i].sgroup, ABILITY_SP_MEDIC_GIVEMORPHINE, nil, nil, true)
			print("ŠŠŠŠŠŠŠŠŠ Medic in position, giving morphine: "..i)
			table_NPC_Medics[i].flag_KitActive = 1
			table_NPC_Medics[i].flag_GiveMorphine = 1
		end
	end
	
	Rule_ChangeInterval(Rule_NPC_Medics, 1.7)
end

--------------------------------------------------------------------------------------------------------------------------------------------------



--------------------------------------------------------------------------------------------------------------------------------------------------
-- AXIS RETREATING
--------------------------------------------------------------------------------------------------------------------------------------------------

-- makes enemy squads retreat when player gets too close
function Rule_AxisRetreat_WhenPlayerClose()
	for i = 1, table.getn(table_PlayerSquads) do
		for j = 1, table.getn(table_AxisRetreaters) do
			-- reset hasRetreated flag so squads can retreat again once they've stopped moving
			if table_AxisRetreaters[j].flag_hasRetreated == 1 
			and table_PlayerSquads[i].flag_spawned == 1 
			and table_PlayerSquads[i].flag_CheckRespawn
			and SGroup_IsEmpty(table_AxisRetreaters[i].sgroup) == false
			and SGroup_IsMoving(table_AxisRetreaters[i].sgroup, ANY) == false then
				table_AxisRetreaters[j].flag_hasRetreated = 0
			end
		
			-- check if player is close enough to Axis squad to force a retreat
			if table_AxisRetreaters[j].flag_hasRetreated == 0 
			and SGroup_IsEmpty(table_AxisRetreaters[j].sgroup) == false 
			and Prox_AreSquadMembersNearMarker(table_PlayerSquads[i].sgroup, SGroup_GetPosition_EVEN_IF_EMPTY(table_AxisRetreaters[j].sgroup), ANY, table_AxisRetreaters[j].retreatProximity) then
				axisPos = SGroup_GetPosition_EVEN_IF_EMPTY(table_AxisRetreaters[j].sgroup)
				
				retreatPos = SGroup_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup)																					-- get position of player squad that we want to move away from
				retreatPos.x = retreatPos.x - World_GetRand(20,40)																												-- modify it by random fudge factor
				retreatPos.z = retreatPos.z - World_GetRand(-10,10)																											-- modify it by random fudge factor
				
				if SGroup_GetSuppression(table_AxisRetreaters[j].sgroup) > 0.3 then																				-- if squad is pinned
					SGroup_SetSuppression(table_AxisRetreaters[j].sgroup, 0.2)
				end
				
				Cmd_Move(table_AxisRetreaters[j].sgroup, retreatPos)																								-- move to retreat position
				print ("telling AxisRetreaters to retreat, table entry: "..j)
				table_AxisRetreaters[j].flag_hasRetreated = 1
			end
		end
	end
end

function Rule_DespawnNPCAttackers()
	for i = 1, table.getn(table_NPCAttackers_Retreat) do
		if table_NPCAttackers_Retreat[i].flag_hasRetreated == 1 and SGroup_IsEmpty(table_NPCAttackers_Retreat[i].sgroup) == false and Prox_AreSquadMembersNearMarker(table_NPCAttackers_Retreat[i].sgroup, ANY, table_NPCAttackers_Retreat[i].retreatPos, 5) then
			SGroup_Kill(table_NPCAttackers_Retreat[i].sgroup)
		end
	end
end

-- spawns fodder squads from Bunker as soon as player gets up on clifftop
function Rule_AxisRetreat_FromBunker()
	if flag_RetreatFromBunker ~= 1 and 
	Prox_ArePlayerMembersNearMarker(player1, Marker_DogWhiteCliffTop_Trigger, ANY) then
--		print ("detecting player squads at clifftop - telling Bunker to start spawning retreaters!")
		flag_RetreatFromBunker = 1
		g_UseSatchelChargesOnBunker = 1
		Rule_RemoveMe()
	end
end

-- moves all the Axis into the appropriate positions after 
function OBJ_DB_AxisMoveIntoPosition()
	if g_Axis_MoveIntoPosition == 1 then
		Rule_RemoveMe()
		
		if EGroup_CountSpawned(table_AxisRetreaters[6].bunker_sp.egroup) >= 1 then
			Util_CreateSquadsAndGarrisonExit(player2, table_AxisRetreaters[6].sgroup, table_AxisRetreaters[6].blueprint, table_AxisRetreaters[6].bunker_sp.egroup, 1, Marker_TrenchDefenders_02_MoveTo, true, table_AxisRetreaters[6].loadout)
			SGroup_SuggestPosture(table_AxisRetreaters[6].sgroup, 1, -1)																										-- tell them to be crouching
			Modify_Vulnerability(table_AxisRetreaters[6].sgroup, 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
			Modify_WeaponAccuracy(table_AxisRetreaters[6].sgroup, "hardpoint_01", 0.6)
			table.insert(table_PinnedAndVulnerable, table_AxisRetreaters[6].sgroup)			-- add to PinnedAndVulnerable table so enemies will become weaker if pinned
			table_AxisRetreaters[6].flag_spawn = 0
		end
		if EGroup_CountSpawned(table_AxisRetreaters[7].bunker_sp.egroup) >= 1 then
			Util_CreateSquadsAndGarrisonExit(player2, table_AxisRetreaters[7].sgroup, table_AxisRetreaters[7].blueprint, table_AxisRetreaters[7].bunker_sp.egroup, 1, Marker_TrenchDefenders_02_MoveTo, true, table_AxisRetreaters[7].loadout)
			SGroup_SuggestPosture(table_AxisRetreaters[7].sgroup, 1, -1)																										-- tell them to be crouching
			Modify_Vulnerability(table_AxisRetreaters[7].sgroup, 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
			Modify_WeaponAccuracy(table_AxisRetreaters[7].sgroup, "hardpoint_01", 0.6)
			table.insert(table_PinnedAndVulnerable, table_AxisRetreaters[7].sgroup)			-- add to PinnedAndVulnerable table so enemies will become weaker if pinned
			table_AxisRetreaters[7].flag_spawn = 0
		end
		if EGroup_CountSpawned(table_AxisRetreaters[10].bunker_sp.egroup) >= 1 then
			Util_CreateSquadsAndGarrisonExit(player2, table_AxisRetreaters[10].sgroup, table_AxisRetreaters[10].blueprint, table_AxisRetreaters[10].bunker_sp.egroup, 1, Marker_TrenchDefenders_05_MoveTo, true, table_AxisRetreaters[10].loadout)
			SGroup_SuggestPosture(table_AxisRetreaters[10].sgroup, 1, -1)																										-- tell them to be crouching
			Modify_Vulnerability(table_AxisRetreaters[10].sgroup, 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
			Modify_WeaponAccuracy(table_AxisRetreaters[10].sgroup, "hardpoint_01", 0.6)
			table.insert(table_PinnedAndVulnerable, table_AxisRetreaters[10].sgroup)			-- add to PinnedAndVulnerable table so enemies will become weaker if pinned
			table_AxisRetreaters[10].flag_spawn = 0
		end
		if EGroup_CountSpawned(table_AxisRetreaters[12].bunker_sp.egroup) >= 1 and table_AxisRetreaters[12].flag_spawn == 1 then
			Util_CreateSquadsAndGarrisonExit(player2, table_AxisRetreaters[12].sgroup, table_AxisRetreaters[12].blueprint, table_AxisRetreaters[12].bunker_sp.egroup, 1, table_AxisRetreaters[12].bunker_sp.mkr_pt, true, table_AxisRetreaters[12].loadout)
			SGroup_SuggestPosture(table_AxisRetreaters[12].sgroup, 1, -1)																										-- tell them to be crouching
			Modify_Vulnerability(table_AxisRetreaters[12].sgroup, 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
			Modify_WeaponAccuracy(table_AxisRetreaters[12].sgroup, "hardpoint_01", 0.6)
			table.insert(table_PinnedAndVulnerable, table_AxisRetreaters[12].sgroup)			-- add to PinnedAndVulnerable table so enemies will become weaker if pinned
			table_AxisRetreaters[12].flag_spawn = 0
			Cmd_Move(Axis_TrenchDefenders_07, Marker_TrenchDefenders_02_MoveTo, true)
		end
		if EGroup_CountSpawned(table_AxisRetreaters[20].bunker_sp.egroup) >= 1 then
			Util_CreateSquadsAndGarrisonExit(player2, table_AxisRetreaters[20].sgroup, table_AxisRetreaters[20].blueprint, table_AxisRetreaters[20].bunker_sp.egroup, 1, Marker_TrenchDefenders_13_MoveTo, true, table_AxisRetreaters[20].loadout)
			SGroup_SuggestPosture(table_AxisRetreaters[20].sgroup, 1, -1)																										-- tell them to be crouching
			Modify_Vulnerability(table_AxisRetreaters[20].sgroup, 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
			Modify_WeaponAccuracy(table_AxisRetreaters[20].sgroup, "hardpoint_01", 0.6)
			table.insert(table_PinnedAndVulnerable, table_AxisRetreaters[20].sgroup)			-- add to PinnedAndVulnerable table so enemies will become weaker if pinned
			table_AxisRetreaters[20].flag_spawn = 0
		end
		
		-- move axis into position
		Cmd_AttackMove(Axis_TrenchDefenders_04, Marker_TrenchDefenders_04_MoveTo)
		Cmd_AttackMove(Axis_TrenchDefenders_09, Marker_TrenchDefenders_09_MoveTo)
		Cmd_AttackMove(Axis_TrenchDefenders_10, Marker_TrenchDefenders_10_MoveTo)
		Cmd_AttackMove(Axis_TrenchDefenders_08, Marker_TrenchDefenders_08_MoveTo)
	end
end

-- moves the trench defenders into position after the bunker is destroyed
function Rule_AxisRetreat_MoveIntoPosition()
	if flag_TrenchDefenders_03_MoveOnce ~= 1 
	and SGroup_IsEmpty(Axis_MGNestNear88s) or SGroup_IsEmpty(Axis_MGNestNear88s_02) then
		Cmd_AttackMove(Axis_TrenchDefenders_03, Marker_TrenchDefenders_03_MoveTo)
		flag_TrenchDefenders_03_MoveOnce = 1
	end
	
	if flag_TrenchDefenders_11_MoveOnce ~= 1 
	and not EGroup_IsEmpty(table_AxisRetreaters[17].bunker_sp.egroup)
	and (SGroup_IsUnderAttack(Axis_TrenchDefenders_10, ANY, 5)) then
		Util_CreateSquadsAndGarrisonExit(player2, table_AxisRetreaters[17].sgroup, table_AxisRetreaters[17].blueprint, table_AxisRetreaters[17].bunker_sp.egroup, 1, table_AxisRetreaters[17].bunker_sp.mkr_pt, true, table_AxisRetreaters[17].loadout)
		SGroup_SuggestPosture(table_AxisRetreaters[17].sgroup, 1, -1)																										-- tell them to be crouching
		Modify_Vulnerability(table_AxisRetreaters[17].sgroup, 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
		Modify_WeaponAccuracy(table_AxisRetreaters[17].sgroup, "hardpoint_01", 0.6)
		table.insert(table_PinnedAndVulnerable, table_AxisRetreaters[17].sgroup)			-- add to PinnedAndVulnerable table so enemies will become weaker if pinned
		table_AxisRetreaters[17].flag_spawn = 0
		Cmd_AttackMove(Axis_TrenchDefenders_11, Marker_TrenchDefenders_11_MoveTo, true)
		flag_TrenchDefenders_11_MoveOnce = 1
	end
	
	if flag_TrenchDefenders_12_MoveOnce ~= 1 
	and not EGroup_IsEmpty(table_AxisRetreaters[18].bunker_sp.egroup)
	and SGroup_IsEmpty(Axis_TrenchDefenders_02) then
		Util_CreateSquadsAndGarrisonExit(player2, table_AxisRetreaters[18].sgroup, table_AxisRetreaters[18].blueprint, table_AxisRetreaters[18].bunker_sp.egroup, 1, table_AxisRetreaters[18].bunker_sp.mkr_pt, true, table_AxisRetreaters[18].loadout)
		SGroup_SuggestPosture(table_AxisRetreaters[18].sgroup, 1, -1)																										-- tell them to be crouching
		Modify_Vulnerability(table_AxisRetreaters[18].sgroup, 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
		Modify_WeaponAccuracy(table_AxisRetreaters[18].sgroup, "hardpoint_01", 0.6)
		table.insert (table_PinnedAndVulnerable, table_AxisRetreaters[18].sgroup)			-- add to PinnedAndVulnerable table so enemies will become weaker if pinned
		
		Cmd_AttackMove(Axis_TrenchDefenders_12, Marker_TrenchDefenders_02_MoveTo, true)
		flag_TrenchDefenders_12_MoveOnce = 1
	end
	
	if flag_TrenchDefenders_14_MoveOnce ~= 1
	and not EGroup_IsEmpty(table_AxisRetreaters[21].bunker_sp.egroup)
	and ( SGroup_IsEmpty(Axis_88Crew_02) or SGroup_IsEmpty(Axis_TrenchDefenders_15) or SGroup_Count(Axis_88Crew_02) < 4 ) then
		Util_CreateSquadsAndGarrisonExit(player2, table_AxisRetreaters[21].sgroup, table_AxisRetreaters[21].blueprint, table_AxisRetreaters[21].bunker_sp.egroup, 1, table_AxisRetreaters[21].bunker_sp.mkr_pt, true, table_AxisRetreaters[21].loadout)
		SGroup_SuggestPosture(table_AxisRetreaters[21].sgroup, 1, -1)																										-- tell them to be crouching
		Modify_Vulnerability(table_AxisRetreaters[21].sgroup, 3.0)											-- Make enemies weaker because it's mission 1 and the enemies are mostly in heavy cover
		Modify_WeaponAccuracy(table_AxisRetreaters[21].sgroup, "hardpoint_01", 0.6)
		table.insert(table_PinnedAndVulnerable, table_AxisRetreaters[21].sgroup)			-- add to PinnedAndVulnerable table so enemies will become weaker if pinned
		table_AxisRetreaters[21].flag_spawn = 0
		Cmd_AttackMove(Axis_TrenchDefenders_14, Marker_TrenchDefenders_14_MoveTo, true)
		flag_TrenchDefenders_14_MoveOnce = 1
	end
end


-- tells Axis squads to move into positions around the bunker when the player gets close (no standing around!)
function Rule_Axis_BunkerGuards_MoveIntoPosition()
	if flag_BunkerGuards_02_MoveOnce ~= 1 and Prox_ArePlayerMembersNearMarker(player1, Marker_BeachExit_Top, ANY) then
		Cmd_Move(Axis_BunkerGuards_02, Marker_BunkerGuards_02_MoveTo)
		Cmd_Move(Axis_BunkerGuards_01, Marker_BunkerGuards_01_MoveTo)
		flag_BunkerGuards_02_MoveOnce = 1
	end

	if Objective_IsStarted(OBJECTIVE_DestroyBunker) and Objective_IsComplete(OBJECTIVE_DestroyBunker) then
		Rule_RemoveMe()
	end
end



-- spawns small 2-man squads that keep the pressure on in case the player's squads are not under attack
function Rule_Axis_KeepPressureOn()
	local add_time = 30
	
	if blah3783 ~= 1 then
		timer_KeepPressureOn = 7383
		distToSpawnPoint = 1000
		closestSpawnMarker = 1
		for i = 1, table.getn(table_AxisKeepPressureOn) do
			table_AxisKeepPressureOn[i].sgroup = SGroup_CreateIfNotFound(table_AxisKeepPressureOn[i].sgroupSTRING)
		end
		blah3783 = 1
	end

	-- if there aren't any more bunkers lefts to spawn guys, then stop spawning enemy units
	if table.getn(eg_bunker_spawn) == 0 then
		Rule_RemoveMe()
	end

	-- if player is in 1st trench section, spawn from sides of trench
	for i = 1, table.getn(table_AxisKeepPressureOn) do
		if g_BunkerTakenNIS_Finished == 1 then
			-- added to make sure that the Axis are continually attacking the player
			if SGroup_IsEmpty(table_AxisKeepPressureOn[i].sgroup) == false 
			and SGroup_IsMoving(table_AxisKeepPressureOn[i].sgroup, ANY) == false
			and SGroup_IsUnderAttack(table_AxisKeepPressureOn[i].sgroup, ANY, 3) == false then
			
				-- *** brw 05/02/06 If needed, may need to force all the buildings to ungarrison, but 
				-- I'd rather not, if we decide to put troops to occupy the buildings. 
				Cmd_AttackMove(table_AxisKeepPressureOn[i].sgroup, Util_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[1].sgroup))
--~ 				print("Order Axis KeepPressureOn Group To Move: "..i)
			end
		end
	end
	
	for i = 1, table.getn(table_AxisKeepPressureOn) do
		if g_BunkerTakenNIS_Finished == 1 then
			if Timer_GetRemaining(timer_KeepPressureOn) == 0 
			and SGroup_IsEmpty(table_AxisKeepPressureOn[i].sgroup) 
			and SGroup_IsUnderAttack(table_PlayerSquads[1].sgroup, ANY, 3) == false then
				Timer_Start(timer_KeepPressureOn, add_time)
				SGroup_Clear(table_AxisKeepPressureOn[i].sgroup)
				
				-----------------------------------------------------------------------------
				-- brw 04/21/06 -- ADDING NEW CODE TO SPAWN ENEMIES FROM BUNKERS IN TRENCHES
				-----------------------------------------------------------------------------
				
				-- determine closest barracks to one of player's squads
				EGroup_Clear(eg_temp)
				local mkr_go_to
				local idx
				for j = 1, table.getn(table_PlayerSquads) do
					if SGroup_IsEmpty(table_PlayerSquads[j].sgroup) == false then
						idx = Util_GetClosestEGroup(table_PlayerSquads[j].sgroup, eg_temp, eg_bunker_spawn)
						-- find the associated marker for that bunker (assuming that the closest bunker is probably the closest marker as well)
						mkr_go_to = mkr_ax_trench_spawn[idx]
						break
					end
				end
				
				-- if the closest bunker to the player does not exist then
				-- remove this rule to stop squads from spawning
				if EGroup_IsEmpty(eg_temp) then
					Rule_RemoveMe()
					return
				end
				
				-- difficulty handle
				local loadout = t_difficulty.ax_sp_loadout
				
				-- change the attacker loadout depending on the player's progress
				if table.getn(eg_bunker_spawn) <= 2 
				or Player_OwnsEGroup(player1, Flag_RH_88) 
				or Player_OwnsEGroup(player1, Flag_LH_88) then
					loadout = t_difficulty.ax_sp_loadout_inc
				end
				
				Util_CreateSquadsAndGarrisonExit(player2, table_AxisKeepPressureOn[i].sgroup, SBP.AXIS.GRENADIER, eg_temp, 1, mkr_go_to, true, loadout)
				-----------------------------------------------------------------------------
				
				-- brw 04/21/06 -- removing legacy code that spawns units from various locations on the map				
				SGroup_SetMoodMode(table_AxisKeepPressureOn[i].sgroup, MM_ForceTense)
				-- this command is more reliable
				
				-- force the axis to attack the sniper specifically if he exists
				if SGroup_IsEmpty(NPC_Sniper) == false
				and i == 2 then
					Cmd_Attack(table_AxisKeepPressureOn[i].sgroup, NPC_Sniper, true)
				else
					Cmd_AttackMove(table_AxisKeepPressureOn[i].sgroup, Util_GetPosition_EVEN_IF_EMPTY(table_PlayerSquads[i].sgroup), true)
				end
				
				Modify_Vulnerability(table_AxisKeepPressureOn[i].sgroup, 3.0)
				Modify_WeaponAccuracy(table_AxisKeepPressureOn[i].sgroup, "hardpoint_01", 0.5)
				print("Spawning Axis KeepPressureOn group: "..i)
			end
		end
	end
end


-- makes 88s fire into the air to simulate pounding the beach with artillery
function Rule_88s_FireInAir()
	if Rule_Exists(Rule_88s_FireInAir) then
		Rule_RemoveMe()
	end
	
	for i = 1, table.getn(table_88s) do
		if Timer_GetRemaining(table_88s[i].timer_88FireInAir) == 0 
		and table_88s[i].flag == 0 
		and SGroup_IsEmpty(table_88s[i].sgroup) == false then 
			
			Command_SquadPos(player2, table_88s[i].sgroup, SCMD_Attack, Marker_GetPosition(table_88s[i].fireInAirMarker), false)
			Timer_Start(table_88s[i].timer_88FireInAir, World_GetRand(10, 28)/10)
		end
	end
end


-- Rule to have the 88s shoot at random locations near the trenches.  They are meant more to scare the player more than anything else.
function Rule_88s_FireAtTrenches()
	for i = 1, table.getn(table_88s) do
		if Timer_GetRemaining(table_88s[i].timer_88FireAtTrenches) <= 0 
		and table_88s[i].flag == 0
		and SGroup_IsEmpty(table_88s[i].sgroup) == false then 
--~ 			print("88 Firing at Player in trenches!")
			target = table_88s[i].mkr_trench_targets[World_GetRand(1, table.getn(table_88s[i].mkr_trench_targets))]
			
			-- check to make sure the player is too close to the target, and if he isn't then shoot!
			Command_SquadPos(player2, table_88s[i].sgroup, SCMD_Attack, Util_GetRandomPosition(target, 15), false)
			Timer_Start(table_88s[i].timer_88FireAtTrenches, World_GetRand(10, 28)/10)
			
		end
	end
end

--------------------------------------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------------------------------------
-- AXIS FALL INTO TRENCH
--------------------------------------------------------------------------------------------------------------------------------------------------

-- watch for player to get near clifftop and then retreat to edge of trench so you can get killed and fall into trench and look cool
function Rule_FallIntoTrench_Check()
	if flag_FallIntoTrench_MoveIntoPosition ~= 1 and ( SGroup_IsEmpty(Axis_MGNest_DogWhite) or SGroup_IsEmpty(Axis_MG42_Flee) ) then
		Cmd_Move(Axis_FallIntoTrench_01, Marker_CliffSandbag_Top)
		Cmd_Move(Axis_CliffDefenders_01, Marker_CliffSandbag_Mid)
		flag_FallIntoTrench_MoveIntoPosition = 1
	end
end

-- move to position on edge of trench
function Rule_FallIntoTrench_Move()
	Cmd_Move(Axis_FallIntoTrench_01, Marker_GetPosition(Marker_FallIntoTrench_01_MoveTo))
	Axis_FallIntoTrench_ModID = Modify_Vulnerability(Axis_FallIntoTrench_01, 2)
end

-- watch for squad to be in position so we can crank their vulnerability up and make them die easily
function Rule_FallIntoTrench_Finished()
	if Prox_AreSquadMembersNearMarker(Axis_FallIntoTrench_01, Marker_FallIntoTrench_01_MoveTo, ANY) then
		Cmd_Stop(Axis_FallIntoTrench_01)
		Rule_RemoveMe()
	end
end
--------------------------------------------------------------------------------------------------------------------------------------------------










--------------------------------------------------------------------------------------------------------------------------------------------------
-- RESCUE SNIPER
--------------------------------------------------------------------------------------------------------------------------------------------------

-- tells one of the NPC MGs to fire at the Sniper if he is onscreen
function Rule_ShootAtSniper()
	SGroup_SuggestPosture(NPC_Sniper, 0, -1)
end

-- when player gets close to the Sniper, he is "rescued" and the player gets control over him
function Rule_RescueSniper()
	if flag_AtTheShingle == 1 then
		Rule_Remove(Rule_ShootAtSniper)
		SGroup_Kill(NPC_Sniper)
		Rule_RemoveMe()
	end
	
	-- don't process anything else until the player selects the sniper
	if Player_OwnsSGroup(player1, NPC_Sniper) == false then
		return
	end
	
	-- clearing some visual parameters on the sniper.
	SGroup_ClearPostureSuggestion(NPC_Sniper)
	Rule_Remove(Rule_ShootAtSniper)
	Ceasefire_RemoveSGroup(NPC_Sniper)
	
	for i = 1, table.getn(table_ShingleMarkers_Rect) do 
		if Prox_AreSquadMembersNearMarker(NPC_Sniper, table_ShingleMarkers_Rect[i], ANY) then
			g_sniperRescued = 1
			SGroup_CreateKickerMessage(NPC_Sniper, player1, 219546)
			SGroup_SetInvulnerable(NPC_Sniper, false)
			EventCue_Create(CUE.NORMAL, 219701, 219701, NPC_Sniper)
			UI_DeleteMinimapBlip(g_SniperPing)
			HintMouseover_Remove(219547, NPC_Sniper)
			Rule_RemoveMe()
			break
		end
	end
end

function Rule_RespawnSniper()
	if Event_IsRunning(EVENTS.AtTheShingle) or Event_IsRunning(EVENTS.BunkerDestroyed) then
		return
	end	
	
	-- respawn Sniper if player has rescued the sniper
	if g_sniperRescued == 1 then
		local pos = World_GetHiddenPositionOnPath(player1, Marker_Respawn, g_SniperPos, CHECK_OFFCAMERA)
		if pos ~= nil then
			Util_CreateSquadsAtMarker(player1, NPC_Sniper, SBP.ALLIES.SNIPER, pos, 1)					-- spawn Sniper from Offscreen if possible
			Cmd_Move(NPC_Sniper, g_SniperPos, true)
		else
			Util_CreateSquadsAtMarker(player1, NPC_Sniper, SBP.ALLIES.SNIPER, g_SniperPos, 1)
		end
		
		if g_BunkerDestroyed == 1 then
			Cmd_Move(NPC_Sniper, mkr_reinforcement_sniper, true)
		end
		
		if 	g_SNIPER_VET ~= nil 
		and g_SNIPER_VET ~= 0 then
			SGroup_IncreaseVeterancyRank(NPC_Sniper, g_SNIPER_VET, true)
		end
		
		if 	g_SNIPER_CGROUP ~= nil 
		and g_SNIPER_CGROUP ~= -1 then
			Misc_SetSquadControlGroup(SGroup_GetRandomSpawnedSquad(NPC_Sniper), g_SNIPER_CGROUP)
		end
		
		Rule_RemoveMe()
	else
		Rule_RemoveMe()
	end
end
--------------------------------------------------------------------------------------------------------------------------------------------------



--------------------------------------------------------------------------------------------------------------------------------------------------
-- TERRITORY
--------------------------------------------------------------------------------------------------------------------------------------------------

-- Switch ownership of territory sectors based on the player's progress in the mission
function Rule_SwitchTerritory()
	-- right hand MG nest in trenches
	if blah8376383 ~= 1 and SGroup_IsEmpty(Axis_MGNestNear88s) then
		EGroup_InstantCaptureStrategicPoint(Flag_RH_MGNest, player1)
		EGroup_SetPlayerOwner(eg_reinforce_bunker, player1)
		EGroup_SetPlayerOwner(eg_reinforce_RH, player1)
		blah8376383 = 1
	end
	
	-- left hand MG nest in trenches
	if blah937373 ~= 1 and SGroup_IsEmpty(Axis_MGNestNear88s_02) then
		EGroup_InstantCaptureStrategicPoint(Flag_LH_MGNest, player1)
		EGroup_SetPlayerOwner(eg_reinforce_bunker, player1)
		EGroup_SetPlayerOwner(eg_reinforce_LH, player1)
		blah937373 = 1
	end

	-- left hand 88
	if blah3737874 ~= 1 and table_88s[1].flag == 1 then
		EGroup_InstantCaptureStrategicPoint(Flag_LH_88, player1)
		EGroup_SetPlayerOwner(eg_reinforce_LH_88, player1)
		blah3737874 = 1
	end
	
	-- right hand 88
	if blah73743834783 ~= 1 and table_88s[2].flag == 1 then
		EGroup_InstantCaptureStrategicPoint(Flag_RH_88, player1)
		EGroup_SetPlayerOwner(eg_reinforce_RH_88, player1)
		blah73743834783 = 1
	end
end

--------------------------------------------------------------------------------------------------------------------------------------------------
-- SPEECH EVENTS
--------------------------------------------------------------------------------------------------------------------------------------------------

-- if player is near craters, tell them craters can be used for cover
function Rule_SpeechEvent_UseCraters()
	for i = 1, table.getn(table_CraterSpeechTriggers) do
		if Prox_AreSquadMembersNearMarker(table_PlayerSquads[1].sgroup, table_CraterSpeechTriggers[i], ANY) then
--			print ("Use craters event has fired")
			Util_StartIntel(EVENTS.UseCratersForCover)
			Rule_RemoveMe()
		end
	end
end

-- tell player to use grenades on MG nest
function Rule_SpeechEvent_UseGrenades()
	if SGroup_IsEmpty(Axis_MGNest_DogWhite) == false then
		Util_StartIntel(EVENTS.UseGrenades)
	end
end




-- tell player to use satchel charges on bunker when they've killed the guards
function Rule_SpeechEvent_UseSatchelCharges()
	if g_BunkerDestroyed ~= 1 then
		Util_StartIntel(EVENTS.UseSatchelCharges)
		UI_HighlightSGroup(table_PlayerSquads[4].sgroup, 20)																	-- highlight Engineers
		HintMouseover_Add(219515, mkr_db_hint, 10, true)
		
		Player_SetAbilityAvailability(player1, ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, ITEM_DEFAULT)
		OBJECTIVE_DestroyBunker.EngPing = Objective_AddUIElements(OBJECTIVE_DestroyBunker, table_PlayerSquads[4].sgroup, true, 219516, true)
		
		runAbilityExecute()																										-- start checking for when satchel charge is thrown at bunker
		
		Rule_AddInterval(Rule_RemovePingOnEngineers, 1.1)
		
		Rule_RemoveMe()
	end
	
	if g_BunkerDestroyed == 1 then
		Rule_RemoveMe()
	end
end


-- removes ping and hint point on Engineers
function Rule_RemovePingOnEngineers()
	if Misc_IsSGroupSelected(table_PlayerSquads[4].sgroup, ANY) then
		if Engineer_PingID ~= nil then
			UI_DeleteMinimapBlip(Engineer_PingID)
		end
		
		Objective_RemoveUIElements(OBJECTIVE_DestroyBunker, OBJECTIVE_DestroyBunker.EngPing)
		Objective_SetAlwaysShowDetails(OBJECTIVE_DestroyBunker, true, true, false)
		
		g_SatchelHintID = HintPoint_AddToAbilityButton(ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, 219560, true)
		g_SatchelFlashID = UI_FlashAbilityButton(ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, true, BT_UI_Weak_CommandBtn)
		Rule_RemoveMe()
	end
end

function Rule_InfantryGrenadeHint()
	SGroup_Clear(sg_temp)
	Misc_GetSelectedSquads(sg_temp, false) 
	SGroup_Filter(sg_temp, SBP_ALLIED_RIFLEMEN_M01, FILTER_KEEP)
	
	if SGroup_IsEmpty(sg_temp) == false then
		g_GRENADE_HINT = HintPoint_AddToAbilityButton(ABILITY.ALLIES.GRENADE_NOREQS, 219561, true)
		g_GRENADE_FLASH = UI_FlashAbilityButton(ABILITY.ALLIES.GRENADE_NOREQS, true, BT_UI_Weak_CommandBtn )
		Rule_RemoveMe()
	end
end

function EventCue_SelectEngineers()
	Camera_FollowSquad(SGroup_GetSpawnedSquadAt(table_PlayerSquads[4].sgroup, 1))
end

-- detect when the player has lost a lot of guys and is standing still and play a speech event telling them to get to cover
function Rule_SpeechEvent_UnderAttack_LosingGuys()
	for i = 1, table.getn(table_PlayerSquads) do
		if blah83738763 ~= 1 and table_PlayerSquads[i].flag_spawned == 1 and table_PlayerSquads[i].flag_CheckRespawn == 1 and SGroup_TotalMembersCount(table_PlayerSquads[i].sgroup) < 4 and SGroup_IsMoving(table_PlayerSquads[i].sgroup, ANY) == false or SGroup_IsAttackMoving(table_PlayerSquads[i].sgroup, ANY) == false and SGroup_IsUnderAttack(table_PlayerSquads[i].sgroup, ANY, 1) then              
			blah83738763 = 1
			print("!!!!!! Playing speech event EVENTS.LosingGuys")
			Util_StartIntel(EVENTS.LosingGuys)
			Rule_RemoveMe()
		end
	end
end

-- play event when player is actually being attacked by MG fire
function Rule_SpeechEvent_UnderAttackFromBunker()
	print("!!!!!! Playing speech event EVENTS.UnderAttackFromBunker")
	Util_StartIntel(EVENTS.MGFire_TakingFire)
end

-- mortars incoming speech event
function Rule_SpeechEvent_MortarsIncoming()
	print("!!!!!! Playing speech event EVENTS.MortarsIncoming")
	Util_StartIntel(EVENTS.MortarsIncoming)
end

-- play unique event the first time the player selects the first squad
function Rule_SpeechEvent_FirstSelected()
	if SGroup_Exists(SGroup_GetName(table_PlayerSquads[1].sgroup)) and SGroup_IsEmpty(table_PlayerSquads[1].sgroup) == false then
		if Misc_IsSquadSelected(SGroup_GetSpawnedSquadAt(table_PlayerSquads[1].sgroup, 1)) then
			Rule_AddInterval(Rule_SpeechEvent_FirstSelected_Delay, 1)
			
			if g_START_INF_HINT ~= nil then
				HintPoint_Remove(g_START_INF_HINT)
				g_START_INF_HINT = nil
			end
			
			Rule_RemoveMe()
		end
	end
end

function Rule_SpeechEvent_FirstSelected_Delay()
	if Objective_IsStarted(OBJECTIVE_MoveToShingle) then
		Util_StartIntel(EVENTS.FirstSelected)
		Rule_RemoveMe()
	end
end

-- when they're near trench network, tell player to use trenches
function Rule_SpeechEvents_UseTrenches()
	if Prox_ArePlayerMembersNearMarker(player1, Marker_FodderBunker01_Trigger01, ANY) 
	or Prox_ArePlayerMembersNearMarker(player1, Marker_TrenchDefenders_04_Trigger1, ANY) then
		print("!!!!!! Playing speech event EVENTS.UseTrenches")
		Util_StartIntel(EVENTS.UseTrenches)
		g_UseTrenchesEventHasPlayed = 1
		Rule_RemoveMe()
	end
end

-- tell player to "flank" MGs when they're being attacked by them
function Rule_SpeechEvents_FlankMGs()
	if g_UseTrenchesEventHasPlayed == 1 then
		-- create a bunch of sgroups used to track who's attacking the player
		RiflemenAttackers = SGroup_CreateIfNotFound("RiflemenAttackers")
		RiflemenAttackers_temp = SGroup_CreateIfNotFound("RiflemenAttackers_temp")
		EngineerAttackers = SGroup_CreateIfNotFound("EngineerAttackers")
		EngineerAttackers_temp = SGroup_CreateIfNotFound("EngineerAttackers_temp")
		
		-- keep track of who's attacking the player's Riflemen and Engineers
		if SGroup_IsEmpty(table_PlayerSquads[1].sgroup) == false then
			Squad_GetLastAttackers(SGroup_GetSpawnedSquadAt(table_PlayerSquads[1].sgroup, 1), RiflemenAttackers, 1)
			SGroup_AddGroup(RiflemenAttackers_temp, RiflemenAttackers)
		end
		if SGroup_IsEmpty(table_PlayerSquads[4].sgroup) == false then
			Squad_GetLastAttackers(SGroup_GetSpawnedSquadAt(table_PlayerSquads[4].sgroup, 1), EngineerAttackers, 1)
			SGroup_AddGroup(EngineerAttackers_temp, EngineerAttackers)
		end
		
		-- do some intersections to see if any of the Axis MG squads are among the attackers
		SGroup_Intersection(RiflemenAttackers, Axis_MGNestNear88s)
		SGroup_Intersection(RiflemenAttackers_temp, Axis_MGNestNear88s_02)
		if SGroup_IsEmpty(RiflemenAttackers) == false then
			g_PlayFlankMGEvent = 1
		elseif SGroup_IsEmpty(RiflemenAttackers_temp) == false then
			g_PlayFlankMGEvent = 1
		end
		
		SGroup_Intersection(EngineerAttackers, Axis_MGNestNear88s)
		SGroup_Intersection(EngineerAttackers_temp, Axis_MGNestNear88s_02)
		if SGroup_IsEmpty(EngineerAttackers) == false then
			g_PlayFlankMGEvent = 1
		elseif SGroup_IsEmpty(EngineerAttackers_temp) == false then
			g_PlayFlankMGEvent = 1
		end
		
		if g_PlayFlankMGEvent == 1 then
			print("!!!!!! Playing speech event EVENTS.UseTrenches")
			Util_StartIntel(EVENTS.FlankMGs)
			Rule_RemoveMe()
		end
	end
end

--------------------------------------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------------------------------------
-- HINT POINTS
--------------------------------------------------------------------------------------------------------------------------------------------------

-- display hint point on Beach obstacles telling player to take cover there
function Rule_HintPoint_BeachCover()
	-- create hint points at startup
	if blah838937 ~= 1 then
		blah838937 = 1
		
		eg_cover_object = EGroup_GetWBTable("CoverObject_0%d")

		for i = 1, table.getn(eg_cover_object) do 
			HintMouseover_Add(219530, eg_cover_object[i], 10, true)
		end		
	end
	
	-- if player is within x meters of cover spots and is in cover, remove hint points
	if g_COVER_HINT_REMOVE ~= 1 
	and SGroup_IsInCover(table_PlayerSquads[1].sgroup, ANY) == true
	and ( Prox_AreSquadMembersNearMarker(table_PlayerSquads[1].sgroup, EGroup_GetPosition_EVEN_IF_EMPTY(CoverObject_01), ANY, 5) 
		or Prox_AreSquadMembersNearMarker(table_PlayerSquads[1].sgroup, EGroup_GetPosition_EVEN_IF_EMPTY(CoverObject_01B), ANY, 5) 
		or Prox_AreSquadMembersNearMarker(table_PlayerSquads[1].sgroup, EGroup_GetPosition_EVEN_IF_EMPTY(CoverObject_02), ANY, 5) ) then
		
		g_COVER_HINT_REMOVE = 1
		for i = 1, table.getn(eg_cover_object) do 
			HintMouseover_Remove(219530, eg_cover_object[i], 10, true)
		end
	
	end
	
	-- if player hasn't used the cover spots and has just blown right by, turn off hint points
	if g_numSquadsAtShingle > 0	then
		for i = 1, table.getn(eg_cover_object) do 
			HintMouseover_Remove(219530, eg_cover_object[i], 10, true)
		end
		Rule_RemoveMe()
	end
end

function Rule_SniperArtillery()
	Player_GetAllSquadsNearMarker(player1, sg_temp, mkr_artillery_sniper, 22)
	if SGroup_IsEmpty(sg_temp) == false then
		SGroup_SetInvulnerable(sg_temp, true, 5)
		Cmd_Ability(player1, ABILITY_SP_ARTILLERY_M01_SINGLE, Marker_GetPosition(mkr_artillery_sniper))
		Rule_AddOneShot(Rule_SniperArtillery_Delay, 2)
		Rule_RemoveMe()
	end
end

function Rule_AmbientArtillery()
	local i = 1
	while( i <= table.getn(mkr_artillery) ) do
		local removed = false
		
		Player_GetAllSquadsNearMarker(player1, sg_temp, mkr_artillery[i], 22)
		if SGroup_IsEmpty(sg_temp) == false 
		and SGroup_IsOnScreen(player1, sg_temp, ANY, 0.8) then
			SGroup_SetInvulnerable(sg_temp, true, 5)
			Cmd_Ability(player1, ABILITY_SP_ARTILLERY_M01_SINGLE, Marker_GetPosition(mkr_artillery[i]))
			table.remove(mkr_artillery, i)
			
			removed = true
		end
		
		if(not removed) then
			i = i + 1
		end
	end

	if table.getn(mkr_artillery) <= 0 then
		Rule_RemoveMe()
	end
end

function Rule_SniperArtillery_Delay()
	EGroup_Kill(eg_sniper_artillery)
end

--------------------------------------------------------------------------------------------------------------------------------------------------
-- MISCELLANEOUS FUNCTIONS
--------------------------------------------------------------------------------------------------------------------------------------------------
function M01_SquadSetCustomAttributes(sgroup, invulnerable)
	Cmd_Ability(sgroup, ABILITY_SP_ANIMTEST, nil, nil, true)	-- make squad move faster
	SGroup_EnableSurprise(sgroup, false)					-- turn off surprise so player's squads don't run backwards
	SGroup_SetMoveType(sgroup, MOVETYPE.FAST)				-- set move type to fast so they hustle
	Modify_ReceivedSuppression(sgroup, 0.5)					-- modify the suppression, so that the squads don't get suppressed to easily
	if invulnerable == true then
		SGroup_SetInvulnerable(sgroup, true, -1)				-- set SGroup to invulnerable temporarily																																		
	end
end

function M01_RemovePlayerSquadInvulnerability()
	for i = 1, table.getn(table_PlayerSquads) do 
		SGroup_SetInvulnerable(table_PlayerSquads[i].sgroup, false)
	end
end

-- remove invulnerability if player has issued a move order (squad is moving)
function Rule_RemoveInvulnerability()
	for i = 1, table.getn(table_PlayerSquads) do
		if table_PlayerSquads[i].flag_spawned == 1 
		and SGroup_IsEmpty(table_PlayerSquads[i].sgroup) == false
		and ( SGroup_IsMoving(table_PlayerSquads[i].sgroup, ANY) or SGroup_IsAttackMoving(table_PlayerSquads[i].sgroup, ANY) )
--~ 		and (table_PlayerSquads[i].ping ~= nil or SGroup_GetInvulnerable(table_PlayerSquads[i].sgroup, ANY)) then
		and SGroup_GetInvulnerable(table_PlayerSquads[i].sgroup, ANY) then
			print("Rule_RemoveInvulnerability: Removing invulnerability on player squad: "..i)
			SGroup_ClearPostureSuggestion(table_PlayerSquads[i].sgroup)
			SGroup_SetInvulnerable(table_PlayerSquads[i].sgroup, false, -1)																-- Remove invulnerability
	
			if table_PlayerSquads[i].ping ~= nil then
				print("Rule_RemoveInvulnerability: Removing ping on player squad: "..i)
				UI_DeleteMinimapBlip(table_PlayerSquads[i].ping)
				table_PlayerSquads[i].ping = nil
			end
		end
	end
end

-- finds the closest egroup from t_egroups to the variable var, then stores that in the egroup
-- var is the object to get a position on,
-- egroup is the group which the player wants to store the egroup,
-- t_egroups is the table of egroups to check
function Util_GetClosestEGroup(var, egroup, t_egroups)
	local dist
	local closest = 99999
	local result = t_egroups[1]
	local index = 1
	
	for i=1, table.getn(t_egroups) do
		if EGroup_IsEmpty(t_egroups[i]) == false then
			dist = World_DistancePointToPoint(Util_GetPosition_EVEN_IF_EMPTY(var), Util_GetPosition_EVEN_IF_EMPTY(t_egroups[i]))
			if dist < closest then
				closest = dist
				result = t_egroups[i]
				index = i
			end
		end
	end
	
	EGroup_Clear(egroup)
	EGroup_AddEGroup(egroup, result)
	
	return index
end

function M01_RuleDestroyMGs()
	-- NOTE: can't use a for loop here because we're removing entries from the table as we're iterating
	local i = 1
	while( i <= table.getn(t_axis_mgs) ) do
		local removed = false
		
		-- special case situation where the player should only be able to capture
		-- these weapons after the bunker is destroyed because it creates some strange bugs.
		if Objective_IsComplete(OBJECTIVE_DestroyBunker) then
			if (t_axis_mgs[i].sgroup == Axis_MGNestNear88s or t_axis_mgs[i].sgroup == Axis_MGNestNear88s_02)
			and SGroup_IsEmpty(t_axis_mgs[i].sgroup) == false then
				SGroup_SetTeamWeaponCapturable(t_axis_mgs[i].sgroup, true)
				table.remove(t_axis_mgs, i)
				
				removed = true
				
				-- prevents the loop from trying to run on table items that may have already been removed
				return
			end
		end
		
		if SGroup_IsEmpty(t_axis_mgs[i].sgroup) and SyncWeapon_Exists(t_axis_mgs[i].sw_id) then
			Entity_Kill(SyncWeapon_GetEntity(t_axis_mgs[i].sw_id))
			table.remove(t_axis_mgs, i)
			
			removed = true
		end
		
		if(not removed) then
			i = i + 1
		end
	end
	
	if table.getn(t_axis_mgs) <= 0 then
		Rule_RemoveMe()
	end
end

function M01_Autosave()
	if Event_IsAnyRunning() == false then
		Scar_Autosave(g_AUTOSAVE)
		Rule_RemoveMe()
	end
end


---------------------------------------------------------------------------------------------------------------------------------------------------------
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- ************************* EVENTS ******************************* 
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---------------------------------------------------------------------------------------------------------------------------------------------------------

EVENTS.Opening = function()
	nis_setintransitiontime(0)
	nis_setouttransitiontime(0)
	
	FOW_Enable(false)
	Game_FadeToBlack(FADE_IN, 0.5)
	CTRL.Scar_PlayNIS(N01_01_LandingTransition)												-- play the NIS
	CTRL.WAIT()
	
	g_startNPCMortars = 1					-- start mortar and MG fire vs. NPCs
	CTRL.WAIT()
	nis_stop()
	FOW_Enable(true)

	-- re-enable sound
	Util_MuteAmbientSound(false)

	-- Remain at end
	SGroup_AddGroup(table_PlayerSquads[1].sgroup, Player_NIS_Riflemen_01)	-- add the Riflemen left behind by the NIS back into the player squads table
	SGroup_AddGroup(Player_StartingGroup_01, Player_NIS_Riflemen_01)		-- add the Riflemen left behind by the NIS back into the player squads table
	table_PlayerSquads[1].flag_spawned = 1									-- set flags so script knows to start checking if squad's dead et al
	table_PlayerSquads[1].flag_CheckRespawn = 1
	
	CTRL.Game_FadeToBlack(FADE_IN, 0)
	CTRL.Game_Letterbox( false, 1)
--	Game_SetMode(UI_Fullscreen)
	CTRL.WAIT()
	CTRL.Event_Delay(1)
	Obj_CreatePopup(OBJECTIVE_MoveToShingle.ID, OBJECTIVE_MoveToShingle.Title)
	Sound_Play2D(SOUND_OBJ_ADDED)
	CTRL.WAIT()
	Objective_Start(OBJECTIVE_MoveToShingle, false)
	CTRL.Event_Delay(4)
	CTRL.WAIT()
--	Game_SetMode(UI_Normal)
	OBJ_MTS_PermanentArrow()
	Util_StartIntel(EVENTS.OBJ_MTS_Start)
	g_START_INF_HINT = HintPoint_Add(table_PlayerSquads[1].sgroup, true, 219575)
	
	M01_SquadSetCustomAttributes(table_PlayerSquads[1].sgroup)
	UI_HighlightSGroup(table_PlayerSquads[1].sgroup, 5)						-- flash selection circles

	Game_SetCinematicAspectRatio(g_NORMAL_ASPECT_RATIO)
	g_openingNISFinished = 1
end

t_medic_selected = {211530, 211532}
EVENTS.MedicSelected = function()
	Actor_PlaySpeechWithoutPortrait(ACTOR.Conti, t_medic_selected[World_GetRand(1, table.getn(t_medic_selected))])
end

table_SpeechEvent_FirstSelected = {210050, 210060, 210071, 210072, 210073, 210074}
EVENTS.FirstSelected = function()
	Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, table_SpeechEvent_FirstSelected[World_GetRand(1, table.getn(table_SpeechEvent_FirstSelected))])		-- We’re dead if we stay put!
end


t_MGFire_StartSpeech = {210090, 210111, 210112, 210113, 210114}
EVENTS.MGFire_Start = function()
	Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, t_MGFire_StartSpeech[World_GetRand(1, table.getn(t_MGFire_StartSpeech))])		-- MG42! Take Cover!
end


table_MGFire_ReloadSpeechEvents = {210190, 210200, 210211, 210220, 210230, 210250, 210255, 210290, 210300, 210301, 210302, 210303}						-- They're reloading!  Move up the beach! / It's clear!  Get moving! / etc.
EVENTS.MGFire_Reload = function()
	Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, table_MGFire_ReloadSpeechEvents[World_GetRand(1, table.getn(table_MGFire_ReloadSpeechEvents))])		-- They're reloading!  Move up the beach!
end

table_MGFire_TakingFireEvents = {210120, 210130, 210140, 210150, 210160, 210170}														-- Incoming!  Find cover! / Sir! We're taking fire! / etc.
EVENTS.MGFire_TakingFire = function()
	Actor_PlaySpeechWithoutPortrait( ACTOR.GenericAlly, table_MGFire_TakingFireEvents[World_GetRand(1, table.getn(table_MGFire_TakingFireEvents))])		-- Incoming!  Get to some cover!
end

EVENTS.UseCratersForCover = function()
	CTRL.Actor_PlaySpeech( ACTOR.GenericAlly, 210260)		-- Use the craters for cover!
end


EVENTS.AllsSoldiersAtShingle = function()
	g_useLBX_ONCE = 0
	Objective_Complete(OBJECTIVE_MoveToShingle, false)
	CTRL.Game_Letterbox( true, 1 )
	CTRL.WAIT()
	-- "good work men"
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 210751)									-- Good work! Able Company's all here.
--~ 	Camera_MoveToPosition(Marker_Shingle_11, true, SLOW_CAMERA_PANNING)
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 210752)									-- Where are the god-damn Engineers?
	CTRL.WAIT()
	
	Cmd_Move(sg_rescue_engineers, t_obj_re_mgr.mkr_pinned, false)
	Camera_MoveToPosition(Util_GetPosition_EVEN_IF_EMPTY(Marker_EngineersCamera), true, SLOW_CAMERA_PANNING)
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 210754)									-- We're going to need Engineers to blow the wire.
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 210756)									-- Get them to the shingle.
	CTRL.WAIT()
	CTRL.Game_Letterbox(false, 1 )
	CTRL.WAIT()
end


table_SquadDeadSpeechEvents = {210770, 210780}																		-- Squad is down! / Able company’s lost a squad. 
table_GetToShingleSpeechEvents = {210791, 210801, 210805, 210815}											-- Find a squad, use cover / Rally a squad and get to the shingle! / etc.
EVENTS.SquadDead = function()
	Actor_PlaySpeechWithoutPortrait( ACTOR.GenericAlly, table_SquadDeadSpeechEvents[World_GetRand(1, table.getn(table_SquadDeadSpeechEvents))])		-- Squad is down!
	if flag_AtTheShingle ~= 1 then
		Actor_PlaySpeechWithoutPortrait( ACTOR.GenericAlly, table_GetToShingleSpeechEvents[World_GetRand(1, table.getn(table_GetToShingleSpeechEvents))])		-- Find a squad, use cover
	end
end

t_engineer_dead_seawall = {210822, 210824}
EVENTS.EngineerSquadDead = function()
	-- player is at the seawall
	if g_OBJ_RE_STARTED == true then
		CTRL.Actor_PlaySpeech( ACTOR.Conti, 210820)		-- Engineer squad is down!
		CTRL.WAIT()
		CTRL.Actor_PlaySpeech( ACTOR.Conti, t_engineer_dead_seawall[World_GetRand(1, table.getn(t_engineer_dead_seawall))])
		CTRL.WAIT()
	else
		Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, 210826)	
	end
end


EVENTS.SquadDeadFocus = function()
	CTRL.Actor_PlaySpeech( ACTOR.GenericAlly, table_SquadDeadSpeechEvents[World_GetRand(1, table.getn(table_SquadDeadSpeechEvents))])		-- Squad is down!
	CTRL.Game_Letterbox( true, 1 )
	CTRL.WAIT()
	if g_anySquadsAtShingle == 1 then
		Camera_FocusOnTargetMarker(Marker_SquadRespawn_Focus, 0)
	else
		Camera_FocusOnTargetMarker(Marker_InitialMove, 0)
	end
	CTRL.Actor_PlaySpeech( ACTOR.GenericAlly, table_GetToShingleSpeechEvents[World_GetRand(1, table.getn(table_GetToShingleSpeechEvents))])		-- Find a squad, use cover
	CTRL.WAIT()
	CTRL.Game_Letterbox( false, 1 )
end

EVENTS.EngineerSquadDeadFocus = function()
	CTRL.Actor_PlaySpeech( ACTOR.GenericAlly, 210820)		-- Engineer squad is down!
	CTRL.Game_Letterbox( true, 1 )
	CTRL.WAIT()
	if g_anySquadsAtShingle == 1 then
		Camera_FocusOnTargetMarker(Marker_SquadRespawn_Focus, 0)
	else
		Camera_FocusOnTargetMarker(Marker_InitialMove, 0)
	end
	CTRL.Actor_PlaySpeech( ACTOR.GenericAlly, 210840)		-- New Engineer squad available
	CTRL.WAIT()
	CTRL.Game_Letterbox( false, 1 )
end


t_losing_guys = {210850, 210860, 210870, 210880, 210872, 210874}
EVENTS.LosingGuys = function()
	Actor_PlaySpeechWithoutPortrait( ACTOR.GenericAlly, t_losing_guys[World_GetRand(1, table.getn(t_losing_guys))])
end

table_MortarsIncomingSpeechEvents = {210320, 210330, 210340, 210350, 210355, 210360, 210370, 210371}
EVENTS.MortarsIncoming = function()
	if g_MORTAR_FIRST_TIME == nil then
		Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, 210310)
		g_MORTAR_FIRST_TIME = false
	else
		Actor_PlaySpeechWithoutPortrait( ACTOR.GenericAlly, table_MortarsIncomingSpeechEvents[World_GetRand(1, table.getn(table_MortarsIncomingSpeechEvents))])		-- Mortars incoming! / INCOMING! / etc.
	end
end


EVENTS.UseTrenches = function()
	Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, 211161)		-- Stay down and use the trenches to cover our advance!
end

EVENTS.UseGrenades = function()
	CTRL.Actor_PlaySpeech( ACTOR.Conti, 211220)		-- Put some grenades in those MG nests!
end



EVENTS.AtTheShingle = function()
	CTRL.Game_Letterbox( true, 1 )
	CTRL.WAIT()
	g_nukePlayerSquads = 1	-- Get rid of all the player squads at the shingle as they're no longer needed (NIS will leave behind squads)
	Rule_NukePlayerSquads()
	Rule_ClearNPCs_N01_02()
	SGroup_DestroyAllSquads(Axis_BunkerMG42_03)
	g_TimerStarted_BlowWire = 1
	Timer_Start(Timer_BlowWire, 36)																									-- start timer used for blowing wire
	FOW_Enable(false)
 	nis_setintransitiontime(g_NIS02_TRANS_TIME)
	nis_stop()
	nis_usegamecamera(false)
	CTRL.Scar_PlayNIS(N01_02_AtTheShingle)																						-- play the NIS
	CTRL.WAIT()
	nis_stop()
	EGroup_Hide(eg_hires_ground, true)
	FOW_Enable(true)
	g_nukePlayerSquads = 0	
	g_blowWire = 1																																-- set flag to blow wire

	CTRL.Game_Letterbox( false, 1 )
	CTRL.WAIT()
--~ 	Camera_ResetToDefault()
	g_AtShingleEventHasFinished = 1																									-- set flag to create next objective
end


t_assault_mgs = {210980, 210969}
EVENTS.AssaultMGNest = function()
	local rand = World_GetRand(1, table.getn(t_assault_mgs))
	CTRL.Actor_PlaySpeech( ACTOR.McKay, t_assault_mgs[rand])		-- Take out those machine guns and clear the draw!
	CTRL.WAIT()
end


EVENTS.DogWhiteOpen = function()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211040)		-- Dog White is open!
	CTRL.WAIT()
end


EVENTS.UseSatchelCharges = function()
	CTRL.Actor_PlaySpeech( ACTOR.Conti, 211060)		-- Engineers! Satchel Charges - on the bunker! NOW!
	Engineer_PingID = UI_CreateMinimapBlip(table_PlayerSquads[4].sgroup, -1, BT_ObjectivePrimary)
	CTRL.WAIT()
	UI_CreateEventCueClickable( CUE.NORMAL.icon, CUE.NORMAL.sound, 219515, 219515, EventCue_SelectEngineers, -1, false)		-- trigger an event cue about it
end

t_flank_mgs = {211210, 211211, 211212, 211220, 211221, 211222}
EVENTS.FlankMGs = function()
	Actor_PlaySpeechWithoutPortrait( ACTOR.Conti, t_flank_mgs[World_GetRand(1, table.getn(t_flank_mgs))])
end

EVENTS.BunkerDestroyed = function()
	CTRL.Game_Letterbox( true, 1 )
	CTRL.WAIT()
	g_nukePlayerSquads = 1																												-- kill off the player's squads (the NIS ones will remain At End)
	SGroup_Hide(Axis_88Crew_01, true)																								-- hide 88 so it doesn't overlap 88 from NIS
	nis_setintransitiontime(g_NIS03_TRANS_TIME)
	nis_setouttransitiontime(0)
	FOW_Enable(false)
	CTRL.Scar_PlayNIS(N01_03_BunkerTaken)																						-- play the NIS
	CTRL.WAIT()
	nis_stop()
	FOW_Enable(true)
	Game_FadeToBlack(FADE_IN, 1)
	SGroup_Hide(Axis_88Crew_01, false)																								-- unhide 88
	SGroup_AddGroup(table_PlayerSquads[1].sgroup, Player_NIS_Riflemen_01)								-- add the Riflemen left behind by the NIS back into the player squads table
	table_PlayerSquads[1].flag_spawned = 1																						-- set flags so script knows to start checking if squad's dead et al
	table_PlayerSquads[1].flag_CheckRespawn = 1
	table_PlayerSquads[1].flag_AtShingle = 1
	if table_PlayerSquads[1].itemTable ~= nil then																				-- if player picked up any weapons on the beach
		Squad_GiveSlotItemsFromTable(SGroup_GetSpawnedSquadAt(table_PlayerSquads[1].sgroup, 1), table_PlayerSquads[1].itemTable)		-- give them back to the squad
	end

	SGroup_AddGroup(table_PlayerSquads[4].sgroup, Player_NIS_Engineers_01)								-- add the Engineers left behind by the NIS back into the player squads table
	table_PlayerSquads[4].flag_spawned = 1																						-- set flags so script knows to start checking if squad's dead et al
	table_PlayerSquads[4].flag_CheckRespawn = 1
	table_PlayerSquads[4].flag_AtShingle = 1
	if table_PlayerSquads[4].itemTable ~= nil then																				-- if player picked up any weapons on the beach
		Squad_GiveSlotItemsFromTable(SGroup_GetSpawnedSquadAt(table_PlayerSquads[4].sgroup, 1), table_PlayerSquads[1].itemTable)		-- give them back to the squad
	end
	
	g_Axis_MoveIntoPosition = 1

	CTRL.WAIT()
	
	CTRL.Game_Letterbox( false, 1 )
	
	CTRL.WAIT()
--~ 	Camera_ResetToDefault()
	g_BunkerTakenNIS_Finished = 1
end


EVENTS.MissionComplete = function()
	CTRL.Game_Letterbox(true, 1 )
	Camera_MoveToPosition(g_LAST_88_DESTROYED, true, SLOW_CAMERA_PANNING)

	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211310)		-- Excellent job men.
	CTRL.WAIT()
	Camera_AutoRotate(Marker_GetPosition(g_LAST_88_DESTROYED), 35, 43, 1)
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211320)		-- Sergeant Conti, get on the radio. Tell HQ our draw is clear for the tanks to come ashore.
	CTRL.WAIT()
	CTRL.Actor_PlaySpeech( ACTOR.McKay, 211340)		-- Secure the perimeter and dig in. Inform Dog Company that we are in position and...
	CTRL.WAIT()
	CTRL.Game_Letterbox(false, 0)
	CTRL.WAIT()
	g_MissionComplete = true
end

--==================================================================================--
-- AMBIENT SPEECH 
--==================================================================================--



function M01_AmbientSpeechSetup()
	g_AMB_SPEECH_PATH = "sound/speech/SP/mission01/"
	g_AMB_SPEECH_TIMER = "g_AMB_SPEECH_TIMER"
	
	-- since all this ambient speech is in order, cheat and use the numbers
	-- as min and max, rather than storing all the data in a giant table
	t_amb_speech = {}
	for i=212036, 212175 do 
		table.insert(t_amb_speech, i)
	end
	
	-- move orders, mixing them in with the ambient speech
	for i=212000, 212015 do 
		table.insert(t_amb_speech, i)
	end
	
	-- selection sounds
	t_amb_speech_select = {}
	for i=212016, 212035 do 
		table.insert(t_amb_speech_select, i)
	end
end

function Rule_PlayAmbientSpeech()
	if Timer_GetRemaining(g_AMB_SPEECH_TIMER) <= 0 then
		M01_PlayAmbientSpeech()
		local rand = World_GetRand(3, 6)
		Timer_Start(g_AMB_SPEECH_TIMER, rand)
	end
end

function M01_PlayAmbientSpeech()
	sg_soundsquads = SGroup_CreateIfNotFound("sg_soundsquads")

	Player_GetAll(player1, sg_soundsquads)
	
	local pos = Camera_GetTargetPos()
	Player_GetAllSquadsNearMarker(player1, sg_temp3)
	Player_GetAllSquadsNearMarker(player3, sg_soundsquads, pos, 20)
	SGroup_AddGroup(sg_soundsquads, sg_temp3)
		
	-- if nobody is on screen that we can use, then stop
	if SGroup_IsEmpty(sg_soundsquads)  then
		return
	end
	
	local squad = SGroup_GetRandomSpawnedSquad(sg_soundsquads)
	
	-- if there is no squad from the group then stop
	if ( Squad_Count( squad ) <= 0 ) then
		return
	end

	rand = World_GetRand(1, table.getn(t_amb_speech))
	
	Sound_Play3D(g_AMB_SPEECH_PATH..t_amb_speech[rand], Squad_EntityAt( squad, 0 ))
end

function M01_PlayAmbientSpeechSelect(sgroup)
	local squad = SGroup_GetRandomSpawnedSquad(sgroup)
	if ( Squad_Count( squad ) <= 0 ) then
		return
	end
	
	local rand = World_GetRand(1, table.getn(t_amb_speech_select))
	
	Sound_Play3D(g_AMB_SPEECH_PATH..t_amb_speech_select[rand], Squad_EntityAt( squad, 0 ))
end


--------------------------------------------------------
-- NIS Higgins Boats
--------------------------------------------------------

function Rule_NISHigginsStart()
	if g_openingNISFinished == 1 and Event_IsRunning(EVENTS.Opening) == false then
		Rule_AddInterval(Rule_NISHigginsPlay, 10)
		Rule_AddInterval(Rule_AddHigginsNPCs, 2.5)
		Rule_RemoveMe()
	end
end

function Rule_NISHigginsPlay()
	if g_NIS_HIGGINS_PLAYING then
		return
	end

	local cur_nis = t_Higgins_NIS[g_HIGGINS_NIS_COUNT]
	nis_usegamecamera(true)
	nis_playambient(cur_nis)
	g_NIS_HIGGINS_PLAYING = true
	
	if g_HIGGINS_NIS_COUNT < table.getn(t_Higgins_NIS) then
		g_HIGGINS_NIS_COUNT = g_HIGGINS_NIS_COUNT + 1
	else
		g_HIGGINS_NIS_COUNT = 1
	end
end

function Rule_AddHigginsNPCs()
	for i = 1, table.getn(t_HigginsNPCs) do 
		if SGroup_IsEmpty(t_HigginsNPCs[i]) == false 
		and Player_OwnsSGroup(player1, t_HigginsNPCs[i]) == false then

			-- check to see if the NISes are continuing to play after this one...
			if Rule_Exists(Rule_NISHigginsPlay) then
				
				print("Running Higgins NPCS: "..i)
				SGroup_SetPlayerOwner(t_HigginsNPCs[i], player3)
				SGroup_AddGroup(NPC_Movers, t_HigginsNPCs[i])
				SGroup_EnableUIDecorator(t_HigginsNPCs[i], false )																									-- turn off decorators on NPCs
				SGroup_EnableMinimapIndicator(t_HigginsNPCs[i], false)
				Cmd_Ability(t_HigginsNPCs[i], ABILITY_SP_ANIMTEST, nil, nil, true)	-- make squad move faster
				SGroup_SetMoveType(t_HigginsNPCs[i], MOVETYPE.FAST)				-- set move type to fast so they hustle
				
				if g_SELECT_ANY_SQUAD == false then
					SGroup_SetSelectable(t_HigginsNPCs[i], false)
				end
				
				local rand = World_GetRand(1, table.getn(mkr_shingle_hint))
				Cmd_Move(t_HigginsNPCs[i], mkr_shingle_hint[rand])
				--brw 06/21/06 - removing the path, since controlling a squad that follows a path is 
				-- not working.
--~ 				Cmd_SquadPath(t_HigginsNPCs[i], "path_nis_higgins"..i, true, false, true, 10)
				SGroup_Clear(t_HigginsNPCs[i])
				
			-- ...otherwise, just kill off the NPCs so that they don't end up at the shingle
			else
				SGroup_EnableUIDecorator(t_HigginsNPCs[i], false )																									-- turn off decorators on NPCs
				SGroup_EnableMinimapIndicator(t_HigginsNPCs[i], false)
				KillNPCsUnjustly(t_HigginsNPCs[i], true)
				SGroup_Clear(t_HigginsNPCs[i])
	
			end
		end
	end
	
	-- Destroy the higgins boat if the player is not looking at it.
	if EGroup_IsEmpty(NIS_HigginsBoat) == false 
	and EGroup_IsOnScreen(player1, NIS_HigginsBoat, ANY) == false then
		EGroup_DestroyAllEntities(NIS_HigginsBoat)
		EGroup_Clear(NIS_HigginsBoat)
		
		-- start the NIS Higgins playing again, if they have stopped (but only
		--  after the boat has been destroyed).
		g_NIS_HIGGINS_PLAYING = false
	end
	
	-- checks if there are anymore NISes to be played and removes the rule if the NISes have stopped playing
	if Rule_Exists(Rule_NISHigginsPlay) == false 
	and g_NIS_HIGGINS_PLAYING == false
	and EGroup_IsEmpty(NIS_HigginsBoat) == false	
	and EGroup_IsOnScreen(player1, NIS_HigginsBoat, ANY) == false then
		EGroup_DestroyAllEntities(NIS_HigginsBoat)
		Rule_RemoveMe()
	end
end


function M01_AutosaveDelay()
	if Rule_Exists(M01_Autosave) == false then
		Rule_Add(M01_Autosave)
	end
end
